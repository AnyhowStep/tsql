declare module "built-in-value-expr/built-in-value-expr" {
    /**
     * In particular,
     * + `BLOB` data should be sent as a `Uint8Array`
     * + `JSON` data should be sent as a `string`
     * + `undefined` IS NOT ALLOWED
     * + `DECIMAL` data is sent as `string` for now because
     *   there is no native arbitrary-precision-floating-point or fixed-point type in JS
     *
     * We do not consider `DECIMAL` a built-in type because JS does not support it natively.
     *
     */
    export type BuiltInValueExpr = bigint | number | string | boolean | Date | Uint8Array | null;
    export type NonNullBuiltInValueExpr = Exclude<BuiltInValueExpr, null>;
}
declare module "date-util/is-date" {
    export function isDate(x: unknown): x is Date;
}
declare module "date-util/index" {
    export * from "date-util/is-date";
}
declare module "built-in-value-expr/util/predicate/is-built-in-value-expr" {
    import { BuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    export function isBuiltInValueExpr(raw: unknown): raw is BuiltInValueExpr;
}
declare module "built-in-value-expr/util/predicate/is-non-null-built-in-value-expr" {
    import { NonNullBuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    export function isNonNullBuiltInValueExpr(raw: unknown): raw is NonNullBuiltInValueExpr;
}
declare module "built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array" {
    import { NonNullBuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    export function isNonNullBuiltInValueExprArray(raw: unknown): raw is NonNullBuiltInValueExpr[];
}
declare module "built-in-value-expr/array-util/predicate/is-built-in-value-expr-array" {
    import { BuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    export function isBuiltInValueExprArray(raw: unknown): raw is BuiltInValueExpr[];
}
declare module "built-in-value-expr/array-util/predicate/index" {
    export * from "built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array";
    export * from "built-in-value-expr/array-util/predicate/is-built-in-value-expr-array";
}
declare module "built-in-value-expr/array-util/index" {
    export * from "built-in-value-expr/array-util/predicate/index";
}
declare module "compile-error/compile-error" {
    /**
     * This type is a workaround for TypeScript's lack of a native "compile error" type.
     *
     * For motivation behind this,
     * https://github.com/microsoft/TypeScript/issues/23689#issuecomment-512114782
     *
     * -----
     *
     * We should never be able to create a value of this type legitimately.
     *
     * `_ErrorMessageT` is our error message
     *
     * -----
     *
     * This workaround should only ever be used in function parameter lists.
     *
     */
    export interface CompileError<_ErrorMessageT> {
        /**
         * There should never be a value of this type
         */
        readonly __compileError: never;
    }
    export interface CompileOk {
        /**
         * There should never be a value of this type
         */
        readonly __compileOk: never;
    }
}
declare module "compile-error/index" {
    export * from "compile-error/compile-error";
}
declare module "type-util/assert-non-never" {
    import { CompileError } from "compile-error/index";
    /**
     * + `AssertNonNever<never, MessageT>` is `never`.
     * + `AssertNonNever<[never], MessageT>` is `CompileError<MessageT>`
     */
    export type AssertNonNever<T extends [any], MessageT> = T[0] extends never ? CompileError<MessageT> : unknown;
}
declare module "type-util/assert-same-own-enumerable-keys" {
    import { CompileError } from "compile-error/index";
    /**
     * Asserts `A` has the same own enumerable keys as `B`.
     *
     * + Assumes `A` is not a union
     * + Assumes `B` is not a union
     */
    export type AssertSameOwnEnumerableKeys<A, B> = (keyof A extends keyof B ? (keyof B extends keyof A ? unknown : CompileError<["Missing keys found", Exclude<keyof B, keyof A>]>) : CompileError<["Extra keys found", Exclude<keyof A, keyof B>]>);
    export function assertSameOwnEnumerableKeys(a: any, b: any): void;
}
declare module "type-util/assert-subset-own-enumerable-keys" {
    import { CompileError } from "compile-error/index";
    /**
     * Asserts `A` has a subset of own enumerable keys as `B`.
     *
     * + Assumes `A` is not a union
     * + Assumes `B` is not a union
     */
    export type AssertSubsetOwnEnumerableKeys<A, B> = keyof A extends keyof B ? unknown : CompileError<["Extra keys found", Exclude<keyof A, keyof B>]>;
}
declare module "type-util/base-type" {
    export type BaseType<T extends unknown> = T extends bigint ? bigint : T extends number ? number : T extends string ? string : T extends boolean ? boolean : T;
}
declare module "type-util/better-return-type" {
    /**
     * https://github.com/microsoft/TypeScript/issues/33457
     *
     * Like `ReturnType<>`.
     * But better.
     */
    export type BetterReturnType<T extends (...args: never) => any> = T extends (...args: never) => infer R ? R : never;
}
declare module "type-util/identity" {
    /**
     * https://github.com/microsoft/TypeScript/issues/31992#issuecomment-503816806
     *
     * A hack to generate "better looking" types.
     */
    export type Identity<T> = T;
}
declare module "type-util/is-strict-same-type" {
    export type IsStrictSameType<A1 extends any, A2 extends any> = (<A>() => A extends A1 ? true : false) extends (<A>() => A extends A2 ? true : false) ? true : false;
    export type ExtractStrictSameType<A1, A2> = A1 extends any ? (IsStrictSameType<A1, A2> extends true ? A1 : never) : never;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-521819804
     *
     * @todo Support both `A1` and `A2` being union types
     * At the moment, it only works right if `A2` is not a union
     */
    export type TryReuseExistingType<A1, A2> = ExtractStrictSameType<A1, A2> extends never ? A2 : ExtractStrictSameType<A1, A2>;
}
declare module "type-util/is-null-safe-comparable" {
    import { NonNullBuiltInValueExpr } from "built-in-value-expr/index";
    import { IsStrictSameType } from "type-util/is-strict-same-type";
    import { BaseType } from "type-util/base-type";
    export type IsNonNullBuiltInValueExprComparable<T extends NonNullBuiltInValueExpr, U extends NonNullBuiltInValueExpr> = IsStrictSameType<BaseType<T>, BaseType<U>>;
    export type IsNullSafeComparableImpl<T extends unknown, U extends unknown> = [T] extends [NonNullBuiltInValueExpr] ? ([U] extends [NonNullBuiltInValueExpr] ? IsNonNullBuiltInValueExprComparable<T, U> : [T] extends [U] ? true : [U] extends [T] ? true : false) : [T] extends [U] ? true : [U] extends [T] ? true : false;
    /**
     * Implements `tsql`'s notion of **null-safe** comparability
     */
    export type IsNullSafeComparable<T extends unknown, U extends unknown> = IsNullSafeComparableImpl<Exclude<T, null>, Exclude<U, null>>;
}
declare module "type-util/is-comparable" {
    import { IsNullSafeComparableImpl } from "type-util/is-null-safe-comparable";
    /**
     * Implements `tsql`'s notion of comparability.
     */
    export type IsComparable<T extends unknown, U extends unknown> = null extends T ? false : null extends U ? false : IsNullSafeComparableImpl<T, U>;
}
declare module "type-util/is-object-with-own-enumerable-keys" {
    import { CompileError } from "compile-error/index";
    export function isObjectWithOwnEnumerableKeys<T>(): <K extends Extract<keyof T, string>>(raw: unknown, keys: Extract<keyof T, string> extends K ? K[] : CompileError<["Missing keys", Exclude<Extract<keyof T, string>, K>]>) => raw is { [k in Extract<keyof T, string>]: unknown; };
}
declare module "type-util/union-to-intersection" {
    import { TypeUtil } from "type-mapping";
    export type UnionToIntersection<U> = TypeUtil.UnionToIntersection<U>;
    /**
     * https://github.com/microsoft/TypeScript/issues/29594#issuecomment-560760300
     */
    export type UnionToIntersection2<U extends BaseT, BaseT> = Extract<UnionToIntersection<U>, BaseT>;
}
declare module "type-util/is-union" {
    import { UnionToIntersection } from "type-util/union-to-intersection";
    import { CompileError } from "compile-error/index";
    export type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true;
    export type AssertNonUnion<T> = [T] extends [UnionToIntersection<T>] ? unknown : CompileError<["Union type not allowed"]>;
    export type AssertNonUnionExceptBoolean<T> = [T] extends [boolean] ? unknown : [T] extends [UnionToIntersection<T>] ? unknown : CompileError<["Union type not allowed"]>;
}
declare module "type-util/merge" {
    /**
     * https://github.com/microsoft/TypeScript/issues/31992#issuecomment-503816806
     *
     * A hack to generate "better looking" types.
     */
    type _<T> = T;
    /**
     * Merges an intersection type into one object type.
     *
     * **DO NOT** pass union types into this type!
     */
    export type Merge<T> = (_<{
        [k in keyof T]: T[k];
    }>);
}
declare module "type-util/no-infer" {
    /**
     * https://github.com/microsoft/TypeScript/issues/14829#issuecomment-504042546
     *
     * Sometimes, we use a generic type parameter twice.
     * However, we only want inference on the first usage and not the second.
     *
     * This is a workaround.
     */
    export type NoInfer<T> = [T][T extends any ? 0 : never];
    /**
     * https://github.com/microsoft/TypeScript/issues/14829#issuecomment-320833603
     *
     * Sometimes, we use a generic type parameter twice.
     * However, we only want inference on the first usage and not the second.
     *
     * This is a workaround.
     *
     * Unusable if `T` may be `null` or `undefined`,
     * https://github.com/microsoft/TypeScript/issues/14829#issuecomment-322267089
     */
    export type InferLast<T> = T & {};
}
declare module "type-util/non-optional-partial" {
    /**
     * + `{ x : undefined }` is assignable to `Partial<{ x : number }>`
     * + `{ x : undefined }` is **NOT** assignable to `NonOptionalPartial<{ x : number }>`
     * + `{}` is assignable to `Partial<{ x : number }>`
     * + `{}` is **NOT** assignable to `NonOptionalPartial<{ x : number }>`
     * + `{ x : number }` is assignable to `Partial<{ x : number }>`
     * + `{ x : number }` is assignable to `NonOptionalPartial<{ x : number }>`
     */
    export type NonOptionalPartial<T> = ({
        [k in keyof T]: ({
            [propertyName in k]: T[k];
        });
    }[keyof T]);
}
declare module "type-util/omit-own-enumerable" {
    export function omitOwnEnumerable<ObjT extends {
        [k: string]: unknown;
    }, KeysT extends readonly Extract<keyof ObjT, string>[]>(obj: ObjT, keys: KeysT): Omit<ObjT, KeysT[number]>;
}
declare module "type-util/only-known-properties" {
    /**
     * Object literal may only specify known properties
     */
    export type OnlyKnownProperties<ConcreteT extends ConstraintT, ConstraintT> = ConcreteT extends ConstraintT ? (ConcreteT & {
        [k in keyof ConcreteT]: (k extends keyof ConstraintT ? ConstraintT[k] : never);
    }) : never;
}
declare module "type-util/outersect" {
    export type Outersect<A, B> = Exclude<A, B> | Exclude<B, A>;
}
declare module "type-util/pick-multi" {
    import { Identity } from "type-util/identity";
    /**
     * + Assumes `T` is not a union
     * + Lets `KeyT` be a union
     */
    export type PickMulti<T, KeyT extends readonly (keyof T)[]> = (KeyT extends readonly (keyof T)[] ? Pick<T, KeyT[number]> : never);
    /**
     * + Assumes `T` may be union
     * + Assumes `KeyT` may not be key of all elements of `T`
     */
    export type DistributePick<T, KeyT extends PropertyKey> = T extends any ? Pick<T, Extract<KeyT, keyof T>> : never;
    export type ReadOnlyPick<T, K extends keyof T> = Identity<{
        readonly [k in K]: T[k];
    }>;
    export type ExpandPick<T, K extends keyof T> = Identity<{
        [k in K]: T[k];
    }>;
}
declare module "type-util/pick-own-enumerable" {
    export function pickOwnEnumerable<ObjT extends {
        [k: string]: unknown;
    }, KeysT extends readonly Extract<keyof ObjT, string>[]>(obj: ObjT, keys: KeysT): Pick<ObjT, KeysT[number]>;
}
declare module "type-util/replace-property" {
    import { NonOptionalPartial } from "type-util/non-optional-partial";
    export type ReplaceProperty<NonGenericT, OldT extends NonGenericT, NewT extends NonOptionalPartial<NonGenericT>, K extends keyof NonGenericT> = (NewT extends Pick<NonGenericT, K> ? NewT[K] : OldT[K]);
}
declare module "type-util/replace" {
    /**
     * Replaces all instances of `NeedleT` with `ReplacementT`
     */
    export type Replace<T, NeedleT, ReplacementT> = (T extends NeedleT ? ReplacementT : T);
}
declare module "type-util/strict-union" {
    type UnionKeys<T> = (T extends unknown ? keyof T : never);
    type StrictUnionImpl<T, TAll> = (T extends unknown ? (T
    /**
     * @todo Debate which looks nicer.
     */
     & (Exclude<UnionKeys<TAll>, keyof T> extends never ? 
    /**
     * If there are no other keys, we just have `T`.
     * This makes the resulting type "look nicer".
     */
    unknown : 
    /**
     * If we have other keys, the resulting type looks a little ugly.
     */
    Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>>)) : never);
    /**
     * TS has excess property checks for object literals.
     *
     * However, it seems to not be performed when the destination type is a union.
     *
     * https://github.com/microsoft/TypeScript/issues/20863#issuecomment-520303071
     *
     * -----
     *
     * This is a workaround and isn't perfect but it almost behaves like excess property checks
     * for object literals when the destination type is a union.
     *
     * https://github.com/microsoft/TypeScript/issues/20863#issuecomment-479471546
     */
    export type StrictUnion<T> = StrictUnionImpl<T, T>;
}
declare module "type-util/to-promise" {
    export type ToPromise<T> = T extends PromiseLike<infer U> ? Promise<U> : Promise<T>;
}
declare module "type-util/to-unknown-if-all-properties-never" {
    import { CompileOk, CompileError } from "compile-error/index";
    /**
     * If all properties are of type `never`, it returns `unknown`.
     * Otherwise, it returns a union of all property values.
     *
     * @todo Better name
     */
    export type ToUnknownIfAllPropertiesNever<T> = T[keyof T] extends never ? unknown : T[keyof T];
    export type ToNeverIfUnknown<T> = unknown extends T ? never : T;
    export type ToUnknownIfCompileOk<CompileResult extends CompileOk | CompileError<any>> = [CompileResult] extends [CompileOk] ? unknown : Extract<CompileResult, CompileError<any>>;
}
declare module "type-util/type-of-await" {
    /**
     * ```ts
     * declare const t;
     *
     * //TypeOfAwait<typeof t>;
     * const x = await t;
     * ```
     */
    export type TypeOfAwait<T> = T extends PromiseLike<infer U> ? U : T;
}
declare module "type-util/writable" {
    export type Writable<T> = (T extends any ? {
        -readonly [k in keyof T]: T[k];
    } : never);
}
declare module "type-util/index" {
    export * from "type-util/assert-non-never";
    export * from "type-util/assert-same-own-enumerable-keys";
    export * from "type-util/assert-subset-own-enumerable-keys";
    export * from "type-util/base-type";
    export * from "type-util/better-return-type";
    export * from "type-util/identity";
    export * from "type-util/is-comparable";
    export * from "type-util/is-null-safe-comparable";
    export * from "type-util/is-object-with-own-enumerable-keys";
    export * from "type-util/is-strict-same-type";
    export * from "type-util/is-union";
    export * from "type-util/merge";
    export * from "type-util/no-infer";
    export * from "type-util/non-optional-partial";
    export * from "type-util/omit-own-enumerable";
    export * from "type-util/only-known-properties";
    export * from "type-util/outersect";
    export * from "type-util/pick-multi";
    export * from "type-util/pick-own-enumerable";
    export * from "type-util/replace-property";
    export * from "type-util/replace";
    export * from "type-util/strict-union";
    export * from "type-util/to-promise";
    export * from "type-util/to-unknown-if-all-properties-never";
    export * from "type-util/union-to-intersection";
    export * from "type-util/type-of-await";
    export * from "type-util/writable";
}
declare module "built-in-value-expr/util/operation/case-insensitive-narrow" {
    import { NonNullBuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    import { BaseType } from "type-util/index";
    /**
     * Assuming case-insensitive equality,
     * + You cannot narrow `string` to a `string-literal`
     *
     *   Given`x = 'HeLlO'`,
     *   `x` could be `'hello'` or `'HELLO'`
     *
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type CaseInsensitiveNarrow<A extends NonNullBuiltInValueExpr, B extends A> = (Extract<A, string | Uint8Array | Date> extends never ? B : BaseType<B>);
}
declare module "built-in-value-expr/util/operation/case-sensitive-narrow" {
    import { NonNullBuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    import { BaseType } from "type-util/index";
    /**
     * Assuming case-sensitive equality,
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type CaseSensitiveNarrow<A extends NonNullBuiltInValueExpr, B extends A> = (Extract<A, Uint8Array | Date> extends never ? B : BaseType<B>);
}
declare module "built-in-value-expr/util/operation/null-safe-case-insensitive-narrow" {
    import { BuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    import { BaseType } from "type-util/index";
    /**
     * Assuming case-insensitive equality,
     * + You cannot narrow `string` to a `string-literal`
     *
     *   Given`x = 'HeLlO'`,
     *   `x` could be `'hello'` or `'HELLO'`
     *
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type NullSafeCaseInsensitiveNarrow<A extends BuiltInValueExpr, B extends A | null> = (Extract<A, string | Uint8Array | Date> extends never ? B : BaseType<B>);
}
declare module "built-in-value-expr/util/operation/null-safe-case-sensitive-narrow" {
    import { BuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    import { BaseType } from "type-util/index";
    /**
     * Assuming case-sensitive equality,
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type NullSafeCaseSensitiveNarrow<A extends BuiltInValueExpr, B extends A> = (Extract<A, Uint8Array | Date> extends never ? B : BaseType<B>);
}
declare module "built-in-value-expr/util/operation/index" {
    export * from "built-in-value-expr/util/operation/case-insensitive-narrow";
    export * from "built-in-value-expr/util/operation/case-sensitive-narrow";
    export * from "built-in-value-expr/util/operation/null-safe-case-insensitive-narrow";
    export * from "built-in-value-expr/util/operation/null-safe-case-sensitive-narrow";
}
declare module "built-in-value-expr/util/predicate/is-equal" {
    import { BuiltInValueExpr } from "built-in-value-expr/built-in-value-expr";
    export function isEqual(a: BuiltInValueExpr, b: BuiltInValueExpr): boolean;
}
declare module "built-in-value-expr/util/predicate/index" {
    export * from "built-in-value-expr/util/predicate/is-equal";
    export * from "built-in-value-expr/util/predicate/is-non-null-built-in-value-expr";
    export * from "built-in-value-expr/util/predicate/is-built-in-value-expr";
}
declare module "built-in-value-expr/util/index" {
    export * from "built-in-value-expr/util/operation/index";
    export * from "built-in-value-expr/util/predicate/index";
}
declare module "built-in-value-expr/index" {
    export * from "built-in-value-expr/built-in-value-expr";
    import * as BuiltInValueExprArrayUtil from "built-in-value-expr/array-util/index";
    import * as BuiltInValueExprUtil from "built-in-value-expr/util/index";
    export { BuiltInValueExprArrayUtil, BuiltInValueExprUtil, };
}
declare module "ast/util/insert-between" {
    import { Ast } from "ast/ast";
    export function insertBetween(operands: readonly Ast[], insertElement: string): Ast[];
}
declare module "ast/operator-node/operand" {
    import { Ast } from "ast/ast";
    export type Operand0 = readonly [];
    export type Operand1 = readonly [Ast];
    export type Operand2 = readonly [Ast, Ast];
    export type Operand3 = readonly [Ast, Ast, Ast];
    export type Operand0ToN = readonly Ast[];
    export type Operand1ToN = readonly [Ast, ...Ast[]];
    export type Operand2ToN = readonly [Ast, Ast, ...Ast[]];
    export type Operand3ToN = readonly [Ast, Ast, Ast, ...Ast[]];
    export type Operand4ToN = readonly [Ast, Ast, Ast, Ast, ...Ast[]];
    export type AnyArityOperand = Operand0 | Operand1 | Operand2 | Operand3 | Operand0ToN | Operand1ToN | Operand2ToN | Operand3ToN | Operand4ToN;
}
declare module "operator-type" {
    /**
     * It's called `OperatorType` but also contains function names.
     * A function is just an operator with different syntax.
     *
     * -----
     *
     * **EVERY** new `OperatorType` added is a **BREAKING CHANGE**.
     * Make sure to bump the **MAJOR** version number.
     */
    export enum OperatorType {
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `BETWEEN ... AND ...`
         * + PostgreSQL   : `BETWEEN ... AND ...`
         * + SQLite       : `BETWEEN ... AND ...`
         */
        BETWEEN_AND = "BETWEEN_AND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
         * + https://www.postgresql.org/docs/9.5/functions-conditional.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `COALESCE(x, ...)`
         * + PostgreSQL   : `COALESCE(x, ...)`
         * + SQLite       : `COALESCE(x, ...)`
         */
        COALESCE = "COALESCE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `=`
         * + PostgreSQL   : `=`
         * + SQLite       : `=`
         */
        EQUAL = "EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<=>`
         * + PostgreSQL   : `IS NOT DISTINCT FROM`
         * + SQLite       : `IS`
         */
        NULL_SAFE_EQUAL = "NULL_SAFE_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `>`
         * + PostgreSQL   : `>`
         * + SQLite       : `>`
         */
        GREATER_THAN = "GREATER_THAN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `>=`
         * + PostgreSQL   : `>=`
         * + SQLite       : `>=`
         */
        GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
         * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
         *
         * -----
         *
         * + MySQL        : `GREATEST(x, y, ...)` //Requires 2 args
         *   + `NULL` values cause return value of `NULL`
         * + PostgreSQL   : `GREATEST(x, ...)`    //Requires 1 arg
         *   + Ignores `NULL` values
         * + SQLite       : `MAX(x, ...)`         //Requires 1 arg
         *   + `NULL` values cause return value of `NULL`
         */
        GREATEST = "GREATEST",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `IN`
         * + PostgreSQL   : `IN`
         * + SQLite       : `IN`
         */
        IN_ARRAY = "IN_ARRAY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `IN`
         * + PostgreSQL   : `IN`
         * + SQLite       : `IN`
         */
        IN_QUERY = "IN_QUERY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS TRUE`
         * + PostgreSQL   : `IS TRUE`
         * + SQLite       : `<NULL_SAFE_EQUAL> TRUE`
         */
        IS_TRUE = "IS_TRUE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS FALSE`
         * + PostgreSQL   : `IS FALSE`
         * + SQLite       : `<NULL_SAFE_EQUAL> FALSE`
         */
        IS_FALSE = "IS_FALSE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * This does not refer to the TypeScript `unknown`.
         * It refers to the three-valued logic `unknown`.
         *
         * It generally has a value equivalent to `NULL`.
         *
         * -----
         *
         * + MySQL        : `IS UNKNOWN`
         * + PostgreSQL   : `IS UNKNOWN`
         * + SQLite       : `<NULL_SAFE_EQUAL> UNKNOWN`
         */
        IS_UNKNOWN = "IS_UNKNOWN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT TRUE`
         * + PostgreSQL   : `IS NOT TRUE`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> TRUE`
         */
        IS_NOT_TRUE = "IS_NOT_TRUE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT FALSE`
         * + PostgreSQL   : `IS NOT FALSE`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> FALSE`
         */
        IS_NOT_FALSE = "IS_NOT_FALSE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * This does not refer to the TypeScript `unknown`.
         * It refers to the three-valued logic `unknown`.
         *
         * It generally has a value equivalent to `NULL`.
         *
         * -----
         *
         * + MySQL        : `IS NOT UNKNOWN`
         * + PostgreSQL   : `IS NOT UNKNOWN`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> UNKNOWN`
         */
        IS_NOT_UNKNOWN = "IS_NOT_UNKNOWN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT NULL`
         * + PostgreSQL   : `IS NOT NULL`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> NULL`
         */
        IS_NOT_NULL = "IS_NOT_NULL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NULL`
         * + PostgreSQL   : `IS NULL`
         * + SQLite       : `<NULL_SAFE_EQUAL> NULL`
         */
        IS_NULL = "IS_NULL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL        : `LEAST(x, y, ...)` //Requires 2 args
         * + PostgreSQL   : `LEAST(x, ...)`    //Requires 1 arg
         * + SQLite       : `MIN(x, ...)`         //Requires 1 arg
         */
        LEAST = "LEAST",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<`
         * + PostgreSQL   : `<`
         * + SQLite       : `<`
         */
        LESS_THAN = "LESS_THAN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<=`
         * + PostgreSQL   : `<=`
         * + SQLite       : `<=`
         */
        LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `LIKE ... ESCAPE ...`
         * + PostgreSQL   : `LIKE ... ESCAPE ...`
         * + SQLite       : `LIKE ... ESCAPE ...`
         */
        LIKE_ESCAPE = "LIKE_ESCAPE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `NOT BETWEEN ... AND ...`
         * + PostgreSQL   : `NOT BETWEEN ... AND ...`
         * + SQLite       : `NOT BETWEEN ... AND ...`
         */
        NOT_BETWEEN_AND = "NOT_BETWEEN_AND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<>`
         * + PostgreSQL   : `<>`
         * + SQLite       : `<>`
         */
        NOT_EQUAL = "NOT_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `<NOT> (x <NULL_SAFE_EQUAL>)`
         * + PostgreSQL   : `IS DISTINCT FROM`
         * + SQLite       : `IS NOT`
         */
        NOT_NULL_SAFE_EQUAL = "NOT_NULL_SAFE_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `NOT IN`
         * + PostgreSQL   : `NOT IN`
         * + SQLite       : `NOT IN`
         */
        NOT_IN_ARRAY = "NOT_IN_ARRAY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `NOT IN`
         * + PostgreSQL   : `NOT IN`
         * + SQLite       : `NOT IN`
         */
        NOT_IN_QUERY = "NOT_IN_QUERY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `NOT LIKE ... ESCAPE ...`
         * + PostgreSQL   : `NOT LIKE ... ESCAPE ...`
         * + SQLite       : `NOT LIKE ... ESCAPE ...`
         */
        NOT_LIKE_ESCAPE = "NOT_LIKE_ESCAPE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `AND`
         * + PostgreSQL   : `AND`
         * + SQLite       : `AND`
         */
        AND = "AND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `NOT`
         * + PostgreSQL   : `NOT`
         * + SQLite       : `NOT`
         */
        NOT = "NOT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `OR`
         * + PostgreSQL   : `OR`
         * + SQLite       : `OR`
         */
        OR = "OR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
         *
         * -----
         *
         * + MySQL        : `XOR`
         * + PostgreSQL   : `<NOT_EQUAL>`
         * + SQLite       : `<NOT_EQUAL>`
         */
        XOR = "XOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
         * + https://www.sqlite.org/lang_expr.html#case
         *
         * -----
         *
         * + MySQL        : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         * + PostgreSQL   : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         * + SQLite       : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         */
        /**
         * This is handled using `CaseValueNode`
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
         * + https://www.sqlite.org/lang_expr.html#case
         *
         * -----
         *
         * + MySQL        : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         * + PostgreSQL   : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         * + SQLite       : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         */
        /**
         * This is handled using `CaseConditionNode`
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
         *
         * -----
         *
         * + MySQL        : `IF(x, y, z)`
         * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
         * + SQLite       : `CASE WHEN x THEN y ELSE z END`
         */
        IF = "IF",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
         * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
         * + https://www.sqlite.org/lang_corefunc.html#ifnull
         *
         * `COALESCE()` is part of the SQL standard.
         * `IFNULL()` is DB-specific.
         *
         * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
         *
         * -----
         *
         * + MySQL        : `IFNULL(x, y)`
         * + PostgreSQL   : `COALESCE(x, y)`
         * + SQLite       : `IFNULL(x, y)`
         */
        IF_NULL = "IF_NULL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
         * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
         * + https://www.sqlite.org/lang_corefunc.html#nullif
         *
         * -----
         *
         * + MySQL        : `NULLIF(x, y)`
         * + PostgreSQL   : `NULLIF(x, y)`
         * + SQLite       : `NULLIF(x, y)`
         *
         * -----
         *
         * This is the same as `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`
         */
        NULL_IF_EQUAL = "NULL_IF_EQUAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `ASCII(x)`
         * + PostgreSQL     : `ASCII(x)`
         * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
         */
        ASCII = "ASCII",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
         *
         * -----
         *
         * + MySQL          : `BIN(x)`
         * + PostgreSQL     : None. Implement with,
         * ```sql
         *  REGEXP_REPLACE(
         *      (x)::bit(64)::varchar(64),
         *      '^0+(\d+)$',
         *      '\1'
         *  )
         * ```
         * + SQLite         : None. Implement with,
         * ```ts
         * //x >= 0
         * (x).toString(2)
         * //x < 0
         * (2n**64n + BigInt(x)).toString(2)
         * ```
         */
        BIN = "BIN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `BIT_LENGTH(x)`
         * + PostgreSQL     : `BIT_LENGTH(x)`
         * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
         */
        BIT_LENGTH = "BIT_LENGTH",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#length
         * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
         *
         * -----
         *
         * + MySQL          : `CHAR_LENGTH(x)`
         *   + `CHAR_LENGTH('cafȩ́')` returns 6
         * + PostgreSQL     : `CHAR_LENGTH(x)`
         *   + `CHAR_LENGTH('cafȩ́')` returns 8
         * + SQLite         : `LENGTH(x)`
         *   + `LENGTH('cafȩ́')` returns 6
         */
        CHAR_LENGTH = "CHAR_LENGTH",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
         *   + MySQL actually treats `||` as the boolean `OR` operator.
         * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
         *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
         *     + This is different from MySQL's `CONCAT()`
         * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
         *   + SQLite uses an operator, not a function, to concatenate strings
         *   + https://www.sqlite.org/lang_expr.html#collateop
         *
         * -----
         *
         * The SQL standard says,
         * > `<concatenation operator>` is an operator, `||`,
         * > that returns the character string made by joining its character string operands in the order given.
         *
         * MySQL actually treats `||` as the boolean `OR` operator.
         */
        CONCAT = "CONCAT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
         * + PostgreSQL     : `CONCAT(x, ...)`
         *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
         *     + This is different from MySQL's `CONCAT()`
         * + SQLite         : `COALESCE(x, '') || ... || ...`
         *
         * -----
         *
         * The SQL standard says,
         * > `<concatenation operator>` is an operator, `||`,
         * > that returns the character string made by joining its character string operands in the order given.
         *
         * MySQL actually treats `||` as the boolean `OR` operator.
         */
        NULL_SAFE_CONCAT = "NULL_SAFE_CONCAT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `CONCAT_WS(separator, x, ...)`
         *   + If the separator is `NULL`, the result is `NULL`
         *   + Ignores `NULL` arguments after the separator
         * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
         *   + If the separator is `NULL`, the result is `NULL`
         *   + Ignores `NULL` arguments after the separator
         * + SQLite         : None. Implement with user-defined function.
         */
        CONCAT_WS = "CONCAT_WS",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `FROM_BASE64(x)`
         *   + `FROM_BASE64('~')` === `NULL`
         * + PostgreSQL     : `DECODE(x, 'base64')`
         *   + `DECODE('~', 'base64')` throws an error
         * + SQLite         : None, implement with user-defined function `atob()`
         *   + `atob('~')` throws an error
         */
        FROM_BASE64 = "FROM_BASE64",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#hex
         *
         * -----
         *
         * + MySQL          : `HEX(x)`
         * + PostgreSQL     : `ENCODE(x, 'hex')`
         * + SQLite         : `HEX(x)`
         */
        HEX = "HEX",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
         * + https://www.sqlite.org/lang_corefunc.html#instr
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `INSTR(str, substr)`
         * + PostgreSQL     : `STRPOS(str, substr)`
         * + SQLite         : `INSTR(str, substr)`
         */
        IN_STR = "IN_STR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_locate
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `LOCATE(substr, str)/LOCATE(substr, str, pos)`
         * + PostgreSQL     : `STRPOS(str, substr)`, the 3-arg version is more complicated.
         *
         *   Tentatively, `STRPOS(SUBSTR(str, pos), substr) + pos` or something like that.
         *
         * + SQLite         : None. Implement with user-defined function.
         * @todo
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#lower
         *
         * -----
         *
         * + MySQL          : `LOWER(x)`
         * + PostgreSQL     : `LOWER(x)`
         * + SQLite         : `LOWER(x)`
         */
        LOWER = "LOWER",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `LPAD(str, len, padstr)`
         *   + `LPAD('123', 4, '98')` === `'9123'`
         *   + `LPAD('123', 2, '98')` === `'12'`
         * + PostgreSQL     : `LPAD(str, len, padstr)`
         *   + `LPAD('123', 4, '98')` === `'9123'`
         *   + `LPAD('123', 2, '98')` === `'12'`
         * + SQLite         : None. Implement with user-defined function.
         */
        LPAD = "LPAD",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#ltrim
         *
         * -----
         *
         * + MySQL          : `LTRIM(x)`
         * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
         * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
         */
        LTRIM = "LTRIM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `OCTET_LENGTH(x)`
         * + PostgreSQL     : `OCTET_LENGTH(x)`
         * + SQLite         : `LENGTH(CAST(x AS BLOB))`
         */
        OCTET_LENGTH = "OCTET_LENGTH",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `POSITION(substr IN str)`
         * + PostgreSQL     : `POSITION(substr IN str)`
         * + SQLite         : None. Implement with user-defined function.
         */
        POSITION = "POSITION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `REPEAT(x, count)`
         * + PostgreSQL     : `REPEAT(x, count)`
         * + SQLite         : None. Implement with user-defined function.
         */
        REPEAT = "REPEAT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#replace
         *
         * -----
         *
         * + MySQL          : `REPLACE(str, from, to)`
         * + PostgreSQL     : `REPLACE(str, from, to)`
         * + SQLite         : `REPLACE(str, from, to)`
         */
        REPLACE = "REPLACE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `REVERSE(x)`
         * + PostgreSQL     : `REVERSE(x)`
         * + SQLite         : None. Implement with user-defined function.
         */
        REVERSE = "REVERSE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `RPAD(str, len, padstr)`
         * + PostgreSQL     : `RPAD(str, len, padstr)`
         * + SQLite         : None. Implement with user-defined function.
         */
        RPAD = "RPAD",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#rtrim
         *
         * -----
         *
         * + MySQL          : `RTRIM(x)`
         * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
         * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
         */
        RTRIM = "RTRIM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `TO_BASE64(x)`
         * + PostgreSQL     : `ENCODE(x, 'base64')`
         * + SQLite         : None, implement with user-defined function `btoa()`
         */
        TO_BASE64 = "TO_BASE64",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#trim
         *
         * -----
         *
         * + MySQL          : `TRIM(x)`
         * + PostgreSQL     : `TRIM(x)`
         * + SQLite         : `TRIM(x)`
         */
        TRIM = "TRIM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `UNHEX(x)`
         *   + `UNHEX('~')` === `NULL`
         * + PostgreSQL     : `DECODE(x, 'hex')`
         *   + `DECODE('~', 'hex')` throws an error
         * + SQLite         : None. Implement with user-defined function.
         */
        UNHEX = "UNHEX",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#upper
         *
         * -----
         *
         * + MySQL          : `UPPER(x)`
         * + PostgreSQL     : `UPPER(x)`
         * + SQLite         : `UPPER(x)`
         */
        UPPER = "UPPER",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_div
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS
         *
         * -----
         *
         * Interestingly enough,
         * MySQL uses `SIGNED` and `UNSIGNED` for integer type names when casting.
         * PostgreSQL uses `INTEGER`
         *
         * -----
         *
         * + MySQL        : `DIV`
         * + PostgreSQL   : `CAST(TRUNC(CAST(x AS NUMERIC) / CAST(y AS NUMERIC), 0) AS BIGINT)`
         * + SQLite       : `CAST(x/y AS BIGINT)`
         *   + SQLite does not have `DECIMAL` data type support...
         *
         */
        INTEGER_DIVISION = "INTEGER_DIVISION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `/`
         * + PostgreSQL   : `/`
         * + SQLite       : `/`
         */
        FRACTIONAL_DIVISION = "FRACTIONAL_DIVISION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
         *
         * -----
         *
         * + MySQL        : `-`
         * + PostgreSQL   : `-`
         * + SQLite       : `-`
         */
        SUBTRACTION = "SUBTRACTION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * @todo Find out if they behave the same
         *
         * + MySQL        : `%`
         *   + `1%0` === `NULL`
         * + PostgreSQL   : `mod(x, y)` (The `%` operator does not handle negative values)
         *   + `mod(1, 0)` throws error
         * + SQLite       : `%`
         *   + `1%0` === `NULL`
         */
        INTEGER_REMAINDER = "INTEGER_REMAINDER",
        FRACTIONAL_REMAINDER = "FRACTIONAL_REMAINDER",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
         *
         * -----
         *
         * + MySQL        : `+`
         * + PostgreSQL   : `+`
         * + SQLite       : `+`
         */
        ADDITION = "ADDITION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
         *
         * -----
         *
         * + MySQL        : `*`
         * + PostgreSQL   : `*`
         * + SQLite       : `*`
         */
        MULTIPLICATION = "MULTIPLICATION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
         *
         * -----
         *
         * + MySQL        : `-`
         * + PostgreSQL   : `-`
         * + SQLite       : `-`
         */
        UNARY_MINUS = "UNARY_MINUS",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_corefunc.html#abs
         *
         * -----
         *
         * + MySQL        : `ABS(x)`
         * + PostgreSQL   : `@` or `ABS(x)` (Let's not use the ugly `@` operator)
         * + SQLite       : `ABS(x)`
         */
        ABSOLUTE_VALUE = "ABSOLUTE_VALUE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ACOS(x)`
         * + PostgreSQL     : `ACOS(x)`
         * + SQLite         : None, implement with user-defined function
         */
        ARC_COSINE = "ARC_COSINE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ASIN(x)`
         * + PostgreSQL     : `ASIN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        ARC_SINE = "ARC_SINE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ATAN(x)`
         * + PostgreSQL     : `ATAN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        ARC_TANGENT = "ARC_TANGENT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ATAN2(y, x)`
         * + PostgreSQL     : `ATAN2(y, x)`
         * + SQLite         : None, implement with user-defined function
         */
        ARC_TANGENT_2 = "ARC_TANGENT_2",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceil
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL        : `CEIL(x)/CEILING(x)`
         * + PostgreSQL   : `CEIL(x)/CEILING(x)`
         * + SQLite       : None, use the following instead,
         *   + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
         * ```sql
         *  (
         *      CASE
         *          WHEN x = CAST(x AS INT) THEN
         *              CAST(x AS INT)
         *          ELSE
         *              1 + CAST(x AS INT)
         *      END
         *  )
         * ```
         *
         */
        CEILING = "CEILING",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `COS(x)`
         * + PostgreSQL     : `COS(x)`
         * + SQLite         : None, implement with user-defined function
         */
        COSINE = "COSINE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `COT(x)`
         * + PostgreSQL     : `COT(x)`
         * + SQLite         : None, implement with user-defined function
         */
        COTANGENT = "COTANGENT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `DEGREES(x)`
         * + PostgreSQL     : `DEGREES(x)`
         * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
         */
        DEGREES = "DEGREES",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `EXP(x)`
         * + PostgreSQL     : `EXP(x)`
         * + SQLite         : None, implement with user-defined function
         */
        NATURAL_EXPONENTIATION = "NATURAL_EXPONENTIATION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL        : `FLOOR(x)`
         * + PostgreSQL   : `FLOOR(x)`
         * + SQLite       : None, use the following instead,
         *   + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
         * ```sql
         *  (
         *      CASE
         *          WHEN x >= 0 THEN
         *              CAST(x AS INT)
         *          WHEN x = CAST(x AS INT) THEN
         *              CAST(x AS INT)
         *          ELSE
         *              CAST(x - 1.0 AS INT)
         *      END
         *  )
         * ```
         */
        FLOOR = "FLOOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `LN(x)`
         * + PostgreSQL     : `LN(x)`
         * + SQLite         : None, implment with user-defined function
         */
        LN = "LN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `LOG(base, x)`
         * + PostgreSQL     : `LOG(base, x)`
         * + SQLite         : None, implment with user-defined function
         */
        LOG = "LOG",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
         *
         * -----
         *
         * + MySQL          : `LOG2(x)`
         * + PostgreSQL     : `LOG(2.0, x)`
         * + SQLite         : None, implment with user-defined function
         */
        LOG2 = "LOG2",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
         *
         * -----
         *
         * + MySQL          : `LOG10(x)`
         * + PostgreSQL     : `LOG(10.0, x)`
         * + SQLite         : None, implment with user-defined function
         */
        LOG10 = "LOG10",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `PI()` Returns `3.141592653589793`
         * + PostgreSQL     : `PI()` Returns `3.14159265358979`
         * + SQLite         : None, implement using `3.141592653589793`
         *
         * -----
         *
         * In JS, `Math.PI` is `3.141592653589793`
         */
        PI = "PI",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * + MySQL        : `POWER(x, y)`
         * + PostgreSQL   : `^` or `POWER(x, y)` (Let's not use the ugly `^` operator)
         * + SQLite       : Requres creating a `POWER(x, y)` user-defined function
         */
        POWER = "POWER",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `RADIANS(x)`
         * + PostgreSQL     : `RADIANS(x)`
         * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
         */
        RADIANS = "RADIANS",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#random
         *
         * -----
         *
         * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
         * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
         * + SQLite         : Incompatible.
         *
         *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
         *
         *   Therefore, one should use, `ABS(RANDOM()) / 9223372036854775808`
         */
        RANDOM = "RANDOM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `SIGN(x)`
         * + PostgreSQL     : `SIGN(x)`
         * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
         */
        SIGN = "SIGN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `SIN(x)`
         * + PostgreSQL     : `SIN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        SINE = "SINE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * -----
         *
         * + MySQL        : `SQRT(x)`
         * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
         * + SQLite       : Requres creating a `SQRT(x)` user-defined function
         */
        SQUARE_ROOT = "SQUARE_ROOT",
        /**
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * -----
         *
         * + MySQL        : `POWER(x, 1.0/3.0)` The `.0` parts are important!
         * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
         * + SQLite       : Requres creating a `CBRT(x)` user-defined function
         *
         * -----
         *
         * MySQL
         * ```sql
         * SELECT POWER(27, 1.0/3.0)
         * > 3
         * ```
         *
         * PostgreSQL
         * ```sql
         * SELECT POWER(27, 1.0/3.0)
         * > 2.99999999999999999997
         * ```
         */
        CUBE_ROOT = "CUBE_ROOT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `TAN(x)`
         * + PostgreSQL     : `TAN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        TANGENT = "TANGENT",
        /**
         * @todo
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_DATE()`
         * + PostgreSQL     : `CURRENT_DATE()`
         * + SQLite         : `strftime('%Y-%m-%d', 'now')`
         */
        CURRENT_DATE = "CURRENT_DATE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(0)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(0),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(0))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(0),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(0)
         *      ))
         *  > 2019-09-07T23:58:20.000Z
         *  > 1567900700
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%S', 'now'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%S', 'now'));
         *  > 2019-09-07 23:59:35
         *  > 1567900775
         * ```
         */
        CURRENT_TIMESTAMP_0 = "CURRENT_TIMESTAMP_0",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(1)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(1),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(1))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.8
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(1),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(1)
         *      ))
         *  > 2019-09-07T23:58:20.400Z
         *  > 1567900700
         * ```
         * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
         * ```sql
         *  SELECT
         *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21),
         *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21));
         *  > 2019-09-07 23:59:35.3
         *  > 1567900775
         * ```
         */
        CURRENT_TIMESTAMP_1 = "CURRENT_TIMESTAMP_1",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(2)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(2),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(2))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.83
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(2),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(2)
         *      ))
         *  > 2019-09-07T23:58:20.470Z
         *  > 1567900700
         * ```
         * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
         * ```sql
         *  SELECT
         *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22),
         *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22));
         *  > 2019-09-07 23:59:35.32
         *  > 1567900775
         * ```
         */
        CURRENT_TIMESTAMP_2 = "CURRENT_TIMESTAMP_2",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(3)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(3),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.836
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(3),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(3)
         *      ))
         *  > 2019-09-07T23:58:20.477Z
         *  > 1567900700
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%f', 'now'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', 'now'));
         *  > 2019-09-07 23:59:35.327
         *  > 1567900775
         * ```
         */
        CURRENT_TIMESTAMP_3 = "CURRENT_TIMESTAMP_3",
        /**
         *
         * -----
         *
         * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
         *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
         *  > 1969-12-31 22:00:00.123
         *  > 10800
         * ```
         * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
         *      FLOOR(EXTRACT(
         *          EPOCH FROM (
         *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
         *          )
         *      ))
         *  > 1970-01-01T03:00:00.123Z
         *  > 10800
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
         *  > 1970-01-01 03:00:00.123
         *  > 10800
         * ```
         *
         * -----
         *
         * Treat `x` as representing a `UTC` timestamp.
         *
         */
        UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR = "UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000.0) / 1000.0`
         * ```sql
         *  SELECT
         *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
         *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
         *  > 32.4560
         * ```
         * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
         * + SQLite         : `strftime('%f', datetime)`
         * ```sql
         *  SELECT
         *      strftime('%f', '2010-03-27 14:45:32.456789')
         *  > 32.457
         *  -- The result is rounded, not truncated.
         *  -- If it were truncated, we would get 32.456
         * ```
         * ```sql
         *  SELECT
         *      strftime('%f', '2010-03-27 23:59:59.999999')
         *  > 59.999
         *  -- The result is truncated, not rounded.
         *  -- If it were rounded, we would get 60
         * ```
         *
         * @todo Make behaviour consistent?
         */
        EXTRACT_FRACTIONAL_SECOND_3 = "EXTRACT_FRACTIONAL_SECOND_3",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(SECOND FROM datetime)`
         * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
         */
        EXTRACT_INTEGER_SECOND = "EXTRACT_INTEGER_SECOND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
         */
        EXTRACT_MINUTE = "EXTRACT_MINUTE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(HOUR FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
         */
        EXTRACT_HOUR = "EXTRACT_HOUR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(DAY FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
         */
        EXTRACT_DAY = "EXTRACT_DAY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(MONTH FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
         */
        EXTRACT_MONTH = "EXTRACT_MONTH",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(YEAR FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
         */
        EXTRACT_YEAR = "EXTRACT_YEAR",
        /**
         * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
         *
         * -----
         *
         * + MySQL          : `LAST_DAY(datetime)`
         * ```sql
         *  SELECT
         *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
         *  > 2010-03-31
         * ```
         * + PostgreSQL     :
         * ```sql
         *  SELECT
         *      (
         *          datetime +
         *          interval '1 month' -
         *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
         *      )::date
         * > 2010-03-31T00:00:00.000Z
         * ```
         * + SQLite         :
         * ```sql
         *  SELECT
         *      strftime(
         *          '%Y-%m-%d',
         *          '2010-03-27 14:45:32.456789',
         *          '+1 month',
         *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
         *      )
         *  > 2010-03-31
         * ```
         */
        LAST_DAY = "LAST_DAY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x/1000.0, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      (x/1000e0) || ' second'
         *  );
         * ```
         */
        TIMESTAMPADD_MILLISECOND = "TIMESTAMPADD_MILLISECOND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' second'
         *  );
         * ```
         */
        TIMESTAMPADD_SECOND = "TIMESTAMPADD_SECOND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0, datetime)`
         *   + `TIMESTAMPADD(MINUTE, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' minute'
         *  );
         * ```
         */
        TIMESTAMPADD_MINUTE = "TIMESTAMPADD_MINUTE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0*60.0, datetime)`
         *   + `TIMESTAMPADD(HOUR, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' hour'
         *  );
         * ```
         */
        TIMESTAMPADD_HOUR = "TIMESTAMPADD_HOUR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*24.0*60.0*60.0, datetime)`
         *   + `TIMESTAMPADD(DAY, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' day'
         *  );
         * ```
         */
        TIMESTAMPADD_DAY = "TIMESTAMPADD_DAY",
        /**
         * Seems to be a MySQL and PostgreSQL thing.
         * SQLite does not have `week` intervals.
         *
         * Could probably be emulated with `7 day` being `1 week`
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' month'
         *  );
         * ```
         */
        TIMESTAMPADD_MONTH = "TIMESTAMPADD_MONTH",
        /**
         * Seems to be a MySQL thing.
         * PostgreSQL and SQLite do not have `quarter` intervals.
         *
         * Could probably be emulated with `3 month` being `1 quarter`
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' year'
         *  );
         * ```
         */
        TIMESTAMPADD_YEAR = "TIMESTAMPADD_YEAR",
        /**
         * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
         *   + The `TRUNC()` at the end is necessary
         *   + Extracting `SECOND` gives a number with decimal places for milliseconds
         *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        TIMESTAMPDIFF_MILLISECOND = "TIMESTAMPDIFF_MILLISECOND",
        /**
         * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
         *   + The `TRUNC()` at the end is necessary
         *   + Extracting `SECOND` gives a number with decimal places for milliseconds
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        TIMESTAMPDIFF_SECOND = "TIMESTAMPDIFF_SECOND",
        /**
         * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        TIMESTAMPDIFF_MINUTE = "TIMESTAMPDIFF_MINUTE",
        /**
         * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        TIMESTAMPDIFF_HOUR = "TIMESTAMPDIFF_HOUR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
         *
         * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
         * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        TIMESTAMPDIFF_DAY = "TIMESTAMPDIFF_DAY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `UNIX_TIMESTAMP()`
         * + PostgreSQL     :
         * ```sql
         *  FLOOR(
         *      EXTRACT(EPOCH FROM (
         *          CURRENT_TIMESTAMP -
         *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
         *      ))
         *  )
         * ```
         * + SQLite         : `strftime('%s', 'now')`
         */
        UNIX_TIMESTAMP_NOW = "UNIX_TIMESTAMP_NOW",
        /**
         * @todo
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS BINARY)`
         * + PostgreSQL     : `CAST(x AS bytea)`
         * + SQLite         : `CAST(x AS BLOB)`
         */
        CAST_AS_BINARY = "CAST_AS_BINARY",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS CHAR) [charset_info]`
         * + PostgreSQL     : `CAST(x AS VARCHAR) [charset_info]`
         * + SQLite         : `CAST(x AS VARCHAR) [charset_info]`
         */
        CAST_AS_VARCHAR = "CAST_AS_VARCHAR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS DECIMAL(precision, scale))`
         *   + Max precision : 65
         *   + Max scale     : 30
         * + PostgreSQL     : `CAST(x AS DECIMAL(precision, scale))`
         *   + Max precision : 1000
         *   + Max scale     : 1000
         * + SQLite         : `CAST(x AS DECIMAL(precision, scale))`
         * ```sql
         * SELECT CAST('1e308' AS DECIMAL)
         * > 1e+308
         * ```
         *
         * For SQLite, this doesn't even cast to an arbitrary precision number.
         * SQLite does not support arbitrary precision numbers.
         * You will get a `double` instead.
         *
         * -----
         *
         * Precision and scale cannot be omitted.
         *
         * When omitted, MySQL defaults to `DECIMAL(10, 0)`
         * When omitted, PostgreSQL defaults to a precision and scale that will contain `x`
         *
         * -----
         *
         * ### Notes about MySQL's `DECIMAL`
         *
         * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1253-L1313
         * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1576-L1598
         *
         * ```js
         * DIG_PER_DEC1 = 9
         * dig2bytes = [0,1,1,2,2,3,3,4,4,4]
         * precision = 65
         * scale = 30
         * //typedef int32 decimal_digit_t;
         * //typedef decimal_digit_t dec1;
         * dec1 = 4
         * function sizeof (arg) { return arg }
         * var
         *      intg = precision - scale,
         *      intg0  = Math.floor(intg / DIG_PER_DEC1),
         *      frac0  = Math.floor(scale / DIG_PER_DEC1),
         *      intg0x = intg - intg0 * DIG_PER_DEC1,
         *      frac0x = scale - frac0 * DIG_PER_DEC1;
         * result = intg0 * sizeof(dec1) + dig2bytes[intg0x] + frac0 * sizeof(dec1) + dig2bytes[frac0x]
         * ```
         *
         * http://ftp.nchu.edu.tw/MySQL/doc/refman/5.0/en/precision-math-decimal-changes.html
         *
         * -----
         *
         * ```js
         * DIG_PER_DEC1 = 9;
         * dig2bytes = [0, 1, 1, 2, 2, 3, 3, 4, 4, 4];
         *
         * res = {};
         *
         * for (let precision = 1; precision < 73; precision++) {
         *      for (let scale = 0; scale <= precision; scale++) {
         *          const intg = precision - scale;
         *          const intg0 = Math.floor(intg / DIG_PER_DEC1);
         *          const frac0 = Math.floor(scale / DIG_PER_DEC1);
         *          const intg0x = intg - intg0 * DIG_PER_DEC1;
         *          const frac0x = scale - frac0 * DIG_PER_DEC1;
         *          const result = (
         *              intg0 * 4 + dig2bytes[intg0x] + frac0 * 4 + dig2bytes[frac0x]
         *          );
         *          res[`${precision}.${scale}`] = result;
         *      }
         * }
         * console.log(res);
         * ```
         *
         * -----
         *
         * ### Notes about PostgreSQL's `DECIMAL`
         *
         * https://doxygen.postgresql.org/numeric_8h.html#a12ab0e498cc609664248b5c9bb6c0a43
         *
         * @karanlyons said,
         * > 511 bytes for 1000 digits in postgres.
         * >
         * > And I think they use the extra byte for some additional bookeeping of the sign, etc.
         * >
         * > So 512, which makes sense!
         * >
         * > <3 u pg.
         * >
         * > Postgres’ source code is way better to read.
         * >
         * > It helps that they’re not insane.
         * >
         * > ~~That extra byte is actually for the type header I think, not internal bookkeeping of the number itself.~~
         * >
         * > The extra byte is for the `typmod` I think, which is 32 bits encoding the precision and scale in the upper 16 and lower 16.
         * >
         * > https://doxygen.postgresql.org/backend_2utils_2adt_2numeric_8c_source.html#l00703
         * >
         * > https://doxygen.postgresql.org/structNumericVar.html
         */
        CAST_AS_DECIMAL = "CAST_AS_DECIMAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL 5.7      : `x + 0e0`
         * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
         * + SQLite         : `CAST(x AS DOUBLE)`
         */
        CAST_AS_DOUBLE = "CAST_AS_DOUBLE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS JSON)`
         * + PostgreSQL     : `CAST(x AS JSON)`
         * + SQLite         : `CAST(x AS TEXT)`; Or implement with user-defined function.
         *
         *   SQLite does not have a `JSON` data type
         */
        CAST_AS_JSON = "CAST_AS_JSON",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS SIGNED INTEGER)`
         *   + Actually gives a signed `bigint`
         *   + Trying to cast `'123e2'` gives `123`
         * + PostgreSQL     : `CAST(x AS bigint)`
         *   + Trying to cast `'123e2'` throws an error
         * + SQLite         : `CAST(x AS BIGINT)`
         *   + Trying to cast `'123e2'` gives `123`
         */
        CAST_AS_BIGINT_SIGNED = "CAST_AS_BIGINT_SIGNED",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x & y AS SIGNED)`
         * + PostgreSQL   : `&`
         * + SQLite       : `&`
         */
        BITWISE_AND = "BITWISE_AND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(~x AS SIGNED)`
         *   + `~1337` === `18446744073709550278`
         *   + `CAST(~1337 AS SIGNED)` === `-1338`
         * + PostgreSQL   : `~x`
         *   + `~1337` === `-1338`
         * + SQLite       : `~x`
         *   + `~1337` === `-1338`
         */
        BITWISE_NOT = "BITWISE_NOT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x | y AS SIGNED)`
         * + PostgreSQL   : `|`
         * + SQLite       : `|`
         */
        BITWISE_OR = "BITWISE_OR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x ^ y AS SIGNED)`
         * + PostgreSQL   : `#`
         * + SQLite       : None, use `(~(a&b))&(a|b)` instead
         *   + https://stackoverflow.com/questions/16440831/bitwise-xor-in-sqlite-bitwise-not-not-working-as-i-expect
         *   + https://www.mail-archive.com/sqlite-users@mailinglists.sqlite.org/msg02250.html
         */
        BITWISE_XOR = "BITWISE_XOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x << y AS SIGNED)`
         * + PostgreSQL   : `<<`
         * + SQLite       : `<<`
         */
        BITWISE_LEFT_SHIFT = "BITWISE_LEFT_SHIFT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x >> y AS SIGNED)`
         * + PostgreSQL   : `>>`
         * + SQLite       : `>>`
         */
        BITWISE_RIGHT_SHIFT = "BITWISE_RIGHT_SHIFT",
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * @todo
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#avg
         *
         * -----
         *
         * + MySQL      : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         * + PostgreSQL : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         * + SQLite     : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         */
        AGGREGATE_AVERAGE = "AGGREGATE_AVERAGE",
        /**
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-xor
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#count
         *
         * -----
         *
         * + MySQL      : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` always returns one row
         * + PostgreSQL : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` can return zero rows
         * + SQLite     : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` can return zero rows
         */
        AGGREGATE_COUNT_EXPR = "AGGREGATE_COUNT_EXPR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#count
         *
         * -----
         *
         * + MySQL      : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         * + PostgreSQL : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         * + SQLite     : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         */
        AGGREGATE_COUNT_ALL = "AGGREGATE_COUNT_ALL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
         *
         * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
         * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
         * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
         *   + The order of the concatenated elements is arbitrary.
         *   + Uses comma as separator
         *
         * -----
         *
         * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
         * for the DB-unified implementation.
         *
         * Unless we modify the SQLite implementation with a user-defined function?
         * @todo Investigate
         */
        AGGREGATE_GROUP_CONCAT_DISTINCT = "AGGREGATE_GROUP_CONCAT_DISTINCT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
         *
         * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
         * + PostgreSQL : `STRING_AGG(expr, separator)`
         * + SQLite     : `GROUP_CONCAT(expr, separator)`
         *   + The order of the concatenated elements is arbitrary.
         */
        AGGREGATE_GROUP_CONCAT_ALL = "AGGREGATE_GROUP_CONCAT_ALL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
         *
         * -----
         *
         * + MySQL      : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         * + PostgreSQL : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         * + SQLite     : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         */
        AGGREGATE_MAX = "AGGREGATE_MAX",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `MIN(DISTINCT x)/MIN(x) OVER()`
         * + PostgreSQL : `MIN(DISTINCT x)/MIN(x) OVER()`
         * + SQLite     : `MIN(DISTINCT x)/MIN(x)/MIN(x) OVER()`
         */
        AGGREGATE_MIN = "AGGREGATE_MIN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
         *
         * -----
         *
         * + MySQL      : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
         * + PostgreSQL : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        AGGREGATE_POPULATION_STANDARD_DEVIATION = "AGGREGATE_POPULATION_STANDARD_DEVIATION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
         *
         * -----
         *
         * + MySQL      : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
         * + PostgreSQL : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        AGGREGATE_SAMPLE_STANDARD_DEVIATION = "AGGREGATE_SAMPLE_STANDARD_DEVIATION",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        AGGREGATE_SUM = "AGGREGATE_SUM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        AGGREGATE_SUM_AS_DECIMAL = "AGGREGATE_SUM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        AGGREGATE_SUM_AS_BIGINT_SIGNED = "AGGREGATE_SUM",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `VAR_POP(x)/VAR_POP(x) OVER()`
         * + PostgreSQL : `VAR_POP(x)/VAR_POP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        AGGREGATE_POPULATION_VARIANCE = "AGGREGATE_POPULATION_VARIANCE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
         * + PostgreSQL : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        AGGREGATE_SAMPLE_VARIANCE = "AGGREGATE_SAMPLE_VARIANCE",
        /**
         * + https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html
         * + https://www.postgresql.org/docs/8.1/functions-subquery.html#AEN13171
         * + https://www.sqlite.org/lang_expr.html#exists_op
         *
         * -----
         *
         * + MySQL      : `EXISTS(query)`
         * + PostgreSQL : `EXISTS(query)`
         * + SQLite     : `EXISTS(query)`
         */
        EXISTS = "EXISTS",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
         * + https://www.postgresql.org/docs/9.2/functions-info.html
         * + https://www.sqlite.org/lang_attach.html
         *
         * -----
         *
         * + MySQL      : `DATABASE()`
         * + PostgreSQL : `CURRENT_SCHEMA`
         * + SQLite     : `'main'` should always be the current database.
         *   + There's also `'temp'`, I guess
         */
        CURRENT_SCHEMA = "CURRENT_SCHEMA",
        /**
         * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
         * + https://www.postgresql.org/docs/9.2/functions-info.html
         * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
         *
         * -----
         *
         * + MySQL      : `CURRENT_USER`
         * + PostgreSQL : `CURRENT_USER`
         * + SQLite     : None. It does not make sense to ask what the current user is.
         */
        CURRENT_USER = "CURRENT_USER",
        /**
         * + MySQL      - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
         * + PostgreSQL - `COALESCE(x, (SELECT NULL UNION ALL SELECT x))`
         *   Unfortunately, with PostgreSQL, we need to duplicate the expression...
         *   But this is a debug expression, anyway, and should not be used often.
         * + SQLite     - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
         */
        THROW_IF_NULL = "THROW_IF_NULL"
    }
}
declare module "ast/operator-node/operator-operand" {
    import { OperatorType } from "operator-type";
    import { Operand1, Operand2, Operand3, Operand1ToN, Operand2ToN, Operand0 } from "ast/operator-node/operand";
    export type OperatorOperand = {
        [OperatorType.BETWEEN_AND]: Operand3;
        [OperatorType.COALESCE]: Operand2ToN;
        [OperatorType.EQUAL]: Operand2;
        [OperatorType.NULL_SAFE_EQUAL]: Operand2;
        [OperatorType.GREATER_THAN]: Operand2;
        [OperatorType.GREATER_THAN_OR_EQUAL]: Operand2;
        [OperatorType.GREATEST]: Operand2ToN;
        [OperatorType.IN_ARRAY]: Operand2ToN;
        [OperatorType.IN_QUERY]: Operand2;
        [OperatorType.IS_TRUE]: Operand1;
        [OperatorType.IS_FALSE]: Operand1;
        [OperatorType.IS_UNKNOWN]: Operand1;
        [OperatorType.IS_NOT_TRUE]: Operand1;
        [OperatorType.IS_NOT_FALSE]: Operand1;
        [OperatorType.IS_NOT_UNKNOWN]: Operand1;
        [OperatorType.IS_NOT_NULL]: Operand1;
        [OperatorType.IS_NULL]: Operand1;
        [OperatorType.LEAST]: Operand2ToN;
        [OperatorType.LESS_THAN]: Operand2;
        [OperatorType.LESS_THAN_OR_EQUAL]: Operand2;
        [OperatorType.LIKE_ESCAPE]: Operand3;
        [OperatorType.NOT_BETWEEN_AND]: Operand3;
        [OperatorType.NOT_EQUAL]: Operand2;
        [OperatorType.NOT_NULL_SAFE_EQUAL]: Operand2;
        [OperatorType.NOT_IN_ARRAY]: Operand2ToN;
        [OperatorType.NOT_IN_QUERY]: Operand2;
        [OperatorType.NOT_LIKE_ESCAPE]: Operand3;
        /**
         * With zero operands, this resolves to `TRUE`
         */
        [OperatorType.AND]: Operand1ToN;
        [OperatorType.NOT]: Operand1;
        /**
         * With zero operands, this resolves to `FALSE`
         */
        [OperatorType.OR]: Operand1ToN;
        [OperatorType.XOR]: Operand2;
        [OperatorType.IF]: Operand3;
        [OperatorType.IF_NULL]: Operand2;
        [OperatorType.NULL_IF_EQUAL]: Operand2;
        [OperatorType.ASCII]: Operand1;
        [OperatorType.BIN]: Operand1;
        [OperatorType.BIT_LENGTH]: Operand1;
        [OperatorType.CHAR_LENGTH]: Operand1;
        [OperatorType.CONCAT]: Operand1ToN;
        [OperatorType.NULL_SAFE_CONCAT]: Operand1ToN;
        [OperatorType.CONCAT_WS]: Operand2ToN;
        [OperatorType.FROM_BASE64]: Operand1;
        [OperatorType.HEX]: Operand1;
        [OperatorType.IN_STR]: Operand2;
        [OperatorType.LOWER]: Operand1;
        [OperatorType.LPAD]: Operand3;
        [OperatorType.LTRIM]: Operand1;
        [OperatorType.OCTET_LENGTH]: Operand1;
        [OperatorType.POSITION]: Operand2;
        [OperatorType.REPEAT]: Operand2;
        [OperatorType.REPLACE]: Operand3;
        [OperatorType.REVERSE]: Operand1;
        [OperatorType.RPAD]: Operand3;
        [OperatorType.RTRIM]: Operand1;
        [OperatorType.TO_BASE64]: Operand1;
        [OperatorType.TRIM]: Operand1;
        [OperatorType.UNHEX]: Operand1;
        [OperatorType.UPPER]: Operand1;
        [OperatorType.INTEGER_DIVISION]: Operand2;
        [OperatorType.FRACTIONAL_DIVISION]: Operand2;
        [OperatorType.SUBTRACTION]: Operand2;
        [OperatorType.INTEGER_REMAINDER]: Operand2;
        [OperatorType.FRACTIONAL_REMAINDER]: Operand2;
        [OperatorType.ADDITION]: Operand1ToN;
        [OperatorType.MULTIPLICATION]: Operand2 | Operand1ToN;
        [OperatorType.UNARY_MINUS]: Operand1;
        [OperatorType.ABSOLUTE_VALUE]: Operand1;
        [OperatorType.ARC_COSINE]: Operand1;
        [OperatorType.ARC_SINE]: Operand1;
        [OperatorType.ARC_TANGENT]: Operand1;
        [OperatorType.ARC_TANGENT_2]: Operand2;
        [OperatorType.CEILING]: Operand1;
        [OperatorType.COSINE]: Operand1;
        [OperatorType.COTANGENT]: Operand1;
        [OperatorType.DEGREES]: Operand1;
        [OperatorType.NATURAL_EXPONENTIATION]: Operand1;
        [OperatorType.FLOOR]: Operand1;
        [OperatorType.LN]: Operand1;
        [OperatorType.LOG]: Operand2;
        [OperatorType.LOG2]: Operand1;
        [OperatorType.LOG10]: Operand1;
        [OperatorType.PI]: Operand0;
        [OperatorType.POWER]: Operand2;
        [OperatorType.RADIANS]: Operand1;
        [OperatorType.RANDOM]: Operand0;
        [OperatorType.SIGN]: Operand1;
        [OperatorType.SINE]: Operand1;
        [OperatorType.SQUARE_ROOT]: Operand1;
        [OperatorType.CUBE_ROOT]: Operand1;
        [OperatorType.TANGENT]: Operand1;
        [OperatorType.CURRENT_DATE]: Operand0;
        [OperatorType.CURRENT_TIMESTAMP_0]: Operand0;
        [OperatorType.CURRENT_TIMESTAMP_1]: Operand0;
        [OperatorType.CURRENT_TIMESTAMP_2]: Operand0;
        [OperatorType.CURRENT_TIMESTAMP_3]: Operand0;
        [OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR]: Operand1;
        [OperatorType.EXTRACT_FRACTIONAL_SECOND_3]: Operand1;
        [OperatorType.EXTRACT_INTEGER_SECOND]: Operand1;
        [OperatorType.EXTRACT_MINUTE]: Operand1;
        [OperatorType.EXTRACT_HOUR]: Operand1;
        [OperatorType.EXTRACT_DAY]: Operand1;
        [OperatorType.EXTRACT_MONTH]: Operand1;
        [OperatorType.EXTRACT_YEAR]: Operand1;
        [OperatorType.LAST_DAY]: Operand1;
        [OperatorType.TIMESTAMPADD_MILLISECOND]: Operand2;
        [OperatorType.TIMESTAMPADD_SECOND]: Operand2;
        [OperatorType.TIMESTAMPADD_MINUTE]: Operand2;
        [OperatorType.TIMESTAMPADD_HOUR]: Operand2;
        [OperatorType.TIMESTAMPADD_DAY]: Operand2;
        [OperatorType.TIMESTAMPADD_MONTH]: Operand2;
        [OperatorType.TIMESTAMPADD_YEAR]: Operand2;
        [OperatorType.TIMESTAMPDIFF_MILLISECOND]: Operand2;
        [OperatorType.TIMESTAMPDIFF_SECOND]: Operand2;
        [OperatorType.TIMESTAMPDIFF_MINUTE]: Operand2;
        [OperatorType.TIMESTAMPDIFF_HOUR]: Operand2;
        [OperatorType.TIMESTAMPDIFF_DAY]: Operand2;
        [OperatorType.UNIX_TIMESTAMP_NOW]: Operand0;
        [OperatorType.CAST_AS_BINARY]: Operand1;
        [OperatorType.CAST_AS_VARCHAR]: Operand1 | Operand2;
        [OperatorType.CAST_AS_DECIMAL]: Operand3;
        [OperatorType.CAST_AS_DOUBLE]: Operand1;
        [OperatorType.CAST_AS_JSON]: Operand1;
        [OperatorType.CAST_AS_BIGINT_SIGNED]: Operand1;
        [OperatorType.BITWISE_AND]: Operand1ToN;
        [OperatorType.BITWISE_NOT]: Operand1;
        [OperatorType.BITWISE_OR]: Operand1ToN;
        [OperatorType.BITWISE_XOR]: Operand2;
        [OperatorType.BITWISE_LEFT_SHIFT]: Operand2;
        [OperatorType.BITWISE_RIGHT_SHIFT]: Operand2;
        [OperatorType.AGGREGATE_AVERAGE]: Operand2;
        [OperatorType.AGGREGATE_COUNT_EXPR]: Operand2;
        [OperatorType.AGGREGATE_COUNT_ALL]: Operand0;
        [OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT]: Operand1;
        [OperatorType.AGGREGATE_GROUP_CONCAT_ALL]: Operand2;
        [OperatorType.AGGREGATE_MAX]: Operand1;
        [OperatorType.AGGREGATE_MIN]: Operand1;
        [OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION]: Operand1;
        [OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION]: Operand1;
        [OperatorType.AGGREGATE_SUM]: Operand2;
        [OperatorType.AGGREGATE_POPULATION_VARIANCE]: Operand1;
        [OperatorType.AGGREGATE_SAMPLE_VARIANCE]: Operand1;
        [OperatorType.EXISTS]: Operand1;
        [OperatorType.CURRENT_SCHEMA]: Operand0;
        [OperatorType.CURRENT_USER]: Operand0;
        [OperatorType.THROW_IF_NULL]: Operand1;
    };
}
declare module "type-hint" {
    export enum TypeHint {
        DECIMAL = "DECIMAL",
        STRING = "STRING",
        DOUBLE = "DOUBLE",
        BIGINT_SIGNED = "BIGINT_SIGNED",
        BOOLEAN = "BOOLEAN",
        BUFFER = "BUFFER",
        NULL = "NULL",
        DATE_TIME = "DATE_TIME"
    }
}
declare module "ast/operator-node/operator-node" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { TypeHint } from "type-hint";
    export interface OperatorNode<OperatorTypeT extends OperatorType = OperatorType> {
        readonly type: "Operator";
        readonly operatorType: OperatorTypeT;
        readonly operands: OperatorOperand[OperatorTypeT];
        /**
         * Necessary because of the following scenario,
         * The AST for computing the `INTEGER_DIVISION` of two numbers will not always be the same.
         *
         * With `DOUBLE` data type,
         * + MySQL      : `(x DIV y) + 0e0`
         * + PostgreSQL : `FLOOR(x / y)`
         * + SQLite     : `FLOOR(x / y)`
         *
         * The AST will look like `{ operatorType : "INTEGER_DIVISION", typeHint : "DOUBLE" }`
         *
         * With `INTEGER` data type,
         * + MySQL      : `x DIV y`
         * + PostgreSQL : `x / y`
         * + SQLite     : `x / y`
         *
         * The AST will look like
         * + `{ operatorType : "INTEGER_DIVISION", typeHint : "BIGINT" }`
         *
         * With `DECIMAL` data type,
         * + MySQL      : `x DIV y`
         * + PostgreSQL : `FLOOR(x / y)`
         * + SQLite     : Does not exist. Maybe implement with custom `DECIMAL_INTERGER_DIVISION(x, y)` function
         *
         * The AST will look like
         * + `{ operatorType : "INTEGER_DIVISION", typeHint : "DECIMAL" }`
         *
         * -----
         *
         */
        readonly typeHint: TypeHint | undefined;
    }
}
declare module "ast/operator-node/util/predicate/assert-has-operand-0" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand0 } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand0<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand0> extends never ? CompileError<["Expected nullary operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/assert-has-operand-1-to-n" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand1ToN } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand1ToN<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand1ToN> extends never ? CompileError<["Expected 1-to-N operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/assert-has-operand-1" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand1 } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand1<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand1> extends never ? CompileError<["Expected unary operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/assert-has-operand-2-to-n" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand2ToN } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand2ToN<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand2ToN> extends never ? CompileError<["Expected 2-to-N operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/assert-has-operand-2" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand2 } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand2<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand2> extends never ? CompileError<["Expected binary operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/assert-has-operand-3" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { Operand3 } from "ast/operator-node/operand";
    import { ExtractStrictSameType } from "type-util/index";
    import { CompileError } from "compile-error/index";
    export type AssertHasOperand3<OperatorTypeT extends OperatorType> = ExtractStrictSameType<OperatorOperand[OperatorTypeT], Operand3> extends never ? CompileError<["Expected binary operator, received", OperatorTypeT]> : unknown;
}
declare module "ast/operator-node/util/predicate/is-operator-node" {
    import { OperatorNode } from "ast/operator-node/operator-node";
    export function isOperatorNode(mixed: unknown): mixed is OperatorNode;
}
declare module "ast/operator-node/util/predicate/index" {
    export * from "ast/operator-node/util/predicate/assert-has-operand-0";
    export * from "ast/operator-node/util/predicate/assert-has-operand-1-to-n";
    export * from "ast/operator-node/util/predicate/assert-has-operand-1";
    export * from "ast/operator-node/util/predicate/assert-has-operand-2-to-n";
    export * from "ast/operator-node/util/predicate/assert-has-operand-2";
    export * from "ast/operator-node/util/predicate/assert-has-operand-3";
    export * from "ast/operator-node/util/predicate/is-operator-node";
}
declare module "ast/operator-node/util/constructor/operator-node-0" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand0 } from "ast/operator-node/util/predicate/index";
    import { TypeHint } from "type-hint";
    export function operatorNode0<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand0<OperatorTypeT>, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node-1-to-n" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand1ToN } from "ast/operator-node/util/predicate/index";
    import { Operand1ToN } from "ast/operator-node/operand";
    import { TypeHint } from "type-hint";
    export function operatorNode1ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand1ToN<OperatorTypeT>, operands: Operand1ToN, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node-1" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand1 } from "ast/operator-node/util/predicate/index";
    import { Operand1 } from "ast/operator-node/operand";
    import { TypeHint } from "type-hint";
    export function operatorNode1<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand1<OperatorTypeT>, operands: Operand1, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node-2-to-n" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand2ToN } from "ast/operator-node/util/predicate/index";
    import { Operand2ToN } from "ast/operator-node/operand";
    import { TypeHint } from "type-hint";
    export function operatorNode2ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand2ToN<OperatorTypeT>, operands: Operand2ToN, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node-2" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand2 } from "ast/operator-node/util/predicate/index";
    import { Operand2 } from "ast/operator-node/operand";
    import { TypeHint } from "type-hint";
    export function operatorNode2<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand2<OperatorTypeT>, operands: Operand2, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node-3" {
    import { OperatorType } from "operator-type";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertHasOperand3 } from "ast/operator-node/util/predicate/index";
    import { Operand3 } from "ast/operator-node/operand";
    import { TypeHint } from "type-hint";
    export function operatorNode3<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertHasOperand3<OperatorTypeT>, operands: Operand3, typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/operator-node" {
    import { OperatorType } from "operator-type";
    import { OperatorOperand } from "ast/operator-node/operator-operand";
    import { OperatorNode } from "ast/operator-node/operator-node";
    import { AssertNonUnion } from "type-util/index";
    import { TypeHint } from "type-hint";
    export function operatorNode<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & AssertNonUnion<OperatorTypeT>, operands: OperatorOperand[OperatorTypeT], typeHint: TypeHint | undefined): OperatorNode<OperatorTypeT>;
}
declare module "ast/operator-node/util/constructor/index" {
    export * from "ast/operator-node/util/constructor/operator-node-0";
    export * from "ast/operator-node/util/constructor/operator-node-1-to-n";
    export * from "ast/operator-node/util/constructor/operator-node-1";
    export * from "ast/operator-node/util/constructor/operator-node-2-to-n";
    export * from "ast/operator-node/util/constructor/operator-node-2";
    export * from "ast/operator-node/util/constructor/operator-node-3";
    export * from "ast/operator-node/util/constructor/operator-node";
}
declare module "ast/operator-node/util/index" {
    export * from "ast/operator-node/util/constructor/index";
    export * from "ast/operator-node/util/predicate/index";
}
declare module "ast/operator-node/index" {
    export * from "ast/operator-node/operand";
    export * from "ast/operator-node/operator-node";
    export * from "ast/operator-node/operator-operand";
    import * as OperatorNodeUtil from "ast/operator-node/util/index";
    export { OperatorNodeUtil, };
}
declare module "ast/literal-value-node/literal-value-node" {
    export enum LiteralValueType {
        /**
         * Can only be created using the `decimalLiteral()` function
         */
        DECIMAL = "DECIMAL",
        /**
         * ```ts
         * typeof x == "string"
         * ```
         */
        STRING = "STRING",
        /**
         * ```ts
         * typeof x == "number"
         * ```
         */
        DOUBLE = "DOUBLE",
        /**
         * ```ts
         * tm.TypeUtil.isBigInt(x) &&
         * //bigint signed minimum value
         * tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
         * //bigint signed maximum value
         * tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807"))
         * ```
         */
        BIGINT_SIGNED = "BIGINT_SIGNED",
        /**
         * ```ts
         * typeof x == "boolean"
         * ```
         */
        BOOLEAN = "BOOLEAN",
        /**
         * An unsigned char array (8-bit unsigned integer)
         * ```ts
         * x instanceof Uint8Array
         * ```
         * @todo Rename this to `UINT8ARRAY`?
         */
        BUFFER = "BUFFER",
        /**
         * ```ts
         * x === null
         * ```
         */
        NULL = "NULL",
        /**
         * ```ts
         * DateUtil.isDate(x)
         * ```
         */
        DATE_TIME = "DATE_TIME"
    }
    export const literalValueTypeElements: readonly LiteralValueType[];
    export interface DecimalLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.DECIMAL;
        readonly literalValue: string;
        readonly precision: bigint;
        readonly scale: bigint;
    }
    export interface StringLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.STRING;
        readonly literalValue: string;
    }
    export interface DoubleLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.DOUBLE;
        readonly literalValue: number;
    }
    export interface BigIntSignedLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.BIGINT_SIGNED;
        readonly literalValue: bigint;
    }
    export interface BooleanLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.BOOLEAN;
        readonly literalValue: boolean;
    }
    /**
     * @todo Rename this to Uint8ArrayLiteralNode
     */
    export interface BufferLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.BUFFER;
        readonly literalValue: Uint8Array;
    }
    export interface NullLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.NULL;
        readonly literalValue: null;
    }
    export interface DateTimeLiteralNode {
        readonly type: "LiteralValue";
        readonly literalValueType: LiteralValueType.DATE_TIME;
        readonly literalValue: Date;
    }
    export type LiteralValueNode = DecimalLiteralNode | StringLiteralNode | DoubleLiteralNode | BigIntSignedLiteralNode | BooleanLiteralNode | BufferLiteralNode | NullLiteralNode | DateTimeLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/bigint-literal-node" {
    import { BigIntSignedLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function isBigIntSigned(x: bigint): boolean;
    /**
     * @todo Remove
     * @deprecated
     */
    export function isBigIntUnsigned(x: bigint): boolean;
    export function isBigIntSignedLiteral(x: bigint): boolean;
    /**
     * @todo Remove
     * @deprecated
     */
    export function isBigIntUnsignedLiteral(x: bigint): boolean;
    export function bigIntSignedLiteralNode(literalValue: bigint): BigIntSignedLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/boolean-literal-node" {
    import { BooleanLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function booleanLiteralNode(literalValue: boolean): BooleanLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/buffer-literal-node" {
    import { BufferLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function bufferLiteralNode(literalValue: Uint8Array): BufferLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/date-time-literal-node" {
    import { DateTimeLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function dateTimeLiteralNode(literalValue: Date): DateTimeLiteralNode;
}
declare module "decimal/decimal" {
    import { Decimal } from "type-mapping/dist/mysql-lib";
    export { Decimal, };
}
declare module "decimal/index" {
    export * from "decimal/decimal";
}
declare module "column-identifier/column-identifier" {
    /**
     * Contains enough information to identify a column within a database.
     *
     * Does not contain the column's type.
     */
    export interface ColumnIdentifier {
        readonly tableAlias: string;
        readonly columnAlias: string;
    }
}
declare module "column-identifier/util/constructor/from-column-identifier-map" {
    import { ColumnIdentifierMap } from "column-identifier-map/index";
    export type FromColumnIdentifierMap<ColumnMapT extends ColumnIdentifierMap> = (ColumnMapT extends ColumnIdentifierMap ? ColumnMapT[Extract<keyof ColumnMapT, string>] : never);
}
declare module "column-identifier/util/constructor/from-column" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type FromColumn<ColumnT extends ColumnIdentifier> = (ColumnT extends ColumnIdentifier ? {
        readonly tableAlias: ColumnT["tableAlias"];
        readonly columnAlias: ColumnT["columnAlias"];
    } : never);
    export function fromColumn<ColumnT extends ColumnIdentifier>(column: ColumnT): FromColumn<ColumnT>;
}
declare module "column-identifier/util/constructor/from-column-map" {
    import { FromColumn } from "column-identifier/util/constructor/from-column";
    import { ColumnIdentifierMap } from "column-identifier-map/index";
    export type FromColumnMap<ColumnMapT extends ColumnIdentifierMap> = (ColumnMapT extends ColumnIdentifierMap ? FromColumn<ColumnMapT[Extract<keyof ColumnMapT, string>]> : never);
    export function fromColumnMap<ColumnMapT extends ColumnIdentifierMap>(map: ColumnMapT): (FromColumnMap<ColumnMapT>[]);
}
declare module "column-identifier/util/constructor/from-column-ref" {
    import { FromColumnMap } from "column-identifier/util/constructor/from-column-map";
    import { ColumnIdentifierRef } from "column-identifier-ref/index";
    export type FromColumnRef<ColumnRefT extends ColumnIdentifierRef> = (ColumnRefT extends ColumnIdentifierRef ? FromColumnMap<ColumnRefT[Extract<keyof ColumnRefT, string>]> : never);
    export function fromColumnRef<ColumnRefT extends ColumnIdentifierRef>(ref: ColumnRefT): (FromColumnRef<ColumnRefT>[]);
}
declare module "expr-select-item/expr-select-item" {
    import * as tm from "type-mapping";
    import { IUsedRef } from "used-ref/index";
    import { Ast } from "ast/index";
    export interface ExprSelectItemData {
        readonly mapper: tm.SafeMapper<any>;
        readonly tableAlias: string;
        readonly alias: string;
        readonly usedRef: IUsedRef;
        readonly isAggregate: boolean;
    }
    /**
     * Could be an aliased expression, or an aliased subquery with one expression selected.
     */
    export interface IExprSelectItem<DataT extends ExprSelectItemData = ExprSelectItemData> {
        /**
         * The mapper that validates/converts raw values for use
         */
        readonly mapper: DataT["mapper"];
        /**
         * The table alias.
         *
         * ```sql
         * SELECT
         *  --The `tableAlias` is `myTable`
         *  --The `alias` is `myAlias`
         *  myTable.myColumn AS myAlias
         * FROM
         *  myTable
         * ```
         *
         * ```sql
         * SELECT
         *  --The `tableAlias` is `$aliased`
         *  --The `alias` is `myAlias`
         *  RAND() AS myAlias
         * ```
         */
        readonly tableAlias: DataT["tableAlias"];
        /**
         * The alias.
         *
         * ```sql
         * SELECT
         *  --The `tableAlias` is `myTable`
         *  --The `alias` is `myAlias`
         *  myTable.myColumn AS myAlias
         * FROM
         *  myTable
         * ```
         */
        readonly alias: DataT["alias"];
        /**
         * The columns used by this expression.
         * ```sql
         * SELECT
         *  --The `usedRef` of this expression are the two columns involved
         *  (myTable.myColumn + otherTable.otherColumn)
         * FROM
         *  myTable
         * JOIN
         *  otherTable
         * ON
         *  myTable.id = otherTable.id
         * ```
         */
        readonly usedRef: DataT["usedRef"];
        readonly isAggregate: DataT["isAggregate"];
        /**
         * The AST without the `AS alias` part.
         *
         * The full AST would be,
         * ```sql
         * (expr) AS alias
         * ```
         *
         * But `unaliasedAst` only has,
         * ```sql
         * (expr)
         * ```
         */
        readonly unaliasedAst: Ast;
    }
    export type IAnonymousExprSelectItem<TypeT, IsAggregateT extends boolean> = (IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        tableAlias: string;
        alias: string;
        usedRef: IUsedRef;
        isAggregate: IsAggregateT;
    }>);
}
declare module "expr-select-item/util/operation/with-type" {
    import * as tm from "type-mapping";
    import { IExprSelectItem } from "expr-select-item/expr-select-item";
    import { IUsedRef } from "used-ref/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WithTypeImpl<TypeT, TableAliasT extends string, AliasT extends string, UsedRefT extends IUsedRef, IsAggregateT extends boolean> = (IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        tableAlias: TableAliasT;
        alias: AliasT;
        usedRef: UsedRefT;
        isAggregate: IsAggregateT;
    }>);
    /**
     * Used to replace the type of an `IExprSelectItem`
     */
    export type WithType<ExprSelectItemT extends IExprSelectItem, TypeT> = (ExprSelectItemT extends IExprSelectItem ? WithTypeImpl<TypeT, ExprSelectItemT["tableAlias"], ExprSelectItemT["alias"], ExprSelectItemT["usedRef"], ExprSelectItemT["isAggregate"]> : never);
    export function withType<ExprSelectItemT extends IExprSelectItem, TypeT>({ tableAlias, alias, usedRef, unaliasedAst, isAggregate, }: ExprSelectItemT, newMapper: tm.SafeMapper<TypeT>): (WithType<ExprSelectItemT, TypeT>);
}
declare module "expr-select-item/util/operation/index" {
    export * from "expr-select-item/util/operation/with-type";
}
declare module "expr-select-item/util/predicate/is-expr-select-item" {
    import { IAnonymousExprSelectItem } from "expr-select-item/expr-select-item";
    /**
     * Does not actually check,
     * + `x.usedRef` is `IUsedRef`
     * + `x.unaliasedAst` is `Ast`
     *
     * @todo Consider adding checks for increased type safety.
     */
    export function isExprSelectItem(x: unknown): x is IAnonymousExprSelectItem<unknown, boolean>;
}
declare module "expr-select-item/util/predicate/index" {
    export * from "expr-select-item/util/predicate/is-expr-select-item";
}
declare module "expr-select-item/util/index" {
    export * from "expr-select-item/util/operation/index";
    export * from "expr-select-item/util/predicate/index";
}
declare module "expr-select-item/index" {
    export * from "expr-select-item/expr-select-item";
    import * as ExprSelectItemUtil from "expr-select-item/util/index";
    export { ExprSelectItemUtil, };
}
declare module "column-identifier/util/constructor/from-expr-select-item" {
    import { IExprSelectItem } from "expr-select-item/index";
    export type FromExprSelectItem<ExprSelectItemT extends Pick<IExprSelectItem, "tableAlias" | "alias">> = (ExprSelectItemT extends Pick<IExprSelectItem, "tableAlias" | "alias"> ? {
        readonly tableAlias: ExprSelectItemT["tableAlias"];
        readonly columnAlias: ExprSelectItemT["alias"];
    } : never);
    export function fromExprSelectItem<ExprSelectItemT extends Pick<IExprSelectItem, "tableAlias" | "alias">>(column: ExprSelectItemT): FromExprSelectItem<ExprSelectItemT>;
}
declare module "column/column" {
    import * as tm from "type-mapping";
    import { Ast } from "ast/index";
    export interface ColumnData {
        readonly tableAlias: string;
        readonly columnAlias: string;
        /**
         * @todo Change this to `unknown` and fix errors
         */
        readonly mapper: tm.SafeMapper<any>;
    }
    export interface IColumn<DataT extends ColumnData = ColumnData> {
        /**
         * The alias of the table that this column belongs to.
         *
         * An aliased expression has this set to `typeof ALIASED`
         */
        readonly tableAlias: DataT["tableAlias"];
        /**
         * The alias of this column
         */
        readonly columnAlias: DataT["columnAlias"];
        /**
         * The mapper that validates/converts raw column values for use
         */
        readonly mapper: DataT["mapper"];
        /**
         * ```sql
         *  (
         *      SELECT
         *          --The `unaliasedAst` of this column is `undefined`
         *          myTable.myColumn,
         *          --The `unaliasedAst` of this column is `RAND()`
         *          RAND() AS `$aliased--curTime` --This is an ExprSelectItem
         *      FROM
         *          myTable
         *      ORDER BY
         *          `$aliased--curTime`  ASC
         *  )
         * ```
         */
        readonly unaliasedAst: undefined | Ast;
    }
    export type IAnonymousColumn<T> = IColumn<{
        tableAlias: string;
        columnAlias: string;
        mapper: tm.SafeMapper<T>;
    }>;
}
declare module "column-map/column-map" {
    import { IColumn } from "column/index";
    export interface ColumnMap {
        readonly [columAlias: string]: IColumn;
    }
    export interface WritableColumnMap {
        [columnAlias: string]: IColumn;
    }
}
declare module "column-map/util/constructor/from-column-array" {
    import { IColumn, ColumnUtil } from "column/index";
    export type FromColumnArray<ColumnsT extends readonly IColumn[]> = (ColumnsT extends readonly IColumn[] ? {
        readonly [columnAlias in ColumnsT[number]["columnAlias"]]: (ColumnUtil.ExtractWithColumnAlias<ColumnsT[number], columnAlias>);
    } : never);
    export function fromColumnArray<ColumnsT extends readonly IColumn[]>(columns: ColumnsT): FromColumnArray<ColumnsT>;
}
declare module "column-map/util/constructor/from-column-union" {
    import { IColumn, ColumnUtil } from "column/index";
    export type FromColumnUnion<ColumnT extends IColumn> = ({
        readonly [columnAlias in ColumnT["columnAlias"]]: (ColumnUtil.ExtractWithColumnAlias<ColumnT, columnAlias>);
    });
}
declare module "column-map/util/constructor/from-column" {
    import { IColumn } from "column/index";
    export type FromColumn<ColumnT extends IColumn> = (ColumnT extends IColumn ? {
        readonly [columnAlias in ColumnT["columnAlias"]]: ColumnT;
    } : never);
    export function fromColumn<ColumnT extends IColumn>(column: ColumnT): FromColumn<ColumnT>;
}
declare module "column-map/util/constructor/from-field-array" {
    import * as tm from "type-mapping";
    import { Column } from "column/index";
    export type FromFieldArray<TableAliasT extends string, FieldsT extends readonly tm.AnyField[]> = (FieldsT[number] extends never ? {} : {
        readonly [columnAlias in FieldsT[number]["__name"]]: (Column<{
            tableAlias: TableAliasT;
            columnAlias: columnAlias;
            mapper: tm.SafeMapper<tm.OutputOf<Extract<FieldsT[number], tm.Name<columnAlias>>>>;
        }>);
    });
    export function fromFieldArray<TableAliasT extends string, FieldsT extends readonly tm.AnyField[]>(tableAlias: TableAliasT, fields: FieldsT): (FromFieldArray<TableAliasT, FieldsT>);
}
declare module "column-map/util/operation/left-compound" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import { Column } from "column/index";
    /**
     * Like `LeftIntersect`, but the type of columns is unioned,
     * not intersected.
     *
     * This is used to implement `CompoundQueryClauseUtil.compoundQuery()`
     *
     * @todo Better name?
     */
    export type LeftCompound<MapA extends ColumnMap, MapB extends ColumnMap> = ({
        readonly [columnAlias in Extract<keyof MapA, string>]: (columnAlias extends keyof MapB ? Column<{
            tableAlias: MapA[columnAlias]["tableAlias"];
            columnAlias: MapA[columnAlias]["columnAlias"];
            mapper: tm.SafeMapper<tm.OutputOf<MapA[columnAlias]["mapper"]> | tm.OutputOf<MapB[columnAlias]["mapper"]>>;
        }> : MapA[columnAlias]);
    });
    export function leftCompound<MapA extends ColumnMap, MapB extends ColumnMap>(mapA: MapA, mapB: MapB): (LeftCompound<MapA, MapB>);
}
declare module "column-map/util/operation/compound" {
    import { ColumnMap } from "column-map/column-map";
    import { LeftCompound } from "column-map/util/operation/left-compound";
    import { Merge } from "type-util/index";
    export type CompoundImpl<MapA extends ColumnMap, MapB extends ColumnMap> = (LeftCompound<MapA, MapB> & {
        readonly [columnAlias in Exclude<Extract<keyof MapB, string>, keyof MapA>]: (MapB[columnAlias]);
    });
    /**
     * Like `Intersect`, but the type of columns is unioned,
     * not intersected.
     *
     * This is used to implement `CompoundQueryClauseUtil.compoundQuery()`
     *
     * @todo Better name?
     */
    export type Compound<MapA extends ColumnMap, MapB extends ColumnMap> = (Merge<CompoundImpl<MapA, MapB>>);
    export function compound<MapA extends ColumnMap, MapB extends ColumnMap>(mapA: MapA, mapB: MapB): (Compound<MapA, MapB>);
}
declare module "data-type/util/constructor/make-data-type" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonCorrelated_NonAggregate } from "built-in-expr/index";
    import { DataType } from "data-type/data-type-impl";
    export function makeDataType<TypeT>(mapper: tm.SafeMapper<TypeT>, toBuiltInExpr_NonCorrelated: (value: TypeT) => BuiltInExpr_NonCorrelated_NonAggregate<TypeT>, isNullSafeEqual: (a: TypeT, b: TypeT) => boolean, extraMapper?: tm.Mapper<TypeT, TypeT>): DataType<TypeT>;
}
declare module "data-type/util/constructor/index" {
    export * from "data-type/util/constructor/make-data-type";
}
declare module "key/key" {
    /**
     * Each `string` element represents a column name.
     *
     * A "key" is a set of columns that uniquely identifies
     * a row in a table.
     */
    export type Key = readonly string[];
}
declare module "key/util/operation/remove-duplicates" {
    import { Key } from "key/key";
    export function removeDuplicates<KeyT extends Key>(key: KeyT): (readonly (KeyT[number])[]);
}
declare module "key/util/operation/append" {
    import { Key } from "key/key";
    export type Append<KeyT extends Key, StrT extends string> = (readonly (KeyT[number] | StrT)[]);
    export function append<KeyT extends Key, StrT extends string>(key: KeyT, str: StrT): (Append<KeyT, StrT>);
}
declare module "key/util/operation/concat" {
    import { Key } from "key/key";
    export type Concat<A extends Key, B extends Key> = (readonly (A[number] | B[number])[]);
    export type ConcatDistribute<A extends Key, B extends Key> = (A extends Key ? (B extends Key ? readonly (A[number] | B[number])[] : never) : never);
    export function concat<A extends Key, B extends Key>(a: A, b: B): (Concat<A, B>);
}
declare module "key/util/operation/extract-sub-key" {
    import { Key } from "key/key";
    /**
     * https://github.com/microsoft/TypeScript/issues/32540#issuecomment-514931644
     *
     * This works and I have no idea why.
     * Please don't kill me.
     *
     * If `A` is a subkey of `B`, it returns `A`.
     * Otherwise, it returns `never`.
     */
    export type ExtractSubKey<A extends Key, B extends Key> = (A extends Key ? (B extends Key ? (A[number] extends Extract<B[number], A[number]> ? A : never) : never) : never);
}
declare module "key/util/operation/extract-super-key" {
    import { Key } from "key/key";
    /**
     * https://github.com/microsoft/TypeScript/issues/32540#issuecomment-514931644
     *
     * This works and I have no idea why.
     * Please don't kill me.
     *
     * -----
     *
     * If `A` is a super key of `B`, `A` is returned.
     * Otherwise, `never` is returned.
     */
    export type ExtractSuperKey<A extends Key, B extends Key> = (A extends Key ? (B extends Key ? (B[number] extends Extract<A[number], B[number]> ? A : never) : never) : never);
}
declare module "key/util/operation/remove" {
    import { Key } from "key/key";
    export type Remove<KeyT extends Key, StrT extends string> = (readonly Exclude<KeyT[number], StrT>[]);
    export function remove<KeyT extends Key, StrT extends string>(key: KeyT, str: StrT): (Remove<KeyT, StrT>);
}
declare module "key/util/operation/subtract" {
    import { Key } from "key/key";
    export type Subtract<A extends Key, B extends Key> = (readonly Exclude<A[number], B[number]>[]);
    export type SubtractDistribute<A extends Key, B extends Key> = A extends Key ? readonly Exclude<A[number], B[number]>[] : never;
    export function subtract<A extends Key, B extends Key>(a: A, b: B): (Subtract<A, B>);
}
declare module "key/util/operation/to-error-message-friendly-type" {
    import { Key } from "key/key";
    /**
     * Used to generate nicer looking error messages
     */
    export type ToErrorMessageFriendlyType<KeyT extends Key> = (KeyT extends Key ? (KeyT[number])[] : never);
}
declare module "key/util/operation/index" {
    export * from "key/util/operation/append";
    export * from "key/util/operation/concat";
    export * from "key/util/operation/extract-sub-key";
    export * from "key/util/operation/extract-super-key";
    export * from "key/util/operation/remove-duplicates";
    export * from "key/util/operation/remove";
    export * from "key/util/operation/subtract";
    export * from "key/util/operation/to-error-message-friendly-type";
}
declare module "key/util/constructor/from-column-array" {
    import { IColumn } from "column/index";
    /**
     * + Assumes `ArrT` may be a union
     */
    export type FromColumnArray<ArrT extends readonly Pick<IColumn, "columnAlias">[]> = (ArrT extends readonly IColumn[] ? readonly (ArrT[number]["columnAlias"])[] : never);
    export function fromColumnArray<ArrT extends readonly IColumn[]>(columns: ArrT): (FromColumnArray<ArrT>);
}
declare module "key/util/constructor/from-column" {
    import { IColumn } from "column/index";
    /**
     * + Assumes `ColumnT` may be a union
     */
    export type FromColumn<ColumnT extends IColumn> = (ColumnT extends IColumn ? readonly (ColumnT["columnAlias"])[] : never);
    export function fromColumn<ColumnT extends IColumn>(column: ColumnT): (FromColumn<ColumnT>);
}
declare module "key/util/constructor/index" {
    export * from "key/util/constructor/from-column-array";
    export * from "key/util/constructor/from-column";
}
declare module "key/util/predicate/is-key" {
    import { Key } from "key/key";
    export function isKey(raw: any): raw is Key;
}
declare module "key/util/predicate/is-sub-key" {
    import { Key } from "key/key";
    export type IsSubKey<A extends Key, B extends Key> = (A extends Key ? (B extends Key ? (A[number] extends B[number] ? true : false) : never) : never);
    export function isSubKey<A extends Key, B extends Key>(a: A, b: B): IsSubKey<A, B>;
}
declare module "key/util/predicate/is-equal" {
    import { Key } from "key/key";
    /**
     * Use this to check if `K0` is equal to **both** `K1` and `K2`
     * ```ts
     * type Result = IsEqual<K0, K1|K2> extends true ? "y" : "n"
     * ```
     *
     * -----
     *
     * Use this to check if `K0` is equal to **either** `K1` or `K2`
     * ```ts
     * type Result = true extends IsEqual<K0, K1|K2> ? "y" : "n"
     * ```
     */
    export type IsEqual<A extends Key, B extends Key> = (A extends Key ? (B extends Key ? (A[number] extends B[number] ? (B[number] extends A[number] ? true : false) : false) : never) : never);
    export function isEqual(a: Key, b: Key): boolean;
}
declare module "key/util/predicate/index" {
    export * from "key/util/predicate/is-key";
    export * from "key/util/predicate/is-equal";
    export * from "key/util/predicate/is-sub-key";
}
declare module "key/util/query/exclude-if-in-key-array" {
    import { Key } from "key/key";
    import * as KeyArrayUtil from "key/array-util/index";
    /**
     * + Assumes `ArrT` may be a union
     * + Assumes `KeyT` may be a union
     *
     * Excludes all `KeyT` that exist in all `ArrT`.
     *
     * If a given `KeyT` does not exist in some `ArrT`, it is not part of the result.
     */
    export type ExcludeIfInKeyArray<KeyT extends Key, ArrT extends readonly Key[]> = (KeyT extends Key ? (KeyArrayUtil.HasKey<ArrT, KeyT> extends true ? never : KeyT) : never);
}
declare module "key/util/query/extract-if-in-column-map" {
    import { Key } from "key/key";
    import { ColumnMap } from "column-map/index";
    /**
     * + Assumes `KeyT` may be a union
     * + Assumes `ColumnMapT` may be a union
     *
     * Extracts all `KeyT` that exist in all `ColumnMapT`.
     *
     * If a given `KeyT` does not exist in some `ColumnMapT`, it is not part of the result.
     */
    export type ExtractIfInColumnMap<KeyT extends Key, ColumnMapT extends ColumnMap> = (KeyT extends Key ? (
    /**
     * keyof ({ x:string,y:string }|{ x:string,z:string }) === "x"
     */
    KeyT[number] extends keyof ColumnMapT ? KeyT : never) : never);
}
declare module "key/util/query/extract-if-in-key-array" {
    import { Key } from "key/key";
    import * as KeyArrayUtil from "key/array-util/index";
    /**
     * + Assumes `ArrT` may be a union
     * + Assumes `KeyT` may be a union
     *
     * Extracts all `KeyT` that exist in all `ArrT`.
     *
     * If a given `KeyT` does not exist in some `ArrT`, it is not part of the result.
     */
    export type ExtractIfInKeyArray<KeyT extends Key, ArrT extends readonly Key[]> = (KeyT extends Key ? (KeyArrayUtil.HasKey<ArrT, KeyT> extends true ? KeyT : never) : never);
}
declare module "key/util/query/index" {
    export * from "key/util/query/exclude-if-in-key-array";
    export * from "key/util/query/extract-if-in-column-map";
    export * from "key/util/query/extract-if-in-key-array";
}
declare module "key/util/index" {
    export * from "key/util/constructor/index";
    export * from "key/util/operation/index";
    export * from "key/util/predicate/index";
    export * from "key/util/query/index";
}
declare module "key/array-util/predicate/has-key" {
    import { Key } from "key/key";
    /**
     * + Assumes `ArrT` is not a union
     * + Assumes `KeyT` may be a union
     */
    export type HasKey_NonUnion<ArrT extends readonly Key[], KeyT extends Key> = (KeyT extends ArrT[number] ? (Extract<ArrT[number], KeyT> extends never ? false : true) : false);
    /**
     * + Assumes `ArrT` may be a union
     * + Assumes `KeyT` may be a union
     */
    export type HasKey<ArrT extends readonly Key[], KeyT extends Key> = (ArrT extends readonly Key[] ? HasKey_NonUnion<ArrT, KeyT> : never);
    export function hasKey<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): HasKey<ArrT, KeyT>;
}
declare module "key/array-util/predicate/has-sub-key" {
    import { Key } from "key/key";
    import * as KeyUtil from "key/util/index";
    export type HasSubKey<ArrT extends readonly Key[], KeyT extends Key> = (true extends KeyUtil.IsSubKey<ArrT[number], KeyT> ? true : false);
    export function hasSubKey<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): HasSubKey<ArrT, KeyT>;
}
declare module "key/array-util/predicate/has-super-key" {
    import { Key } from "key/key";
    import * as KeyUtil from "key/util/index";
    export type HasSuperKey<ArrT extends readonly Key[], KeyT extends Key> = (true extends KeyUtil.IsSubKey<KeyT, ArrT[number]> ? true : false);
    export function hasSuperKey<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): HasSuperKey<ArrT, KeyT>;
}
declare module "key/array-util/predicate/is-key-array" {
    import { Key } from "key/key";
    export function isKeyArray(raw: any): raw is readonly Key[];
}
declare module "key/array-util/predicate/is-disjoint" {
    import { Key } from "key/key";
    export function isDisjoint(arrayA: readonly Key[], arrayB: readonly Key[]): boolean;
}
declare module "key/array-util/predicate/index" {
    export * from "key/array-util/predicate/has-key";
    export * from "key/array-util/predicate/has-sub-key";
    export * from "key/array-util/predicate/has-super-key";
    export * from "key/array-util/predicate/is-key-array";
    export * from "key/array-util/predicate/is-disjoint";
}
declare module "key/array-util/operation/remove-duplicates" {
    import { Key } from "key/key";
    export function removeDuplicates<ArrT extends readonly Key[]>(arr: ArrT): (readonly (ArrT[number])[]);
}
declare module "key/array-util/operation/append" {
    import { Key } from "key/key";
    export type Append<ArrT extends readonly Key[], KeyT extends Key> = (readonly (ArrT[number] | KeyT)[]);
    export function append<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): (Append<ArrT, KeyT>);
}
declare module "key/array-util/operation/index" {
    export * from "key/array-util/operation/append";
    export * from "key/array-util/operation/remove-duplicates";
}
declare module "key/array-util/query/extract-keys-in-common" {
    import { Key } from "key/key";
    import * as KeyUtil from "key/util/index";
    /**
     * + Assumes `ArrT` may be a union
     *
     * Extracts a `Key` if it is in all `ArrT`
     */
    export type ExtractKeysInCommon<ArrT extends readonly Key[]> = (KeyUtil.ExtractIfInKeyArray<ArrT[number], ArrT>);
}
declare module "key/array-util/query/find-sub-key" {
    import { Key } from "key/key";
    import * as KeyUtil from "key/util/index";
    export type FindSubKey<ArrT extends readonly Key[], KeyT extends Key> = (KeyUtil.ExtractSubKey<ArrT[number], KeyT>);
    export function findSubKeys<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): FindSubKey<ArrT, KeyT>[];
}
declare module "key/array-util/query/find-super-key" {
    import { Key } from "key/key";
    import * as KeyUtil from "key/util/index";
    export type FindSuperKey<ArrT extends readonly Key[], KeyT extends Key> = (KeyUtil.ExtractSuperKey<ArrT[number], KeyT>);
    export function findSuperKeys<ArrT extends readonly Key[], KeyT extends Key>(arr: ArrT, key: KeyT): FindSuperKey<ArrT, KeyT>[];
}
declare module "key/array-util/query/index" {
    export * from "key/array-util/query/extract-keys-in-common";
    export * from "key/array-util/query/find-sub-key";
    export * from "key/array-util/query/find-super-key";
}
declare module "key/array-util/index" {
    export * from "key/array-util/operation/index";
    export * from "key/array-util/predicate/index";
    export * from "key/array-util/query/index";
}
declare module "key/index" {
    export * from "key/key";
    import * as KeyArrayUtil from "key/array-util/index";
    import * as KeyUtil from "key/util/index";
    export { KeyArrayUtil, KeyUtil, };
}
declare module "aliased-table/aliased-table" {
    import { ColumnMap } from "column-map/index";
    import { Ast } from "ast/index";
    import { IUsedRef } from "used-ref/index";
    export interface AliasedTableData {
        readonly isLateral: boolean;
        /**
         * This has to be called `alias` and not `tableAlias`.
         *
         * `IExprSelectItem` has `tableAlias` and `alias`.
         * When the SQL is generated, it should look like, `tableAlias--alias`.
         *
         * When an `IQueryBase` is aliased, it can be,
         * + `DerivedTable`
         *   ```sql
         *      SELECT
         *          *
         *      FROM
         *          (
         *              SELECT
         *                  *
         *              FROM
         *                  myTable
         *          ) AS q
         *   ```
         * + `DerivedTable` & `IExprSelectItem`
         *    The below SQL snippet can be used as both a derived table
         *    and a correlated subquery!
         *    ```sql
         *      (SELECT myColumn FROM myTable LIMIT 1) AS q
         *    ```
         *
         * When we have `DerivedTable` & `IExprSelectItem`,
         * + `tableAlias` will be set to `typeof ALIASED`
         * + `alias` will be set to `q` (given the above example)
         *
         * So, the `alias` of `DerivedTable` must also be `q`.
         */
        readonly alias: string;
        readonly columns: ColumnMap;
        readonly usedRef: IUsedRef;
    }
    export interface IAliasedTable<DataT extends AliasedTableData = AliasedTableData> {
        /**
         * + Not in MySQL 5.7
         * + New in MySQL 8.0
         *
         * In MySQL 5.7, a derived table could not reference tables
         * in the same `FROM/JOIN` clause.
         *
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      sameFromClauseTable
         *  JOIN
         *      --This derived table references `sameFromClauseTable.sameFromClauseColumn`
         *      --This is not allowed
         *      (
         *          SELECT
         *              *
         *          FROM
         *              innerTable
         *          WHERE
         *              --This expression references `sameFromClauseTable.sameFromClauseColumn`
         *              sameFromClauseTable.sameFromClauseColumn > innerTable.innerColumn
         *      ) AS derivedTable
         * ```
         *
         * -----
         *
         * In MySQL 8.0, the `LATERAL` keyword was introduced that allows
         * derived tables to reference tables in the same `FROM/JOIN` clause.
         *
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      sameFromClauseTable
         *  JOIN
         *      --This derived table references `sameFromClauseTable.sameFromClauseColumn`
         *      --This is allowed because of `LATERAL`
         *      LATERAL (
         *          SELECT
         *              *
         *          FROM
         *              innerTable
         *          WHERE
         *              --This expression references `sameFromClauseTable.sameFromClauseColumn`
         *              sameFromClauseTable.sameFromClauseColumn > innerTable.innerColumn
         *      ) AS derivedTable
         * ```
         */
        readonly isLateral: DataT["isLateral"];
        /**
         * The alias of the table.
         *
         * ```sql
         * SELECT
         *  *
         * FROM
         *  --The `alias` is `myAlias`
         *  (
         *      SELECT
         *          *
         *      FROM
         *          myTable
         *  ) AS myAlias
         * ```
         */
        readonly alias: DataT["alias"];
        /**
         * The columns of this table
         */
        readonly columns: DataT["columns"];
        /**
         * The columns used by this expression.
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * CROSS JOIN LATERAL
         *  --The `usedRef` of this table is `myTable.myColumn`,
         *  --an outer query column
         *  (
         *     SELECT
         *          (myTable.myColumn + otherTable.otherColumn)
         *     FROM
         *          otherTable
         *     WHERE
         *          myTable.id = otherTable.id
         *  ) AS tmpTable
         * ```
         *
         * For now, derived tables cannot have columns in `usedRef`
         *
         * @todo Implement `LATERAL` joins?
         */
        readonly usedRef: DataT["usedRef"];
        /**
         * Given the following,
         *
         * ```sql
         *  (
         *      SELECT
         *          RAND() AS randomNumber,
         *          UTC_TIMESTAMP() AS timeNow
         *  ) AS tmpTable --This is an `AliasedTable`
         * ```
         *
         * The unaliased AST is,
         * ```sql
         *  (
         *      SELECT
         *          RAND() AS randomNumber,
         *          UTC_TIMESTAMP() AS timeNow
         *  )
         * ```
         *
         */
        readonly unaliasedAst: Ast;
    }
    /**
     * A table can be aliased,
     *
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * CROSS JOIN
     *  (
     *      myTable
     *  ) AS otherTable --This is an `AliasedTable`
     * ```
     *
     * For aliasing a query (derived tables), @see {@link DerivedTable}
     */
    export class AliasedTable<DataT extends AliasedTableData> implements IAliasedTable<DataT> {
        readonly isLateral: DataT["isLateral"];
        readonly alias: DataT["alias"];
        readonly columns: DataT["columns"];
        readonly usedRef: DataT["usedRef"];
        readonly unaliasedAst: Ast;
        constructor(data: DataT, unaliasedAst: Ast);
    }
}
declare module "aliased-table/util/query/candidate-keys" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { ITable } from "table/index";
    export type CandidateKeys<AliasedTableT extends IAliasedTable> = (AliasedTableT extends ITable ? AliasedTableT["candidateKeys"] : readonly []);
    export function candidateKeys<AliasedTableT extends IAliasedTable>(aliasedTable: AliasedTableT): (CandidateKeys<AliasedTableT>);
}
declare module "aliased-table/util/query/delete-enabled" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { ITable } from "table/index";
    export type DeleteEnabled<AliasedTableT extends IAliasedTable> = (AliasedTableT extends ITable ? AliasedTableT["deleteEnabled"] : false);
    export function deleteEnabled<AliasedTableT extends IAliasedTable>(aliasedTable: AliasedTableT): (DeleteEnabled<AliasedTableT>);
}
declare module "aliased-table/util/query/extract-with-table-alias" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    /**
     * Given a union of `IAliasedTable`, it extracts the ones with the specified `TableAliasT`
     */
    export type ExtractWithTableAlias<AliasedTableT extends IAliasedTable, TableAliasT extends string> = (Extract<AliasedTableT, {
        tableAlias: TableAliasT;
    }>);
}
declare module "aliased-table/util/query/mutable-columns" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { ITable } from "table/index";
    export type MutableColumns<AliasedTableT extends IAliasedTable> = (AliasedTableT extends ITable ? AliasedTableT["mutableColumns"] : readonly []);
    export function mutableColumns<AliasedTableT extends IAliasedTable>(aliasedTable: AliasedTableT): (MutableColumns<AliasedTableT>);
}
declare module "aliased-table/util/query/primary-key" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { ITable } from "table/index";
    export type PrimaryKey<AliasedTableT extends IAliasedTable> = (AliasedTableT extends ITable ? AliasedTableT["primaryKey"] : undefined);
    export function primaryKey<AliasedTableT extends IAliasedTable>(aliasedTable: AliasedTableT): (PrimaryKey<AliasedTableT>);
}
declare module "aliased-table/util/query/index" {
    export * from "aliased-table/util/query/candidate-keys";
    export * from "aliased-table/util/query/delete-enabled";
    export * from "aliased-table/util/query/extract-with-table-alias";
    export * from "aliased-table/util/query/mutable-columns";
    export * from "aliased-table/util/query/primary-key";
}
declare module "aliased-table/util/index" {
    export * from "aliased-table/util/query/index";
}
declare module "aliased-table/array-util/query/duplicate-table-alias" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { IsUnion } from "type-util/index";
    import { ExtractWithTableAlias } from "aliased-table/util/index";
    export type DuplicateTableAlias<ArrT extends readonly IAliasedTable[]> = ({
        [tableAlias in ArrT[number]["alias"]]: (IsUnion<ExtractWithTableAlias<ArrT[number], tableAlias>> extends true ? tableAlias : never);
    }[ArrT[number]["alias"]]);
    export function duplicateTableAlias<ArrT extends readonly IAliasedTable[]>(arr: ArrT): (DuplicateTableAlias<ArrT>[]);
}
declare module "aliased-table/array-util/query/index" {
    export * from "aliased-table/array-util/query/duplicate-table-alias";
}
declare module "aliased-table/array-util/predicate/assert-no-duplicate-table-alias" {
    import { IAliasedTable } from "aliased-table/aliased-table";
    import { DuplicateTableAlias } from "aliased-table/array-util/query/index";
    import { CompileError } from "compile-error/index";
    export type AssertNoDuplicateTableAlias<ArrT extends readonly IAliasedTable[]> = (DuplicateTableAlias<ArrT> extends never ? unknown : CompileError<["Duplicate table alias not allowed", DuplicateTableAlias<ArrT>]>);
    export function assertNoDuplicateTableAlias(arr: readonly IAliasedTable[]): void;
}
declare module "aliased-table/array-util/predicate/index" {
    export * from "aliased-table/array-util/predicate/assert-no-duplicate-table-alias";
}
declare module "aliased-table/array-util/index" {
    export * from "aliased-table/array-util/predicate/index";
    export * from "aliased-table/array-util/query/index";
}
declare module "aliased-table/index" {
    export * from "aliased-table/aliased-table";
    import * as AliasedTableArrayUtil from "aliased-table/array-util/index";
    import * as AliasedTableUtil from "aliased-table/util/index";
    export { AliasedTableArrayUtil, AliasedTableUtil, };
}
declare module "table/table" {
    import { Key } from "key/index";
    import { AliasedTableData, IAliasedTable } from "aliased-table/index";
    import { Ast } from "ast/index";
    /**
     * Does not have `parents` property.
     * https://www.postgresql.org/docs/9.1/ddl-inherit.html
     *
     * If a DBMS supports table inheritance, they should implement it
     * on their DBMS-specific repositories.
     */
    export interface TableData extends AliasedTableData {
        readonly autoIncrement: undefined | string;
        readonly id: undefined | string;
        readonly primaryKey: undefined | Key;
        /**
         * @todo Debate making this `undefined|(readonly Key[])`
         *
         * Right now `eqPrimaryKey()` and `eqCandidateKey()` are slightly different.
         * `eqPrimaryKey()` requires `primaryKey : Key`.
         */
        readonly candidateKeys: readonly Key[];
        readonly insertEnabled: boolean;
        readonly deleteEnabled: boolean;
        readonly generatedColumns: readonly string[];
        readonly nullableColumns: readonly string[];
        readonly explicitDefaultValueColumns: readonly string[];
        readonly mutableColumns: readonly string[];
        readonly explicitAutoIncrementValueEnabled: boolean;
    }
    export interface ITable<DataT extends TableData = TableData> extends IAliasedTable<DataT> {
        readonly isLateral: DataT["isLateral"];
        readonly alias: DataT["alias"];
        readonly columns: DataT["columns"];
        readonly usedRef: DataT["usedRef"];
        readonly unaliasedAst: Ast;
        /**
         * The name of the auto-increment column.
         *
         * The maximum value `BIGINT UNSIGNED` can have is
         * `18446744073709551615`
         * which is `2^(32*8)-1` because `BIGINT UNSIGNED` uses 8 bytes.
         *
         * `BIGINT UNSIGNED` can have up to 20 digits...
         *
         * This cannot be represented correctly with JS' `number` type,
         * which should be an 8-byte floating point.
         *
         * The maximum safe value is `Number.MAX_SAFE_INTEGER`
         * which is `9,007,199,254,740,991`
         */
        readonly autoIncrement: DataT["autoIncrement"];
        /**
         * The name of the column that uniquely identifies a row
         * on the table.
         *
         * Note:
         *
         * + It is recommended you name your `id` columns in the format `tableNameId`.
         *
         *   A `user` table would have its `id` column named `userId`
         *   A `planet` table would have its `id` column named `planetId`
         *
         * + A table can have an `id` column that is not an `AUTO_INCREMENT` column
         * + A table can have a PK that is an FK to an auto-increment column in another table
         */
        readonly id: DataT["id"];
        /**
         * The column names that make up the primary key of the table.
         *
         * In MySQL, a primary key is just a candidate key
         * with the additional restriction that
         * all its columns cannot be nullable!
         *
         * Apart from that, the only thing "special"
         * about a primary key is that we say,
         *
         * > This is **the** candidate key I want to talk about by default
         *
         * -----
         *
         * It is recommended that every table have a primary key
        */
        readonly primaryKey: DataT["primaryKey"];
        /**
         * The candidate keys of the table.
         *
         * This includes the primary key, too.
         *
         * In MySQL, a candidate key is either a primary key or unique key.
         */
        readonly candidateKeys: DataT["candidateKeys"];
        /**
         * Determines if rows of this table can be inserted through this library.
         *
         * Defaults to `true`
         */
        readonly insertEnabled: DataT["insertEnabled"];
        /**
         * Determines if rows of this table can be deleted through this library.
         *
         * Defaults to `true`
         */
        readonly deleteEnabled: DataT["deleteEnabled"];
        /**
         * The name of `GENERATED` columns.
         *
         * A generated column has a default value *implicitly*.
         *
         * https://dev.mysql.com/doc/refman/5.7/en/create-table-generated-columns.html
         *
         * -----
         *
         * If a column is generated, you must specify as such manually.
         *
         * + Setting generated column values will not be allowed with `INSERT` statements.
         * + Updating generated column values will also not be allowed with `UPDATE` statements.
        */
        readonly generatedColumns: DataT["generatedColumns"];
        /**
         * The name of nullable columns.
         *
         * If a column is nullable, it has a server default value of `NULL`.
         *
         * A nullable column has a default value *implicitly*.
         *
         * -----
         *
         * ```ts
         *  const myTable = table("myTable")
         *      .addColumns({
         *          myColumn : tm.mysql.bigIntUnsigned().orNull(),
         *      });
         * ```
         *
         * `myTable.nullableColumns` is now `["myColumn"]` because
         * `"myColumn"` is nullable.
         *
         */
        readonly nullableColumns: DataT["nullableColumns"];
        /**
         * The name of columns with explicit default values.
         *
         * If a column is NOT nullable, but has a server default value,
         * like `CURRENT_TIMESTAMP` or some other value,
         * you will have to specify as such manually.
         *
         * + Columns with server default values are optional with `INSERT` statements.
         * + Generated columns have implicit default values.
         * + Nullable columns have implicit default values.
         */
        readonly explicitDefaultValueColumns: DataT["explicitDefaultValueColumns"];
        /**
         * The name of columns that can be updated through this library.
         *
         * By default, all columns are immutable.
         *
         * + Calling `addMutable()` will add the specified columns to the set of mutable columns.
         * + Calling `removeMutable()` will remove the specified columns from the set of mutable columns.
         * + Calling `addAllMutable()` will make as many columns as possible mutable.
         * + Calling `removeAllMutable()` will make all columns immutable.
         * + Generated columns cannot be mutable.
         */
        readonly mutableColumns: DataT["mutableColumns"];
        /**
         * Defaults to `false`.
         *
         * If `true`,
         * + Users can specify auto-increment values for `INSERT` statements.
         * + Users can mark the auto-increment column as mutable.
         */
        readonly explicitAutoIncrementValueEnabled: DataT["explicitAutoIncrementValueEnabled"];
    }
    export type InsertableTable = (ITable & {
        insertEnabled: true;
    });
    export type DeletableTable = (ITable & {
        deleteEnabled: true;
    });
    export type TableWithPrimaryKey = (ITable & {
        primaryKey: Key;
    });
    export type TableWithAutoIncrement = (ITable & {
        autoIncrement: string;
    });
    export type TableWithoutAutoIncrement = (ITable & {
        autoIncrement: undefined;
    });
}
declare module "table/util/constructor/from-table-alias" {
    import { Table } from "table/table-impl";
    import { IUsedRef } from "used-ref/index";
    export type FromTableAlias<TableAliasT extends string> = (Table<{
        isLateral: false;
        alias: TableAliasT;
        columns: {};
        usedRef: IUsedRef<{}>;
        autoIncrement: undefined;
        id: undefined;
        primaryKey: undefined;
        candidateKeys: readonly [];
        insertEnabled: true;
        deleteEnabled: true;
        generatedColumns: readonly [];
        nullableColumns: readonly [];
        explicitDefaultValueColumns: readonly [];
        mutableColumns: readonly [];
        explicitAutoIncrementValueEnabled: false;
    }>);
    /**
     * Creates a table with the given alias
     *
     * @param tableAlias
     */
    export function fromTableAlias<TableAliasT extends string>(tableAlias: TableAliasT): (FromTableAlias<TableAliasT>);
}
declare module "table/util/constructor/from-table" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type FromTable<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Creates a copy of the `table`
     *
     * @param table
     */
    export function fromTable<TableT extends ITable>(table: TableT): (FromTable<TableT>);
}
declare module "table/util/constructor/index" {
    export * from "table/util/constructor/from-table-alias";
    export * from "table/util/constructor/from-table";
}
declare module "event/transaction-listener-collection" {
    export interface IReadonlyTransactionListenerCollection {
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnCommitListeners(): {
            syncErrors: unknown[];
        };
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnRollbackListeners(): {
            syncErrors: unknown[];
        };
    }
}
declare module "event/event-base" {
    import { IPool, IConnection } from "execution/index";
    import { IReadonlyTransactionListenerCollection } from "event/transaction-listener-collection";
    export interface IEventBase {
        readonly pool: IPool;
        readonly connection: IConnection;
        addOnCommitListener(listener: () => void): void;
        addOnRollbackListener(listener: () => void): void;
    }
    export class EventBase implements IEventBase, IReadonlyTransactionListenerCollection {
        readonly pool: IPool;
        readonly connection: IConnection;
        constructor(args: {
            readonly connection: IConnection;
        });
        private onCommitListeners;
        private onRollbackListeners;
        /**
         * If the `listener` has already been added, it will be ignored.
         */
        addOnCommitListener(listener: () => void): void;
        /**
         * If the `listener` has already been added, it will be ignored.
         */
        addOnRollbackListener(listener: () => void): void;
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnCommitListeners(): {
            syncErrors: unknown[];
        };
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnRollbackListeners(): {
            syncErrors: unknown[];
        };
    }
}
declare module "event/event-handler" {
    import { IEventBase } from "event/event-base";
    export interface EventHandler<EventT extends IEventBase> {
        (event: EventT): void | Promise<void>;
    }
}
declare module "event/pool-event-emitter" {
    import { IEventBase } from "event/event-base";
    import { EventHandler } from "event/event-handler";
    export interface IPoolEventEmitter<EventT extends IEventBase> {
        addHandler(handler: EventHandler<EventT>): void;
        removeHandler(handler: EventHandler<EventT>): void;
        getHandlers(): readonly EventHandler<EventT>[];
    }
    export class PoolEventEmitter<EventT extends IEventBase> implements IPoolEventEmitter<EventT> {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove handlers while invoking a handler.
         */
        private handlers;
        /**
         * If the `handler` has already been added, it will be ignored.
         */
        addHandler(handler: EventHandler<EventT>): void;
        removeHandler(handler: EventHandler<EventT>): void;
        getHandlers(): readonly EventHandler<EventT>[];
    }
}
declare module "event/connection-event-emitter" {
    import { IEventBase } from "event/event-base";
    import { IReadonlyTransactionListenerCollection } from "event/transaction-listener-collection";
    import { IPoolEventEmitter } from "event/pool-event-emitter";
    export interface IConnectionEventEmitter<EventT extends IEventBase> {
        invoke(event: (EventT & IReadonlyTransactionListenerCollection)): Promise<void>;
    }
    export class ConnectionEventEmitter<EventT extends IEventBase> implements IConnectionEventEmitter<EventT> {
        private readonly poolEventEmitter;
        private readonly addEventImpl;
        constructor(poolEventEmitter: IPoolEventEmitter<EventT>, addTransactionListenerCollectionImpl: (event: IReadonlyTransactionListenerCollection) => void);
        /**
         * This may throw
         */
        invoke(event: (EventT & IReadonlyTransactionListenerCollection)): Promise<void>;
    }
}
declare module "custom-expr/custom-expr" {
    import * as tm from "type-mapping";
    import { IExpr } from "expr/index";
    import { ColumnUtil } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { UsedRefUtil } from "used-ref/index";
    import { ColumnMap } from "column-map/index";
    import { NonValueExpr_NonCorrelated, NonValueExpr_NonCorrelated_NonAggregate } from "built-in-expr/index";
    export type CustomExpr_NonCorrelated<TypeT> = TypeT | NonValueExpr_NonCorrelated<TypeT>;
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     */
    export type CustomExpr_NonCorrelatedOrUndefined<TypeT> = CustomExpr_NonCorrelated<TypeT> | undefined;
    /**
     * We don't support subqueries because it's too complicated
     * to check their `IUsedRef`... For now.
     */
    export type CustomExpr_MapCorrelated<ColumnMapT extends ColumnMap, TypeT> = TypeT | IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        isAggregate: boolean;
    }> | ColumnUtil.FromColumnMap<ColumnMapT> | IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        tableAlias: string;
        alias: string;
        isAggregate: boolean;
    }>;
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     *
     * We don't support subqueries because it's too complicated
     * to check their `IUsedRef`... For now.
     */
    export type CustomExpr_MapCorrelatedOrUndefined<ColumnMapT extends ColumnMap, TypeT> = CustomExpr_MapCorrelated<ColumnMapT, TypeT> | undefined;
    /**
     * @todo Better name
     */
    export type CustomExpr_NonCorrelated_NonAggregate<TypeT> = TypeT | NonValueExpr_NonCorrelated_NonAggregate<TypeT>;
    /**
     * @todo Better name
     */
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     */
    export type CustomExpr_NonCorrelated_NonAggregateOrUndefined<TypeT> = CustomExpr_NonCorrelated_NonAggregate<TypeT> | undefined;
    /**
     * @todo Better name
     */
    export type CustomExpr_MapCorrelated_NonAggregate<ColumnMapT extends ColumnMap, TypeT> = TypeT | IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        isAggregate: false;
    }> | ColumnUtil.FromColumnMap<ColumnMapT> | IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        tableAlias: string;
        alias: string;
        isAggregate: false;
    }>;
    /**
     * @todo Better name
     */
    export type CustomExpr_MapCorrelated_NonAggregateOrUndefined<ColumnMapT extends ColumnMap, TypeT> = CustomExpr_MapCorrelated_NonAggregate<ColumnMapT, TypeT> | undefined;
}
declare module "on-clause/on-clause" {
    import { IAnonymousExpr } from "expr/index";
    /**
     * The `ON` clause of a `JOIN`.
     *
     * `FROM` and `CROSS JOIN` do not have an `ON` clause.
     *
     * -----
     *
     * Also called a `join condition`.
     *
     * Information technology - Database languages - SQL - Part 2: Foundation (SQL/Foundation) Ed 5
     *
     * -----
     *
     * The `ON` clause may reference outer query tables,
     *
     * https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj35034.html
     * > The scope of expressions in the `ON` clause includes the current tables
     * > and any tables in outer query blocks to the current `SELECT`.
     */
    export type OnClause = IAnonymousExpr<boolean, false>;
}
declare module "column-ref/column-ref" {
    import { ColumnMap, WritableColumnMap } from "column-map/index";
    export interface ColumnRef {
        readonly [tableAlias: string]: ColumnMap;
    }
    export interface WritableColumnRef {
        [tableAlias: string]: WritableColumnMap;
    }
}
declare module "column-ref/util/constructor/from-column" {
    import { IColumn } from "column/index";
    import { ColumnMapUtil } from "column-map/index";
    import { WritableColumnRef } from "column-ref/column-ref";
    export type FromColumn<ColumnT extends IColumn> = (ColumnT extends IColumn ? {
        readonly [tableAlias in ColumnT["tableAlias"]]: (ColumnMapUtil.FromColumn<ColumnT>);
    } : never);
    export function setColumn(ref: WritableColumnRef, column: IColumn): WritableColumnRef;
    export function fromColumn<ColumnT extends IColumn>(column: ColumnT): FromColumn<ColumnT>;
}
declare module "column-ref/util/constructor/from-column-array" {
    import { IColumn, ColumnUtil } from "column/index";
    import { ColumnMapUtil } from "column-map/index";
    export type FromColumnArray<ColumnsT extends readonly IColumn[]> = (ColumnsT extends readonly IColumn[] ? {
        readonly [tableAlias in ColumnsT[number]["tableAlias"]]: (ColumnMapUtil.FromColumnArray<ColumnUtil.ExtractWithTableAlias<ColumnsT[number], tableAlias>[]>);
    } : never);
    export function fromColumnArray<ColumnsT extends readonly IColumn[]>(columns: ColumnsT): FromColumnArray<ColumnsT>;
}
declare module "column-ref/util/constructor/from-column-map" {
    import { WritableColumnRef } from "column-ref/column-ref";
    import { ColumnMap } from "column-map/index";
    export function setColumnMap(ref: WritableColumnRef, map: ColumnMap): void;
}
declare module "column-ref/util/constructor/from-join" {
    import { WritableColumnRef } from "column-ref/column-ref";
    import { IJoin } from "join/index";
    export function setJoin(ref: WritableColumnRef, join: IJoin): void;
}
declare module "column-ref/util/constructor/from-join-array" {
    import { IJoin, JoinArrayUtil } from "join/index";
    import { ColumnMapUtil } from "column-map/index";
    import { WritableColumnRef } from "column-ref/column-ref";
    /**
     * + Assumes `JoinsT` is not a union type
     * + Assumes no duplicate `tableAlias` in `JoinsT`
     */
    export type FromJoinArray<JoinsT extends readonly IJoin[]> = ({
        readonly [tableAlias in JoinArrayUtil.TableAlias<JoinsT>]: (ColumnMapUtil.FromJoin<JoinArrayUtil.ExtractWithTableAlias<JoinsT, tableAlias>>);
    });
    export function setJoinArray(ref: WritableColumnRef, joins: readonly IJoin[]): void;
    export function fromJoinArray<JoinsT extends readonly IJoin[]>(joins: JoinsT): (FromJoinArray<JoinsT>);
}
declare module "column-ref/util/constructor/from-from-clause" {
    import { IFromClause } from "from-clause/index";
    import { IJoin } from "join/index";
    import { FromJoinArray } from "column-ref/util/constructor/from-join-array";
    import { WritableColumnRef } from "column-ref/column-ref";
    /**
     * Moon moon
     */
    export type FromFromClause<FromClauseT extends IFromClause> = ((FromClauseT["currentJoins"] extends readonly IJoin[] ? FromJoinArray<FromClauseT["currentJoins"]> : {}) & (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromJoinArray<FromClauseT["outerQueryJoins"]> : {}));
    export function setFromClause(ref: WritableColumnRef, fromClause: IFromClause): void;
    export function fromFromClause<FromClauseT extends IFromClause>(fromClause: FromClauseT): (FromFromClause<FromClauseT>);
}
declare module "column-ref/util/constructor/from-column-union" {
    import { ColumnMapUtil } from "column-map/index";
    import { IColumn, ColumnUtil } from "column/index";
    export type FromColumnUnion<ColumnT extends IColumn> = ({
        readonly [tableAlias in ColumnT["tableAlias"]]: (ColumnMapUtil.FromColumnUnion<ColumnUtil.ExtractWithTableAlias<ColumnT, tableAlias>>);
    });
}
declare module "column-ref/util/constructor/from-select-clause" {
    import { SelectClause } from "select-clause/index";
    import { ColumnUtil } from "column/index";
    import { FromColumnUnion } from "column-ref/util/constructor/from-column-union";
    export type FromSelectClause<SelectClauseT extends SelectClause> = FromColumnUnion<ColumnUtil.FromSelectClause<SelectClauseT>>;
    export function fromSelectClause<SelectClauseT extends SelectClause>(selectClause: SelectClauseT): (FromSelectClause<SelectClauseT>);
}
declare module "column-ref/util/constructor/index" {
    export * from "column-ref/util/constructor/from-column-array";
    export * from "column-ref/util/constructor/from-column";
    export * from "column-ref/util/constructor/from-from-clause";
    export * from "column-ref/util/constructor/from-join-array";
    export * from "column-ref/util/constructor/from-select-clause";
}
declare module "column-ref/util/operation/left-compound" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    /**
     * Like `LeftIntersect`, but the type of columns is unioned,
     * not intersected.
     *
     * This is used to implement `CompoundQueryClauseUtil.compoundQuery()`
     *
     * @todo Better name?
     */
    export type LeftCompound<RefA extends ColumnRef, RefB extends ColumnRef> = ({
        readonly [tableAlias in Extract<keyof RefA, string>]: (tableAlias extends keyof RefB ? ColumnMapUtil.Compound<RefA[tableAlias], RefB[tableAlias]> : RefA[tableAlias]);
    });
    export function leftCompound<RefA extends ColumnRef, RefB extends ColumnRef>(refA: RefA, refB: RefB): (LeftCompound<RefA, RefB>);
}
declare module "column-ref/util/operation/compound" {
    import { ColumnRef } from "column-ref/column-ref";
    import { LeftCompound } from "column-ref/util/operation/left-compound";
    import { Merge } from "type-util/index";
    /**
     * Like `Intersect`, but the type of columns is unioned,
     * not intersected.
     *
     * This is used to implement `CompoundQueryClauseUtil.compoundQuery()`
     *
     * @todo Better name?
     */
    export type Compound<RefA extends ColumnRef, RefB extends ColumnRef> = (Merge<LeftCompound<RefA, RefB> & {
        readonly [tableAlias in Exclude<Extract<keyof RefB, string>, keyof RefA>]: (RefB[tableAlias]);
    }>);
    export function compound<RefA extends ColumnRef, RefB extends ColumnRef>(refA: RefA, refB: RefB): Compound<RefA, RefB>;
}
declare module "column-ref/util/operation/left-intersect" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type LeftIntersect<RefA extends ColumnRef, RefB extends ColumnRef> = ({
        readonly [tableAlias in Extract<keyof RefA, string>]: (tableAlias extends keyof RefB ? ColumnMapUtil.Intersect<RefA[tableAlias], RefB[tableAlias]> : RefA[tableAlias]);
    });
    export function leftIntersect<RefA extends ColumnRef, RefB extends ColumnRef>(refA: RefA, refB: RefB): (LeftIntersect<RefA, RefB>);
}
declare module "column-ref/util/operation/intersect" {
    import { ColumnRef } from "column-ref/column-ref";
    import { LeftIntersect } from "column-ref/util/operation/left-intersect";
    export type Intersect<RefA extends ColumnRef, RefB extends ColumnRef> = (
    /**
     * @todo Use `Merge<>` like in `ColumnMapUtil.Intersect<>`?
     * Is there a reason to not do it?
     */
    Extract<LeftIntersect<RefA, RefB> & {
        readonly [tableAlias in Exclude<Extract<keyof RefB, string>, keyof RefA>]: (RefB[tableAlias]);
    }, ColumnRef>);
    export function intersect<RefA extends ColumnRef, RefB extends ColumnRef>(refA: RefA, refB: RefB): Intersect<RefA, RefB>;
}
declare module "column-ref/util/query/has-one-table" {
    import { ColumnRef } from "column-ref/column-ref";
    /**
     * Move this to `predicate`
     */
    export type HasOneTable<ColumnRefT extends ColumnRef> = (Extract<keyof ColumnRefT, string> extends never ? false : string extends Extract<keyof ColumnRefT, string> ? boolean : ({
        [tableAlias in Extract<keyof ColumnRefT, string>]: (Exclude<Extract<keyof ColumnRefT, string>, tableAlias>);
    }[Extract<keyof ColumnRefT, string>]) extends never ? true : false);
}
declare module "column-ref/util/operation/try-flatten" {
    import { ColumnRef } from "column-ref/column-ref";
    import { HasOneTable } from "column-ref/util/query/has-one-table";
    export type TryFlatten<RefT extends ColumnRef> = (RefT extends ColumnRef ? (HasOneTable<RefT> extends true ? RefT[Extract<keyof RefT, string>] : RefT) : never);
    export function tryFlatten<RefT extends ColumnRef>(ref: RefT): (TryFlatten<RefT>);
}
declare module "column-ref/util/operation/index" {
    export * from "column-ref/util/operation/compound";
    export * from "column-ref/util/operation/intersect";
    export * from "column-ref/util/operation/try-flatten";
}
declare module "column-ref/util/predicate/is-column-ref" {
    import { ColumnRef } from "column-ref/column-ref";
    export function isColumnRef(mixed: unknown): mixed is ColumnRef;
}
declare module "column-ref/util/predicate/index" {
    export * from "column-ref/util/predicate/is-column-ref";
}
declare module "column-ref/util/query/column-alias" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type ColumnAlias<RefT extends ColumnRef> = (RefT extends ColumnRef ? {
        [tableAlias in Extract<keyof RefT, string>]: (ColumnMapUtil.ColumnAlias<RefT[tableAlias]>);
    }[Extract<keyof RefT, string>] : never);
    export function columnAlias<RefT extends ColumnRef>(ref: RefT): ColumnAlias<RefT>[];
}
declare module "column-ref/util/query/duplicate-column-alias" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type DuplicateColumnAlias<RefT extends ColumnRef> = ({
        [tableAlias in Extract<keyof RefT, string>]: (Extract<
        /**
         * Get the `columnAlias` of this `ColumnMap`
         */
        ColumnMapUtil.ColumnAlias<RefT[tableAlias]>, 
        /**
         * Get the `columnAlias` of all the other `ColumnMap`
         */
        ColumnMapUtil.ColumnAlias<RefT[Exclude<Extract<keyof RefT, string>, tableAlias>]>>);
    }[Extract<keyof RefT, string>]);
    export function duplicateColumnAlias<RefT extends ColumnRef>(ref: RefT): (DuplicateColumnAlias<RefT>[]);
}
declare module "column-ref/util/query/extract-column-identifier" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    import { ColumnIdentifier } from "column-identifier/index";
    import { Identity } from "type-util/index";
    export type ExtractColumnIdentifier_TableAlias<RefT extends ColumnRef, ColumnIdentifierT extends ColumnIdentifier> = {
        [tableAlias in Extract<keyof RefT, string>]: (tableAlias extends ColumnIdentifierT["tableAlias"] ? tableAlias : never);
    }[Extract<keyof RefT, string>];
    export type ExtractColumnIdentifier_Mutable<RefT extends ColumnRef, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        [tableAlias in ExtractColumnIdentifier_TableAlias<RefT, ColumnIdentifierT>]: (ColumnMapUtil.ExtractColumnIdentifier_Mutable<RefT[tableAlias], Extract<ColumnIdentifierT, {
            tableAlias: tableAlias;
        }>>);
    }>;
    export type ExtractColumnIdentifier<RefT extends ColumnRef, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        readonly [tableAlias in ExtractColumnIdentifier_TableAlias<RefT, ColumnIdentifierT>]: (ColumnMapUtil.ExtractColumnIdentifier<RefT[tableAlias], Extract<ColumnIdentifierT, {
            tableAlias: tableAlias;
        }>>);
    }>;
    export function extractColumnIdentifiers<RefT extends ColumnRef, ColumnIdentifierT extends ColumnIdentifier>(ref: RefT, columnIdentifiers: readonly ColumnIdentifierT[]): (ExtractColumnIdentifier<RefT, ColumnIdentifierT>);
}
declare module "column-ref/util/query/extract-non-nullable" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type ExtractNonNullable<RefT extends ColumnRef> = (RefT extends ColumnRef ? {
        readonly [tableAlias in Extract<keyof RefT, string>]: (ColumnMapUtil.ExtractNonNullable<RefT[tableAlias]>);
    } : never);
    export function extractNonNullable<RefT extends ColumnRef>(ref: RefT): (ExtractNonNullable<RefT>);
}
declare module "column-ref/util/query/extract-nullable" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type ExtractNullable<RefT extends ColumnRef> = (RefT extends ColumnRef ? {
        readonly [tableAlias in Extract<keyof RefT, string>]: (ColumnMapUtil.ExtractNullable<RefT[tableAlias]>);
    } : never);
    export function extractNullable<RefT extends ColumnRef>(ref: RefT): (ExtractNullable<RefT>);
}
declare module "column-ref/util/query/extract-with-type" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type ExtractWithType<RefT extends ColumnRef, TypeT> = (RefT extends ColumnRef ? {
        readonly [tableAlias in Extract<keyof RefT, string>]: (ColumnMapUtil.ExtractWithType<RefT[tableAlias], TypeT>);
    } : never);
    /**
     * Returns `ref` without modifying it.
     * Is basically a no-op.
     *
     * This function merely exists to enforce compile-time safety.
     */
    export function __noOp_extractWithType<TypeT>(): (<RefT extends ColumnRef>(ref: RefT) => ExtractWithType<RefT, TypeT>);
}
declare module "column-ref/util/query/find-with-column-alias" {
    import { ColumnRef } from "column-ref/column-ref";
    import { ColumnMapUtil } from "column-map/index";
    export type FindWithColumnAlias<RefT extends ColumnRef, ColumnAliasT extends string> = (RefT extends ColumnRef ? ColumnMapUtil.FindWithColumnAlias<RefT[Extract<keyof RefT, string>], ColumnAliasT> : never);
}
declare module "column-ref/util/query/index" {
    export * from "column-ref/util/query/column-alias";
    export * from "column-ref/util/query/duplicate-column-alias";
    export * from "column-ref/util/query/extract-column-identifier";
    export * from "column-ref/util/query/extract-non-nullable";
    export * from "column-ref/util/query/extract-nullable";
    export * from "column-ref/util/query/extract-with-type";
    export * from "column-ref/util/query/find-with-column-alias";
    export * from "column-ref/util/query/has-one-table";
}
declare module "column-ref/util/index" {
    export * from "column-ref/util/constructor/index";
    export * from "column-ref/util/operation/index";
    export * from "column-ref/util/predicate/index";
    export * from "column-ref/util/query/index";
}
declare module "column-ref/index" {
    export * from "column-ref/column-ref";
    import * as ColumnRefUtil from "column-ref/util/index";
    export { ColumnRefUtil, };
}
declare module "on-clause/util/query/allowed-used-ref" {
    /**
     * @todo Revisit implementations/typedefs?
     *
     * Seems a little wasteful at the moment.
     * However, correctness > performance
     */
    import { FromClauseUtil } from "from-clause/index";
    import { IAliasedTable } from "aliased-table/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { JoinUtil, JoinArrayUtil, IJoin } from "join/index";
    import { UsedRefUtil } from "used-ref/index";
    export type AllowedColumnRef<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable> = ColumnRefUtil.FromJoinArray<JoinArrayUtil.Append<JoinArrayUtil.Append<FromClauseT["currentJoins"], (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"][number] : never)>, 
    /**
     * Inside the `ON` clause,
     * even if we are using a `LEFT` join,
     * the join is not considered `nullable`.
     *
     * At the time the `ON` clause is executed,
     * it is evaluated for each pair on the LHS and RHS of the join operator.
     *
     * ```sql
     *  FROM
     *      myTable
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      --otherTable.column0 is not null
     *      myTable.column0 = otherTable.column0
     *  WHERE
     *      --otherTable.column0 may be null, because of the LEFT JOIN
     *      otherTable.column0 IS NOT NULL
     * ```
     */
    JoinUtil.FromAliasedTable<AliasedTableT, false>>>;
    export type AllowedUsedRef<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable> = UsedRefUtil.FromJoinArray<JoinArrayUtil.Append<JoinArrayUtil.Append<FromClauseT["currentJoins"], (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"][number] : never)>, 
    /**
     * Inside the `ON` clause,
     * even if we are using a `LEFT` join,
     * the join is not considered `nullable`.
     *
     * At the time the `ON` clause is executed,
     * it is evaluated for each pair on the LHS and RHS of the join operator.
     *
     * ```sql
     *  FROM
     *      myTable
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      --otherTable.column0 is not null
     *      myTable.column0 = otherTable.column0
     *  WHERE
     *      --otherTable.column0 may be null, because of the LEFT JOIN
     *      otherTable.column0 IS NOT NULL
     * ```
     */
    JoinUtil.FromAliasedTable<AliasedTableT, false>>>;
    export function allowedColumnRef<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedColumnRef<FromClauseT, AliasedTableT>);
    export function allowedUsedRef<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedUsedRef<FromClauseT, AliasedTableT>);
}
declare module "on-clause/util/query/index" {
    export * from "on-clause/util/query/allowed-used-ref";
}
declare module "on-clause/util/predicate/assert-no-outer-query-used-ref" {
    import { CompileError } from "compile-error/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IFromClause, FromClauseUtil } from "from-clause/index";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    /**
     * Problem: `ON` clause cannot reference outer query tables
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      outerQueryTable
     *  WHERE
     *      --This is a subquery
     *      EXISTS (
     *          SELECT
     *              *
     *          FROM
     *              myTable
     *          INNER JOIN
     *              otherTable
     *          ON
     *              --This `ON` clause references `outerQueryTable.outerQueryColumn`
     *              outerQueryTable.outerQueryColumn IS NOT NULL
     *      )
     * ```
     *
     * + In MySQL 8.0, you cannot
     * + In MySQL 5.7, you cannot
     * + This is not a restriction of the SQL standard. Just a MySQL limitation.
     * + In PostgreSQL 9.4 you can
     * + In SQLite 3.26 you can
     *
     * Solution: Rewrite the query
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      outerQueryTable
     *  WHERE
     *      --This is a subquery
     *      EXISTS (
     *          SELECT
     *              *
     *          FROM
     *              myTable
     *          INNER JOIN
     *              otherTable
     *          WHERE
     *              --This `WHERE` clause references `outerQueryTable.outerQueryColumn`
     *              outerQueryTable.outerQueryColumn IS NOT NULL
     *      )
     * ```
     *
     */
    export type AssertNoOuterQueryUsedRef<FromClauseT extends Pick<IFromClause, "outerQueryJoins">, RawOnClauseT extends BuiltInExpr<boolean>> = (Extract<UsedRefUtil.TableAlias<BuiltInExprUtil.UsedRef<RawOnClauseT>>, FromClauseUtil.OuterQueryTableAlias<FromClauseT>> extends never ? unknown : CompileError<["ON clause must not reference outer query tables", Extract<UsedRefUtil.TableAlias<BuiltInExprUtil.UsedRef<RawOnClauseT>>, FromClauseUtil.OuterQueryTableAlias<FromClauseT>>]>);
    export function assertNoOuterQueryUsedRef(fromClause: Pick<IFromClause, "outerQueryJoins">, rawOnClause: BuiltInExpr<boolean>): void;
}
declare module "on-clause/util/predicate/assert-valid-used-ref" {
    import { FromClauseUtil } from "from-clause/index";
    import { IAliasedTable } from "aliased-table/index";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { AllowedUsedRef } from "on-clause/util/query/index";
    import { UsedRefUtil } from "used-ref/index";
    export type AssertValidUsedRef<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr<boolean>> = (UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT, AliasedTableT>, BuiltInExprUtil.UsedRef<RawOnClauseT>>);
    export function assertValidUsedRef(fromClause: FromClauseUtil.AfterFromClause, aliasedTable: IAliasedTable, rawOnClause: BuiltInExpr<boolean>): void;
}
declare module "on-clause/util/predicate/index" {
    export * from "on-clause/util/predicate/assert-no-outer-query-used-ref";
    export * from "on-clause/util/predicate/assert-valid-used-ref";
}
declare module "on-clause/util/operation/on" {
    import { FromClauseUtil } from "from-clause/index";
    import { IAliasedTable } from "aliased-table/index";
    import { OnDelegate } from "on-clause/on-delegate";
    import { OnClause } from "on-clause/on-clause";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    export function on<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable, 
    /**
     * @todo This looks like it should be `MapCorrelated`, or `RefCorrelated`.
     * Yet, I don't see that restriction here.
     */
    RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(fromClause: FromClauseT, aliasedTable: AliasedTableT, onDelegate: OnDelegate<FromClauseT, AliasedTableT, RawOnClauseT>): (OnClause);
}
declare module "on-clause/util/operation/index" {
    export * from "on-clause/util/operation/on";
}
declare module "on-clause/util/index" {
    export * from "on-clause/util/operation/index";
    export * from "on-clause/util/predicate/index";
    export * from "on-clause/util/query/index";
}
declare module "on-clause/on-delegate" {
    import { FromClauseUtil } from "from-clause/index";
    import { IAliasedTable } from "aliased-table/index";
    import * as OnClauseUtil from "on-clause/util/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { AssertValidUsedRef } from "on-clause/util/index";
    export type OnDelegate<FromClauseT extends FromClauseUtil.AfterFromClause, AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr<boolean>> = (columns: OnClauseUtil.AllowedColumnRef<FromClauseT, AliasedTableT>) => (RawOnClauseT & AssertValidUsedRef<FromClauseT, AliasedTableT, RawOnClauseT>);
}
declare module "on-clause/index" {
    export * from "on-clause/on-clause";
    export * from "on-clause/on-delegate";
    import * as OnClauseUtil from "on-clause/util/index";
    export { OnClauseUtil, };
}
declare module "join/join" {
    import { ColumnMap } from "column-map/index";
    import { Key } from "key/index";
    import { OnClause } from "on-clause/index";
    import { Ast } from "ast/index";
    export enum JoinType {
        FROM = "FROM",
        INNER = "INNER",
        LEFT = "LEFT",
        /**
         * @todo Remove this?
         */
        RIGHT = "RIGHT",
        CROSS = "CROSS"
    }
    export const JoinTypeValues: readonly JoinType[];
    export interface JoinData {
        readonly tableAlias: string;
        readonly nullable: boolean;
        /**
         * These columns can have their types narrowed.
         * For example, with the `IS NULL` or `IS NOT NULL` or `=` operators.
         */
        readonly columns: ColumnMap;
        /**
         * Needed for multi-table `UPDATE` statements.
         * So, we will know the data type of each column.
         */
        readonly originalColumns: ColumnMap;
        /**
         * Needed for `whereEqPrimaryKey()`
         */
        readonly primaryKey: undefined | Key;
        /**
         * Needed for `whereEqCandidateKey()`
         */
        readonly candidateKeys: readonly Key[];
        /**
         * Needed for multi-table `DELETE` statements.
         * We need to know which tables we can delete rows from.
         */
        readonly deleteEnabled: boolean;
        /**
         * Needed for multi-table `UPDATE` statements.
         * We need to know which columns are mutable.
         */
        readonly mutableColumns: readonly string[];
    }
    /**
     * @todo Make this invariant
     */
    export interface IJoin<DataT extends JoinData = JoinData> {
        /**
         * Used for duplicate `tableAlias` detection.
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable
         *  CROSS JOIN
         *      myTable --Error, `myTable` already used in same query; consider aliasing
         * ```
         */
        readonly tableAlias: DataT["tableAlias"];
        /**
         * If `true`, this table may be missing from a `JOIN`.
         * For example, as a result of a `LEFT/RIGHT JOIN`.
         */
        readonly nullable: DataT["nullable"];
        /**
         * We keep our own copy of the `ColumnMap` because
         * we may decide to make some fields nullable (`LEFT JOIN`)
         * or change their type entirely (`WHERE columnAlias = 34`).
         */
        readonly columns: DataT["columns"];
        /**
         * Needed for multi-table `UPDATE` statements.
         * So, we will know the data type of each column.
         */
        readonly originalColumns: DataT["originalColumns"];
        /**
         * Needed for `whereEqPrimaryKey()`
         */
        readonly primaryKey: DataT["primaryKey"];
        /**
         * Needed for `whereEqCandidateKey()`
         */
        readonly candidateKeys: readonly Key[];
        /**
         * Needed for multi-table `DELETE` statements.
         * We need to know which tables we can delete rows from.
         */
        readonly deleteEnabled: DataT["deleteEnabled"];
        /**
         * Needed for multi-table `UPDATE` statements.
         * We need to know which columns are mutable.
         */
        readonly mutableColumns: DataT["mutableColumns"];
        /**
         * The type of `JOIN`.
         *
         * `FROM` is considered a "type" or `JOIN`.
         * We also have `INNER`, `LEFT`, `RIGHT`, `CROSS`.
         */
        readonly joinType: JoinType;
        /**
         * + `FROM` and `CROSS JOIN` do not have `ON` clause.
         * + All other `JOIN`s have `ON` clause.
         */
        readonly onClause: OnClause | undefined;
        /**
         * The AST for a joined table could be as simple as an identifier...
         * Or as complex as a sub-query!
         */
        readonly tableAst: Ast;
    }
}
declare module "join/join-impl" {
    import { JoinData, IJoin, JoinType } from "join/join";
    import { OnClause } from "on-clause/index";
    import { Ast } from "ast/index";
    export class Join<DataT extends JoinData> implements IJoin<DataT> {
        readonly tableAlias: DataT["tableAlias"];
        readonly nullable: DataT["nullable"];
        readonly columns: DataT["columns"];
        readonly originalColumns: DataT["originalColumns"];
        readonly primaryKey: DataT["primaryKey"];
        readonly candidateKeys: DataT["candidateKeys"];
        readonly deleteEnabled: DataT["deleteEnabled"];
        readonly mutableColumns: DataT["mutableColumns"];
        readonly joinType: JoinType;
        readonly onClause: OnClause | undefined;
        readonly tableAst: Ast;
        constructor(data: DataT, joinType: JoinType, onClause: OnClause | undefined, tableAst: Ast);
    }
}
declare module "join/array-util/operation/append" {
    import { IJoin } from "join/join";
    export type Append<ArrT extends readonly IJoin[], JoinT extends IJoin> = (readonly (ArrT[number] | JoinT)[]);
    export function append<ArrT extends readonly IJoin[], JoinT extends IJoin>(arr: ArrT, ...join: JoinT[]): (Append<ArrT, JoinT>);
}
declare module "join/util/constructor/from-aliased-table" {
    import { Join } from "join/join-impl";
    import { IAliasedTable, AliasedTableUtil } from "aliased-table/index";
    import { JoinType } from "join/join";
    import { OnClause } from "on-clause/index";
    export type FromAliasedTableImpl<AliasedTableT extends IAliasedTable, NullableT extends boolean> = (Join<{
        tableAlias: AliasedTableT["alias"];
        nullable: NullableT;
        /**
         * These columns can have their types narrowed.
         * For example, with the `IS NULL` or `IS NOT NULL` or `=` operators.
         */
        columns: AliasedTableT["columns"];
        /**
         * Needed for multi-table `UPDATE` statements.
         * So, we will know the data type of each column.
         */
        originalColumns: AliasedTableT["columns"];
        /**
         * Needed for `whereEqPrimaryKey()`
         */
        primaryKey: AliasedTableUtil.PrimaryKey<AliasedTableT>;
        /**
         * Needed for `whereEqCandidateKey()`
         */
        candidateKeys: AliasedTableUtil.CandidateKeys<AliasedTableT>;
        /**
         * Needed for multi-table `DELETE` statements.
         * We need to know which tables we can delete rows from.
         *
         * @todo If we are not implementing multi-table `DELETE` statements, this should be removed.
         */
        deleteEnabled: AliasedTableUtil.DeleteEnabled<AliasedTableT>;
        /**
         * Needed for multi-table `UPDATE` statements.
         * We need to know which columns are mutable.
         *
         * @todo If we are not implementing multi-table `UPDATE` statements, this should be removed.
         */
        mutableColumns: AliasedTableUtil.MutableColumns<AliasedTableT>;
    }>);
    export type FromAliasedTable<AliasedTableT extends IAliasedTable, NullableT extends boolean> = (AliasedTableT extends IAliasedTable ? FromAliasedTableImpl<AliasedTableT, NullableT> : never);
    export function fromAliasedTable<AliasedTableT extends IAliasedTable, NullableT extends boolean>(aliasedTable: AliasedTableT, nullable: NullableT, joinType: JoinType, onClause: OnClause | undefined): (FromAliasedTable<AliasedTableT, NullableT>);
}
declare module "join/util/constructor/index" {
    export * from "join/util/constructor/from-aliased-table";
}
declare module "join/util/helper-type/with-primary-key" {
    import { IJoin } from "join/join";
    import { ColumnMap } from "column-map/index";
    import { Key } from "key/index";
    export interface WithPrimaryKey extends IJoin<{
        tableAlias: string;
        nullable: boolean;
        columns: ColumnMap;
        originalColumns: ColumnMap;
        primaryKey: Key;
        candidateKeys: readonly Key[];
        deleteEnabled: boolean;
        mutableColumns: readonly string[];
    }> {
    }
}
declare module "join/util/helper-type/index" {
    export * from "join/util/helper-type/with-primary-key";
}
declare module "join/util/operation/replace-column" {
    import * as tm from "type-mapping";
    import { IJoin } from "join/join";
    import { ColumnMapUtil } from "column-map/index";
    import { Join } from "join/join-impl";
    import { IColumn } from "column/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type ReplaceColumnImpl<ColumnAliasT extends string, TypeT, TableAliasT extends IJoin["tableAlias"], NullableT extends IJoin["nullable"], ColumnsT extends IJoin["columns"], OriginalColumnsT extends IJoin["originalColumns"], PrimaryKeyT extends IJoin["primaryKey"], CandidateKeysT extends IJoin["candidateKeys"], DeleteEnabledT extends IJoin["deleteEnabled"], MutableColumnsT extends IJoin["mutableColumns"]> = (Join<{
        tableAlias: TableAliasT;
        nullable: NullableT;
        columns: ColumnMapUtil.ReplaceColumn<ColumnsT, ColumnAliasT, TypeT>;
        originalColumns: OriginalColumnsT;
        primaryKey: PrimaryKeyT;
        candidateKeys: CandidateKeysT;
        deleteEnabled: DeleteEnabledT;
        mutableColumns: MutableColumnsT;
    }>);
    export type ReplaceColumn<JoinT extends IJoin, TableAliasT extends string, ColumnAliasT extends string, TypeT> = (JoinT extends {
        tableAlias: TableAliasT;
        columns: {
            [columnAlias in ColumnAliasT]: IColumn;
        };
    } ? (ReplaceColumnImpl<ColumnAliasT, TypeT, JoinT["tableAlias"], JoinT["nullable"], JoinT["columns"], JoinT["originalColumns"], JoinT["primaryKey"], JoinT["candidateKeys"], JoinT["deleteEnabled"], JoinT["mutableColumns"]>) : JoinT);
    export function replaceColumn<JoinT extends IJoin, TableAliasT extends string, ColumnAliasT extends string, TypeT>(join: JoinT, tableAlias: TableAliasT, columnAlias: ColumnAliasT, mapper: tm.SafeMapper<TypeT>): (ReplaceColumn<JoinT, TableAliasT, ColumnAliasT, TypeT>);
}
declare module "join/util/operation/index" {
    export * from "join/util/operation/replace-column";
}
declare module "join/util/query/extract-with-candidate-key" {
    import { IJoin } from "join/join";
    /**
     * Given a union of `IJoin`, it extracts the ones with at least one candidate key
     */
    export type ExtractWithCandidateKey<JoinT extends IJoin> = (JoinT extends IJoin ? (JoinT["candidateKeys"][number] extends never ? never : JoinT) : never);
}
declare module "join/util/predicate/has-null-safe-comparable-primary-key" {
    import { ColumnMap } from "column-map/index";
    import { WithPrimaryKey } from "join/util/helper-type/index";
    import { TableUtil } from "table/index";
    /**
     * Returns `true` if all primary key columns of `JoinT`
     * are **null-safe** comparable with columns in `ColumnMapT` that have the same name
     *
     * Assumes `JoinT` is not a union
     */
    export type HasNullSafeComparablePrimaryKey<JoinT extends Pick<WithPrimaryKey, "columns" | "primaryKey">, ColumnMapT extends ColumnMap> = (TableUtil.HasNullSafeComparablePrimaryKey<JoinT, ColumnMapT>);
}
declare module "join/util/predicate/index" {
    export * from "join/util/predicate/has-null-safe-comparable-primary-key";
}
declare module "join/util/query/extract-with-null-safe-comparable-primary-key" {
    import { IJoin } from "join/join";
    import { ColumnMap } from "column-map/index";
    import { WithPrimaryKey } from "join/util/helper-type/index";
    import { HasNullSafeComparablePrimaryKey } from "join/util/predicate/index";
    /**
     * Given a union of `IJoin`, it extracts the ones with the a primary key
     * **null-safe** comparable to `ColumnMapT`
     *
     */
    export type ExtractWithNullSafeComparablePrimaryKey<JoinT extends IJoin, ColumnMapT extends ColumnMap> = (JoinT extends IJoin ? (JoinT extends WithPrimaryKey ? (HasNullSafeComparablePrimaryKey<JoinT, ColumnMapT> extends true ? JoinT : never) : never) : never);
}
declare module "join/util/query/extract-with-primary-key" {
    import { IJoin } from "join/join";
    import { Key } from "key/index";
    /**
     * Given a union of `IJoin`, it extracts the ones with the a primary key
     */
    export type ExtractWithPrimaryKey<JoinT extends IJoin> = (Extract<JoinT, {
        primaryKey: Key;
    }>);
}
declare module "join/util/query/extract-with-table-alias" {
    import { IJoin } from "join/join";
    /**
     * Given a union of `IJoin`, it extracts the ones with the specified `TableAliasT`
     */
    export type ExtractWithTableAlias<JoinT extends IJoin, TableAliasT extends string> = (JoinT extends IJoin ? (JoinT["tableAlias"] extends TableAliasT ? JoinT : never) : never);
}
declare module "join/util/query/index" {
    export * from "join/util/query/extract-with-candidate-key";
    export * from "join/util/query/extract-with-null-safe-comparable-primary-key";
    export * from "join/util/query/extract-with-primary-key";
    export * from "join/util/query/extract-with-table-alias";
}
declare module "join/util/index" {
    export * from "join/util/constructor/index";
    export * from "join/util/helper-type/index";
    export * from "join/util/operation/index";
    export * from "join/util/query/index";
}
declare module "join/array-util/operation/replace-column" {
    import * as tm from "type-mapping";
    import { IJoin } from "join/join";
    import * as JoinUtil from "join/util/index";
    export type ReplaceColumn<JoinsT extends readonly IJoin[], TableAliasT extends string, ColumnAliasT extends string, TypeT> = (readonly (JoinUtil.ReplaceColumn<JoinsT[number], TableAliasT, ColumnAliasT, TypeT>)[]);
    export function replaceColumn<JoinsT extends readonly IJoin[], TableAliasT extends string, ColumnAliasT extends string, TypeT>(joins: JoinsT, tableAlias: TableAliasT, columnAlias: ColumnAliasT, mapper: tm.SafeMapper<TypeT>): (ReplaceColumn<JoinsT, TableAliasT, ColumnAliasT, TypeT>);
}
declare module "join/array-util/operation/index" {
    export * from "join/array-util/operation/append";
    export * from "join/array-util/operation/replace-column";
}
declare module "join/array-util/query/extract-with-candidate-key" {
    import { IJoin } from "join/join";
    import * as JoinUtil from "join/util/index";
    /**
     * Given an array of `IJoin`, it extracts the ones with at least one candidate key
     */
    export type ExtractWithCandidateKey<JoinsT extends readonly IJoin[]> = (JoinUtil.ExtractWithCandidateKey<JoinsT[number]>);
    export function extractWithCandidateKey<JoinsT extends readonly IJoin[]>(joins: JoinsT): (ExtractWithCandidateKey<JoinsT>[]);
}
declare module "join/array-util/query/extract-with-primary-key" {
    import { IJoin } from "join/join";
    import * as JoinUtil from "join/util/index";
    /**
     * Given an array of `IJoin`, it extracts the ones with the a primary key
     */
    export type ExtractWithPrimaryKey<JoinsT extends readonly IJoin[]> = (JoinUtil.ExtractWithPrimaryKey<JoinsT[number]>);
    export function extractWithPrimaryKey<JoinsT extends readonly IJoin[]>(joins: JoinsT): (ExtractWithPrimaryKey<JoinsT>[]);
}
declare module "join/array-util/query/extract-with-null-safe-comparable-primary-key" {
    import { IJoin } from "join/join";
    import * as JoinUtil from "join/util/index";
    import { ColumnMap } from "column-map/index";
    /**
     * Given an array of `IJoin`, it extracts the ones with the a primary key
     * **null-safe** comparable to `ColumnMapT`
     */
    export type ExtractWithNullSafeComparablePrimaryKey<JoinsT extends readonly IJoin[], ColumnMapT extends ColumnMap> = (JoinUtil.ExtractWithNullSafeComparablePrimaryKey<JoinsT[number], ColumnMapT>);
    export function extractWithNullSafeComparablePrimaryKey<JoinsT extends readonly IJoin[], ColumnMapT extends ColumnMap>(joins: JoinsT, columnMap: ColumnMapT): (ExtractWithNullSafeComparablePrimaryKey<JoinsT, ColumnMapT>[]);
}
declare module "join/array-util/query/extract-with-table-alias" {
    import { IJoin } from "join/join";
    import * as JoinUtil from "join/util/index";
    /**
     * Given an array of `IJoin`, it extracts the ones with the specified `TableAliasT`
     */
    export type ExtractWithTableAlias<JoinsT extends readonly IJoin[], TableAliasT extends string> = (JoinUtil.ExtractWithTableAlias<JoinsT[number], TableAliasT>);
}
declare module "join/array-util/query/non-nullable-table-alias" {
    import { IJoin } from "join/join";
    export type NonNullableTableAlias<JoinsT extends readonly IJoin[]> = (Extract<JoinsT[number], {
        nullable: false;
    }>["tableAlias"]);
}
declare module "join/array-util/query/nullable-table-alias" {
    import { IJoin } from "join/join";
    export type NullableTableAlias<JoinsT extends readonly IJoin[]> = (Extract<JoinsT[number], {
        nullable: true;
    }>["tableAlias"]);
}
declare module "join/array-util/query/table-alias" {
    import { IJoin } from "join/join";
    export type TableAlias<JoinsT extends readonly IJoin[]> = (JoinsT[number]["tableAlias"]);
}
declare module "join/array-util/query/index" {
    export * from "join/array-util/query/extract-with-candidate-key";
    export * from "join/array-util/query/extract-with-primary-key";
    export * from "join/array-util/query/extract-with-null-safe-comparable-primary-key";
    export * from "join/array-util/query/extract-with-table-alias";
    export * from "join/array-util/query/non-nullable-table-alias";
    export * from "join/array-util/query/nullable-table-alias";
    export * from "join/array-util/query/table-alias";
}
declare module "join/array-util/index" {
    export * from "join/array-util/operation/index";
    export * from "join/array-util/query/index";
}
declare module "join/index" {
    export * from "join/join-impl";
    export * from "join/join";
    import * as JoinArrayUtil from "join/array-util/index";
    import * as JoinUtil from "join/util/index";
    export { JoinArrayUtil, JoinUtil, };
}
declare module "from-clause/from-clause" {
    import { IJoin } from "join/index";
    export interface FromClauseData {
        readonly outerQueryJoins: (readonly IJoin[]) | undefined;
        readonly currentJoins: (readonly IJoin[]) | undefined;
    }
    export interface IFromClause<DataT extends FromClauseData = FromClauseData> {
        readonly outerQueryJoins: DataT["outerQueryJoins"];
        readonly currentJoins: DataT["currentJoins"];
    }
}
declare module "from-clause/util/constructor/new-instance" {
    import { IFromClause } from "from-clause/from-clause";
    export type NewInstance = IFromClause<{
        outerQueryJoins: undefined;
        currentJoins: undefined;
    }>;
    export function newInstance(): NewInstance;
}
declare module "from-clause/util/constructor/index" {
    export * from "from-clause/util/constructor/new-instance";
}
declare module "from-clause/util/helper-type/after-from-clause" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin } from "join/index";
    export interface AfterFromClause extends IFromClause<{
        outerQueryJoins: (readonly IJoin[]) | undefined;
        currentJoins: readonly IJoin[];
    }> {
    }
}
declare module "from-clause/util/helper-type/before-from-clause" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin } from "join/index";
    export interface BeforeFromClause extends IFromClause<{
        outerQueryJoins: (readonly IJoin[]) | undefined;
        currentJoins: undefined;
    }> {
    }
}
declare module "from-clause/util/helper-type/correlated" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin } from "join/index";
    /**
     * A correlated subquery is a subquery that contains a reference to a table that also appears in the outer query.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html
     */
    export interface Correlated extends IFromClause<{
        outerQueryJoins: readonly IJoin[];
        currentJoins: (readonly IJoin[]) | undefined;
    }> {
    }
}
declare module "from-clause/util/helper-type/non-correlated" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin } from "join/index";
    /**
     * The opposite of a correlated subquery.
     *
     * -----
     *
     * A correlated subquery is a subquery that contains a reference to a table that also appears in the outer query.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html
     */
    export interface NonCorrelated extends IFromClause<{
        outerQueryJoins: undefined;
        currentJoins: (readonly IJoin[]) | undefined;
    }> {
    }
}
declare module "from-clause/util/helper-type/index" {
    export * from "from-clause/util/helper-type/after-from-clause";
    export * from "from-clause/util/helper-type/before-from-clause";
    export * from "from-clause/util/helper-type/correlated";
    export * from "from-clause/util/helper-type/non-correlated";
}
declare module "from-clause/util/operation/correlate" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin } from "join/index";
    /**
     * A correlated subquery is a subquery that uses columns from outer queries.
     *
     * This is really intended to be used as a convenience function,
     * ```ts
     *  tsql
     *      .from(myTable)
     *      //@todo Implement this usage where necessary
     *      .where((_columns, query) => tsql.nullSafeEq(
     *          query
     *              .correlate()
     *              .from(otherTable)
     *              .whereEqOuterQueryPrimaryKey(
     *                  tables => tables.otherTable,
     *                  outerTables => outerTables.myTable
     *              )
     *              .select(columns => [columns.otherValue])
     *              .limit(1),
     *          45
     *      ));
     * ```
     *
     * The equivalent, without the convenience function,
     * ```ts
     *  const myCorrelatedSubquery = tsql
     *      .requireOuterQueryJoins(myTable)
     *      .from(otherTable)
     *      .whereEqOuterQueryPrimaryKey(
     *          tables => tables.otherTable,
     *          outerTables => outerTables.myTable
     *      )
     *      .select(columns => [columns.otherValue])
     *      .limit(1);
     *
     *  tsql
     *      .from(myTable)
     *      .where(() => tsql.nullSafeEq(
     *          myCorrelatedSubquery,
     *          45
     *      ));
     * ```
     *
     * Both generate the following SQL (For SQLite),
     * ```sql
     *  FROM
     *      "myTable"
     *  where
     *      (
     *          SELECT
     *              "otherTable"."otherValue"
     *          FROM
     *              "otherTable"
     *          WHERE
     *              "otherTable"."myTablePk" IS "myTable"."myTablePk"
     *          LIMIT
     *              1
     *      ) IS 45
     * ```
     *
     * For more composable queries, you **SHOULD NOT** use the convenience function.
     *
     * The convenience function is only really useful for prototyping/single-use correlated subqueries.
     * When you start building more complex applications, you should split expressions out
     * into smaller, more modular chunks.
     */
    export type Correlate<FromClauseT extends IFromClause> = IFromClause<{
        /**
         * @todo It seems like a huge waste to make `outerQueryJoins` an entire `IJoin` object.
         * We probably only ever use `tableAlias`, `columns`, `primaryKey` and `candidateKeys`.
         *
         * It **might** be possible to trim away `nullable`, `originalColumns`, `deleteEnabled`,
         * and `mutableColumns`
         */
        outerQueryJoins: (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? readonly (FromClauseT["outerQueryJoins"][number] | Extract<FromClauseT["currentJoins"], readonly IJoin[]>[number])[] : FromClauseT["currentJoins"] extends readonly IJoin[] ? readonly (Extract<FromClauseT["currentJoins"], readonly IJoin[]>[number])[] : undefined);
        currentJoins: undefined;
    }>;
    export function correlate<FromClauseT extends IFromClause>(fromClause: FromClauseT): (Correlate<FromClauseT>);
}
declare module "from-clause/util/predicate/allowed-used-ref" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { IJoin } from "join/index";
    import { UsedRefUtil } from "used-ref/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { ColumnIdentifierRefUtil } from "column-identifier-ref/index";
    export type AllowedJoinArray<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">> = (readonly (
    /**
     * According to the SQL standard,
     * a derived table may reference columns from
     * outer queries
     */
    (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"] : never)
    /**
     * A lateral derived table may reference columns from
     * the same `FROM/JOIN` clause
     */
     | (AliasedTableT["isLateral"] extends true ? (FromClauseT["currentJoins"] extends readonly IJoin[] ? FromClauseT["currentJoins"] : never) : never))[number][]);
    export type AllowedColumnRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">> = (ColumnRefUtil.FromJoinArray<AllowedJoinArray<FromClauseT, AliasedTableT>>);
    export type AllowedColumnIdentifierRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">> = (ColumnIdentifierRefUtil.FromJoinArray<AllowedJoinArray<FromClauseT, AliasedTableT>>);
    export type AllowedUsedRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">> = (UsedRefUtil.FromJoinArray<AllowedJoinArray<FromClauseT, AliasedTableT>>);
    export function allowedJoinArray<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedJoinArray<FromClauseT, AliasedTableT>);
    export function allowedColumnRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedColumnRef<FromClauseT, AliasedTableT>);
    export function allowedColumnIdentifierRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedColumnIdentifierRef<FromClauseT, AliasedTableT>);
    export function allowedUsedRef<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "isLateral">>(fromClause: FromClauseT, aliasedTable: AliasedTableT): (AllowedUsedRef<FromClauseT, AliasedTableT>);
}
declare module "from-clause/util/predicate/assert-after-from-clause" {
    import { IFromClause } from "from-clause/from-clause";
    export function assertAfterFromClause(fromClause: IFromClause): void;
}
declare module "from-clause/util/predicate/assert-before-from-clause" {
    import { IFromClause } from "from-clause/from-clause";
    export function assertBeforeFromClause(fromClause: IFromClause): void;
}
declare module "from-clause/util/predicate/assert-no-used-ref" {
    import { IAliasedTable } from "aliased-table/index";
    import { CompileError } from "compile-error/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * Problem: Derived tables cannot reference same `FROM/JOIN` clause tables
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      sameFromClauseTable
     *  JOIN
     *      --This derived table references `sameFromClauseTable.sameFromClauseColumn`
     *      (
     *          SELECT
     *              *
     *          FROM
     *              innerTable
     *          WHERE
     *              --This expression references `sameFromClauseTable.sameFromClauseColumn`
     *              sameFromClauseTable.sameFromClauseColumn > innerTable.innerColumn
     *      ) AS derivedTable
     * ```
     *
     * + This is not allowed in MySQL 5.7
     * + This is not allowed in MySQL 8.0
     * + This can work with `LATERAL` in MySQL 8.0
     *
     * Solution: Rewrite the query
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      sameFromClauseTable
     *  JOIN
     *      innerTable
     *  WHERE
     *      sameFromClauseTable.sameFromClauseColumn > innerTable.innerColumn
     * ```
     *
     * @todo Implement `LATERAL`
     *
     * With `LATERAL`, you should be able to write,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      sameFromClauseTable
     *  JOIN
     *      --This lateral derived table references `sameFromClauseTable.sameFromClauseColumn`
     *      LATERAL (
     *          SELECT
     *              *
     *          FROM
     *              innerTable
     *          WHERE
     *              --This expression references `sameFromClauseTable.sameFromClauseColumn`
     *              sameFromClauseTable.sameFromClauseColumn > innerTable.innerColumn
     *      ) AS derivedTable
     * ```
     *
     * -----
     *
     * Problem: Derived tables cannot reference outer query tables
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      outerQueryTable
     *  WHERE
     *      --This is a subquery
     *      EXISTS (
     *          SELECT
     *              *
     *          FROM
     *              --This derived table references `outerQueryTable.outerQueryColumn`
     *              (
     *                  SELECT
     *                      *
     *                  FROM
     *                      innerTable
     *                  WHERE
     *                      --This expression references `outerQueryTable.outerQueryColumn`
     *                      outerQueryTable.outerQueryColumn > innerTable.innerColumn
     *              ) AS derivedTable
     *      )
     * ```
     *
     * + In MySQL 8.0, you can reference outer query tables
     * + In MySQL 5.7, you cannot
     * + This is not a restriction of the SQL standard. Just a MySQL limitation.
     *
     * Solution: Rewrite the query
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      outerQueryTable
     *  WHERE
     *      EXISTS (
     *          SELECT
     *              *
     *          FROM
     *              innerTable
     *          WHERE
     *              --This expression references `outerQueryTable.outerQueryColumn`
     *              outerQueryTable.outerQueryColumn > innerTable.innerColumn
     *      )
     * ```
     *
     */
    export type AssertNoUsedRef<AliasedTableT extends Pick<IAliasedTable, "alias" | "usedRef">> = (UsedRefUtil.TableAlias<AliasedTableT["usedRef"]> extends never ? unknown : CompileError<["Derived table", AliasedTableT["alias"], "must not reference outer query tables or tables in the same FROM/JOIN clause", UsedRefUtil.TableAlias<AliasedTableT["usedRef"]>]>);
    export function assertNoUsedRef(aliasedTable: Pick<IAliasedTable, "alias" | "usedRef">): void;
}
declare module "from-clause/util/predicate/assert-not-in-current-joins" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { IJoin, JoinArrayUtil } from "join/index";
    import { CompileError } from "compile-error/index";
    /**
     * Problem: Duplicate table names in current `FROM/JOIN` clause not allowed
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  JOIN
     *      tableA
     * ```
     *
     * Solution: Alias the duplicate table
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  JOIN
     *      tableA AS otherTableA
     * ```
     */
    export type AssertNotInCurrentJoins<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "alias">> = (FromClauseT["currentJoins"] extends readonly IJoin[] ? (Extract<AliasedTableT["alias"], JoinArrayUtil.TableAlias<FromClauseT["currentJoins"]>> extends never ? unknown : CompileError<["Table alias", Extract<AliasedTableT["alias"], JoinArrayUtil.TableAlias<FromClauseT["currentJoins"]>>, "already used in current query JOINs", JoinArrayUtil.TableAlias<FromClauseT["currentJoins"]>]>) : unknown);
    export function assertNotInCurrentJoins(fromClause: IFromClause, aliasedTable: Pick<IAliasedTable, "alias">): void;
}
declare module "from-clause/util/predicate/assert-not-in-outer-query-joins" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { IJoin, JoinArrayUtil } from "join/index";
    import { CompileError } from "compile-error/index";
    /**
     * Problem: Duplicate table names in outer query `FROM/JOIN` clause and current `FROM/JOIN` clause not allowed
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA --outerQueryJoins
     *  WHERE (
     *      EXISTS ( --This sub query says it requires outerQueryJoins `tableA`
     *          SELECT
     *              *
     *          FROM
     *              tableA --Error
     *          WHERE
     *              tableA.id > 0
     *      )
     *  )
     * ```
     *
     * Solution: Alias the duplicate table
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA --outerQueryJoins
     *  WHERE (
     *      EXISTS ( --This sub query says it requires outerQueryJoins `tableA`
     *          SELECT
     *              *
     *          FROM
     *              tableA AS otherTableA --Error
     *          WHERE
     *              otherTableA.id > 0
     *      )
     *  )
     * ```
     */
    export type AssertNotInOuterQueryJoins<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "alias">> = (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? (Extract<AliasedTableT["alias"], JoinArrayUtil.TableAlias<FromClauseT["outerQueryJoins"]>> extends never ? unknown : CompileError<["Table alias", Extract<AliasedTableT["alias"], JoinArrayUtil.TableAlias<FromClauseT["outerQueryJoins"]>>, "already used in outer query JOINs", JoinArrayUtil.TableAlias<FromClauseT["outerQueryJoins"]>]>) : unknown);
    export function assertNotInOuterQueryJoins(fromClause: IFromClause, aliasedTable: Pick<IAliasedTable, "alias">): void;
}
declare module "from-clause/util/predicate/assert-not-lateral" {
    import { IAliasedTable } from "aliased-table/index";
    import { CompileError } from "compile-error/index";
    /**
     * + The `LATERAL` keyword was added in MySQL 8.0
     * + The `LATERAL` keyword is not in MySQL 5.7
     */
    export type AssertNotLateral<AliasedTableT extends IAliasedTable> = (Extract<AliasedTableT["isLateral"], true> extends never ? unknown : CompileError<[AliasedTableT["alias"], "cannot be LATERAL; does your DBMS support it?"]>);
    export function assertNotLateral(aliasedTable: IAliasedTable): void;
}
declare module "from-clause/util/predicate/assert-valid-current-join-base" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertNotInCurrentJoins } from "from-clause/util/predicate/assert-not-in-current-joins";
    import { AssertNotInOuterQueryJoins } from "from-clause/util/predicate/assert-not-in-outer-query-joins";
    import { AllowedUsedRef } from "from-clause/util/predicate/allowed-used-ref";
    /**
     * These constraints are required, no matter what database.
     */
    export type AssertValidCurrentJoinBase<FromClauseT extends IFromClause, AliasedTableT extends Pick<IAliasedTable, "alias" | "isLateral">> = ({
        usedRef: AllowedUsedRef<FromClauseT, AliasedTableT>;
    } & AssertNotInCurrentJoins<FromClauseT, AliasedTableT> & AssertNotInOuterQueryJoins<FromClauseT, AliasedTableT>);
    export function assertValidCurrentJoinBase(fromClause: IFromClause, aliasedTable: Pick<IAliasedTable, "alias" | "isLateral" | "usedRef">): void;
}
declare module "from-clause/util/predicate/assert-valid-outer-query-joins" {
    import { IFromClause } from "from-clause/from-clause";
    import { AssertNotInCurrentJoins } from "from-clause/util/predicate/assert-not-in-current-joins";
    import { AssertNotInOuterQueryJoins } from "from-clause/util/predicate/assert-not-in-outer-query-joins";
    import { AliasedTableArrayUtil, IAliasedTable } from "aliased-table/index";
    export type AssertValidOuterQueryJoins<FromClauseT extends IFromClause, AliasedTablesT extends readonly IAliasedTable[]> = (AssertNotInCurrentJoins<FromClauseT, AliasedTablesT[number]> & AssertNotInOuterQueryJoins<FromClauseT, AliasedTablesT[number]> & AliasedTableArrayUtil.AssertNoDuplicateTableAlias<AliasedTablesT>);
    export function assertValidOuterQueryJoins(fromClause: IFromClause, aliasedTables: readonly IAliasedTable[]): void;
}
declare module "from-clause/util/predicate/is-from-clause" {
    import { IFromClause } from "from-clause/from-clause";
    /**
     * Only checks that the properties exist.
     * Does not actually check that they are the right data type!
     *
     * @todo Consider adding checks for increased type safety.
     */
    export function isFromClause(x: unknown): x is IFromClause;
}
declare module "from-clause/util/predicate/is-after-from-clause" {
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    export function isAfterFromClause(x: unknown): x is AfterFromClause;
}
declare module "from-clause/util/predicate/is-before-from-clause" {
    import { BeforeFromClause } from "from-clause/util/helper-type/index";
    export function isBeforeFromClause(x: unknown): x is BeforeFromClause;
}
declare module "from-clause/util/predicate/index" {
    export * from "from-clause/util/predicate/allowed-used-ref";
    export * from "from-clause/util/predicate/assert-after-from-clause";
    export * from "from-clause/util/predicate/assert-before-from-clause";
    export * from "from-clause/util/predicate/assert-no-used-ref";
    export * from "from-clause/util/predicate/assert-not-in-current-joins";
    export * from "from-clause/util/predicate/assert-not-in-outer-query-joins";
    export * from "from-clause/util/predicate/assert-not-lateral";
    export * from "from-clause/util/predicate/assert-valid-current-join-base";
    export * from "from-clause/util/predicate/assert-valid-outer-query-joins";
    export * from "from-clause/util/predicate/is-after-from-clause";
    export * from "from-clause/util/predicate/is-before-from-clause";
    export * from "from-clause/util/predicate/is-from-clause";
}
declare module "from-clause/util/operation/cross-join" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { JoinUtil, JoinArrayUtil } from "join/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { AssertNonUnion } from "type-util/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CrossJoinImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, false>>;
    }>);
    export type CrossJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = (CrossJoinImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    export function crossJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable>(fromClause: FromClauseT, aliasedTable: (AliasedTableT & AssertNonUnion<AliasedTableT> & AssertValidCurrentJoinBase<FromClauseT, AliasedTableT>)): (CrossJoin<FromClauseT, AliasedTableT>);
}
declare module "from-clause/util/operation/from" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { BeforeFromClause } from "from-clause/util/helper-type/index";
    import { JoinUtil } from "join/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    export type From<FromClauseT extends BeforeFromClause, AliasedTableT extends IAliasedTable> = (IFromClause<{
        outerQueryJoins: FromClauseT["outerQueryJoins"];
        currentJoins: readonly JoinUtil.FromAliasedTable<AliasedTableT, false>[];
    }>);
    export function from<FromClauseT extends BeforeFromClause, AliasedTableT extends IAliasedTable>(fromClause: FromClauseT, aliasedTable: (AliasedTableT & AssertValidCurrentJoinBase<FromClauseT, AliasedTableT>)): (From<FromClauseT, AliasedTableT>);
}
declare module "join-map/join-map" {
    import { IJoin } from "join/index";
    export interface JoinMap {
        readonly [tableAlias: string]: IJoin;
    }
    export interface WritableJoinMap {
        [tableAlias: string]: IJoin;
    }
}
declare module "join-map/util/constructor/from-join-array" {
    import { IJoin, JoinUtil } from "join/index";
    export type FromJoinArray<JoinsT extends readonly IJoin[]> = (JoinsT extends readonly IJoin[] ? {
        readonly [tableAlias in JoinsT[number]["tableAlias"]]: (JoinUtil.ExtractWithTableAlias<JoinsT[number], tableAlias>);
    } : never);
    export function fromJoinArray<JoinsT extends readonly IJoin[]>(joins: JoinsT): (FromJoinArray<JoinsT>);
}
declare module "join-map/util/constructor/index" {
    export * from "join-map/util/constructor/from-join-array";
}
declare module "join-map/util/index" {
    export * from "join-map/util/constructor/index";
}
declare module "join-map/index" {
    export * from "join-map/join-map";
    import * as JoinMapUtil from "join-map/util/index";
    export { JoinMapUtil, };
}
declare module "from-clause/util/operation/inner-join" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { OnDelegate } from "on-clause/index";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, false>>;
    }>;
    export type InnerJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * ```sql
     *  INNER JOIN
     *      myTable
     *  ON
     *      --condition
     * ```
     */
    export function innerJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable, 
    /**
     * @todo This looks like it should be `MapCorrelated`, or `RefCorrelated`.
     * Yet, I don't see that restriction here.
     */
    RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(fromClause: FromClauseT, aliasedTable: (AliasedTableT & AssertNonUnion<AliasedTableT> & AssertValidCurrentJoinBase<FromClauseT, AliasedTableT>), onDelegate: OnDelegate<FromClauseT, AliasedTableT, RawOnClauseT>): (InnerJoin<FromClauseT, AliasedTableT>);
}
declare module "from-clause/util/operation/inner-join-using-candidate-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { TableUtil, ITable } from "table/index";
    import { JoinMapUtil } from "join-map/index";
    import * as ExprLib from "expr-library/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingCandidateKeyImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, false>>;
    }>;
    export type InnerJoinUsingCandidateKey<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinUsingCandidateKeyImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingCandidateKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type InnerJoinUsingCandidateKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (InnerJoinUsingCandidateKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .innerJoin(
     *      otherTable,
     *      () => tsql.eqCandidateKeyOfTable(
     *          myTable,
     *          otherTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      )
     *  )
     * ```
     *
     * ```sql
     *  INNER JOIN
     *      otherTable
     *  ON
     *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
     *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
     *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
     *      --snip
     * ```
     */
    export function innerJoinUsingCandidateKey<FromClauseT extends AfterFromClause, SrcT extends FromClauseT["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(fromClause: FromClauseT, srcDelegate: InnerJoinUsingCandidateKeySrcDelegate<FromClauseT, SrcT>, aliasedTable: (DstT & AssertNonUnion<DstT> & AssertValidCurrentJoinBase<FromClauseT, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (InnerJoinUsingCandidateKey<FromClauseT, DstT>);
}
declare module "from-clause/util/operation/inner-join-using-primary-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { TableWithPrimaryKey, TableUtil } from "table/index";
    import { JoinMapUtil } from "join-map/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingPrimaryKeyImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, false>>;
    }>;
    export type InnerJoinUsingPrimaryKey<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinUsingPrimaryKeyImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingPrimaryKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type InnerJoinUsingPrimaryKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (InnerJoinUsingPrimaryKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .innerJoin(
     *      otherTable,
     *      () => tsql.eqPrimaryKeyOfTable(
     *          myTable,
     *          otherTable
     *      )
     *  )
     * ```
     *
     * ```sql
     *  INNER JOIN
     *      otherTable
     *  ON
     *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
     *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
     *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
     *      --snip
     * ```
     */
    export function innerJoinUsingPrimaryKey<FromClauseT extends AfterFromClause, SrcT extends FromClauseT["currentJoins"][number], DstT extends TableWithPrimaryKey>(fromClause: FromClauseT, srcDelegate: InnerJoinUsingPrimaryKeySrcDelegate<FromClauseT, SrcT>, aliasedTable: (DstT & AssertNonUnion<DstT> & AssertValidCurrentJoinBase<FromClauseT, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (InnerJoinUsingPrimaryKey<FromClauseT, DstT>);
}
declare module "from-clause/util/operation/left-join" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { OnDelegate } from "on-clause/index";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, true>>;
    }>;
    export type LeftJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * ```sql
     *  LEFT JOIN
     *      myTable
     *  ON
     *      --condition
     * ```
     */
    export function leftJoin<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(fromClause: FromClauseT, aliasedTable: (AliasedTableT & AssertNonUnion<AliasedTableT> & AssertValidCurrentJoinBase<FromClauseT, AliasedTableT>), onDelegate: OnDelegate<FromClauseT, AliasedTableT, RawOnClauseT>): (LeftJoin<FromClauseT, AliasedTableT>);
}
declare module "from-clause/util/operation/left-join-using-candidate-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { TableUtil, ITable } from "table/index";
    import { JoinMapUtil } from "join-map/index";
    import * as ExprLib from "expr-library/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingCandidateKeyImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, true>>;
    }>;
    export type LeftJoinUsingCandidateKey<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinUsingCandidateKeyImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingCandidateKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type LeftJoinUsingCandidateKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (LeftJoinUsingCandidateKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .leftJoin(
     *      otherTable,
     *      () => tsql.eqCandidateKeyOfTable(
     *          myTable,
     *          otherTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      )
     *  )
     * ```
     *
     * ```sql
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
     *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
     *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
     *      --snip
     * ```
     */
    export function leftJoinUsingCandidateKey<FromClauseT extends AfterFromClause, SrcT extends FromClauseT["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(fromClause: FromClauseT, srcDelegate: LeftJoinUsingCandidateKeySrcDelegate<FromClauseT, SrcT>, aliasedTable: (DstT & AssertNonUnion<DstT> & AssertValidCurrentJoinBase<FromClauseT, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (LeftJoinUsingCandidateKey<FromClauseT, DstT>);
}
declare module "from-clause/util/operation/left-join-using-primary-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidCurrentJoinBase } from "from-clause/util/predicate/index";
    import { JoinArrayUtil, JoinUtil } from "join/index";
    import { AssertNonUnion } from "type-util/index";
    import { TableWithPrimaryKey, TableUtil } from "table/index";
    import { JoinMapUtil } from "join-map/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingPrimaryKeyImpl<AliasedTableT extends IAliasedTable, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.Append<CurrentJoinsT, JoinUtil.FromAliasedTable<AliasedTableT, true>>;
    }>;
    export type LeftJoinUsingPrimaryKey<FromClauseT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinUsingPrimaryKeyImpl<AliasedTableT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingPrimaryKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type LeftJoinUsingPrimaryKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (LeftJoinUsingPrimaryKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .leftJoin(
     *      otherTable,
     *      () => tsql.eqPrimaryKeyOfTable(
     *          myTable,
     *          otherTable
     *      )
     *  )
     * ```
     *
     * ```sql
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
     *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
     *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
     *      --snip
     * ```
     */
    export function leftJoinUsingPrimaryKey<FromClauseT extends AfterFromClause, SrcT extends FromClauseT["currentJoins"][number], DstT extends TableWithPrimaryKey>(fromClause: FromClauseT, srcDelegate: LeftJoinUsingPrimaryKeySrcDelegate<FromClauseT, SrcT>, aliasedTable: (DstT & AssertNonUnion<DstT> & AssertValidCurrentJoinBase<FromClauseT, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (LeftJoinUsingPrimaryKey<FromClauseT, DstT>);
}
declare module "from-clause/util/operation/require-outer-query-joins-impl" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { JoinUtil, JoinArrayUtil, IJoin } from "join/index";
    import { AssertValidOuterQueryJoins } from "from-clause/util/predicate/index";
    export type RequireOuterQueryJoinsImpl<FromClauseT extends IFromClause, NullableT extends boolean, AliasedTablesT extends readonly IAliasedTable[]> = (AliasedTablesT[number] extends never ? FromClauseT : IFromClause<{
        outerQueryJoins: (FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? JoinArrayUtil.Append<FromClauseT["outerQueryJoins"], JoinUtil.FromAliasedTable<AliasedTablesT[number], NullableT>> : readonly JoinUtil.FromAliasedTable<AliasedTablesT[number], NullableT>[]);
        currentJoins: FromClauseT["currentJoins"];
    }>);
    export function requireOuterQueryJoinsImpl<FromClauseT extends IFromClause, NullableT extends boolean, AliasedTablesT extends readonly IAliasedTable[]>(fromClause: FromClauseT, nullable: NullableT, ...aliasedTables: (AliasedTablesT & AssertValidOuterQueryJoins<FromClauseT, AliasedTablesT>)): (RequireOuterQueryJoinsImpl<FromClauseT, NullableT, AliasedTablesT>);
}
declare module "from-clause/util/operation/require-nullable-outer-query-joins" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { AssertValidOuterQueryJoins } from "from-clause/util/predicate/index";
    import { RequireOuterQueryJoinsImpl } from "from-clause/util/operation/require-outer-query-joins-impl";
    export type RequireNullableOuterQueryJoins<FromClauseT extends IFromClause, AliasedTablesT extends readonly IAliasedTable[]> = (RequireOuterQueryJoinsImpl<FromClauseT, true, AliasedTablesT>);
    export function requireNullableOuterQueryJoins<FromClauseT extends IFromClause, AliasedTablesT extends readonly IAliasedTable[]>(fromClause: FromClauseT, ...aliasedTables: (AliasedTablesT & AssertValidOuterQueryJoins<FromClauseT, AliasedTablesT>)): (RequireNullableOuterQueryJoins<FromClauseT, AliasedTablesT>);
}
declare module "from-clause/util/operation/require-outer-query-joins" {
    import { IFromClause } from "from-clause/from-clause";
    import { IAliasedTable } from "aliased-table/index";
    import { RequireOuterQueryJoinsImpl } from "from-clause/util/operation/require-outer-query-joins-impl";
    import { AssertValidOuterQueryJoins } from "from-clause/util/predicate/index";
    import { JoinUtil } from "join/index";
    export type NewInstanceWithOuterQueryJoins<NullableT extends boolean, AliasedTablesT extends readonly IAliasedTable[]> = IFromClause<{
        outerQueryJoins: readonly JoinUtil.FromAliasedTable<AliasedTablesT[number], NullableT>[];
        currentJoins: undefined;
    }>;
    export type RequireOuterQueryJoins<FromClauseT extends IFromClause, AliasedTablesT extends readonly IAliasedTable[]> = (RequireOuterQueryJoinsImpl<FromClauseT, false, AliasedTablesT>);
    export function requireOuterQueryJoins<FromClauseT extends IFromClause, AliasedTablesT extends readonly IAliasedTable[]>(fromClause: FromClauseT, ...aliasedTables: (AliasedTablesT & AssertValidOuterQueryJoins<FromClauseT, AliasedTablesT>)): (RequireOuterQueryJoins<FromClauseT, AliasedTablesT>);
}
declare module "where-clause/where-clause" {
    import { IAnonymousExpr } from "expr/index";
    /**
     * The `WHERE` clause of a query.
     */
    export type WhereClause = IAnonymousExpr<boolean, false>;
}
declare module "where-clause/util/query/allowed-used-ref" {
    import { IFromClause, FromClauseUtil } from "from-clause/index";
    export type AllowedColumnRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedColumnRef<FromClauseT, {
        isLateral: true;
    }>);
    export type AllowedUsedRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedUsedRef<FromClauseT, {
        isLateral: true;
    }>);
    export function allowedColumnRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedColumnRef<FromClauseT>);
    export function allowedUsedRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedUsedRef<FromClauseT>);
}
declare module "where-clause/util/query/index" {
    export * from "where-clause/util/query/allowed-used-ref";
}
declare module "where-clause/util/operation/where" {
    import { IFromClause } from "from-clause/index";
    import { WhereDelegate } from "where-clause/where-delegate";
    import { WhereClause } from "where-clause/where-clause";
    /**
     * Returns the MySQL equivalent of `whereClause AND whereDelegate(columns)`
     *
     * @param fromClause
     * @param whereClause
     * @param whereDelegate
     */
    export function where<FromClauseT extends IFromClause>(fromClause: FromClauseT, whereClause: WhereClause | undefined, whereDelegate: WhereDelegate<FromClauseT>): (WhereClause);
}
declare module "where-clause/util/operation/index" {
    export * from "where-clause/util/operation/where";
}
declare module "where-clause/util/index" {
    export * from "where-clause/util/operation/index";
    export * from "where-clause/util/query/index";
}
declare module "where-clause/where-delegate" {
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { IExpr } from "expr/index";
    import * as WhereClauseUtil from "where-clause/util/index";
    import { ColumnUtil } from "column/index";
    export type WhereDelegate<FromClauseT extends IFromClause> = ((columns: ColumnRefUtil.TryFlatten<WhereClauseUtil.AllowedColumnRef<FromClauseT>>) => (boolean | IExpr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: WhereClauseUtil.AllowedUsedRef<FromClauseT>;
        isAggregate: false;
    }> | ColumnUtil.ExtractWithType<ColumnUtil.FromColumnRef<WhereClauseUtil.AllowedColumnRef<FromClauseT>>, boolean>));
}
declare module "where-clause/index" {
    export * from "where-clause/where-clause";
    export * from "where-clause/where-delegate";
    import * as WhereClauseUtil from "where-clause/util/index";
    export { WhereClauseUtil, };
}
declare module "type-map/type-map" {
    export interface TypeMap {
        /**
         * The `any` is the type of the column.
         */
        readonly [columnAlias: string]: any;
    }
}
declare module "type-map/util/constructor/from-column-array" {
    import * as tm from "type-mapping";
    import { IColumn, ColumnUtil } from "column/index";
    export type FromColumnArray<ColumnsT extends readonly IColumn[]> = ({
        readonly [columnAlias in ColumnsT[number]["columnAlias"]]: (tm.OutputOf<ColumnUtil.ExtractWithColumnAlias<ColumnsT[number], columnAlias>["mapper"]>);
    });
}
declare module "type-map/util/constructor/from-column-map" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/index";
    export type FromColumnMap<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        readonly [columnAlias in Extract<keyof MapT, string>]: (tm.OutputOf<MapT[columnAlias]["mapper"]>);
    } : never);
    export type WritableFromColumnMap<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        [columnAlias in Extract<keyof MapT, string>]: (tm.OutputOf<MapT[columnAlias]["mapper"]>);
    } : never);
}
declare module "type-map/util/constructor/index" {
    export * from "type-map/util/constructor/from-column-array";
    export * from "type-map/util/constructor/from-column-map";
}
declare module "type-map/util/operator/intersect" {
    import { TypeMap } from "type-map/type-map";
    import { UnionToIntersection, Merge } from "type-util/index";
    /**
     * Assumes `U` is a union
     */
    export type Intersect<U extends TypeMap> = (Merge<UnionToIntersection<U>>);
}
declare module "type-map/util/operator/with-value" {
    import { TypeMap } from "type-map/type-map";
    import { Identity } from "type-util/index";
    export type WithValue<MapT extends TypeMap, ColumnAliasT extends string, ValueT extends unknown> = Identity<{
        [columnAlias in Extract<keyof MapT, string>]: (ColumnAliasT extends columnAlias ? ValueT : MapT[columnAlias]);
    }>;
}
declare module "type-map/util/operator/index" {
    export * from "type-map/util/operator/intersect";
    export * from "type-map/util/operator/with-value";
}
declare module "type-map/util/index" {
    export * from "type-map/util/constructor/index";
    export * from "type-map/util/operator/index";
}
declare module "type-map/index" {
    export * from "type-map/type-map";
    import * as TypeMapUtil from "type-map/util/index";
    export { TypeMapUtil, };
}
declare module "candidate-key/candidate-key" {
    import { ITable } from "table/index";
    import { ColumnMap } from "column-map/index";
    import { TypeMapUtil, TypeMap } from "type-map/index";
    import { Key } from "key/index";
    import { UnionToIntersection } from "type-util/index";
    export type CandidateKey_NonUnionImpl<MapT extends ColumnMap, K extends Key> = (K extends Key ? TypeMapUtil.FromColumnMap<Pick<MapT, K[number]>> : never);
    /**
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `CandidateKey_Output/Input<U>` instead.
     *
     * -----
     *
     * Also assumes `TableT["columns"]` and `TableT["candidateKeys"]` are not unions.
     * They really shouldn't be unions.
     * + Why does your table not have a definite set of columns?
     *   Is it Schrödinger's columns?
     * + Why does your table not have a definite set candidate keys?
     *   Is it Schrödinger's candidate keys?
     */
    export type CandidateKey_NonUnion<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (CandidateKey_NonUnionImpl<TableT["columns"], TableT["candidateKeys"][number]>);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of candidate keys.
     * Meant for output/read/covariant positions.
     */
    export type CandidateKey_Output<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (TableT extends Pick<ITable, "columns" | "candidateKeys"> ? CandidateKey_NonUnion<TableT> : never);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of (intersection of candidate keys).
     * Meant for input/write/contravariant positions.
     *
     * -----
     *
     * ```ts
     *  //The following types are equal
     *  type a = (
     *      | ({x: ""} & {a: ""})
     *      | ({x: ""} & {b: ""})
     *      | ({y: ""} & {a: ""})
     *      | ({y: ""} & {b: ""})
     *  );
     *  type a = UnionToIntersection<
     *      //Assume these are candidate keys of table X
     *      | [{x:""}|{y:""}]
     *      //Assume these are candidate keys of table A
     *      | [{a:""}|{b:""}]
     *  >[number];
     * ```
     * http://www.typescriptlang.org/play/#code/C4TwDgpgBAqgdgSwPZwCpIJJ2BATgZwgGNhk4AeeAPigF4oAKAWACgp3HWPvY4oIAHjjgATfFACGcEFAD8jANYAuXgEo6NAG5IEIqCrgRNeLh3WDhYzmx7sGyqAjgAzPFAzraWnSNPt18hj6UIbGuKyqANysrAD0AFSsoJCSdNbcAD6MAN4CKgBE+QC+UABkUNkSBcWqflBZDLnVJeXZAEbNtTbsDdkgzWUVVVCFRV2ZOf0jxYPtnRGs8bFJ4NASafBk6Fg4BMSkKOR1WQDaTaMZfUqjALrHUGdVF3O3rFQncACuALZteDdAA
     */
    export type CandidateKey_Input<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (Extract<(UnionToIntersection<TableT extends Pick<ITable, "columns" | "candidateKeys"> ? [CandidateKey_NonUnion<TableT>] : never>), [TypeMap]>[number]);
}
declare module "primary-key/primary-key" {
    import { TableWithPrimaryKey } from "table/index";
    import { TypeMapUtil } from "type-map/index";
    import { UnionToIntersection } from "type-util/index";
    /**
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `PrimaryKey_Output/Input<U>` instead.
     *
     * -----
     *
     * Also assumes `TableT["columns"]` and `TableT["primaryKey"]` are not unions.
     * They really shouldn't be unions.
     * + Why does your table not have a definite set of columns?
     *   Is it Schrödinger's columns?
     * + Why does your table not have a definite primary key?
     *   Is it Schrödinger's primary key?
     */
    export type PrimaryKey_NonUnion<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">> = (TypeMapUtil.FromColumnMap<Pick<TableT["columns"], TableT["primaryKey"][number]>>);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of primary keys.
     * Meant for output/read/covariant positions.
     */
    export type PrimaryKey_Output<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">> = (TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey"> ? PrimaryKey_NonUnion<TableT> : never);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return an intersection of primary keys.
     * Meant for input/write/contravariant positions.
     */
    export type PrimaryKey_Input<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">> = (UnionToIntersection<PrimaryKey_Output<TableT>>);
    /**
     * Represents a primary key of the table, when retrieved from the database.
     *
     * An alias of `PrimaryKey_NonUnion<>` for convenience reasons.
     *
     * -----
     *
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `PrimaryKey_Output/Input<U>` instead.
     */
    export type PrimaryKey<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">> = PrimaryKey_NonUnion<TableT>;
}
declare module "primary-key/util/query/mapper" {
    import * as tm from "type-mapping";
    import { PrimaryKey_Output } from "primary-key/primary-key";
    import { TableWithPrimaryKey } from "table/index";
    export type Mapper<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">> = (tm.SafeMapper<PrimaryKey_Output<TableT>>);
    export function mapper<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">>(table: TableT): (Mapper<TableT>);
}
declare module "primary-key/util/query/index" {
    export * from "primary-key/util/query/mapper";
}
declare module "primary-key/util/index" {
    export * from "primary-key/util/query/index";
}
declare module "primary-key/index" {
    export * from "primary-key/primary-key";
    import * as PrimaryKeyUtil from "primary-key/util/index";
    export { PrimaryKeyUtil, };
}
declare module "candidate-key/util/query/mapper" {
    import * as tm from "type-mapping";
    import { CandidateKey_Output } from "candidate-key/candidate-key";
    import { ITable } from "table/index";
    export type Mapper<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (tm.SafeMapper<CandidateKey_Output<TableT>>);
    export function mapper<TableT extends Pick<ITable, "columns" | "candidateKeys">>(table: TableT): (Mapper<TableT>);
    export function mapperPreferPrimaryKey<TableT extends Pick<ITable, "columns" | "candidateKeys" | "primaryKey">>(table: TableT): (Mapper<TableT>);
}
declare module "candidate-key/util/query/index" {
    export * from "candidate-key/util/query/mapper";
}
declare module "candidate-key/util/index" {
    export * from "candidate-key/util/query/index";
}
declare module "candidate-key/index" {
    export * from "candidate-key/candidate-key";
    import * as CandidateKeyUtil from "candidate-key/util/index";
    export { CandidateKeyUtil, };
}
declare module "from-clause/util/operation/where-eq-candidate-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { JoinMapUtil } from "join-map/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqCandidateKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    /**
     * @todo Consider making `nullable` joins non-nullable when
     * used with `whereEqCandidateKey()`
     *
     * Not a priority because people should not usually
     * write such a query.
     *
     * -----
     *
     * Assume `tableB.tableBId` is the candidate key of `tableB`.
     *
     * Normally, `tableB` should be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     * ```
     *
     * However, `tableB` should not be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     *  WHERE
     *      --If you want to follow the SQL standard,
     *      --tableB.tableBId IS NOT DISTINCT FROM 1
     *      tableB.tableBId <=> 1
     * ```
     */
    export type WhereEqCandidateKey<FromClauseT extends AfterFromClause> = (WhereEqCandidateKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqCandidateKeyDelegateImpl<TableT extends JoinArrayUtil.ExtractWithCandidateKey<CurrentJoinsT>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithCandidateKey<CurrentJoinsT>[]>) => TableT);
    export type WhereEqCandidateKeyDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]>> = (WhereEqCandidateKeyDelegateImpl<TableT, FromClauseT["currentJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqCandidateKey(
     *          myTable,
     *          myCandidateKey
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Excess properties are especially dangerous for this function.
     *
     * If your `candidateKeyInput` is actually a super key of two candidate keys,
     * then the candidate key this function compares against is arbitrary.
     *
     * The extra properties will be discarded.
     *
     * If you want to compare against a super key, use `whereEqSuperKey()` instead.
     *
     */
    export function whereEqCandidateKey<FromClauseT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]> ? [WhereEqCandidateKeyDelegate<FromClauseT, TableT>, StrictUnion<CandidateKey_NonUnion<TableT>>] : never)): ({
        fromClause: WhereEqCandidateKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "partial-row/partial-row" {
    import * as tm from "type-mapping";
    import { ITable } from "table/index";
    /**
     * Represents a partial row of the table, when retrieved from the database.
     *
     * -----
     *
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `PartialRow_Output/Input<U>` instead.
     *
     * -----
     *
     * Also assumes `TableT["columns"]` are not unions.
     * They really shouldn't be unions.
     * + Why does your table not have a definite set of columns?
     *   Is it Schrödinger's columns?
     */
    export type PartialRow_NonUnion<TableT extends Pick<ITable, "columns">> = ({
        readonly [columnAlias in Extract<keyof TableT["columns"], string>]?: (tm.OutputOf<TableT["columns"][columnAlias]["mapper"]>);
    });
    /**
     * Represents a partial row of the table, when retrieved from the database.
     *
     * -----
     *
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of rows.
     * Meant for output/read/covariant positions.
     */
    export type PartialRow_Output<TableT extends Pick<ITable, "columns">> = (TableT extends Pick<ITable, "columns"> ? PartialRow_NonUnion<TableT> : never);
    /**
     * Represents a partial row of the table, when retrieved from the database.
     *
     * -----
     *
     * Works properly, even when `TableT` is a union.
     *
     * Will return an intersection of rows.
     * Meant for input/write/contravariant positions.
     */
    export type PartialRow_Input<TableT extends Pick<ITable, "columns">> = (
    /**
     * When all properties are optional,
     * the input and output types are the same.
     */
    PartialRow_Output<TableT>);
    /**
     * Represents a partial row of the table, when retrieved from the database.
     *
     * An alias of `PartialRow_NonUnion<>` for convenience reasons.
     *
     * -----
     *
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `PartialRow_Output/Input<U>` instead.
     */
    export type PartialRow<TableT extends Pick<ITable, "columns">> = (PartialRow_NonUnion<TableT>);
}
declare module "partial-row/util/query/mapper" {
    import * as tm from "type-mapping";
    import { TableWithPrimaryKey } from "table/index";
    import { PartialRow_Output } from "partial-row/partial-row";
    export type Mapper<TableT extends Pick<TableWithPrimaryKey, "columns">> = (tm.SafeMapper<PartialRow_Output<TableT>>);
    export function mapper<TableT extends Pick<TableWithPrimaryKey, "columns">>(table: TableT): (Mapper<TableT>);
}
declare module "partial-row/util/query/index" {
    export * from "partial-row/util/query/mapper";
}
declare module "partial-row/util/index" {
    export * from "partial-row/util/query/index";
}
declare module "partial-row/index" {
    export * from "partial-row/partial-row";
    import * as PartialRowUtil from "partial-row/util/index";
    export { PartialRowUtil, };
}
declare module "from-clause/util/operation/where-eq-columns" {
    import { IFromClause } from "from-clause/from-clause";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { JoinMapUtil } from "join-map/index";
    import { PartialRow_NonUnion } from "partial-row/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqColumnsImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    /**
     * @todo Consider narrowing the values of columns?
     * @todo If at least one of the columns is narrowed to non-null, make the `IJoin` non-nullable?
     */
    export type WhereEqColumns<FromClauseT extends AfterFromClause> = (WhereEqColumnsImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqColumnsDelegateImpl<TableT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => TableT);
    export type WhereEqColumnsDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, TableT extends FromClauseT["currentJoins"][number]> = (WhereEqColumnsDelegateImpl<TableT, FromClauseT["currentJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqColumns(
     *          myTable,
     *          myColumns
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    export function whereEqColumns<FromClauseT extends AfterFromClause, TableT extends FromClauseT["currentJoins"][number]>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends FromClauseT["currentJoins"][number] ? [WhereEqColumnsDelegate<FromClauseT, TableT>, PartialRow_NonUnion<TableT>] : never)): ({
        fromClause: WhereEqColumns<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-eq-inner-query-primary-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause, Correlated } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { JoinMapUtil } from "join-map/index";
    import { AssertNonUnion } from "type-util/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqInnerQueryPrimaryKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    export type WhereEqInnerQueryPrimaryKey<FromClauseT extends AfterFromClause> = (WhereEqInnerQueryPrimaryKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqInnerQueryPrimaryKeySrcDelegateImpl<SrcT extends OuterQueryJoinsT[number], OuterQueryJoinsT extends Correlated["outerQueryJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<OuterQueryJoinsT>) => SrcT & AssertNonUnion<SrcT>);
    export type WhereEqInnerQueryPrimaryKeySrcDelegate<FromClauseT extends Pick<Correlated, "outerQueryJoins">, SrcT extends FromClauseT["outerQueryJoins"][number]> = (WhereEqInnerQueryPrimaryKeySrcDelegateImpl<SrcT, FromClauseT["outerQueryJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqInnerQueryPrimaryKeyDstDelegateImpl<SrcT extends OuterQueryJoinsT[number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<CurrentJoinsT, SrcT["columns"]>, OuterQueryJoinsT extends Correlated["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<CurrentJoinsT, SrcT["columns"]>[]>) => DstT);
    export type WhereEqInnerQueryPrimaryKeyDstDelegate<FromClauseT extends (Correlated & AfterFromClause), SrcT extends FromClauseT["outerQueryJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<FromClauseT["currentJoins"], SrcT["columns"]>> = (WhereEqInnerQueryPrimaryKeyDstDelegateImpl<SrcT, DstT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKeyOfTable(
     *          outerQueryTable,
     *          currentQueryTable
     *      ));
     * ```
     * -----
     *
     * + The `outerQueryTable` does not need to have keys.
     * + The `currentQueryTable` must have a primary key.
     * + The `outerQueryTable` must have columns comparable to columns of `currentQueryTable`'s primary key.
     */
    export function whereEqInnerQueryPrimaryKey<FromClauseT extends (Correlated & AfterFromClause), SrcT extends FromClauseT["outerQueryJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<FromClauseT["currentJoins"], SrcT["columns"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, srcDelegate: WhereEqInnerQueryPrimaryKeySrcDelegate<FromClauseT, SrcT>, dstDelegate: (WhereEqInnerQueryPrimaryKeyDstDelegate<FromClauseT, SrcT, DstT>)): ({
        fromClause: WhereEqInnerQueryPrimaryKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-eq-outer-query-candidate-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause, Correlated } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { EqCandidateKeyOfTable, EqCandidateKeyOfTableDelegate } from "expr-library/index";
    import { JoinMapUtil } from "join-map/index";
    import { TableUtil } from "table/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryCandidateKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    export type WhereEqOuterQueryCandidateKey<FromClauseT extends AfterFromClause> = (WhereEqOuterQueryCandidateKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryCandidateKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type WhereEqOuterQueryCandidateKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (WhereEqOuterQueryCandidateKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryCandidateKeyDstDelegateImpl<DstT extends JoinArrayUtil.ExtractWithCandidateKey<OuterQueryJoinsT>, OuterQueryJoinsT extends Correlated["outerQueryJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithCandidateKey<OuterQueryJoinsT>[]>) => DstT);
    export type WhereEqOuterQueryCandidateKeyDstDelegate<FromClauseT extends (Correlated & AfterFromClause), DstT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["outerQueryJoins"]>> = (WhereEqOuterQueryCandidateKeyDstDelegateImpl<DstT, FromClauseT["outerQueryJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqCandidateKeyOfTable(
     *          currentQueryTable,
     *          outerQueryTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      ));
     * ```
     * -----
     *
     * + The `currentQueryTable` does not need to have keys.
     * + The `outerQueryTable` must have at least one candidate key.
     * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s candidate key.
     */
    export function whereEqOuterQueryCandidateKey<FromClauseT extends (Correlated & AfterFromClause), SrcT extends FromClauseT["currentJoins"][number], DstT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["outerQueryJoins"]>, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * @todo Remove this
     */
    eqCandidateKeyOfTable: EqCandidateKeyOfTable, srcDelegate: WhereEqOuterQueryCandidateKeySrcDelegate<FromClauseT, SrcT>, dstDelegate: (WhereEqOuterQueryCandidateKeyDstDelegate<FromClauseT, DstT>), eqCandidateKeyOfTableDelegate: EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): ({
        fromClause: WhereEqOuterQueryCandidateKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-eq-outer-query-primary-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause, Correlated } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { JoinMapUtil } from "join-map/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryPrimaryKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    export type WhereEqOuterQueryPrimaryKey<FromClauseT extends AfterFromClause> = (WhereEqOuterQueryPrimaryKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryPrimaryKeySrcDelegateImpl<SrcT extends CurrentJoinsT[number], CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<CurrentJoinsT>) => SrcT);
    export type WhereEqOuterQueryPrimaryKeySrcDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, SrcT extends FromClauseT["currentJoins"][number]> = (WhereEqOuterQueryPrimaryKeySrcDelegateImpl<SrcT, FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryPrimaryKeyDstDelegateImpl<SrcT extends CurrentJoinsT[number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<OuterQueryJoinsT, SrcT["columns"]>, CurrentJoinsT extends AfterFromClause["currentJoins"], OuterQueryJoinsT extends Correlated["outerQueryJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<OuterQueryJoinsT, SrcT["columns"]>[]>) => DstT);
    export type WhereEqOuterQueryPrimaryKeyDstDelegate<FromClauseT extends (Correlated & AfterFromClause), SrcT extends FromClauseT["currentJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<FromClauseT["outerQueryJoins"], SrcT["columns"]>> = (WhereEqOuterQueryPrimaryKeyDstDelegateImpl<SrcT, DstT, FromClauseT["currentJoins"], FromClauseT["outerQueryJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKeyOfTable(
     *          currentQueryTable,
     *          outerQueryTable
     *      ));
     * ```
     * -----
     *
     * + The `currentQueryTable` does not need to have keys.
     * + The `outerQueryTable` must have a primary key.
     * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s primary key.
     */
    export function whereEqOuterQueryPrimaryKey<FromClauseT extends (Correlated & AfterFromClause), SrcT extends FromClauseT["currentJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<FromClauseT["outerQueryJoins"], SrcT["columns"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate: (SrcT extends FromClauseT["currentJoins"][number] ? WhereEqOuterQueryPrimaryKeySrcDelegate<FromClauseT, SrcT> : never), dstDelegate: (WhereEqOuterQueryPrimaryKeyDstDelegate<FromClauseT, SrcT, DstT>)): ({
        fromClause: WhereEqOuterQueryPrimaryKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-eq-primary-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { PrimaryKey_NonUnion } from "primary-key/index";
    import { JoinMapUtil } from "join-map/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqPrimaryKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    /**
     * @todo Consider making `nullable` joins non-nullable when
     * used with `whereEqPrimaryKey()`
     *
     * Not a priority because people should not usually
     * write such a query.
     *
     * -----
     *
     * Assume `tableB.tableBId` is the primary key of `tableB`.
     *
     * Normally, `tableB` should be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     * ```
     *
     * However, `tableB` should not be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     *  WHERE
     *      tableB.tableBId = 1
     * ```
     */
    export type WhereEqPrimaryKey<FromClauseT extends AfterFromClause> = (WhereEqPrimaryKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqPrimaryKeyDelegateImpl<TableT extends JoinArrayUtil.ExtractWithPrimaryKey<CurrentJoinsT>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithPrimaryKey<CurrentJoinsT>[]>) => TableT);
    export type WhereEqPrimaryKeyDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, TableT extends JoinArrayUtil.ExtractWithPrimaryKey<FromClauseT["currentJoins"]>> = (WhereEqPrimaryKeyDelegateImpl<TableT, FromClauseT["currentJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKey(
     *          myTable,
     *          myPrimaryKey
     *      ));
     * ```
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    export function whereEqPrimaryKey<FromClauseT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithPrimaryKey<FromClauseT["currentJoins"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithPrimaryKey<FromClauseT["currentJoins"]> ? [WhereEqPrimaryKeyDelegate<FromClauseT, TableT>, PrimaryKey_NonUnion<TableT>] : never)): ({
        fromClause: WhereEqPrimaryKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "super-key/super-key" {
    import { ITable } from "table/index";
    import { ColumnMap } from "column-map/index";
    import { TypeMapUtil, TypeMap } from "type-map/index";
    import { Key } from "key/index";
    import { CandidateKey_NonUnionImpl } from "candidate-key/index";
    import { UnionToIntersection } from "type-util/index";
    export type SuperKey_NonUnionImpl<MapT extends ColumnMap, K extends Key> = (K extends Key ? CandidateKey_NonUnionImpl<MapT, K> & Partial<TypeMapUtil.FromColumnMap<Omit<MapT, K[number]>>> : never);
    /**
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `SuperKey_Output/Input<U>` instead.
     *
     * -----
     *
     * Also assumes `TableT["columns"]` and `TableT["candidateKeys"]` are not unions.
     * They really shouldn't be unions.
     * + Why does your table not have a definite set of columns?
     *   Is it Schrödinger's columns?
     * + Why does your table not have a definite set candidate keys?
     *   Is it Schrödinger's candidate keys?
     */
    export type SuperKey_NonUnion<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (SuperKey_NonUnionImpl<TableT["columns"], TableT["candidateKeys"][number]>);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of super keys.
     * Meant for output/read/covariant positions.
     */
    export type SuperKey_Output<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (TableT extends Pick<ITable, "columns" | "candidateKeys"> ? SuperKey_NonUnion<TableT> : never);
    /**
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of (intersection of super keys).
     * Meant for input/write/contravariant positions.
     *
     * -----
     *
     * ```ts
     *  //The following types are equal
     *  type a = (
     *      | ({x: ""} & {a: ""})
     *      | ({x: ""} & {b: ""})
     *      | ({y: ""} & {a: ""})
     *      | ({y: ""} & {b: ""})
     *  );
     *  type a = UnionToIntersection<
     *      //Assume these are candidate keys of table X
     *      | [{x:""}|{y:""}]
     *      //Assume these are candidate keys of table A
     *      | [{a:""}|{b:""}]
     *  >[number];
     * ```
     * http://www.typescriptlang.org/play/#code/C4TwDgpgBAqgdgSwPZwCpIJJ2BATgZwgGNhk4AeeAPigF4oAKAWACgp3HWPvY4oIAHjjgATfFACGcEFAD8jANYAuXgEo6NAG5IEIqCrgRNeLh3WDhYzmx7sGyqAjgAzPFAzraWnSNPt18hj6UIbGuKyqANysrAD0AFSsoJCSdNbcAD6MAN4CKgBE+QC+UABkUNkSBcWqflBZDLnVJeXZAEbNtTbsDdkgzWUVVVCFRV2ZOf0jxYPtnRGs8bFJ4NASafBk6Fg4BMSkKOR1WQDaTaMZfUqjALrHUGdVF3O3rFQncACuALZteDdAA
     */
    export type SuperKey_Input<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (Extract<(UnionToIntersection<TableT extends Pick<ITable, "columns" | "candidateKeys"> ? [SuperKey_NonUnion<TableT>] : never>), [TypeMap]>[number]);
}
declare module "super-key/util/query/mapper" {
    import * as tm from "type-mapping";
    import { SuperKey_Output } from "super-key/super-key";
    import { ITable } from "table/index";
    export type Mapper<TableT extends Pick<ITable, "columns" | "candidateKeys">> = (tm.SafeMapper<SuperKey_Output<TableT>>);
    export function mapper<TableT extends Pick<ITable, "columns" | "candidateKeys">>(table: TableT): (Mapper<TableT>);
}
declare module "super-key/util/query/index" {
    export * from "super-key/util/query/mapper";
}
declare module "super-key/util/index" {
    export * from "super-key/util/query/index";
}
declare module "super-key/index" {
    export * from "super-key/super-key";
    import * as SuperKeyUtil from "super-key/util/index";
    export { SuperKeyUtil, };
}
declare module "from-clause/util/operation/where-eq-super-key" {
    import { IFromClause } from "from-clause/from-clause";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { JoinMapUtil } from "join-map/index";
    import { EqSuperKey } from "expr-library/index";
    import { SuperKey_NonUnion } from "super-key/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqSuperKeyImpl<OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: CurrentJoinsT;
    }>);
    /**
     * @todo Consider making `nullable` joins non-nullable when
     * used with `whereEqSuperKey()`
     *
     * Not a priority because people should not usually
     * write such a query.
     *
     * -----
     *
     * Assume `tableB.tableBId` is the candidate key of `tableB`.
     *
     * Normally, `tableB` should be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     * ```
     *
     * However, `tableB` should not be `nullable` in the following query,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      tableA
     *  LEFT JOIN
     *      tableB
     *  ON
     *      tableA.tableBId = tableB.tableBId
     *  WHERE
     *      --If you want to follow the SQL standard,
     *      --tableB.tableBId IS NOT DISTINCT FROM 1
     *      tableB.tableBId <=> 1 AND
     *      tableB.otherColumn <=> 'hi'
     * ```
     */
    export type WhereEqSuperKey<FromClauseT extends AfterFromClause> = (WhereEqSuperKeyImpl<FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqSuperKeyDelegateImpl<TableT extends JoinArrayUtil.ExtractWithCandidateKey<CurrentJoinsT>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((
    /**
     * Is called `tables` but is really a map of joins
     */
    tables: JoinMapUtil.FromJoinArray<JoinArrayUtil.ExtractWithCandidateKey<CurrentJoinsT>[]>) => TableT);
    export type WhereEqSuperKeyDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]>> = (WhereEqSuperKeyDelegateImpl<TableT, FromClauseT["currentJoins"]>);
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqSuperKey(
     *          myTable,
     *          mySuperKey
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    export function whereEqSuperKey<FromClauseT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * @todo Remove this
     */
    eqSuperKey: EqSuperKey, 
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<FromClauseT["currentJoins"]> ? [WhereEqSuperKeyDelegate<FromClauseT, TableT>, SuperKey_NonUnion<TableT>] : never)): ({
        fromClause: WhereEqSuperKey<FromClauseT>;
        whereClause: WhereClause;
    });
}
declare module "value-expr/util/operation/case-insensitive-narrow" {
    import { NonNullBuiltInValueExpr, BuiltInValueExprUtil } from "built-in-value-expr/index";
    /**
     * Assuming case-insensitive equality,
     * + You cannot narrow `string` to a `string-literal`
     *
     *   Given`x = 'HeLlO'`,
     *   `x` could be `'hello'` or `'HELLO'`
     *
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type CaseInsensitiveNarrow<A extends unknown, B extends A> = ([A] extends [NonNullBuiltInValueExpr] ? BuiltInValueExprUtil.CaseInsensitiveNarrow<A, B> : A extends unknown ? (B extends A ? A : never) : never);
}
declare module "value-expr/util/operation/null-safe-case-insensitive-narrow" {
    import { BuiltInValueExprUtil, BuiltInValueExpr } from "built-in-value-expr/index";
    /**
     * Assuming case-insensitive equality,
     * + You cannot narrow `string` to a `string-literal`
     *
     *   Given`x = 'HeLlO'`,
     *   `x` could be `'hello'` or `'HELLO'`
     *
     * + You cannot narrow `Uint8Array` to a `Uint8Array-literal`
     *
     *   There is no `Uint8Array-literal` type
     *
     * + You cannot narrow `Date` to a `Date-literal`
     *
     *   There is no `Date-literal` type
     *
     */
    export type NullSafeCaseInsensitiveNarrow<A extends unknown, B extends A | null> = ([A] extends [BuiltInValueExpr] ? BuiltInValueExprUtil.NullSafeCaseInsensitiveNarrow<A, B> : A extends unknown ? (B extends A ? A : 
    /**
     * @todo Maybe `null extends B ? null : never`?
     *
     * Makes sense to make it "never" since if `A` is non-nullable,
     * then having `A <=> null` should always be false.
     */
    never) : never);
}
declare module "value-expr/util/operation/index" {
    export * from "value-expr/util/operation/case-insensitive-narrow";
    export * from "value-expr/util/operation/null-safe-case-insensitive-narrow";
}
declare module "value-expr/util/index" {
    export * from "value-expr/util/operation/index";
}
declare module "value-expr/index" {
    import * as ValueExprUtil from "value-expr/util/index";
    export { ValueExprUtil, };
}
declare module "from-clause/util/operation/where-eq" {
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/from-clause";
    import { ColumnUtil } from "column/index";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { ValueExprUtil } from "value-expr/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqImpl<ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.ReplaceColumn<CurrentJoinsT, ColumnT["tableAlias"], ColumnT["columnAlias"], ValueExprUtil.CaseInsensitiveNarrow<tm.OutputOf<ColumnT["mapper"]>, ValueT>>;
    }>);
    export type WhereEq<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>> = (WhereEqImpl<ColumnT, ValueT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqDelegateImpl<ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((columns: (ColumnRefUtil.TryFlatten<ColumnRefUtil.ExtractNonNullable<ColumnRefUtil.FromColumnArray<ColumnUtil.FromJoinArray<CurrentJoinsT>[]>>>)) => ColumnT);
    export type WhereEqDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>> = (WhereEqDelegateImpl<ColumnT, FromClauseT["currentJoins"]>);
    /**
     * Narrows a column's type based on equality to a value
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn = 1
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `1`.
     */
    export function whereEq<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>> ? [WhereEqDelegate<FromClauseT, ColumnT>, ValueT] : never)): ({
        fromClause: WhereEq<FromClauseT, ColumnT, ValueT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-is-not-null" {
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/from-clause";
    import { ColumnUtil } from "column/index";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNotNullImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.ReplaceColumn<CurrentJoinsT, ColumnT["tableAlias"], ColumnT["columnAlias"], Exclude<tm.OutputOf<ColumnT["mapper"]>, null>>;
    }>);
    export type WhereIsNotNull<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>> = (WhereIsNotNullImpl<ColumnT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNotNullDelegateImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((columns: (ColumnRefUtil.TryFlatten<ColumnRefUtil.ExtractNullable<ColumnRefUtil.FromColumnArray<ColumnUtil.FromJoinArray<CurrentJoinsT>[]>>>)) => ColumnT);
    export type WhereIsNotNullDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>> = (WhereIsNotNullDelegateImpl<ColumnT, FromClauseT["currentJoins"]>);
    /**
     * Narrows a column's type to **exclude** `null`
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn IS NOT NULL
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set **WILL NOT** be `null`.
     */
    export function whereIsNotNull<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, whereIsNotNullDelegate: WhereIsNotNullDelegate<FromClauseT, ColumnT>): ({
        fromClause: WhereIsNotNull<FromClauseT, ColumnT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-is-null" {
    import { IFromClause } from "from-clause/from-clause";
    import { ColumnUtil } from "column/index";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNullImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.ReplaceColumn<CurrentJoinsT, ColumnT["tableAlias"], ColumnT["columnAlias"], null>;
    }>);
    export type WhereIsNull<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>> = (WhereIsNullImpl<ColumnT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNullDelegateImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<CurrentJoinsT>>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((columns: (ColumnRefUtil.TryFlatten<ColumnRefUtil.ExtractNullable<ColumnRefUtil.FromColumnArray<ColumnUtil.FromJoinArray<CurrentJoinsT>[]>>>)) => ColumnT);
    export type WhereIsNullDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>> = (WhereIsNullDelegateImpl<ColumnT, FromClauseT["currentJoins"]>);
    /**
     * Narrows a column's type to `null`
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn IS NULL
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `null`.
     */
    export function whereIsNull<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>>(fromClause: FromClauseT, whereClause: WhereClause | undefined, whereIsNullDelegate: WhereIsNullDelegate<FromClauseT, ColumnT>): ({
        fromClause: WhereIsNull<FromClauseT, ColumnT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/where-null-safe-eq" {
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/from-clause";
    import { ColumnUtil } from "column/index";
    import { JoinArrayUtil } from "join/index";
    import { AfterFromClause } from "from-clause/util/helper-type/index";
    import { WhereClause } from "where-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { ValueExprUtil } from "value-expr/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereNullSafeEqImpl<ColumnT extends ColumnUtil.FromJoinArray<CurrentJoinsT>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null, OuterQueryJoinsT extends AfterFromClause["outerQueryJoins"], CurrentJoinsT extends AfterFromClause["currentJoins"]> = (IFromClause<{
        outerQueryJoins: OuterQueryJoinsT;
        currentJoins: JoinArrayUtil.ReplaceColumn<CurrentJoinsT, ColumnT["tableAlias"], ColumnT["columnAlias"], ValueExprUtil.NullSafeCaseInsensitiveNarrow<tm.OutputOf<ColumnT["mapper"]>, ValueT>>;
    }>);
    export type WhereNullSafeEq<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null> = (WhereNullSafeEqImpl<ColumnT, ValueT, FromClauseT["outerQueryJoins"], FromClauseT["currentJoins"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereNullSafeEqDelegateImpl<ColumnT extends ColumnUtil.FromJoinArray<CurrentJoinsT>, CurrentJoinsT extends AfterFromClause["currentJoins"]> = ((columns: (ColumnRefUtil.TryFlatten<ColumnRefUtil.FromColumnArray<ColumnUtil.FromJoinArray<CurrentJoinsT>[]>>)) => ColumnT);
    export type WhereNullSafeEqDelegate<FromClauseT extends Pick<AfterFromClause, "currentJoins">, ColumnT extends ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>> = (WhereNullSafeEqDelegateImpl<ColumnT, FromClauseT["currentJoins"]>);
    /**
     * Narrows a column's type based on null-safe equality to a value
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn <=> 1
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `1`.
     */
    export function whereNullSafeEq<FromClauseT extends AfterFromClause, ColumnT extends ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null>(fromClause: FromClauseT, whereClause: WhereClause | undefined, 
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (ColumnT extends ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]> ? [WhereNullSafeEqDelegate<FromClauseT, ColumnT>, ValueT] : never)): ({
        fromClause: WhereNullSafeEq<FromClauseT, ColumnT, ValueT>;
        whereClause: WhereClause;
    });
}
declare module "from-clause/util/operation/index" {
    export * from "from-clause/util/operation/correlate";
    export * from "from-clause/util/operation/cross-join";
    export * from "from-clause/util/operation/from";
    export * from "from-clause/util/operation/inner-join-using-candidate-key";
    export * from "from-clause/util/operation/inner-join-using-primary-key";
    export * from "from-clause/util/operation/inner-join";
    export * from "from-clause/util/operation/left-join-using-candidate-key";
    export * from "from-clause/util/operation/left-join-using-primary-key";
    export * from "from-clause/util/operation/left-join";
    export * from "from-clause/util/operation/require-nullable-outer-query-joins";
    export * from "from-clause/util/operation/require-outer-query-joins-impl";
    export * from "from-clause/util/operation/require-outer-query-joins";
    export * from "from-clause/util/operation/where-eq-candidate-key";
    export * from "from-clause/util/operation/where-eq-columns";
    export * from "from-clause/util/operation/where-eq-inner-query-primary-key";
    export * from "from-clause/util/operation/where-eq-outer-query-candidate-key";
    export * from "from-clause/util/operation/where-eq-outer-query-primary-key";
    export * from "from-clause/util/operation/where-eq-primary-key";
    export * from "from-clause/util/operation/where-eq-super-key";
    export * from "from-clause/util/operation/where-eq";
    export * from "from-clause/util/operation/where-is-not-null";
    export * from "from-clause/util/operation/where-is-null";
    export * from "from-clause/util/operation/where-null-safe-eq";
}
declare module "from-clause/util/query/outer-query-table-alias" {
    import { IFromClause } from "from-clause/from-clause";
    import { IJoin, JoinArrayUtil } from "join/index";
    export type OuterQueryTableAlias<FromClauseT extends Pick<IFromClause, "outerQueryJoins">> = FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? JoinArrayUtil.TableAlias<FromClauseT["outerQueryJoins"]> : never;
    export function outerQueryTableAlias<FromClauseT extends Pick<IFromClause, "outerQueryJoins">>(fromClause: FromClauseT): (OuterQueryTableAlias<FromClauseT>[]);
}
declare module "from-clause/util/query/index" {
    export * from "from-clause/util/query/outer-query-table-alias";
}
declare module "from-clause/util/index" {
    export * from "from-clause/util/constructor/index";
    export * from "from-clause/util/helper-type/index";
    export * from "from-clause/util/operation/index";
    export * from "from-clause/util/predicate/index";
    export * from "from-clause/util/query/index";
}
declare module "from-clause/index" {
    export * from "from-clause/from-clause";
    import * as FromClauseUtil from "from-clause/util/index";
    export { FromClauseUtil, };
}
declare module "compound-query/compound-query" {
    import { QueryBaseUtil } from "query-base/index";
    export enum CompoundQueryType {
        UNION = "UNION",
        INTERSECT = "INTERSECT",
        EXCEPT = "EXCEPT"
    }
    export interface CompoundQuery {
        /**
         * We have an enum with all three compound query types
         * but we will only use `UNION` for the unified library.
         *
         * The database+version-specific libraries may use the other
         * compound query types.
         */
        compoundQueryType: CompoundQueryType;
        /**
         * Defaults to `true`.
         *
         * Used for `UNION DISTINCT` or `UNION ALL`.
         *
         * For SQLite, you cannot write `UNION DISTINCT`.
         * You can only write,
         * + `UNION` (The `DISTINCT` is implied)
         * + `UNION ALL`
         *
         * -----
         *
         * For `INTERSECT` and `EXCEPT`, this is always `true` because
         * SQLite does not allow the `DISTINCT|ALL` keywords for those two clauses.
         *
         * -----
         *
         * This library will only allow,
         * + `UNION` (distinct implied)
         * + `UNION ALL`
         * + `INTERSECT` (distinct implied)
         * + `EXCEPT` (distinct implied)
         *
         * -----
         *
         * Mixed `UNION` types are treated such that a `DISTINCT` union overrides
         * any `ALL` union to its left.
         */
        readonly isDistinct: boolean;
        readonly query: QueryBaseUtil.AfterSelectClause;
    }
}
declare module "compound-query/index" {
    export * from "compound-query/compound-query";
}
declare module "compound-query-clause/compound-query-clause" {
    import { CompoundQuery } from "compound-query/index";
    export type CompoundQueryClause = readonly CompoundQuery[];
}
declare module "compound-query-clause/util/predicate/assert-select-clause-compatible" {
    import * as tm from "type-mapping";
    import { SelectClause } from "select-clause/index";
    import { IColumn } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { ColumnMap } from "column-map/index";
    import { ColumnRef } from "column-ref/index";
    import { CompileError } from "compile-error/index";
    import { IsStrictSameType, ToUnknownIfAllPropertiesNever, Merge } from "type-util/index";
    export type FindItemCompatibilityError<IdentifierT extends Record<PropertyKey, PropertyKey>, A extends {
        mapper: tm.AnyMapper;
    }, B extends {
        mapper: tm.AnyMapper;
    }> = tm.OutputOf<B["mapper"]> extends tm.OutputOf<A["mapper"]> ? never : CompileError<["Expected", IdentifierT, "to be subtype of", tm.OutputOf<A["mapper"]>, "received", tm.OutputOf<B["mapper"]>]>;
    export type FindMapCompatibilityError<IdentifierT extends Record<PropertyKey, PropertyKey>, A extends ColumnMap, B extends ColumnMap> = Exclude<keyof A, keyof B> extends never ? (Exclude<keyof B, keyof A> extends never ? {
        [columnAlias in (keyof A) & (keyof B)]: (FindItemCompatibilityError<Merge<IdentifierT & {
            columnAlias: columnAlias;
        }>, A[columnAlias], B[columnAlias]>);
    }[(keyof A) & (keyof B)] : CompileError<[IdentifierT, "has extra columns", Exclude<keyof B, keyof A>]>) : CompileError<["Expected", IdentifierT, "to have columns", Exclude<keyof A, keyof B>]>;
    export type FindRefCompatibilityError<IdentifierT extends Record<PropertyKey, PropertyKey>, A extends ColumnRef, B extends ColumnRef> = Exclude<keyof A, keyof B> extends never ? (Exclude<keyof B, keyof A> extends never ? {
        [tableAlias in (keyof A) & (keyof B)]: (FindMapCompatibilityError<Merge<IdentifierT & {
            tableAlias: tableAlias;
        }>, A[tableAlias], B[tableAlias]>);
    }[(keyof A) & (keyof B)] : CompileError<[IdentifierT, "has extra tables", Exclude<keyof B, keyof A>]>) : CompileError<["Expected", IdentifierT, "to have tables", Exclude<keyof A, keyof B>]>;
    /**
     * @todo Consider allowing nullable columns to be compounded with non-nullable columns.
     * This will require modifying the type of the original `SELECT` clause.
     */
    export type AssertSelectClauseCompatible<A extends SelectClause, B extends SelectClause> = number extends A["length"] ? CompileError<["Cannot compare to invalid SELECT clause length", A["length"]]> : IsStrictSameType<A["length"], B["length"]> extends false ? CompileError<["SELECT clause length mismatch; expected", A["length"], "received", B["length"]]> : ToUnknownIfAllPropertiesNever<{
        [index in (keyof A) & (keyof B)]: (A[index] extends IColumn | IExprSelectItem ? (B[index] extends IColumn | IExprSelectItem ? FindItemCompatibilityError<{
            index: index;
        }, A[index], B[index]> : CompileError<["Expected index", index, "to be Column or ExprSelectItem"]>) : A[index] extends ColumnMap ? (B[index] extends ColumnMap ? FindMapCompatibilityError<{
            index: index;
        }, A[index], B[index]> : CompileError<["Expected index", index, "to be ColumnMap"]>) : A[index] extends ColumnRef ? (B[index] extends ColumnRef ? FindRefCompatibilityError<{
            index: index;
        }, A[index], B[index]> : CompileError<["Expected index", index, "to be ColumnRef"]>) : never);
    }>;
    export function assertMapCompatibilityError(identifier: (string | number)[], a: ColumnMap, b: ColumnMap): void;
    export function assertRefCompatibilityError(identifier: (string | number)[], a: ColumnRef, b: ColumnRef): void;
    export function assertSelectClauseCompatible(a: SelectClause, b: SelectClause): void;
}
declare module "compound-query-clause/util/predicate/assert-outer-query-joins-compatible" {
    import { IFromClause } from "from-clause/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    export type AssertOuterQueryJoinsCompatible<FromClauseT extends Pick<IFromClause, "outerQueryJoins">, TargetFromClauseT extends Pick<IFromClause, "outerQueryJoins">> = UsedRefUtil.AssertAllowed<UsedRefUtil.FromJoinArray<FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"] : []>, UsedRefUtil.FromJoinArray<TargetFromClauseT["outerQueryJoins"] extends readonly IJoin[] ? TargetFromClauseT["outerQueryJoins"] : []>>;
    export function assertOuterQueryJoinsCompatible(fromClause: Pick<IFromClause, "outerQueryJoins">, targetFromClause: Pick<IFromClause, "outerQueryJoins">): void;
}
declare module "compound-query-clause/util/predicate/assert-compatible" {
    import { SelectClause } from "select-clause/index";
    import { QueryBaseUtil } from "query-base/index";
    import { IFromClause } from "from-clause/index";
    import { AssertSelectClauseCompatible } from "compound-query-clause/util/predicate/assert-select-clause-compatible";
    import { AssertOuterQueryJoinsCompatible } from "compound-query-clause/util/predicate/assert-outer-query-joins-compatible";
    export type AssertCompatible<FromClauseT extends Pick<IFromClause, "outerQueryJoins">, SelectClauseT extends SelectClause, TargetQueryT extends QueryBaseUtil.AfterSelectClause> = AssertSelectClauseCompatible<SelectClauseT, TargetQueryT["selectClause"]> & AssertOuterQueryJoinsCompatible<FromClauseT, TargetQueryT["fromClause"]>;
    export function assertCompatible(fromClause: Pick<IFromClause, "outerQueryJoins">, selectClause: SelectClause, targetQuery: QueryBaseUtil.AfterSelectClause): void;
}
declare module "compound-query-clause/util/predicate/index" {
    export * from "compound-query-clause/util/predicate/assert-compatible";
    export * from "compound-query-clause/util/predicate/assert-outer-query-joins-compatible";
    export * from "compound-query-clause/util/predicate/assert-select-clause-compatible";
}
declare module "compound-query-clause/util/operation/compound-query" {
    import { SelectClause, SelectClauseUtil } from "select-clause/index";
    import { CompoundQueryType } from "compound-query/index";
    import { CompoundQueryClause } from "compound-query-clause/compound-query-clause";
    import { QueryBaseUtil } from "query-base/index";
    import { AssertNonUnion } from "type-util/index";
    import { AssertCompatible } from "compound-query-clause/util/predicate/index";
    import { IFromClause } from "from-clause/index";
    export function compoundQuery<FromClauseT extends Pick<IFromClause, "outerQueryJoins">, SelectClauseT extends SelectClause, TargetQueryT extends QueryBaseUtil.AfterSelectClause>(fromClause: FromClauseT, selectClause: SelectClauseT & AssertNonUnion<SelectClauseT>, compoundQueryClause: CompoundQueryClause | undefined, compoundQueryType: CompoundQueryType, isDistinct: boolean, targetQuery: (TargetQueryT & AssertCompatible<FromClauseT, SelectClauseT, TargetQueryT>)): ({
        /**
         * We only need to `LeftCompound` because we already asserted
         * that both `SELECT` clauses have the same length.
         */
        selectClause: SelectClauseUtil.LeftCompound<SelectClauseT, TargetQueryT["selectClause"]>;
        compoundQueryClause: CompoundQueryClause;
    });
}
declare module "compound-query-clause/util/operation/index" {
    export * from "compound-query-clause/util/operation/compound-query";
}
declare module "compound-query-clause/util/index" {
    export * from "compound-query-clause/util/operation/index";
    export * from "compound-query-clause/util/predicate/index";
}
declare module "compound-query-clause/index" {
    export * from "compound-query-clause/compound-query-clause";
    import * as CompoundQueryClauseUtil from "compound-query-clause/util/index";
    export { CompoundQueryClauseUtil, };
}
declare module "limit-clause/limit-clause" {
    /**
     * May be used for the `LIMIT` clause or `COMPOUND QUERY`'s `LIMIT` clause.
     *
     * The values are `bigint` because having a `maxRowCount/offset` of
     * `3.141` would be weird.
     */
    export interface LimitClause {
        /**
         * This is called `**max**RowCount` and not `rowCount` (like MySQL calls it)
         * because we can say we want a `maxRowCount` of `10` and only get `3` rows.
         * Or a `maxRowCount` of `1` and get `0` rows.
         */
        readonly maxRowCount: bigint;
        /**
         * The offset of the initial row is `0`.
         * (Remember, arrays start from zero!)
         */
        readonly offset: bigint;
    }
}
declare module "limit-clause/util/operation/offset-bigint" {
    import { LimitClause } from "limit-clause/limit-clause";
    /**
     * `PostgreSQL` supports the `LIMIT ALL` syntax.
     * https://www.postgresql.org/docs/8.0/queries-limit.html
     *
     * -----
     *
     * SQLite does not support the `LIMIT ALL` syntax.
     *
     * The max integer value for SQLite is `9223372036854775807` (signed 8-byte int).
     * SQLite does not have `BIGINT UNSIGNED`.
     *
     * So, we use `LIMIT 9223372036854775807` for SQLite.
     *
     * -----
     *
     * `MySQL` does not support the `LIMIT ALL` syntax.
     * We **could** use the max `BIGINT UNSIGNED` value.
     *
     * But we want to be compatible with SQLite.
     *
     * So, instead of using  `LIMIT 18446744073709551615`,
     * we use SQLite's instead.
     */
    export type ALL_ROW_COUNT = 9223372036854775807n;
    export const ALL_ROW_COUNT: ALL_ROW_COUNT;
    export type MAX_OFFSET = 9223372036854775807n;
    export const MAX_OFFSET: MAX_OFFSET;
    export type OffsetBigInt<LimitClauseT extends LimitClause | undefined, OffsetT extends bigint> = LimitClauseT extends LimitClause ? {
        readonly maxRowCount: LimitClauseT["maxRowCount"];
        readonly offset: OffsetT;
    } : {
        readonly maxRowCount: ALL_ROW_COUNT;
        readonly offset: OffsetT;
    };
    export function offsetBigInt<LimitClauseT extends LimitClause | undefined, OffsetT extends bigint>(limitClause: LimitClauseT, offset: OffsetT): (OffsetBigInt<LimitClauseT, OffsetT>);
}
declare module "limit-clause/util/operation/limit-bigint" {
    import { LimitClause } from "limit-clause/limit-clause";
    export type LimitBigInt<LimitClauseT extends LimitClause | undefined, MaxRowCountT extends bigint> = LimitClauseT extends LimitClause ? {
        readonly maxRowCount: MaxRowCountT;
        readonly offset: LimitClauseT["offset"];
    } : {
        readonly maxRowCount: MaxRowCountT;
        readonly offset: 0n;
    };
    export function limitBigInt<LimitClauseT extends LimitClause | undefined, MaxRowCountT extends bigint>(limitClause: LimitClauseT, maxRowCount: MaxRowCountT): (LimitBigInt<LimitClauseT, MaxRowCountT>);
}
declare module "limit-clause/util/operation/limit-number" {
    import { LimitClause } from "limit-clause/limit-clause";
    import { LimitBigInt } from "limit-clause/util/operation/limit-bigint";
    export type LimitNumber0<LimitClauseT extends LimitClause | undefined> = LimitBigInt<LimitClauseT, 0n>;
    export type LimitNumber1<LimitClauseT extends LimitClause | undefined> = LimitBigInt<LimitClauseT, 1n>;
    export type LimitNumber0Or1<LimitClauseT extends LimitClause | undefined> = LimitBigInt<LimitClauseT, 0n | 1n>;
    export type LimitNumber<LimitClauseT extends LimitClause | undefined> = LimitBigInt<LimitClauseT, bigint>;
    export function limitNumber<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 0): (LimitNumber0<LimitClauseT>);
    export function limitNumber<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 1): (LimitNumber1<LimitClauseT>);
    export function limitNumber<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 0 | 1): (LimitNumber0Or1<LimitClauseT>);
    export function limitNumber<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: number): (LimitNumber<LimitClauseT>);
}
declare module "limit-clause/util/operation/limit" {
    import { LimitClause } from "limit-clause/limit-clause";
    import { LimitBigInt } from "limit-clause/util/operation/limit-bigint";
    import { LimitNumber0, LimitNumber1, LimitNumber0Or1, LimitNumber } from "limit-clause/util/operation/limit-number";
    export function limit<LimitClauseT extends LimitClause | undefined, MaxRowCountT extends bigint>(limitClause: LimitClauseT, maxRowCount: MaxRowCountT): (LimitBigInt<LimitClauseT, MaxRowCountT>);
    export function limit<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 0): (LimitNumber0<LimitClauseT>);
    export function limit<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 1): (LimitNumber1<LimitClauseT>);
    export function limit<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: 0 | 1): (LimitNumber0Or1<LimitClauseT>);
    export function limit<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: number): (LimitNumber<LimitClauseT>);
    export function limit<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, maxRowCount: number | bigint): (LimitNumber<LimitClauseT>);
}
declare module "limit-clause/util/operation/offset-number" {
    import { LimitClause } from "limit-clause/limit-clause";
    import { OffsetBigInt } from "limit-clause/util/operation/offset-bigint";
    export type OffsetNumber<LimitClauseT extends LimitClause | undefined> = OffsetBigInt<LimitClauseT, bigint>;
    export function offsetNumber<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, offset: number): (OffsetNumber<LimitClauseT>);
}
declare module "limit-clause/util/operation/offset" {
    import { LimitClause } from "limit-clause/limit-clause";
    import { OffsetBigInt } from "limit-clause/util/operation/offset-bigint";
    import { OffsetNumber } from "limit-clause/util/operation/offset-number";
    export function offset<LimitClauseT extends LimitClause | undefined, OffsetT extends bigint>(limitClause: LimitClauseT, offset: OffsetT): (OffsetBigInt<LimitClauseT, OffsetT>);
    export function offset<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, offset: number): (OffsetNumber<LimitClauseT>);
    export function offset<LimitClauseT extends LimitClause | undefined>(limitClause: LimitClauseT, offset: number | bigint): (OffsetNumber<LimitClauseT>);
}
declare module "limit-clause/util/operation/index" {
    export * from "limit-clause/util/operation/limit-bigint";
    export * from "limit-clause/util/operation/limit-number";
    export * from "limit-clause/util/operation/limit";
    export * from "limit-clause/util/operation/offset-bigint";
    export * from "limit-clause/util/operation/offset-number";
    export * from "limit-clause/util/operation/offset";
}
declare module "limit-clause/util/index" {
    export * from "limit-clause/util/operation/index";
}
declare module "limit-clause/index" {
    export * from "limit-clause/limit-clause";
    import * as LimitClauseUtil from "limit-clause/util/index";
    export { LimitClauseUtil, };
}
declare module "group-by-clause/group-by-clause" {
    import { ColumnIdentifier } from "column-identifier/index";
    export type GroupByClause = readonly ColumnIdentifier[];
}
declare module "group-by-clause/util/query/allowed-used-ref" {
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnIdentifierRefUtil } from "column-identifier-ref/index";
    /**
     * https://stackoverflow.com/questions/59922428/portable-group-by-clause-rules/59922712#59922712
     *
     * 1. Aliased expressions in the `SELECT` clause **must not** be used in the `GROUP BY` clause
     *    + MySQL allows this
     * 2. Columns from outer queries **must not** be used in the `GROUP BY` clause
     *    + No databases allow this
     * 3. The `GROUP BY` clause **must not** contain non-column expressions
     *    + MySQL, PostgreSQL, SQLite, MS SQL Server all support this
     *    + This is not part of the SQL standard, however
     * 4. The `GROUP BY` clause **must not** be used without a `FROM` clause
     *    + A restriction of MySQL
     */
    export type AllowedColumnIdentifierRef<FromClauseT extends FromClauseUtil.AfterFromClause> = ColumnIdentifierRefUtil.FromJoinArray<FromClauseT["currentJoins"]>;
    export function allowedColumnIdentifierRef<FromClauseT extends FromClauseUtil.AfterFromClause>(fromClause: FromClauseT): (AllowedColumnIdentifierRef<FromClauseT>);
}
declare module "group-by-clause/util/query/index" {
    export * from "group-by-clause/util/query/allowed-used-ref";
}
declare module "group-by-clause/util/operation/group-by" {
    import { FromClauseUtil } from "from-clause/index";
    import { AllowedColumnIdentifierRef } from "group-by-clause/util/query/index";
    import { GroupByClause } from "group-by-clause/group-by-clause";
    import { GroupByDelegate } from "group-by-clause/group-by-delegate";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    export type GroupBy<GroupByClauseT extends GroupByClause | undefined, GroupByT extends GroupByClause> = GroupByClauseT extends GroupByClause ? readonly (GroupByClauseT[number] | GroupByT[number])[] : readonly (GroupByT[number])[];
    /**
     * Returns the MySQL equivalent of `...groupByClause, ...groupByDelegate(columns)`
     *
     * -----
     *
     * Consider the following,
     * ```sql
     *  SELECT 1 AS a GROUP BY a
     * ```
     *
     * + The above works on PostgreSQL 9.4
     * + The above **does not** work on MySQL 5.7
     * -----
     *
     * We only allow `GROUP BY` after the `FROM` clause because
     * it isn't very useful without a `FROM` clause.
     *
     * @param fromClause
     * @param selectClause
     * @param groupByClause
     * @param groupByDelegate
     */
    export function groupBy<
    /**
     * For MySQL 5.7,
     * the constraint **must** be `FromClauseUtil.AfterFromClause`
     */
    FromClauseT extends FromClauseUtil.AfterFromClause, GroupByClauseT extends GroupByClause | undefined, GroupByT extends readonly ColumnIdentifierUtil.FromColumnRef<AllowedColumnIdentifierRef<FromClauseT>>[]>(fromClause: FromClauseT, groupByClause: GroupByClauseT, groupByDelegate: GroupByDelegate<FromClauseT, GroupByT>): (GroupBy<GroupByClauseT, GroupByT>);
}
declare module "group-by-clause/util/operation/index" {
    export * from "group-by-clause/util/operation/group-by";
}
declare module "group-by-clause/util/predicate/is-non-empty" {
    import { GroupByClause } from "group-by-clause/group-by-clause";
    import { CompileError } from "compile-error/index";
    export type AssertNonEmpty<GroupByClauseT extends GroupByClause> = GroupByClauseT[number] extends never ? CompileError<"GROUP BY clause cannot be empty"> : unknown;
    export function assertNonEmpty(groupByClause: GroupByClause): void;
}
declare module "group-by-clause/util/predicate/index" {
    export * from "group-by-clause/util/predicate/is-non-empty";
}
declare module "group-by-clause/util/index" {
    export * from "group-by-clause/util/operation/index";
    export * from "group-by-clause/util/predicate/index";
    export * from "group-by-clause/util/query/index";
}
declare module "group-by-clause/group-by-delegate" {
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnIdentifierRefUtil } from "column-identifier-ref/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import * as GroupByClauseUtil from "group-by-clause/util/index";
    export type GroupByDelegate<FromClauseT extends FromClauseUtil.AfterFromClause, GroupByT extends readonly ColumnIdentifierUtil.FromColumnRef<GroupByClauseUtil.AllowedColumnIdentifierRef<FromClauseT>>[]> = ((columns: ColumnIdentifierRefUtil.TryFlatten<GroupByClauseUtil.AllowedColumnIdentifierRef<FromClauseT>>) => GroupByT);
}
declare module "group-by-clause/index" {
    export * from "group-by-clause/group-by-clause";
    export * from "group-by-clause/group-by-delegate";
    import * as GroupByClauseUtil from "group-by-clause/util/index";
    export { GroupByClauseUtil, };
}
declare module "having-clause/having-clause" {
    import { IAnonymousExpr } from "expr/index";
    /**
     * The `HAVING` clause of a query.
     *
     * -----
     *
     * For now, it's basically the same as the `WHERE` clause.
     *
     * At some point, they should diverge when `WHERE` clause is prevented
     * from using aggregation functions.
     */
    export type HavingClause = IAnonymousExpr<boolean, boolean>;
}
declare module "having-clause/util/query/allowed-non-aggregate-used-ref" {
    import { IFromClause } from "from-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    import { Merge } from "type-util/index";
    export type AllowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = Merge<ColumnRefUtil.FromJoinArray<FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"] : []> & ColumnRefUtil.ExtractColumnIdentifier<ColumnRefUtil.FromJoinArray<FromClauseT["currentJoins"] extends readonly IJoin[] ? FromClauseT["currentJoins"] : []>, GroupByClauseT[number]>>;
    export type AllowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = UsedRefUtil.FromColumnRef<AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT>>;
    export function allowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT): (AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT>);
    export function allowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT): (AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>);
}
declare module "having-clause/util/query/allowed-used-ref" {
    import { IFromClause, FromClauseUtil } from "from-clause/index";
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedColumnRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     *
     * -----
     *
     * The following is valid for MySQL and SQLite,
     * but not for PostgreSQL,
     *
     * ```sql
     *  SELECT
     *      myTable.myColumn+2 AS someAlias
     *  FROM
     *      myTable
     *  GROUP BY
     *      someAlias
     *  HAVING
     *      someAlias > 0
     * ```
     */
    export type AllowedColumnRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedColumnRef<FromClauseT, {
        isLateral: true;
    }>);
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedUsedRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     */
    export type AllowedUsedRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedUsedRef<FromClauseT, {
        isLateral: true;
    }>);
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedColumnRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     */
    export function allowedColumnRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedColumnRef<FromClauseT>);
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedUsedRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     */
    export function allowedUsedRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedUsedRef<FromClauseT>);
}
declare module "having-clause/util/query/index" {
    export * from "having-clause/util/query/allowed-non-aggregate-used-ref";
    export * from "having-clause/util/query/allowed-used-ref";
}
declare module "having-clause/util/operation/having" {
    import { IFromClause } from "from-clause/index";
    import { HavingDelegate } from "having-clause/having-delegate";
    import { HavingClause } from "having-clause/having-clause";
    import { GroupByClause } from "group-by-clause/index";
    /**
     * Returns the MySQL equivalent of `havingClause AND havingDelegate(columns)`
     *
     * -----
     *
     * For now, this is basically the same as `WhereClauseUtil.where<>()`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     *
     * -----
     *
     * @param fromClause
     * @param havingClause
     * @param havingDelegate
     */
    export function having<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT, havingClause: HavingClause | undefined, havingDelegate: HavingDelegate<FromClauseT, GroupByClauseT>): (HavingClause);
}
declare module "having-clause/util/operation/index" {
    export * from "having-clause/util/operation/having";
}
declare module "having-clause/util/index" {
    export * from "having-clause/util/operation/index";
    export * from "having-clause/util/query/index";
}
declare module "having-clause/having-delegate" {
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { IExpr } from "expr/index";
    import * as HavingClauseUtil from "having-clause/util/index";
    import { ColumnUtil } from "column/index";
    import { GroupByClause, GroupByClauseUtil } from "group-by-clause/index";
    import { Identity } from "type-util/index";
    export type AllowedHavingClause<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = Identity<boolean | IExpr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: HavingClauseUtil.AllowedUsedRef<FromClauseT>;
        isAggregate: true;
    }>
    /**
     * If `isAggregate` is `false` or `boolean`, we treat it
     * as a non-aggregate expression.
     *
     * Non-aggregate expressions have more restrictions
     * on what can be referenced.
     */
     | IExpr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: HavingClauseUtil.AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>;
        isAggregate: boolean;
    }>
    /**
     * Columns are non-aggregate expressions
     */
     | ColumnUtil.ExtractWithType<ColumnUtil.FromColumnRef<HavingClauseUtil.AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT>>, boolean>>;
    /**
     * SQLite requires a non-empty `GROUP BY` clause before the `HAVING` clause.
     */
    export type HavingDelegate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = ((columns: ColumnRefUtil.TryFlatten<HavingClauseUtil.AllowedColumnRef<FromClauseT>>) => (AllowedHavingClause<FromClauseT, GroupByClauseT> & GroupByClauseUtil.AssertNonEmpty<GroupByClauseT>));
}
declare module "having-clause/index" {
    export * from "having-clause/having-clause";
    export * from "having-clause/having-delegate";
    import * as HavingClauseUtil from "having-clause/util/index";
    export { HavingClauseUtil, };
}
declare module "sort-direction/sort-direction" {
    /**
     * The direction to sort the result set
     */
    export namespace SortDirection {
        /**
         * Sorts the result set in ascending order
         */
        const ASC = "ASC";
        type ASC = typeof ASC;
        /**
         * Sorts the result set in descending order
         */
        const DESC = "DESC";
        type DESC = typeof DESC;
    }
    export type SortDirection = (typeof SortDirection.ASC | typeof SortDirection.DESC);
}
declare module "sort-direction/util/predicate/is-sort-direction" {
    import { SortDirection } from "sort-direction/sort-direction";
    export function isSortDirection(mixed: unknown): mixed is SortDirection;
}
declare module "sort-direction/util/predicate/index" {
    export * from "sort-direction/util/predicate/is-sort-direction";
}
declare module "sort-direction/util/index" {
    export * from "sort-direction/util/predicate/index";
}
declare module "sort-direction/index" {
    export * from "sort-direction/sort-direction";
    import * as SortDirectionUtil from "sort-direction/util/index";
    export { SortDirectionUtil, };
}
declare module "order/order" {
    import { IColumn } from "column/index";
    import { IExpr } from "expr/index";
    import { SortDirection } from "sort-direction/index";
    import { IExprSelectItem } from "expr-select-item/index";
    /**
     * These types are sortable.
     *
     * ```sql
     * ORDER BY
     *  myTable.myColumn ASC
     * ```
     *
     * -----
     *
     * ```sql
     * ORDER BY
     *  RAND() ASC
     * ```
     *
     * -----
     *
     * ```sql
     * SELECT
     *  myTable.myColumn + RAND() AS x
     * FROM
     *  myTable
     * ORDER BY
     *  x --This is an `IColumn` with `__isFromExprSelectItem` set to true
     * ```
     *
     * -----
     *
     * We allow sorting by `IExprSelectItem` out of convenience.
     * Internally, it just uses the `Expr` part of the `IExprSelectItem`
     * and discards the `alias`.
     */
    export type SortExpr = IColumn | IExpr | IExprSelectItem;
    /**
     * A 2-tuple that describes a sort order in MySQL.
     */
    export type Order = readonly [SortExpr, SortDirection];
    /**
     * This,
     *
     * ```sql
     * ORDER BY
     *  mySortExpr
     * ```
     *
     * is the same as,
     * ```sql
     * ORDER BY
     *  mySortExpr ASC
     * ```
     */
    export type RawOrder = SortExpr | Order;
}
declare module "order/util/predicate/is-order" {
    import { Order } from "order/order";
    /**
     * Checks,
     * + If it is an 2-tuple
     * + If the second element is a `SortDirection`
     *
     * Does not check,
     * + If the first element is a `SortExpr` (for run-time performance)
     *
     * @param mixed
     */
    export function isOrder(mixed: unknown): mixed is Order;
}
declare module "order/util/predicate/is-sort-expr" {
    import { SortExpr } from "order/order";
    export function isSortExpr(mixed: unknown): mixed is SortExpr;
}
declare module "order/util/predicate/index" {
    export * from "order/util/predicate/is-order";
    export * from "order/util/predicate/is-sort-expr";
}
declare module "order/util/constructor/from-raw-order" {
    import { RawOrder, SortExpr } from "order/order";
    import { SortDirection } from "sort-direction/index";
    export type FromRawOrder<RawOrderT extends RawOrder> = RawOrderT extends SortExpr ? [RawOrderT, SortDirection.ASC] : RawOrderT;
    export function fromRawOrder<RawOrderT extends RawOrder>(rawOrder: RawOrderT): (FromRawOrder<RawOrderT>);
}
declare module "order/util/constructor/index" {
    export * from "order/util/constructor/from-raw-order";
}
declare module "order/util/query/extract-sort-expr" {
    import { RawOrder, Order } from "order/order";
    export type ExtractSortExpr<RawOrderT extends RawOrder> = RawOrderT extends Order ? RawOrderT[0] : RawOrderT;
    export function extractSortExpr<RawOrderT extends RawOrder>(rawOrder: RawOrderT): (ExtractSortExpr<RawOrderT>);
}
declare module "order/util/query/index" {
    export * from "order/util/query/extract-sort-expr";
}
declare module "order/util/index" {
    export * from "order/util/constructor/index";
    export * from "order/util/predicate/index";
    export * from "order/util/query/index";
}
declare module "order/index" {
    export * from "order/order";
    import * as OrderUtil from "order/util/index";
    export { OrderUtil, };
}
declare module "order-by-clause/order-by-clause" {
    import { Order } from "order/index";
    /**
     * The `ORDER BY` clause of a query.
     *
     */
    export type OrderByClause = readonly Order[];
}
declare module "order-by-clause/util/query/allowed-non-aggregate-used-ref" {
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    import { GroupByClause } from "group-by-clause/index";
    export type AllowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectClauseT extends SelectClause | undefined> = ColumnRefUtil.Intersect<
    /**
     * We know these will never be aggregate expressions
     */
    ColumnRefUtil.ExtractColumnIdentifier<ColumnRefUtil.FromJoinArray<FromClauseT["currentJoins"] extends readonly IJoin[] ? FromClauseT["currentJoins"] : []>, GroupByClauseT[number]>, (SelectClauseT extends SelectClause ? 
    /**
     * May possibly contain aggregate expressions,
     * if they are `$aliased`
     *
     * Non-aggregate expressions are not supposed to reference aggregate expressions.
     * However, you shouldn't be able to create an expression that references an aggregate...
     * and not have it become an aggregate expression, itself.
     *
     * So, we can just let non-aggregate expressions reference aggregate expressions.
     *
     * However, the types might be cleaner if we remove aggregate expressions...
     *
     * @todo Consider removing all `isAggregate : true` and `isAggregate : boolean` expressions?
     * But keep `isAggregate : false` expressions!
     */
    ColumnRefUtil.FromSelectClause<SelectClauseT> : {})>;
    export type AllowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectClauseT extends SelectClause | undefined> = UsedRefUtil.FromColumnRef<AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT, SelectClauseT>>;
    export function allowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectClauseT extends SelectClause | undefined>(fromClause: FromClauseT, groupByClause: GroupByClauseT, selectClause: SelectClauseT): (AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT, SelectClauseT>);
    export function allowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectClauseT extends SelectClause | undefined>(fromClause: FromClauseT, groupByClause: GroupByClauseT, selectClause: SelectClauseT): (AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT, SelectClauseT>);
}
declare module "order-by-clause/util/query/allowed-used-ref" {
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    /**
     * They will change when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     *
     * @todo You should be able to `ORDER BY` columns in the `SELECT` clause
     * ```sql
     *  SELECT
     *      *,
     *      RAND() AS r
     *  FROM
     *      myTable
     *  ORDER BY
     *      r --This is valid
     * ```
     *
     * SQLite does not allow outer query columns to be referenced in the `ORDER BY` clause.
     * https://stackoverflow.com/questions/59982992/order-by-cannot-reference-outer-query-column
     */
    export type AllowedColumnRef<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined> = (ColumnRefUtil.Intersect<
    /**
     * We know these will never be aggregate expressions
     */
    ColumnRefUtil.FromJoinArray<FromClauseT["currentJoins"] extends readonly IJoin[] ? FromClauseT["currentJoins"] : []>, (SelectClauseT extends SelectClause ? 
    /**
     * May possibly contain aggregate expressions,
     * if they are `$aliased`
     */
    ColumnRefUtil.FromSelectClause<SelectClauseT> : {})>);
    /**
     * They change diverge when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    export type AllowedUsedRef<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined> = (UsedRefUtil.FromColumnRef<AllowedColumnRef<FromClauseT, SelectClauseT>>);
    /**
     * For now, this is basically the same as `HavingClauseUtil.AllowedColumnRef<>`.
     *
     * They will diverge when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    export function allowedColumnRef<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined>(fromClause: FromClauseT, selectClause: SelectClauseT): (AllowedColumnRef<FromClauseT, SelectClauseT>);
    /**
     * For now, this is basically the same as `HavingClauseUtil.AllowedUsedRef<>`.
     *
     * They will diverge when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    export function allowedUsedRef<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined>(fromClause: FromClauseT, selectClause: SelectClauseT): (AllowedUsedRef<FromClauseT, SelectClauseT>);
}
declare module "order-by-clause/util/query/index" {
    export * from "order-by-clause/util/query/allowed-non-aggregate-used-ref";
    export * from "order-by-clause/util/query/allowed-used-ref";
}
declare module "order-by-clause/util/operation/order-by" {
    import { IFromClause } from "from-clause/index";
    import { OrderByDelegate } from "order-by-clause/order-by-delegate";
    import { OrderByClause } from "order-by-clause/order-by-clause";
    import { SelectClause } from "select-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    /**
     * Returns the MySQL equivalent of `...orderBy, orderByDelegate(columns)`
     *
     * This will change when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     *
     * -----
     *
     * @param fromClause
     * @param orderByClause
     * @param orderByDelegate
     */
    export function orderBy<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined>(fromClause: FromClauseT, groupByClause: GroupByClauseT, selectClause: SelectClauseT, orderByClause: OrderByClause | undefined, orderByDelegate: OrderByDelegate<FromClauseT, GroupByClauseT, SelectClauseT>): (OrderByClause);
}
declare module "order-by-clause/util/operation/index" {
    export * from "order-by-clause/util/operation/order-by";
}
declare module "order-by-clause/util/index" {
    export * from "order-by-clause/util/operation/index";
    export * from "order-by-clause/util/query/index";
}
declare module "order-by-clause/order-by-delegate" {
    /**
     * 1. `GROUP BY` clause exists?
     * 2. Non-aggregate expression used?
     * 3. Aggregate expression used?
     *
     * | 1 | 2 | 3 | Result
     * |---|---|---|--------
     * | Y | Y | Y | non-aggregate must use grouped columns
     * | Y | Y | N | non-aggregate must use grouped columns
     * | Y | N | Y | no problems
     * | Y | N | N | no problems
     * | N | Y | Y | compile error; use explicit group by
     * | N | Y | N | no problems
     * | N | N | Y | create empty grouping set
     * | N | N | N | no problems
     */
    import * as tm from "type-mapping";
    import { IFromClause } from "from-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { IExpr } from "expr/index";
    import { ColumnUtil } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { SortDirection } from "sort-direction/index";
    import * as OrderByClauseUtil from "order-by-clause/util/index";
    import { SelectClause } from "select-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    import { Identity } from "type-util/index";
    /**
     * No aggregate expressions allowed.
     *
     * @todo Move this to `util`?
     */
    type ValidSortExpr_WithoutGroupByClause<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined> = Identity<ColumnUtil.FromColumnRef<
    /**
     * This should technically exclude all aggregate expressions from
     * `SelectClauseT`.
     *
     * But this type should only be used if no aggregate expressions are used.
     * So, this is fine.
     */
    OrderByClauseUtil.AllowedColumnRef<FromClauseT, SelectClauseT>> | IExpr<{
        mapper: tm.SafeMapper<unknown>;
        /**
         * This should technically exclude all aggregate expressions from
         * `SelectClauseT`.
         *
         * But this type should only be used if no aggregate expressions are used.
         * So, this is fine.
         */
        usedRef: OrderByClauseUtil.AllowedUsedRef<FromClauseT, SelectClauseT>;
        isAggregate: false;
    }> | IExprSelectItem<{
        mapper: tm.SafeMapper<unknown>;
        /**
         * This should technically exclude all aggregate expressions from
         * `SelectClauseT`.
         *
         * But this type should only be used if no aggregate expressions are used.
         * So, this is fine.
         */
        usedRef: OrderByClauseUtil.AllowedUsedRef<FromClauseT, SelectClauseT>;
        isAggregate: false;
        /**
         * @todo Determine if passing an aliased column is OK
         */
        tableAlias: string;
        alias: string;
    }>>;
    /**
     * Aggregate expressions allowed.
     *
     * @todo Move this to `util`?
     */
    type ValidSortExpr_WithGroupByClause<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectClauseT extends SelectClause | undefined> = Identity<ColumnUtil.FromColumnRef<OrderByClauseUtil.AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT, SelectClauseT>> | IExpr<{
        mapper: tm.SafeMapper<unknown>;
        usedRef: OrderByClauseUtil.AllowedUsedRef<FromClauseT, SelectClauseT>;
        isAggregate: true;
    }> | IExprSelectItem<{
        mapper: tm.SafeMapper<unknown>;
        usedRef: OrderByClauseUtil.AllowedUsedRef<FromClauseT, SelectClauseT>;
        isAggregate: true;
        /**
         * @todo Determine if passing an aliased column is OK
         */
        tableAlias: string;
        alias: string;
    }>
    /**
     * If `isAggregate` is `false` or `boolean`, we treat it
     * as a non-aggregate expression.
     *
     * Non-aggregate expressions have more restrictions
     * on what can be referenced.
     */
     | IExpr<{
        mapper: tm.SafeMapper<unknown>;
        usedRef: OrderByClauseUtil.AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT, SelectClauseT>;
        isAggregate: boolean;
    }> | IExprSelectItem<{
        mapper: tm.SafeMapper<unknown>;
        usedRef: OrderByClauseUtil.AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT, SelectClauseT>;
        isAggregate: boolean;
        /**
         * @todo Determine if passing an aliased column is OK
         */
        tableAlias: string;
        alias: string;
    }>>;
    export type OrderByDelegateColumns<
    /**
     * @todo Debate if this should be changed to `FromClauseUtil.AfterFromClause`
     * It doesn't make much sense to use `ORDER BY` without a `FROM` clause.
     * Are you going to order one row?
     */
    FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined> = ColumnRefUtil.TryFlatten<OrderByClauseUtil.AllowedColumnRef<FromClauseT, SelectClauseT>>;
    export type OrderByDelegateReturnType<
    /**
     * @todo Debate if this should be changed to `FromClauseUtil.AfterFromClause`
     * It doesn't make much sense to use `ORDER BY` without a `FROM` clause.
     * Are you going to order one row?
     */
    FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined> = (GroupByClauseT extends GroupByClause ? readonly (ValidSortExpr_WithGroupByClause<FromClauseT, GroupByClauseT, SelectClauseT> | readonly [ValidSortExpr_WithGroupByClause<FromClauseT, GroupByClauseT, SelectClauseT>, SortDirection])[] : readonly (ValidSortExpr_WithoutGroupByClause<FromClauseT, SelectClauseT> | readonly [ValidSortExpr_WithoutGroupByClause<FromClauseT, SelectClauseT>, SortDirection])[]);
    /**
     * This will change when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    export type OrderByDelegate<
    /**
     * @todo Debate if this should be changed to `FromClauseUtil.AfterFromClause`
     * It doesn't make much sense to use `ORDER BY` without a `FROM` clause.
     * Are you going to order one row?
     */
    FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined> = ((columns: OrderByDelegateColumns<FromClauseT, SelectClauseT>) => OrderByDelegateReturnType<FromClauseT, GroupByClauseT, SelectClauseT>);
}
declare module "order-by-clause/index" {
    export * from "order-by-clause/order-by-clause";
    export * from "order-by-clause/order-by-delegate";
    import * as OrderByClauseUtil from "order-by-clause/util/index";
    export { OrderByClauseUtil, };
}
declare module "compound-query-order-by-clause/compound-query-order-by-clause" {
    import { SortDirection } from "sort-direction/index";
    import { IColumn } from "column/index";
    export type CompoundQueryOrder = readonly [IColumn, SortDirection];
    export type CompoundQueryOrderByClause = readonly CompoundQueryOrder[];
}
declare module "compound-query-order-by-clause/util/query/allowed-used-ref" {
    import { ColumnRefUtil } from "column-ref/index";
    import { SelectClause } from "select-clause/index";
    /**
     * https://www.postgresql.org/docs/8.3/queries-order.html
     *
     * > ORDER BY can be applied to the result of a UNION, INTERSECT, or EXCEPT combination, but in this case
     * > it is only permitted to sort by output column names or numbers, not by expressions.
     *
     * -----
     *
     * PostgreSQL does not allow ordering by expressions in the `COMPOUND QUERY ORDER BY` clause.
     * However, MySQL does.
     *
     * -----
     *
     * The workaround for PostgreSQL is to just...
     * Add the expressions you want to sort by in the `SELECT` clause.
     */
    export type AllowedColumnRef<SelectClauseT extends SelectClause> = ColumnRefUtil.FromSelectClause<SelectClauseT>;
    export function allowedColumnRef<SelectClauseT extends SelectClause>(selectClause: SelectClauseT): (AllowedColumnRef<SelectClauseT>);
}
declare module "compound-query-order-by-clause/util/query/index" {
    export * from "compound-query-order-by-clause/util/query/allowed-used-ref";
}
declare module "tuple-util/pop-front" {
    /**
     * Removes the first element of a tuple and returns the rest of the tuple.
     *
     * ```ts
     * //type Result = [1,2,3,4]
     * type Result = PopFront<[0,1,2,3,4]>
     * ```
     */
    export type PopFront<ArrT extends readonly any[]> = ((...arr: ArrT) => void) extends ((head: any, ...arr: infer ResultT) => void) ? ResultT : never;
}
declare module "tuple-util/push-front" {
    /**
     * Adds an element to the front of the tuple.
     *
     * ```ts
     * //type Result = [0,1,2,3,4]
     * type Result = PushFront<[1,2,3,4], 0>
     * ```
     */
    export type PushFront<ArrT extends readonly any[], ElementT> = ((element: ElementT, ...arr: ArrT) => void) extends ((...arr: infer ResultT) => void) ? ResultT : never;
}
declare module "tuple-util/trampoline-util" {
    export type MaxDepth = 8;
    type Countdown = [0, 0, 1, 2, 3, 4, 5, 6, 7];
    export type DecrementMaxDepth<MaxDepthT extends number> = Countdown[MaxDepthT];
}
declare module "tuple-util/reverse" {
    /**
     * This naive implementation works but will quickly give you a max-instantiation-depth error.
     *
     * ```ts
     *  type Reverse<ArrT extends any[], ResultT extends any[]=[]> =
     *      {
     *          //We cannot reverse a non-tuple.
     *          0 : ArrT,
     *          //We are done reversing the tuple.
     *          1 : ResultT,
     *          //We are **not** done reversing the tuple.
     *          //Keep computing recursively.
     *          2 : Reverse<
     *              PopFront<ArrT>,
     *                  PushFront<
     *                  ResultT,
     *                  ArrT[0]
     *              >
     *          >,
     *      }[
     *          number extends ArrT["length"] ?
     *          0 :
     *          ArrT["length"] extends 0 ?
     *          1 :
     *          2
     *      ]
     *  ;
     * ```
     *
     * The below implementation lets us pick an arbitrary depth limit.
     */
    import { PopFront } from "tuple-util/pop-front";
    import { PushFront } from "tuple-util/push-front";
    import { MaxDepth, DecrementMaxDepth } from "tuple-util/trampoline-util";
    /**
     * The state of our `Reverse<>` algorithm.
     */
    interface Reverse_State {
        /**
         * Are we done computing?
         */
        done: boolean;
        /**
         * The tuple to reverse.
         * Should be an empty tuple if we are `done`.
         */
        arr: readonly any[];
        /**
         * The result.
         * If we are not `done`, it will only contain a **partial** result.
         */
        result: readonly any[];
    }
    /**
     * Performs `8` iterations of our `Reverse<>` algorithm.
     * It looks a lot like our naive implementation.
     *
     * The difference is that we only do `8` recursive iterations (to prevent going over the max depth).
     * We also return a `Reverse_State`.
     */
    type Reverse_Bounce<ArrT extends readonly any[], ResultT extends readonly any[], MaxDepthT extends number = MaxDepth> = {
        0: {
            done: true;
            arr: ArrT;
            result: ArrT;
        };
        1: {
            done: true;
            arr: ArrT;
            result: ResultT;
        };
        /**
         * We ran out of `MaxDepthT` and haven't completed the computation.
         */
        2: {
            done: false;
            arr: PopFront<ArrT>;
            result: PushFront<ResultT, ArrT[0]>;
        };
        /**
         * Keep trying to compute the type.
         */
        3: Reverse_Bounce<PopFront<ArrT>, PushFront<ResultT, ArrT[0]>, DecrementMaxDepth<MaxDepthT>>;
    }[number extends ArrT["length"] ? 0 : ArrT["length"] extends 0 ? 1 : MaxDepthT extends 0 ? 2 : 3];
    /**
     * If we are `done`, we don't need to compute anything else.
     *
     * Performs up to `8` iterations of our `Reverse<>` algorithm.
     */
    type Reverse_Bounce1<StateT extends Reverse_State> = StateT["done"] extends true ? 
    /**
     * Reuse the `StateT` type.
     * Creating fewer unnecessary types is better.
     */
    StateT : 
    /**
     * Iterate.
     */
    Reverse_Bounce<StateT["arr"], StateT["result"]>;
    /**
     * Calls `Reverse_Bounce1<>` 8 times.
     *
     * Performs up to `8*8 = 64` iterations of our `Reverse<>` algorithm.
     */
    type Reverse_Bounce8<StateT extends Reverse_State> = Reverse_Bounce1<StateT> extends infer S0 ? (Reverse_Bounce1<Extract<S0, Reverse_State>> extends infer S1 ? (Reverse_Bounce1<Extract<S1, Reverse_State>> extends infer S2 ? (Reverse_Bounce1<Extract<S2, Reverse_State>> extends infer S3 ? (Reverse_Bounce1<Extract<S3, Reverse_State>> extends infer S4 ? (Reverse_Bounce1<Extract<S4, Reverse_State>> extends infer S5 ? (Reverse_Bounce1<Extract<S5, Reverse_State>> extends infer S6 ? (Reverse_Bounce1<Extract<S6, Reverse_State>> extends infer S7 ? (S7) : never) : never) : never) : never) : never) : never) : never) : never;
    /**
     * Calls `Reverse_Bounce8<>` 4 times.
     *
     * So, this supports reversing a tuple less than length `64*4 = 256`
     *
     * There is no real reason why the limit was set to `256`.
     * It could have easily been higher or lower.
     *
     * However, if you are reversing really large tuples while using this
     * library, you must either be writing **really** large SQL queries
     * or are doing something wrong.
     */
    type Reverse_Trampoline<ArrT extends readonly any[], ResultT extends readonly any[]> = Reverse_Bounce8<{
        done: false;
        arr: ArrT;
        result: ResultT;
    }> extends infer S0 ? (Reverse_Bounce8<Extract<S0, Reverse_State>> extends infer S1 ? (Reverse_Bounce8<Extract<S1, Reverse_State>> extends infer S2 ? (Reverse_Bounce8<Extract<S2, Reverse_State>> extends infer S3 ? (S3) : never) : never) : never) : never;
    /**
     * Reverses a tuple.
     *
     * ```ts
     * //type Result = [4,3,2,1,0]
     * type Result = Reverse<[0,1,2,3,4]>
     * ```
     *
     * This supports reversing a tuple less than length `64*4 = 256`
     *
     * There is no real reason why the limit was set to `256`.
     * It could have easily been higher or lower.
     *
     * However, if you are reversing really large tuples while using this
     * library, you must either be writing **really** large SQL queries
     * or are doing something wrong.
     */
    export type Reverse<ArrT extends readonly any[], ResultT extends readonly any[] = []> = Reverse_Trampoline<ArrT, ResultT> extends {
        done: infer DoneT;
        result: infer R;
    } ? (DoneT extends true ? R : never) : never;
}
declare module "tuple-util/concat" {
    /**
     * This naive implementation works.
     * @todo Debate implementation details.
     * Are there cases where this naive implementation fails?
     *
     * ```ts
     *  type Concat<ArrT extends any[], OtherT extends any[]> =
     *      Reverse<
     *          Reverse<ArrT>,
     *          OtherT
     *      >
     *  ;
     * ```
     */
    import { Reverse } from "tuple-util/reverse";
    /**
     * Concatenates two tuples.
     *
     * ```ts
     *  //type Result = [0,1,2,3,4,5,6,7,8,9]
     *  type Result = Concat<[0,1,2,3,4], [5,6,7,8,9]>
     * ```
     */
    export type Concat<ArrT extends readonly any[], OtherT extends readonly any[]> = Reverse<Reverse<ArrT>, OtherT>;
}
declare module "tuple-util/index" {
    export * from "tuple-util/concat";
    export * from "tuple-util/pop-front";
    export * from "tuple-util/push-front";
    export * from "tuple-util/reverse";
}
declare module "compound-query-order-by-clause/util/operation/compound-query-order-by" {
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryOrderByClause } from "compound-query-order-by-clause/compound-query-order-by-clause";
    import { CompoundQueryOrderByDelegate } from "compound-query-order-by-clause/compound-query-order-by-delegate";
    import { Concat } from "tuple-util/index";
    /**
     * This will probably never be used...
     */
    export type CompoundQueryOrderBy<CompoundQueryOrderByClauseT extends CompoundQueryOrderByClause | undefined, CompoundQueryOrderByT extends CompoundQueryOrderByClause> = CompoundQueryOrderByClauseT extends CompoundQueryOrderByClause ? Concat<CompoundQueryOrderByClauseT, CompoundQueryOrderByT> : CompoundQueryOrderByT;
    /**
     * Returns the MySQL equivalent of `...compoundQueryOrderByClause, ...compoundQueryOrderByDelegate(columns)`
     *
     * @param selectClause
     * @param compoundQueryOrderByClause
     * @param compoundQueryOrderByDelegate
     */
    export function compoundQueryOrderBy<
    /**
     * You can only `COMPOUND QUERY ORDER BY` names in the `SELECT` clause.
     * So, it only makes sense to use this after the `SELECT` clause.
     */
    SelectClauseT extends SelectClause>(selectClause: SelectClauseT, compoundQueryOrderByClause: CompoundQueryOrderByClause | undefined, compoundQueryOrderByDelegate: CompoundQueryOrderByDelegate<SelectClauseT>): (CompoundQueryOrderByClause);
}
declare module "compound-query-order-by-clause/util/operation/index" {
    export * from "compound-query-order-by-clause/util/operation/compound-query-order-by";
}
declare module "compound-query-order-by-clause/util/index" {
    export * from "compound-query-order-by-clause/util/operation/index";
    export * from "compound-query-order-by-clause/util/query/index";
}
declare module "compound-query-order-by-clause/compound-query-order-by-delegate" {
    import { SelectClause } from "select-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { ColumnUtil } from "column/index";
    import * as CompoundQueryOrderByClauseUtil from "compound-query-order-by-clause/util/index";
    import { SortDirection } from "sort-direction/index";
    /**
     * @todo Move this to `util`
     */
    type ValidUnionSortExpr<SelectClauseT extends SelectClause> = ColumnUtil.FromColumnRef<CompoundQueryOrderByClauseUtil.AllowedColumnRef<SelectClauseT>>;
    export type CompoundQueryOrderByDelegate<SelectClauseT extends SelectClause> = ((columns: ColumnRefUtil.TryFlatten<CompoundQueryOrderByClauseUtil.AllowedColumnRef<SelectClauseT>>) => (readonly (ValidUnionSortExpr<SelectClauseT> | readonly [ValidUnionSortExpr<SelectClauseT>, SortDirection])[]));
}
declare module "compound-query-order-by-clause/index" {
    export * from "compound-query-order-by-clause/compound-query-order-by-clause";
    export * from "compound-query-order-by-clause/compound-query-order-by-delegate";
    import * as CompoundQueryOrderByClauseUtil from "compound-query-order-by-clause/util/index";
    export { CompoundQueryOrderByClauseUtil, };
}
declare module "map-delegate/map-delegate" {
    import { IsolableSelectConnection } from "execution/index";
    /**
     * Maps fetched rows from one shape to another
     *
     * + `ReturnT` may be a `Promise`.
     * + A `MapDelegate` may be `async`.
     *
     * @param row - The row's current "shape";
     * may be different from the original row if chaining `MapDelegate`s
     * @param connection - The connection to the SQL server
     * @param originalRow - The original row fetched
     */
    export type MapDelegate<RowT = never, OriginalRowT = never, ReturnT = unknown> = (row: RowT, connection: IsolableSelectConnection, originalRow: OriginalRowT) => ReturnT;
}
declare module "map-delegate/util/operation/compose" {
    import { MapDelegate } from "map-delegate/map-delegate";
    import { TypeOfAwait } from "type-util/index";
    export type Compose<OriginalRowT, NxtReturnT> = MapDelegate<OriginalRowT, OriginalRowT, Promise<TypeOfAwait<NxtReturnT>>>;
    export function compose<OriginalRowT, ReturnT, NxtReturnT>(cur: MapDelegate<OriginalRowT, OriginalRowT, ReturnT>, nxt: MapDelegate<TypeOfAwait<ReturnT>, OriginalRowT, NxtReturnT>): (Compose<OriginalRowT, NxtReturnT>);
}
declare module "map-delegate/util/operation/index" {
    export * from "map-delegate/util/operation/compose";
}
declare module "map-delegate/util/index" {
    export * from "map-delegate/util/operation/index";
}
declare module "map-delegate/index" {
    export * from "map-delegate/map-delegate";
    import * as MapDelegateUtil from "map-delegate/util/index";
    export { MapDelegateUtil, };
}
declare module "query-base/query-base" {
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { WhereClause } from "where-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    import { HavingClause } from "having-clause/index";
    import { OrderByClause } from "order-by-clause/index";
    import { CompoundQueryOrderByClause } from "compound-query-order-by-clause/index";
    import { MapDelegate } from "map-delegate/index";
    export interface QueryBaseData {
        readonly fromClause: IFromClause;
        readonly selectClause: SelectClause | undefined;
        readonly limitClause: LimitClause | undefined;
        readonly compoundQueryClause: CompoundQueryClause | undefined;
        readonly compoundQueryLimitClause: LimitClause | undefined;
        readonly mapDelegate: MapDelegate | undefined;
        /**
         * When a `HAVING` clause exists without a `GROUP BY` clause,
         * it is usually an error.
         *
         * When SQL-fying, we should treat a missing `GROUP BY` clause as an `<empty grouping set>`.
         *
         * -----
         *
         * + PostgreSQL 10.0    : `GROUP BY ()` (SQL 1999)
         * + PostgreSQL  9.4    : `GROUP BY NULL || NULL` (Apply string concatenation on two `NULL` values to get `NULL`)
         * + MySQL       8.0    : `GROUP BY NULL`
         * + MySQL       5.7    : `GROUP BY NULL`
         * + SQLite      3.28   : `GROUP BY NULL`
         *
         * https://blog.jooq.org/2018/05/25/how-to-group-by-nothing-in-sql/
         */
        readonly groupByClause: GroupByClause | undefined;
    }
    /**
     * All database-specific libraries should implement this interface.
     */
    export interface IQueryBase<DataT extends QueryBaseData = QueryBaseData> {
        readonly fromClause: DataT["fromClause"];
        readonly selectClause: DataT["selectClause"];
        readonly limitClause: DataT["limitClause"];
        readonly compoundQueryClause: DataT["compoundQueryClause"];
        /**
         * In MySQL 5.7, a `COMPOUND QUERY LIMIT` clause without a `COMPOUND QUERY` clause
         * **overwrites** the `LIMIT` clause.
         *
         * In PostgreSQL 9.4, it is an error.
         *
         * In SQLite 3.28, it is an error.
         *
         * However, for this library, the generated SQL
         * for PostgreSQL and SQLite will emulate MySQL's behaviour.
         */
        readonly compoundQueryLimitClause: DataT["compoundQueryLimitClause"];
        /**
         * A `MapDelegate` lets you transform each row of the result set
         * before it is returned.
         *
         * ```ts
         *  const resultSet : (
         *      {
         *          x : number
         *      }[]
         *  ) = await myQuery
         *      .select(columns => [
         *          columns.myTable.myColumn0,
         *          columns.myTable.myColumn1,
         *          columns.myTable.myColumn2,
         *      ])
         *      .map((row) => {
         *          return {
         *              x : row.myTable.myColumn0 + row.myTable.myColumn1 + row.myTable.myColumn2,
         *          };
         *      })
         *      .fetchAll(connection);
         * ```
         */
        readonly mapDelegate: DataT["mapDelegate"];
        readonly groupByClause: DataT["groupByClause"];
        readonly whereClause: WhereClause | undefined;
        readonly havingClause: HavingClause | undefined;
        readonly orderByClause: OrderByClause | undefined;
        readonly compoundQueryOrderByClause: CompoundQueryOrderByClause | undefined;
        /**
         * Should default to `false`.
         *
         * Affects the `SELECT` clause.
         * ```sql
         * -- isDistinct : false
         * SELECT ...
         * ```
         *
         * ```sql
         * -- isDistinct : true
         * SELECT DISTINCT ...
         * ```
         *
         * @todo Should this be part of the `SelectClause` type instead?
         */
        readonly isDistinct: boolean;
    }
}
declare module "query-base/util/helper-type/after-compound-query-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface AfterCompoundQueryClause extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/after-from-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface AfterFromClause extends IQueryBase<{
        fromClause: FromClauseUtil.AfterFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/after-group-by-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface AfterGroupByClause extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause;
    }> {
    }
}
declare module "query-base/util/helper-type/after-select-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface AfterSelectClause extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/before-from-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface BeforeFromClauseData {
        fromClause: FromClauseUtil.BeforeFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }
    export interface BeforeFromClause extends IQueryBase<BeforeFromClauseData> {
    }
}
declare module "query-base/util/helper-type/before-select-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface BeforeSelectClause extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/before-compound-query-clause" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface BeforeCompoundQueryClauseData {
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }
    export interface BeforeCompoundQueryClause extends IQueryBase<BeforeCompoundQueryClauseData> {
    }
}
declare module "query-base/util/helper-type/correlated" {
    import { IQueryBase } from "query-base/query-base";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    /**
     * A correlated subquery is a subquery that contains a reference to a table that also appears in the outer query.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html
     */
    export interface Correlated extends IQueryBase<{
        fromClause: FromClauseUtil.Correlated;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/mapped" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface Mapped extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/non-correlated" {
    import { IQueryBase } from "query-base/query-base";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface NonCorrelatedData {
        fromClause: FromClauseUtil.NonCorrelated;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }
    /**
     * The opposite of a correlated subquery.
     *
     * -----
     *
     * A correlated subquery is a subquery that contains a reference to a table that also appears in the outer query.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html
     */
    export interface NonCorrelated extends IQueryBase<NonCorrelatedData> {
    }
}
declare module "query-base/util/helper-type/one-row" {
    import { IQueryBase } from "query-base/query-base";
    import { FromClauseUtil, IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface OneRowBeforeFromClause extends IQueryBase<{
        /**
         * No `FROM` clause allowed.
         */
        fromClause: FromClauseUtil.BeforeFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        /**
         * No compound queries allowed
         */
        compoundQueryClause: undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
    export interface OneRowEmptyGroupingSet extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        /**
         * No compound queries allowed
         */
        compoundQueryClause: undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        /**
         * Empty grouping set
         */
        groupByClause: readonly never[];
    }> {
    }
    /**
     * To guarantee a query returns one row only,
     * you cannot have a `FROM` clause or `COMPOUND QUERY` clause.
     *
     * Either that, or you must have `GROUP BY ()` and no `COMPOUND QUERY` clause.
     */
    export type OneRow = OneRowBeforeFromClause | OneRowEmptyGroupingSet;
}
declare module "query-base/util/helper-type/one-select-item" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { AnonymousSingleValueSelectItem } from "select-item/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    /**
     * @todo Rename to `ScalarQuery`?
     * The SQL standard seems to use that name.
     *
     * The number of names in the `SELECT` clause is called the **degree** of the query.
     * A scalar query has a degree of **one**.
     */
    export interface OneSelectItem<TypeT> extends IQueryBase<{
        fromClause: IFromClause;
        /**
         * A 1-tuple containing a single-value select item
         */
        selectClause: readonly [AnonymousSingleValueSelectItem<TypeT>];
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/unmapped" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface UnmappedData {
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        compoundQueryLimitClause: LimitClause | undefined;
        mapDelegate: undefined;
        groupByClause: GroupByClause | undefined;
    }
    export interface Unmapped extends IQueryBase<UnmappedData> {
    }
}
declare module "query-base/util/helper-type/zero-or-one-row-using-limit" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface ZeroOrOneRowUsingLimit extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: {
            readonly maxRowCount: 0n | 1n;
            readonly offset: bigint;
        };
        /**
         * `COMPOUND QUERY` clause not allowed
         */
        compoundQueryClause: undefined;
        compoundQueryLimitClause: undefined;
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/zero-or-one-row-using-compound-query-limit" {
    import { IQueryBase } from "query-base/query-base";
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { CompoundQueryClause } from "compound-query-clause/index";
    import { LimitClause } from "limit-clause/index";
    import { MapDelegate } from "map-delegate/index";
    import { GroupByClause } from "group-by-clause/index";
    export interface ZeroOrOneRowUsingCompoundQueryLimit extends IQueryBase<{
        fromClause: IFromClause;
        selectClause: SelectClause | undefined;
        limitClause: LimitClause | undefined;
        compoundQueryClause: CompoundQueryClause | undefined;
        /**
         * If `LIMIT` occurs within a subquery and also is applied in the outer query,
         * the outermost `LIMIT` takes precedence.
         *
         * https://dev.mysql.com/doc/refman/8.0/en/select.html
         */
        compoundQueryLimitClause: {
            readonly maxRowCount: 0n | 1n;
            readonly offset: bigint;
        };
        mapDelegate: MapDelegate | undefined;
        groupByClause: GroupByClause | undefined;
    }> {
    }
}
declare module "query-base/util/helper-type/zero-or-one-row" {
    import { OneRow } from "query-base/util/helper-type/one-row";
    import { ZeroOrOneRowUsingLimit } from "query-base/util/helper-type/zero-or-one-row-using-limit";
    import { ZeroOrOneRowUsingCompoundQueryLimit } from "query-base/util/helper-type/zero-or-one-row-using-compound-query-limit";
    export type ZeroOrOneRow = (OneRow | ZeroOrOneRowUsingLimit | ZeroOrOneRowUsingCompoundQueryLimit);
}
declare module "query-base/util/helper-type/index" {
    export * from "query-base/util/helper-type/after-compound-query-clause";
    export * from "query-base/util/helper-type/after-from-clause";
    export * from "query-base/util/helper-type/after-group-by-clause";
    export * from "query-base/util/helper-type/after-select-clause";
    export * from "query-base/util/helper-type/before-from-clause";
    export * from "query-base/util/helper-type/before-select-clause";
    export * from "query-base/util/helper-type/before-compound-query-clause";
    export * from "query-base/util/helper-type/correlated";
    export * from "query-base/util/helper-type/mapped";
    export * from "query-base/util/helper-type/non-correlated";
    export * from "query-base/util/helper-type/one-row";
    export * from "query-base/util/helper-type/one-select-item";
    export * from "query-base/util/helper-type/unmapped";
    export * from "query-base/util/helper-type/zero-or-one-row-using-limit";
    export * from "query-base/util/helper-type/zero-or-one-row-using-compound-query-limit";
    export * from "query-base/util/helper-type/zero-or-one-row";
}
declare module "derived-table/util/operation/lateral" {
    import { AliasedTableData } from "aliased-table/index";
    import { DerivedTable } from "derived-table/derived-table-impl";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LateralImpl<TableAliasT extends AliasedTableData["alias"], ColumnsT extends AliasedTableData["columns"], UsedRefT extends AliasedTableData["usedRef"]> = (DerivedTable<{
        isLateral: true;
        alias: TableAliasT;
        columns: ColumnsT;
        usedRef: UsedRefT;
    }>);
    export type Lateral<DerivedTableT extends DerivedTable<AliasedTableData>> = (LateralImpl<DerivedTableT["alias"], DerivedTableT["columns"], DerivedTableT["usedRef"]>);
    /**
     * Makes a derived table a `LATERAL` derived table.
     *
     * -----
     *
     * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      (
     *          SELECT
     *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * However, a `LATERAL` derived table can,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      LATERAL (
     *          SELECT
     *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * Note:
     * + Not supported in MySQL 5.7
     * + Supported as of MySQL 8.0.14
     */
    export function lateral<DerivedTableT extends DerivedTable<AliasedTableData>>(derivedTable: DerivedTableT): (Lateral<DerivedTableT>);
}
declare module "derived-table/util/operation/index" {
    export * from "derived-table/util/operation/lateral";
}
declare module "derived-table/util/index" {
    export * from "derived-table/util/operation/index";
}
declare module "derived-table/derived-table-impl" {
    import { AliasedTableData, IAliasedTable } from "aliased-table/index";
    import { Ast } from "ast/index";
    import * as DerivedTableUtil from "derived-table/util/index";
    /**
     * A query can be aliased,
     *
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * CROSS JOIN
     *  (
     *      SELECT
     *          RAND() AS randomNumber,
     *          UTC_TIMESTAMP() AS timeNow
     *  ) AS tmpTable --This is a `DerivedTable`
     * ```
     *
     */
    export class DerivedTable<DataT extends AliasedTableData> implements IAliasedTable<DataT> {
        readonly isLateral: DataT["isLateral"];
        readonly alias: DataT["alias"];
        readonly columns: DataT["columns"];
        readonly usedRef: DataT["usedRef"];
        readonly unaliasedAst: Ast;
        constructor(data: DataT, unaliasedAst: Ast);
        /**
         * Makes a derived table a `LATERAL` derived table.
         *
         * -----
         *
         * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable
         *  CROSS JOIN
         *      (
         *          SELECT
         *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
         *              myTable.x + otherTable.y AS z
         *          FROM
         *              otherTable
         *      ) AS tmpTable
         * ```
         *
         * However, a `LATERAL` derived table can,
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable
         *  CROSS JOIN
         *      LATERAL (
         *          SELECT
         *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
         *              myTable.x + otherTable.y AS z
         *          FROM
         *              otherTable
         *      ) AS tmpTable
         * ```
         *
         * Note:
         * + Not supported in MySQL 5.7
         * + Supported as of MySQL 8.0.14
         */
        lateral(): DerivedTableUtil.Lateral<this>;
    }
}
declare module "derived-table/index" {
    export * from "derived-table/derived-table-impl";
    import * as DerivedTableUtil from "derived-table/util/index";
    export { DerivedTableUtil, };
}
declare module "query-base/util/query/type-of" {
    import { OneSelectItem, ZeroOrOneRow, OneRow } from "query-base/util/helper-type/index";
    import { SelectItemUtil } from "select-item/index";
    /**
     * The type of the select item in the query.
     *
     * @todo Better name
     */
    export type TypeOfSelectItem<QueryT extends OneSelectItem<unknown>> = SelectItemUtil.TypeOf<QueryT["selectClause"][0]>;
    /**
     * The type of the **entire** query, when used as an expression.
     */
    export type TypeOf<QueryT extends OneSelectItem<unknown> & ZeroOrOneRow> = (QueryT extends OneRow ? TypeOfSelectItem<QueryT> : null | TypeOfSelectItem<QueryT>);
}
declare module "query-base/util/predicate/is-query" {
    import { IQueryBase } from "query-base/query-base";
    /**
     * Only checks that the properties exist.
     * Does not actually check that they are the right data type!
     *
     * @todo Consider adding checks for increased type safety.
     */
    export function isQuery(x: unknown): x is IQueryBase;
}
declare module "query-base/util/predicate/is-after-from-clause" {
    import { AfterFromClause } from "query-base/util/helper-type/index";
    export function isAfterFromClause(x: unknown): x is AfterFromClause;
}
declare module "query-base/util/predicate/is-after-select-clause" {
    import { AfterSelectClause } from "query-base/util/helper-type/index";
    export function isAfterSelectClause(x: unknown): x is AfterSelectClause;
}
declare module "query-base/util/predicate/is-before-compound-query-clause" {
    import { BeforeCompoundQueryClause } from "query-base/util/helper-type/index";
    export function isBeforeCompoundQueryClause(x: unknown): x is BeforeCompoundQueryClause;
}
declare module "query-base/util/predicate/is-before-select-clause" {
    import { BeforeSelectClause } from "query-base/util/helper-type/index";
    export function isBeforeSelectClause(x: unknown): x is BeforeSelectClause;
}
declare module "query-base/util/predicate/is-one-row" {
    import { OneRow } from "query-base/util/helper-type/index";
    export function isOneRow(x: unknown): x is OneRow;
}
declare module "query-base/util/predicate/is-one-select-item" {
    import { OneSelectItem } from "query-base/util/helper-type/index";
    export function isOneSelectItem(x: unknown): x is OneSelectItem<unknown>;
}
declare module "query-base/util/predicate/is-zero-or-one-row-using-limit" {
    import { ZeroOrOneRowUsingLimit } from "query-base/util/helper-type/index";
    export function isZeroOrOneRowUsingLimit(x: unknown): x is ZeroOrOneRowUsingLimit;
}
declare module "query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit" {
    import { ZeroOrOneRowUsingCompoundQueryLimit } from "query-base/util/helper-type/index";
    export function isZeroOrOneRowUsingCompoundQueryLimit(x: unknown): x is ZeroOrOneRowUsingCompoundQueryLimit;
}
declare module "query-base/util/predicate/is-zero-or-one-row" {
    import { ZeroOrOneRow } from "query-base/util/helper-type/index";
    export function isZeroOrOneRow(x: unknown): x is ZeroOrOneRow;
}
declare module "query-base/util/predicate/index" {
    export * from "query-base/util/predicate/is-after-from-clause";
    export * from "query-base/util/predicate/is-after-select-clause";
    export * from "query-base/util/predicate/is-before-compound-query-clause";
    export * from "query-base/util/predicate/is-before-select-clause";
    export * from "query-base/util/predicate/is-one-row";
    export * from "query-base/util/predicate/is-one-select-item";
    export * from "query-base/util/predicate/is-query";
    export * from "query-base/util/predicate/is-zero-or-one-row-using-limit";
    export * from "query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit";
    export * from "query-base/util/predicate/is-zero-or-one-row";
}
declare module "query-base/util/query/mapper" {
    import * as tm from "type-mapping";
    import { OneSelectItem, ZeroOrOneRow } from "query-base/util/helper-type/index";
    import { TypeOf } from "query-base/util/query/type-of";
    export type Mapper<QueryT extends OneSelectItem<unknown> & ZeroOrOneRow> = (tm.SafeMapper<TypeOf<QueryT>>);
    export function mapper<QueryT extends OneSelectItem<unknown> & ZeroOrOneRow>(query: QueryT): (Mapper<QueryT>);
}
declare module "query-base/util/query/index" {
    export * from "query-base/util/query/mapper";
    export * from "query-base/util/query/type-of";
}
declare module "constants" {
    /**
     * This string value `$aliased` was picked
     * as it is unlikely to be part of an identifier
     * in a database.
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  RAND() AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  RAND() AS `$aliased--r`
     * ```
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
     * ```
     *
     * @todo Make this a reserved `tableAlias`
     * No `ITable/IAliasedTable` should be able to have
     * a `tableAlias` value of `typeof ALIASED`.
     *
     * If such a thing were to happen,
     * it would make enforcing safe interactions between
     * `SELECT` and `FROM` clause very difficult/troublesome.
     *
     * But... What's the probability of someone using `$aliased`
     * as a table name?
     */
    export const ALIASED = "$aliased";
    /**
     * This string value `--` was picked
     * as it is unlikely to be part of an identifier
     * in a database.
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  RAND() AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  RAND() AS `$aliased--r`
     * ```
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
     * ```
     */
    export const SEPARATOR = "--";
}
declare module "derived-table-select-item/derived-table-select-item-impl" {
    import { AliasedTableData, IAliasedTable } from "aliased-table/index";
    import { IExprSelectItem, ExprSelectItemData } from "expr-select-item/index";
    import { Ast } from "ast/index";
    import { DerivedTableUtil } from "derived-table/index";
    import { ExprUtil, IExpr, ExprData } from "expr/index";
    import { SortDirection } from "sort-direction/index";
    /**
     * Meant to be a combination of `DerivedTable` and `AliasedExpr`.
     */
    export class DerivedTableSelectItem<DataT extends AliasedTableData & ExprData & ExprSelectItemData> implements IAliasedTable<DataT>, IExpr<DataT>, IExprSelectItem<DataT> {
        readonly mapper: DataT["mapper"];
        readonly isLateral: DataT["isLateral"];
        readonly tableAlias: DataT["tableAlias"];
        readonly alias: DataT["alias"];
        readonly columns: DataT["columns"];
        readonly usedRef: DataT["usedRef"];
        readonly isAggregate: DataT["isAggregate"];
        readonly ast: Ast;
        readonly unaliasedAst: Ast;
        constructor(data: DataT, unaliasedAst: Ast);
        /**
         * For now, the moment you use the `LATERAL` modifier,
         * it can no longer be used as an expression or aliased expression.
         *
         * No real reason for this rule, just laziness.
         */
        lateral(): DerivedTableUtil.Lateral<this>;
        /**
         * For now, the moment you try to re-alias,
         * it can no longer be used as a derived table.
         *
         * No real reason for this rule, just laziness.
         *
         * -----
         *
         * If you are running into "max instantiation depth" errors,
         * consider adding explicit `TableExpr<>` type annotations.
         *
         * If that doesn't help,
         * consider using `ExprUtil.as()` instead.
         *
         * Also, consider reading this to understand my frustration,
         * https://github.com/microsoft/TypeScript/issues/29511
         *
         * @param alias
         */
        as<AliasT extends string>(alias: AliasT): ExprUtil.As<this, AliasT>;
        /**
         * ```sql
         * ORDER BY
         *  RAND() ASC
         * ```
         */
        asc(): ExprUtil.Asc<this>;
        /**
         * ```sql
         * ORDER BY
         *  RAND() DESC
         * ```
         */
        desc(): ExprUtil.Desc<this>;
        /**
         * ```sql
         * ORDER BY
         *  (myTable.myColumn IS NOT NULL) ASC,
         *  RAND() DESC
         * ```
         */
        sort(sortDirection: SortDirection): ExprUtil.Sort<this>;
    }
}
declare module "derived-table-select-item/index" {
    export * from "derived-table-select-item/derived-table-select-item-impl";
}
declare module "query-base/util/operation/as" {
    import { OneSelectItem, ZeroOrOneRow, AfterSelectClause } from "query-base/util/helper-type/index";
    import { DerivedTable } from "derived-table/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    import { ColumnMapUtil } from "column-map/index";
    import { Mapper } from "query-base/util/query/index";
    import { ALIASED } from "constants";
    import { DerivedTableSelectItem } from "derived-table-select-item/index";
    import { SelectClauseUtil } from "select-clause/index";
    import { CompileError } from "compile-error/index";
    export type As<QueryT extends AfterSelectClause, AliasT extends string> = QueryT extends (OneSelectItem<any> & ZeroOrOneRow) ? DerivedTableSelectItem<{
        mapper: Mapper<QueryT>;
        isLateral: false;
        tableAlias: typeof ALIASED;
        alias: AliasT;
        columns: ColumnMapUtil.FromSelectClause<QueryT["selectClause"], AliasT>;
        usedRef: UsedRefUtil.FromJoinArray<QueryT["fromClause"]["outerQueryJoins"] extends readonly IJoin[] ? QueryT["fromClause"]["outerQueryJoins"] : []>;
        isAggregate: false;
    }> : DerivedTable<{
        isLateral: false;
        alias: AliasT;
        columns: ColumnMapUtil.FromSelectClause<QueryT["selectClause"], AliasT>;
        usedRef: UsedRefUtil.FromJoinArray<QueryT["fromClause"]["outerQueryJoins"] extends readonly IJoin[] ? QueryT["fromClause"]["outerQueryJoins"] : []>;
    }>;
    export type AssertAliasable<QueryT extends AfterSelectClause> = SelectClauseUtil.DuplicateColumnAlias<QueryT["selectClause"]> extends never ? unknown : CompileError<["Cannot alias query with duplicate names in SELECT clause", SelectClauseUtil.DuplicateColumnAlias<QueryT["selectClause"]>]>;
    export function as<QueryT extends AfterSelectClause, AliasT extends string>(query: QueryT, alias: AliasT & AssertAliasable<QueryT>): (As<QueryT, AliasT>);
}
declare module "query-base/util/operation/coalesce" {
    import { AnySubqueryExpr, AnyBuiltInExpr } from "built-in-expr/index";
    import * as ExprLib from "expr-library/index";
    export type Coalesce<QueryT extends AnySubqueryExpr, DefaultValueT extends AnyBuiltInExpr> = ExprLib.CoalesceExpr<[QueryT, DefaultValueT]>;
    export function coalesce<QueryT extends AnySubqueryExpr, DefaultValueT extends AnyBuiltInExpr>(query: QueryT, defaultValue: DefaultValueT): (Coalesce<QueryT, DefaultValueT>);
}
declare module "query-base/util/operation/asc" {
    import { AnySubqueryExpr } from "built-in-expr/index";
    import { SortDirection } from "sort-direction/index";
    import { Coalesce } from "query-base/util/operation/coalesce";
    export type Asc<QueryT extends AnySubqueryExpr> = readonly [Coalesce<QueryT, null>, SortDirection.ASC];
    export function asc<QueryT extends AnySubqueryExpr>(query: QueryT): Asc<QueryT>;
}
declare module "query-base/util/operation/desc" {
    import { AnySubqueryExpr } from "built-in-expr/index";
    import { SortDirection } from "sort-direction/index";
    import { Coalesce } from "query-base/util/operation/coalesce";
    export type Desc<QueryT extends AnySubqueryExpr> = readonly [Coalesce<QueryT, null>, SortDirection.DESC];
    export function desc<QueryT extends AnySubqueryExpr>(query: QueryT): Desc<QueryT>;
}
declare module "query-base/util/operation/sort" {
    import { AnySubqueryExpr } from "built-in-expr/index";
    import { SortDirection } from "sort-direction/index";
    import { Coalesce } from "query-base/util/operation/coalesce";
    export type Sort<QueryT extends AnySubqueryExpr> = readonly [Coalesce<QueryT, null>, SortDirection];
    export function sort<QueryT extends AnySubqueryExpr>(query: QueryT, sortDirection: SortDirection): Sort<QueryT>;
}
declare module "query-base/util/operation/throw-if-null" {
    import { AnySubqueryExpr } from "built-in-expr/index";
    import * as ExprLib from "expr-library/index";
    export type ThrowIfNull<QueryT extends AnySubqueryExpr> = ExprLib.ThrowIfNullExpr<QueryT>;
    export function throwIfNull<QueryT extends AnySubqueryExpr>(query: QueryT): (ThrowIfNull<QueryT>);
}
declare module "query-base/util/operation/index" {
    export * from "query-base/util/operation/as";
    export * from "query-base/util/operation/asc";
    export * from "query-base/util/operation/coalesce";
    export * from "query-base/util/operation/desc";
    export * from "query-base/util/operation/sort";
    export * from "query-base/util/operation/throw-if-null";
}
declare module "query-base/util/index" {
    export * from "query-base/util/helper-type/index";
    export * from "query-base/util/operation/index";
    export * from "query-base/util/predicate/index";
    export * from "query-base/util/query/index";
}
declare module "query-base/index" {
    export * from "query-base/query-base";
    import * as QueryBaseUtil from "query-base/util/index";
    export { QueryBaseUtil, };
}
declare module "custom-expr/util/query/is-aggregate" {
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { IQueryBase } from "query-base/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    /**
     * Conditional types seem to reduce the amount of nesting allowed
     * before hitting the max instantiation depth.
     *
     * @todo Refactor this to not require conditional types?
     * Seems impossible.
     */
    export type IsAggregate<CustomExprT extends unknown> = CustomExprT extends AnyBuiltInExpr | IQueryBase ? BuiltInExprUtil.IsAggregate<CustomExprT> : false;
    export function isAggregate<CustomExprT extends unknown>(customExpr: CustomExprT): (IsAggregate<CustomExprT>);
}
declare module "custom-expr/util/query/type-of" {
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    export type TypeOf<CustomExprT extends unknown> = CustomExprT extends AnyBuiltInExpr ? BuiltInExprUtil.TypeOf<CustomExprT> : CustomExprT;
}
declare module "custom-expr/util/query/used-ref" {
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { IUsedRef } from "used-ref/index";
    import { IQueryBase } from "query-base/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    /**
     * Conditional types seem to reduce the amount of nesting allowed
     * before hitting the max instantiation depth.
     *
     * @todo Refactor this to not require conditional types?
     * Seems impossible.
     */
    export type UsedRef<CustomExprT extends unknown> = CustomExprT extends AnyBuiltInExpr | IQueryBase ? BuiltInExprUtil.UsedRef<CustomExprT> : IUsedRef<{}>;
    export function usedRef<CustomExprT extends unknown>(customExpr: CustomExprT): (UsedRef<CustomExprT>);
}
declare module "custom-expr/util/query/index" {
    export * from "custom-expr/util/query/is-aggregate";
    export * from "custom-expr/util/query/type-of";
    export * from "custom-expr/util/query/used-ref";
}
declare module "custom-expr/util/operation/map-non-correlated" {
    import * as tm from "type-mapping";
    import { IAnonymousColumn } from "column/index";
    import { CustomExpr_NonCorrelated } from "custom-expr/custom-expr";
    /**
     * If `value` is `AnyNonValueExpr`, we don't bother checking.
     * We can't really check, anyway.
     *
     * Else, we return `mapper(, value)`,
     * which will throw an error if `value` is invalid.
     */
    export function mapNonCorrelated<TypeT>(mapper: tm.SafeMapper<TypeT> | IAnonymousColumn<TypeT>, customExpr: CustomExpr_NonCorrelated<TypeT>): CustomExpr_NonCorrelated<TypeT>;
}
declare module "custom-expr/util/operation/index" {
    export * from "custom-expr/util/operation/map-non-correlated";
}
declare module "custom-expr/util/index" {
    export * from "custom-expr/util/operation/index";
    export * from "custom-expr/util/query/index";
}
declare module "custom-expr/index" {
    export * from "custom-expr/custom-expr";
    import * as CustomExprUtil from "custom-expr/util/index";
    export { CustomExprUtil, };
}
declare module "insert/insert-row" {
    import { ITable, TableUtil } from "table/index";
    import { BuiltInExpr_NonCorrelated, BuiltInExpr_NonCorrelatedOrUndefined } from "built-in-expr/index";
    import { CustomExpr_NonCorrelated, CustomExpr_NonCorrelatedOrUndefined } from "custom-expr/index";
    import { Key, KeyUtil } from "key/index";
    import { Identity } from "type-util/index";
    export type CustomInsertRowWithCandidateKey_NonUnion<TableT extends ITable, CandidateKeyT extends Key> = Identity<{
        readonly [columnAlias in Exclude<TableUtil.RequiredColumnAlias<TableT>, CandidateKeyT[number]>]: (CustomExpr_NonCorrelated<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.OptionalColumnAlias<TableT>, CandidateKeyT[number]>]?: (CustomExpr_NonCorrelatedOrUndefined<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    }
    /**
     * This Candidate key is required.
     */
     & {
        readonly [candidateKeyColumnAlias in CandidateKeyT[number]]: (CustomExpr_NonCorrelated<ReturnType<TableT["columns"][candidateKeyColumnAlias]["mapper"]>>);
    }>;
    export type CustomInsertRowWithCandidateKeyImpl<TableT extends ITable, CandidateKeyT extends Key> = CandidateKeyT extends Key ? (KeyUtil.IsSubKey<CandidateKeyT, TableUtil.InsertableColumnAlias<TableT>[]> extends true ? CustomInsertRowWithCandidateKey_NonUnion<TableT, CandidateKeyT> : never) : never;
    export type CustomInsertRowWithCandidateKey<TableT extends ITable> = CustomInsertRowWithCandidateKeyImpl<TableT, TableT["candidateKeys"][number]>;
    /**
     * This allows custom data types
     */
    export type CustomInsertRow<TableT extends ITable> = Identity<{
        readonly [columnAlias in TableUtil.RequiredColumnAlias<TableT>]: (CustomExpr_NonCorrelated<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in TableUtil.OptionalColumnAlias<TableT>]?: (CustomExpr_NonCorrelatedOrUndefined<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    }>;
    export type ValueInsertRow<TableT extends ITable> = Identity<{
        readonly [columnAlias in TableUtil.RequiredColumnAlias<TableT>]: (ReturnType<TableT["columns"][columnAlias]["mapper"]>);
    } & {
        readonly [columnAlias in TableUtil.OptionalColumnAlias<TableT>]?: (ReturnType<TableT["columns"][columnAlias]["mapper"]>);
    }>;
    /**
     * This **does not** allow custom data types
     */
    export type BuiltInInsertRow<TableT extends ITable> = Identity<{
        readonly [columnAlias in TableUtil.RequiredColumnAlias<TableT>]: (BuiltInExpr_NonCorrelated<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in TableUtil.OptionalColumnAlias<TableT>]?: (BuiltInExpr_NonCorrelatedOrUndefined<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    }>;
}
declare module "error/sql-error" {
    /**
     * Used to wrap and rethrow an `innerError`
     */
    export interface WrappedSqlErrorArgs {
        readonly sql: string | undefined;
        readonly innerError: unknown;
    }
    /**
     * Used when there is no `innerError` to wrap and throw
     */
    export interface MessageSqlErrorArgs {
        readonly message: string | undefined;
        readonly sql: string | undefined;
    }
    export type SqlErrorArgs = WrappedSqlErrorArgs | MessageSqlErrorArgs;
    /**
     * All errors in this library should extend this class.
     */
    export class SqlError extends Error {
        /**
         * The SQL string that caused this error.
         *
         * May be `undefined`.
         */
        readonly sql: string | undefined;
        /**
         * The error that caused this error to be thrown.
         * Generally comes from the database driver library.
         *
         * May be `undefined`, may be any throwable value.
         */
        readonly innerError: unknown;
        constructor(args: SqlErrorArgs);
    }
    export function isSqlError(mixed: unknown): mixed is SqlError;
}
declare module "error/clean-insert-row/missing-required-insert-column" {
    import { SqlError } from "error/sql-error";
    import { ITable } from "table/index";
    export interface MissingRequiredInsertColumnErrorArgs {
        readonly message: string;
        readonly table: ITable;
        readonly columnAlias: string;
    }
    export class MissingRequiredInsertColumnError extends SqlError {
        readonly table: ITable;
        readonly columnAlias: string;
        constructor(args: MissingRequiredInsertColumnErrorArgs);
    }
}
declare module "error/clean-insert-row/potential-null-in-required-insert-column" {
    import { SqlError } from "error/sql-error";
    import { ITable } from "table/index";
    export interface PotentialNullInRequiredInsertColumnErrorArgs {
        readonly message: string;
        readonly table: ITable;
        readonly columnAlias: string;
    }
    export class PotentialNullInRequiredInsertColumnError extends SqlError {
        readonly table: ITable;
        readonly columnAlias: string;
        constructor(args: PotentialNullInRequiredInsertColumnErrorArgs);
    }
}
declare module "error/clean-insert-row/index" {
    export * from "error/clean-insert-row/missing-required-insert-column";
    export * from "error/clean-insert-row/potential-null-in-required-insert-column";
}
declare module "error/execution/invalid-sql" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    /**
     * This error happens when the database is unable to parse the SQL string.
     *
     * + MySQL      : `ER_SYNTAX_ERROR`, `ER_PARSE_ERROR`
     * + PostgreSQL : `syntax error at`
     */
    export class InvalidSqlError extends SqlError {
        constructor(args: SqlErrorArgs);
    }
}
declare module "error/execution/row-not-found" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    export class RowNotFoundError extends SqlError {
        readonly sql: string;
        constructor(args: SqlErrorArgs & {
            readonly sql: string;
        });
    }
}
declare module "error/execution/too-many-rows-found" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    export class TooManyRowsFoundError extends SqlError {
        readonly sql: string;
        constructor(args: SqlErrorArgs & {
            readonly sql: string;
        });
    }
}
declare module "error/execution/index" {
    export * from "error/execution/invalid-sql";
    export * from "error/execution/row-not-found";
    export * from "error/execution/too-many-rows-found";
}
declare module "error/expr/cannot-count" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    export class CannotCountError extends SqlError {
        constructor(args: SqlErrorArgs);
    }
}
declare module "error/expr/data-out-of-range" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    /**
     * This error happens when you do something like,
     * + `MAX_BIGINT_SIGNED + 1`
     * + `MIN_BIGINT_SIGNED - 1`
     * + General overflow errors
     *
     * + MySQL      : `ER_DATA_OUT_OF_RANGE`
     * + PostgreSQL : `out of range`
     */
    export class DataOutOfRangeError extends SqlError {
        constructor(args: SqlErrorArgs);
    }
}
declare module "error/expr/divide-by-zero" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    /**
     * This error happens when you do something like,
     * + `1 / 0`
     * + `0 / 0`
     *
     * + MySQL      : -NA- (Returns `null`)
     * + PostgreSQL : `division by zero`
     */
    export class DivideByZeroError extends SqlError {
        constructor(args: SqlErrorArgs);
    }
}
declare module "error/expr/invalid-input" {
    import { SqlError, SqlErrorArgs } from "error/sql-error";
    /**
     * This error happens when you do something like,
     * + `'qwerty'::timestamp` (PostgreSQL)
     * + General input errors
     *
     * + MySQL      : `ER_INVALID_JSON_TEXT_IN_PARAM` (`CAST('qwerty' AS JSON)`), etc.
     * + PostgreSQL : `invalid input syntax for type`
     */
    export class InvalidInputError extends SqlError {
        constructor(args: SqlErrorArgs);
    }
}
declare module "error/expr/index" {
    export * from "error/expr/cannot-count";
    export * from "error/expr/data-out-of-range";
    export * from "error/expr/divide-by-zero";
    export * from "error/expr/invalid-input";
}
declare module "error/index" {
    export * from "error/clean-insert-row/index";
    export * from "error/execution/index";
    export * from "error/expr/index";
    export * from "error/sql-error";
}
declare module "insert/util/operation/clean-insert-column" {
    import { ITable } from "table/index";
    import { CustomInsertRow, BuiltInInsertRow } from "insert/insert-row";
    export function cleanInsertColumn<TableT extends ITable>(table: TableT, row: CustomInsertRow<TableT>, columnAlias: keyof CustomInsertRow<TableT>, required: true): BuiltInInsertRow<TableT>[keyof BuiltInInsertRow<TableT>];
    export function cleanInsertColumn<TableT extends ITable>(table: TableT, row: CustomInsertRow<TableT>, columnAlias: keyof CustomInsertRow<TableT>, required: false): BuiltInInsertRow<TableT>[keyof BuiltInInsertRow<TableT>] | undefined;
}
declare module "insert/util/operation/clean-insert-row" {
    import { ITable } from "table/index";
    import { CustomInsertRow, BuiltInInsertRow } from "insert/insert-row";
    /**
     * + Removes excess properties.
     * + Removes properties with value `undefined`.
     * + Checks required properties are there.
     */
    export function cleanInsertRow<TableT extends ITable>(table: TableT, row: CustomInsertRow<TableT>): BuiltInInsertRow<TableT>;
}
declare module "insert/util/operation/index" {
    export * from "insert/util/operation/clean-insert-column";
    export * from "insert/util/operation/clean-insert-row";
}
declare module "insert/util/index" {
    export * from "insert/util/operation/index";
}
declare module "insert/index" {
    export * from "insert/insert-row";
    import * as InsertUtil from "insert/util/index";
    export { InsertUtil, };
}
declare module "row/row" {
    import * as tm from "type-mapping";
    import { ITable } from "table/index";
    import { UnionToIntersection, Identity } from "type-util/index";
    /**
     * Represents a row of the table, when retrieved from the database.
     *
     * -----
     *
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `Row_Output/Input<U>` instead.
     *
     * -----
     *
     * Also assumes `TableT["columns"]` are not unions.
     * They really shouldn't be unions.
     * + Why does your table not have a definite set of columns?
     *   Is it Schrödinger's columns?
     */
    export type Row_NonUnion<TableT extends Pick<ITable, "columns">> = Identity<{
        readonly [columnAlias in keyof TableT["columns"]]: (tm.OutputOf<TableT["columns"][columnAlias]["mapper"]>);
    }>;
    /**
     * Represents a row of the table, when retrieved from the database.
     *
     * -----
     *
     * Works properly, even when `TableT` is a union.
     *
     * Will return a union of rows.
     * Meant for output/read/covariant positions.
     */
    export type Row_Output<TableT extends Pick<ITable, "columns">> = (TableT extends Pick<ITable, "columns"> ? Row_NonUnion<TableT> : never);
    /**
     * Represents a row of the table, when retrieved from the database.
     *
     * -----
     *
     * Works properly, even when `TableT` is a union.
     *
     * Will return an intersection of rows.
     * Meant for input/write/contravariant positions.
     */
    export type Row_Input<TableT extends Pick<ITable, "columns">> = (UnionToIntersection<Row_Output<TableT>>);
    /**
     * Represents a row of the table, when retrieved from the database.
     *
     * An alias of `Row_NonUnion<>` for convenience reasons.
     *
     * -----
     *
     * Assumes `TableT` is not a union.
     *
     * If it is a union, use `Row_Output/Input<U>` instead.
     */
    export type Row<TableT extends Pick<ITable, "columns">> = (Row_NonUnion<TableT>);
}
declare module "row/util/query/mapper" {
    import * as tm from "type-mapping";
    import { TableWithPrimaryKey } from "table/index";
    import { Row_Output } from "row/row";
    export type Mapper<TableT extends Pick<TableWithPrimaryKey, "columns">> = (tm.SafeMapper<Row_Output<TableT>>);
    export function mapper<TableT extends Pick<TableWithPrimaryKey, "columns">>(table: TableT): (Mapper<TableT>);
}
declare module "row/util/query/index" {
    export * from "row/util/query/mapper";
}
declare module "row/util/index" {
    export * from "row/util/query/index";
}
declare module "row/index" {
    export * from "row/row";
    import * as RowUtil from "row/util/index";
    export { RowUtil, };
}
declare module "event/insert-event" {
    import { InsertManyResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { CandidateKey_Output } from "candidate-key/index";
    import { Row_Output } from "row/index";
    import { IEventBase, EventBase } from "event/event-base";
    export interface IInsertEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        /**
         * Guaranteed to contain at least one row.
         */
        readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
        readonly insertResult: InsertManyResult;
        /**
         * If we can get the `candidateKey` from the `insertRow`, this will be set.
         * This is only possible if at least one candidate key is set using just
         * value expressions, on the `insertRow`.
         */
        readonly candidateKeys: readonly [undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>), ...(undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>))[]];
        /**
         * This may throw for a number of reasons,
         * + `candidateKey` is `undefined` (cannot be derived from `insertRow`)
         * + Row was updated to a different `candidateKey` value before initial fetch
         * + Connection released
         * + etc.
         *
         * First call to `getOrFetch()` fetches the row.
         * Subsequent calls return a cached copy of the row.
         */
        getOrFetch(index: number): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IInsertEvent<T>;
    }
    global {
        interface Array<T> {
            map<U>(this: [T, ...T[]], callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): [U, ...U[]];
            map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];
        }
        interface ReadonlyArray<T> {
            map<U>(this: readonly [T, ...T[]], callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): [U, ...U[]];
        }
    }
    export class InsertEvent<TableT extends ITable> extends EventBase implements IInsertEvent<TableT> {
        readonly table: TableT;
        /**
         * Guaranteed to contain at least one row.
         */
        readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
        readonly insertResult: InsertManyResult;
        private candidateKeysCache;
        readonly candidateKeys: readonly [undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>), ...(undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>))[]];
        private fetchPromises;
        getOrFetch(index: number): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
            readonly insertResult: InsertManyResult;
        });
        isFor<T extends ITable>(table: T): this is IInsertEvent<T>;
    }
}
declare module "event/insert-one-event" {
    import { InsertOneResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { CandidateKey_Output } from "candidate-key/index";
    import { Row_Output } from "row/index";
    import { IEventBase, EventBase } from "event/event-base";
    export interface IInsertOneEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly insertResult: InsertOneResult;
        /**
         * If we can get the `candidateKey` from the `insertRow`, this will be set.
         * This is only possible if at least one candidate key is set using just
         * value expressions, on the `insertRow`.
         */
        readonly candidateKey: undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>);
        /**
         * This may throw for a number of reasons,
         * + `candidateKey` is `undefined` (cannot be derived from `insertRow`)
         * + Row was updated to a different `candidateKey` value before initial fetch
         * + Connection released
         * + etc.
         *
         * First call to `getOrFetch()` fetches the row.
         * Subsequent calls return a cached copy of the row.
         */
        getOrFetch(): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IInsertOneEvent<T>;
    }
    export class InsertOneEvent<TableT extends ITable> extends EventBase implements IInsertOneEvent<TableT> {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly insertResult: InsertOneResult;
        private candidateKeyCache;
        readonly candidateKey: undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>);
        private fetchPromise;
        getOrFetch(): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly insertRow: BuiltInInsertRow<TableT>;
            readonly insertResult: InsertOneResult;
        });
        isFor<T extends ITable>(table: T): this is IInsertOneEvent<T>;
    }
}
declare module "event/insert-and-fetch-event" {
    import { InsertOneResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { Row_Output } from "row/index";
    import { IEventBase, EventBase } from "event/event-base";
    export interface IInsertAndFetchEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly insertResult: InsertOneResult;
        readonly fetchedRow: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IInsertAndFetchEvent<T>;
    }
    export class InsertAndFetchEvent<TableT extends ITable> extends EventBase implements IInsertAndFetchEvent<TableT> {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly insertResult: InsertOneResult;
        readonly fetchedRow: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly insertRow: BuiltInInsertRow<TableT>;
            readonly insertResult: InsertOneResult;
            readonly fetchedRow: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
        });
        isFor<T extends ITable>(table: T): this is IInsertAndFetchEvent<T>;
    }
}
declare module "event/replace-event" {
    import { ReplaceManyResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { CandidateKey_Output } from "candidate-key/index";
    import { Row_Output } from "row/index";
    import { IEventBase, EventBase } from "event/event-base";
    export interface IReplaceEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        /**
         * Guaranteed to contain at least one row.
         */
        readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
        readonly replaceResult: ReplaceManyResult;
        /**
         * If we can get the `candidateKey` from the `insertRow`, this will be set.
         * This is only possible if at least one candidate key is set using just
         * value expressions, on the `insertRow`.
         */
        readonly candidateKeys: readonly [undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>), ...(undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>))[]];
        /**
         * This may throw for a number of reasons,
         * + `candidateKey` is `undefined` (cannot be derived from `insertRow`)
         * + Row was updated to a different `candidateKey` value before initial fetch
         * + Connection released
         * + etc.
         *
         * First call to `getOrFetch()` fetches the row.
         * Subsequent calls return a cached copy of the row.
         */
        getOrFetch(index: number): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IReplaceEvent<T>;
    }
    global {
        interface Array<T> {
            map<U>(this: [T, ...T[]], callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): [U, ...U[]];
            map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];
        }
        interface ReadonlyArray<T> {
            map<U>(this: readonly [T, ...T[]], callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): [U, ...U[]];
        }
    }
    export class ReplaceEvent<TableT extends ITable> extends EventBase implements IReplaceEvent<TableT> {
        readonly table: TableT;
        /**
         * Guaranteed to contain at least one row.
         */
        readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
        readonly replaceResult: ReplaceManyResult;
        private candidateKeysCache;
        readonly candidateKeys: readonly [undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>), ...(undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>))[]];
        private fetchPromises;
        getOrFetch(index: number): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly insertRows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]];
            readonly replaceResult: ReplaceManyResult;
        });
        isFor<T extends ITable>(table: T): this is IReplaceEvent<T>;
    }
}
declare module "update/assignment-map" {
    import { ITable, TableUtil } from "table/index";
    import { BuiltInExpr_MapCorrelatedOrUndefined } from "built-in-expr/index";
    import { CustomExpr_MapCorrelatedOrUndefined } from "custom-expr/index";
    export type CustomAssignmentMap<TableT extends Pick<ITable, "columns" | "mutableColumns">> = {
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (CustomExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    };
    export type BuiltInAssignmentMap<TableT extends ITable> = {
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (BuiltInExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    };
}
declare module "update/assignment-map-delegate" {
    import { ITable } from "table/index";
    import { CustomAssignmentMap } from "update/assignment-map";
    import { Identity, AssertSubsetOwnEnumerableKeys } from "type-util/index";
    export type AssignmentMapDelegate<TableT extends Pick<ITable, "columns" | "mutableColumns">, AssignmentMapT extends CustomAssignmentMap<TableT>> = Identity<(columns: TableT["columns"]) => AssignmentMapT & AssertSubsetOwnEnumerableKeys<AssignmentMapT, CustomAssignmentMap<TableT>>>;
}
declare module "update/util/operation/clean-assignment-map" {
    import { ITable } from "table/index";
    import { CustomAssignmentMap, BuiltInAssignmentMap } from "update/assignment-map";
    export function cleanAssignmentMap<TableT extends ITable>(table: TableT, raw: CustomAssignmentMap<TableT>): BuiltInAssignmentMap<TableT>;
}
declare module "update/util/operation/set" {
    import { ITable } from "table/index";
    import { BuiltInAssignmentMap, CustomAssignmentMap } from "update/assignment-map";
    import { AssignmentMapDelegate } from "update/assignment-map-delegate";
    export function set<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): BuiltInAssignmentMap<TableT>;
}
declare module "update/util/operation/index" {
    export * from "update/util/operation/clean-assignment-map";
    export * from "update/util/operation/set";
}
declare module "update/util/index" {
    export * from "update/util/operation/index";
}
declare module "update/index" {
    export * from "update/assignment-map-delegate";
    export * from "update/assignment-map";
    import * as UpdateUtil from "update/util/index";
    export { UpdateUtil, };
}
declare module "event/update-event" {
    import { IConnection, UpdateResult } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInAssignmentMap } from "update/index";
    import { IEventBase, EventBase } from "event/event-base";
    import { WhereClause } from "where-clause/index";
    export interface IUpdateEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly whereClause: WhereClause;
        readonly assignmentMap: BuiltInAssignmentMap<TableT>;
        readonly updateResult: UpdateResult;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IUpdateEvent<T>;
    }
    export class UpdateEvent<TableT extends ITable> extends EventBase implements IUpdateEvent<TableT> {
        readonly table: TableT;
        readonly whereClause: WhereClause;
        readonly assignmentMap: BuiltInAssignmentMap<TableT>;
        readonly updateResult: UpdateResult;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly whereClause: WhereClause;
            readonly assignmentMap: BuiltInAssignmentMap<TableT>;
            readonly updateResult: UpdateResult;
        });
        isFor<T extends ITable>(table: T): this is IUpdateEvent<T>;
    }
}
declare module "execution/util/helper-type/fetch-all-connection" {
    import { QueryBaseUtil } from "query-base/index";
    import { MapDelegate } from "map-delegate/index";
    import { IsolableSelectConnection, SelectConnection } from "execution/connection/index";
    /**
     * The `IConnection` subtype to use for `fetchAll()`
     *
     * @todo Consider renaming this to something else.
     * Like `FetchConnection`
     */
    export type FetchAllConnection<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "mapDelegate">> = QueryT["mapDelegate"] extends MapDelegate ? IsolableSelectConnection : SelectConnection;
}
declare module "execution/util/helper-type/mapped-row" {
    import { BetterReturnType, TypeOfAwait } from "type-util/index";
    import { QueryBaseUtil } from "query-base/index";
    export type MappedRow<QueryT extends Pick<QueryBaseUtil.Mapped, "mapDelegate">> = TypeOfAwait<BetterReturnType<QueryT["mapDelegate"]>>;
}
declare module "type-ref/type-ref" {
    import { TypeMap } from "type-map/index";
    export interface TypeRef {
        readonly [tableAlias: string]: TypeMap;
    }
}
declare module "type-ref/util/constructor/from-column-array" {
    import { IColumn, ColumnUtil } from "column/index";
    import { TypeMapUtil } from "type-map/index";
    export type FromColumnArray<ColumnsT extends readonly IColumn[]> = ({
        readonly [tableAlias in ColumnsT[number]["tableAlias"]]: (TypeMapUtil.FromColumnArray<ColumnUtil.ExtractWithTableAlias<ColumnsT[number], tableAlias>[]>);
    });
}
declare module "type-ref/util/constructor/from-column-map" {
    import { ColumnUtil } from "column/index";
    import { ColumnMap } from "column-map/index";
    import { FromColumnArray } from "type-ref/util/constructor/from-column-array";
    export type FromColumnMap<MapT extends ColumnMap> = (FromColumnArray<ColumnUtil.FromColumnMap<MapT>[]>);
}
declare module "type-ref/util/constructor/from-column-ref" {
    import { ColumnRef } from "column-ref/index";
    import { TypeMapUtil } from "type-map/index";
    export type FromColumnRef<RefT extends ColumnRef> = (RefT extends ColumnRef ? {
        readonly [tableAlias in Extract<keyof RefT, string>]: (TypeMapUtil.FromColumnMap<RefT[tableAlias]>);
    } : never);
    export type WritableFromColumnRef<RefT extends ColumnRef> = (RefT extends ColumnRef ? {
        [tableAlias in Extract<keyof RefT, string>]: (TypeMapUtil.WritableFromColumnMap<RefT[tableAlias]>);
    } : never);
}
declare module "type-ref/util/constructor/from-column" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/index";
    export type FromColumn<ColumnT extends Pick<IColumn, "tableAlias" | "columnAlias" | "mapper">> = (ColumnT extends Pick<IColumn, "tableAlias" | "columnAlias" | "mapper"> ? {
        readonly [tableAlias in ColumnT["tableAlias"]]: ({
            readonly [columnAlias in ColumnT["columnAlias"]]: (tm.OutputOf<ColumnT["mapper"]>);
        });
    } : never);
}
declare module "type-ref/util/constructor/index" {
    export * from "type-ref/util/constructor/from-column-array";
    export * from "type-ref/util/constructor/from-column-map";
    export * from "type-ref/util/constructor/from-column-ref";
    export * from "type-ref/util/constructor/from-column";
}
declare module "type-ref/util/query/extract-excess-column-identifier" {
    import { TypeRef } from "type-ref/type-ref";
    export type ExtractExcessColumnIdentifier<A extends TypeRef, B extends TypeRef> = {
        [tableAlias in Extract<keyof A, string>]: ({
            [columnAlias in Extract<keyof A[tableAlias], string>]: (tableAlias extends keyof B ? (columnAlias extends keyof B[tableAlias] ? never : [tableAlias, columnAlias]) : [tableAlias, columnAlias]);
        }[Extract<keyof A[tableAlias], string>]);
    }[Extract<keyof A, string>];
}
declare module "type-ref/util/query/extract-type-map" {
    import { TypeRef } from "type-ref/type-ref";
    export type ExtractTypeMap<U extends TypeRef, TableAliasT extends string> = (U extends TypeRef ? (TableAliasT extends keyof U ? U[TableAliasT] : never) : never);
}
declare module "type-ref/util/query/extract-with-strict-sub-type" {
    import { TypeRef } from "type-ref/type-ref";
    /**
     * If the type of a column in `A` is a **strict** subtype of the same column in `B`,
     * it is returned.
     */
    export type ExtractWithStrictSubType<A extends TypeRef, B extends TypeRef> = {
        [tableAlias in Extract<keyof A, string>]: ({
            [columnAlias in Extract<keyof A[tableAlias], string>]: (tableAlias extends keyof B ? (columnAlias extends keyof B[tableAlias] ? (A[tableAlias][columnAlias] extends B[tableAlias][columnAlias] ? (B[tableAlias][columnAlias] extends A[tableAlias][columnAlias] ? never : [tableAlias, columnAlias, A[tableAlias][columnAlias], B[tableAlias][columnAlias]]) : never) : never) : never);
        }[Extract<keyof A[tableAlias], string>]);
    }[Extract<keyof A, string>];
}
declare module "type-ref/util/query/index" {
    export * from "type-ref/util/query/extract-excess-column-identifier";
    export * from "type-ref/util/query/extract-type-map";
    export * from "type-ref/util/query/extract-with-strict-sub-type";
}
declare module "type-ref/util/operator/intersect" {
    import { TypeRef } from "type-ref/type-ref";
    import { TypeMapUtil } from "type-map/index";
    import { ExtractTypeMap } from "type-ref/util/query/index";
    type K<U extends TypeRef> = (U extends TypeRef ? keyof U : never);
    /**
     * Assumes `U` is a union
     */
    export type Intersect<U extends TypeRef> = ({
        readonly [tableAlias in Extract<K<U>, string>]: (TypeMapUtil.Intersect<ExtractTypeMap<U, tableAlias>>);
    });
}
declare module "type-ref/util/operator/with-value" {
    import { TypeRef } from "type-ref/type-ref";
    import { TypeMapUtil } from "type-map/index";
    import { Identity } from "type-util/index";
    export type WithValue<RefT extends TypeRef, TableAliasT extends string, ColumnAliasT extends string, ValueT extends unknown> = Identity<{
        [tableAlias in Extract<keyof RefT, string>]: (TableAliasT extends tableAlias ? TypeMapUtil.WithValue<RefT[tableAlias], ColumnAliasT, ValueT> : RefT[tableAlias]);
    }>;
}
declare module "type-ref/util/operator/index" {
    export * from "type-ref/util/operator/intersect";
    export * from "type-ref/util/operator/with-value";
}
declare module "type-ref/util/index" {
    export * from "type-ref/util/constructor/index";
    export * from "type-ref/util/operator/index";
    export * from "type-ref/util/query/index";
}
declare module "type-ref/index" {
    export * from "type-ref/type-ref";
    import * as TypeRefUtil from "type-ref/util/index";
    export { TypeRefUtil, };
}
declare module "execution/util/helper-type/unmapped-row" {
    import { ColumnRefUtil } from "column-ref/index";
    import { TypeRefUtil, TypeRef } from "type-ref/index";
    import { IJoin, JoinArrayUtil } from "join/index";
    import { Merge } from "type-util/index";
    import { QueryBaseUtil } from "query-base/index";
    /**
     * Gives you a `TypeMap`, containing columns from the `TableAliasT`
     */
    type RowOfTable<RefT extends TypeRef, JoinsT extends readonly IJoin[], TableAliasT extends string> = Merge<{
        readonly [columnName in Extract<keyof RefT[TableAliasT], keyof JoinArrayUtil.ExtractWithTableAlias<JoinsT, TableAliasT>["columns"]>]: (ReturnType<JoinArrayUtil.ExtractWithTableAlias<JoinsT, TableAliasT>["columns"][columnName]["mapper"]>);
    } & {
        readonly [columnName in Exclude<keyof RefT[TableAliasT], keyof JoinArrayUtil.ExtractWithTableAlias<JoinsT, TableAliasT>["columns"]>]: (RefT[TableAliasT][columnName]);
    }>;
    /**
     * @todo Rename?
     */
    type ApplyNullableJoins<RefT extends TypeRef, JoinsT extends readonly IJoin[]> = Merge<{
        readonly [tableAlias in Extract<JoinArrayUtil.NonNullableTableAlias<JoinsT>, keyof RefT>]: (RowOfTable<RefT, JoinsT, tableAlias>);
    } & {
        readonly [tableAlias in Extract<JoinArrayUtil.NullableTableAlias<JoinsT>, keyof RefT>]?: (RowOfTable<RefT, JoinsT, tableAlias>);
    } & {
        readonly [tableAlias in Exclude<keyof RefT, JoinArrayUtil.TableAlias<JoinsT>>]: (RefT[tableAlias]);
    }>;
    export type UnmappedRow<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause">> = ApplyNullableJoins<TypeRefUtil.FromColumnRef<ColumnRefUtil.FromSelectClause<QueryT["selectClause"]>>, (QueryT["fromClause"]["currentJoins"] extends readonly IJoin[] ? QueryT["fromClause"]["currentJoins"] : [])>;
}
declare module "execution/util/predicate/can-flatten-unmapped-row" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectClauseUtil } from "select-clause/index";
    import { IJoin } from "join/index";
    /**
     * + Assumes `QueryT` is not a union.
     */
    export type CanFlattenUnmappedRow<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause">> = SelectClauseUtil.DuplicateColumnAlias<QueryT["selectClause"]> extends never ? (QueryT["fromClause"]["currentJoins"] extends readonly IJoin[] ? (true extends QueryT["fromClause"]["currentJoins"][number]["nullable"] ? 
    /**
     * Cannot flatten if we have `nullable` joins.
     * Flattening causes us to not know which tables were "nulled out".
     */
    false : 
    /**
     * No `nullable` joins, we can flatten safely
     */
    true) : 
    /**
     * No `nullable` joins, we can flatten safely
     */
    true) : 
    /**
     * Cannot flatten if we have duplicate `columnAlias`
     */
    false;
    export function canFlattenUnmappedRow<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause">>(query: QueryT): boolean;
}
declare module "execution/util/predicate/index" {
    export * from "execution/util/predicate/can-flatten-unmapped-row";
}
declare module "execution/util/helper-type/unmapped-flattened-row" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedRow } from "execution/util/helper-type/unmapped-row";
    import { TypeMapUtil } from "type-map/index";
    import { ColumnUtil } from "column/index";
    import { CanFlattenUnmappedRow } from "execution/util/predicate/index";
    /**
     * Contrary to its name, it does not actually flatten the row all the time.
     * If it can be flattened "safely", it will be flattened.
     *
     * Otherwise, it will not be flattened.
     */
    export type UnmappedFlattenedRow<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause">> = CanFlattenUnmappedRow<QueryT> extends true ? TypeMapUtil.FromColumnArray<ColumnUtil.FromSelectClause<QueryT["selectClause"]>[]> : UnmappedRow<QueryT>;
}
declare module "execution/util/helper-type/fetched-row" {
    import { QueryBaseUtil } from "query-base/index";
    import { MapDelegate } from "map-delegate/index";
    import { MappedRow } from "execution/util/helper-type/mapped-row";
    import { UnmappedFlattenedRow } from "execution/util/helper-type/unmapped-flattened-row";
    export type FetchedRow<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause" | "mapDelegate">> = QueryT["mapDelegate"] extends MapDelegate ? MappedRow<Extract<QueryT, QueryBaseUtil.Mapped>> : UnmappedFlattenedRow<QueryT>;
}
declare module "execution/util/helper-type/fetched-result-set" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchedRow } from "execution/util/helper-type/fetched-row";
    export type FetchedResultSet<QueryT extends Pick<QueryBaseUtil.AfterSelectClause, "selectClause" | "fromClause" | "mapDelegate">> = FetchedRow<QueryT>[];
}
declare module "execution/util/helper-type/raw-row" {
    /**
     * A row in the middle of processing.
     */
    export type RawRow = {
        [tableAlias: string]: (undefined | {
            [columnAlias: string]: unknown;
        });
    };
}
declare module "execution/util/helper-type/mapped-result-set" {
    import { QueryBaseUtil } from "query-base/index";
    import { MappedRow } from "execution/util/helper-type/mapped-row";
    export type MappedResultSet<QueryT extends Pick<QueryBaseUtil.Mapped, "mapDelegate">> = (MappedRow<QueryT>[]);
}
declare module "execution/util/helper-type/unmapped-flattened-result-set" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedFlattenedRow } from "execution/util/helper-type/unmapped-flattened-row";
    export type UnmappedFlattenedResultSet<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = (UnmappedFlattenedRow<QueryT>[]);
}
declare module "execution/util/helper-type/unmapped-result-set" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedRow } from "execution/util/helper-type/unmapped-row";
    export type UnmappedResultSet<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = (UnmappedRow<QueryT>[]);
}
declare module "execution/util/helper-type/index" {
    export * from "execution/util/helper-type/fetch-all-connection";
    export * from "execution/util/helper-type/fetched-result-set";
    export * from "execution/util/helper-type/fetched-row";
    export * from "execution/util/helper-type/raw-row";
    export * from "execution/util/helper-type/mapped-result-set";
    export * from "execution/util/helper-type/mapped-row";
    export * from "execution/util/helper-type/unmapped-flattened-result-set";
    export * from "execution/util/helper-type/unmapped-flattened-row";
    export * from "execution/util/helper-type/unmapped-result-set";
    export * from "execution/util/helper-type/unmapped-row";
}
declare module "execution/util/operation/paginate/paginate-args" {
    /**
     * Better to use `bigint`.
     *
     * `9223372036854775807n` cannot be represented using a `double`.
     *
     * It gets rounded to `9223372036854776000`
     */
    export interface RawPaginateArgs {
        /**
         * The page to fetch.
         * The first page is zero.
         */
        page?: number | bigint;
        /**
         * The number of rows to fetch per page.
         * You should control this value.
         *
         * If `rowsPerPage` is too high, and too many rows are fetched,
         * it may cause an out-of-memory exception!
         */
        rowsPerPage?: number | bigint;
        /**
         * When positive, lets you skip the first `rowOffset` rows.
         * Has no effect when negative or zero.
         */
        rowOffset?: number | bigint;
    }
    export interface PaginateArgs {
        page: bigint;
        rowsPerPage: bigint;
        rowOffset: bigint;
    }
    export function toPaginateArgs(rawArgs: RawPaginateArgs): PaginateArgs;
    /**
     * It is possible for this value to be greater than
     * `9223372036854775807n`.
     *
     * When this happens, you will get an error from the RDBMS
     */
    export function getPaginationStart(args: PaginateArgs): bigint;
    export function calculatePagesFound(args: PaginateArgs, rowsFound: bigint): bigint;
}
declare module "execution/util/operation/paginate/apply-paginate-args" {
    import { QueryBaseUtil, IQueryBase } from "query-base/index";
    import { PaginateArgs } from "execution/util/operation/paginate/paginate-args";
    export function applyPaginateArgs<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, args: PaginateArgs): (Pick<QueryT, Exclude<keyof IQueryBase, "limitClause" | "compoundQueryLimitClause">> & Pick<IQueryBase, "limitClause" | "compoundQueryLimitClause">);
}
declare module "execution/util/operation/impl/ensure-one-or" {
    import { IQueryBase } from "query-base/index";
    /**
     * @todo Better naming
     */
    export function ensureOneOr<ResultSetT extends any[], DefaultValueT>(query: Pick<IQueryBase, "fromClause">, fetched: {
        sql: string;
        resultSet: ResultSetT;
    }, defaultValue: DefaultValueT): (ResultSetT[number] | DefaultValueT);
}
declare module "execution/util/operation/impl/ensure-one" {
    import { IQueryBase } from "query-base/index";
    /**
     * @todo Better naming
     */
    export function ensureOne<ResultSetT extends any[]>(query: Pick<IQueryBase, "fromClause">, fetched: {
        sql: string;
        resultSet: ResultSetT;
    }): (ResultSetT[number]);
}
declare module "unified-query/query" {
    import { QueryBaseData, IQueryBase } from "query-base/index";
    import { WhereClause } from "where-clause/index";
    import { HavingClause } from "having-clause/index";
    import { OrderByClause } from "order-by-clause/index";
    import { CompoundQueryOrderByClause } from "compound-query-order-by-clause/index";
    /**
     * @todo Rename to `UnifiedQueryData` or something
     */
    export interface QueryData extends QueryBaseData {
    }
    /**
     * @todo Rename to `ExtraUnifiedQueryData` or something
     */
    export interface ExtraQueryData {
        readonly whereClause: WhereClause | undefined;
        readonly havingClause: HavingClause | undefined;
        readonly orderByClause: OrderByClause | undefined;
        readonly compoundQueryOrderByClause: CompoundQueryOrderByClause | undefined;
        readonly isDistinct: boolean;
    }
    /**
     * @todo Rename to `IUnifiedQuery` or something
     */
    export interface IQuery<DataT extends QueryData = QueryData> extends IQueryBase<DataT> {
    }
}
declare module "insert-select/insert-select-row" {
    import { ITable, TableUtil } from "table/index";
    import { BuiltInExpr_NonCorrelated, BuiltInExpr_NonCorrelatedOrUndefined } from "built-in-expr/index";
    import { QueryBaseUtil } from "query-base/index";
    import { ColumnUtil } from "column/index";
    /**
     * @todo Allow `RawExprNoUsedRef_Input`
     */
    export type InsertSelectRow<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable> = {
        readonly [columnAlias in TableUtil.RequiredColumnAlias<TableT>]: (BuiltInExpr_NonCorrelated<ReturnType<TableT["columns"][columnAlias]["mapper"]>> | ColumnUtil.ExtractWithType<ColumnUtil.FromSelectClause<QueryT["selectClause"]>, ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in TableUtil.OptionalColumnAlias<TableT>]?: (BuiltInExpr_NonCorrelatedOrUndefined<ReturnType<TableT["columns"][columnAlias]["mapper"]>> | ColumnUtil.ExtractWithType<ColumnUtil.FromSelectClause<QueryT["selectClause"]>, ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    };
}
declare module "insert-select/insert-select-delegate" {
    import { ITable } from "table/index";
    import { QueryBaseUtil } from "query-base/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { InsertSelectRow } from "insert-select/insert-select-row";
    export type InsertSelectDelegateColumns<QueryT extends QueryBaseUtil.AfterSelectClause> = ColumnRefUtil.TryFlatten<ColumnRefUtil.FromSelectClause<QueryT["selectClause"]>>;
    export type InsertSelectDelegate<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable> = (columns: InsertSelectDelegateColumns<QueryT>) => InsertSelectRow<QueryT, TableT>;
}
declare module "insert-select/util/operation/clean-insert-select-column" {
    import { ITable } from "table/index";
    import { InsertSelectRow } from "insert-select/insert-select-row";
    import { QueryBaseUtil } from "query-base/index";
    import { ColumnRefUtil } from "column-ref/index";
    export function cleanInsertSelectColumn<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable>(allowedColumnRef: ColumnRefUtil.FromSelectClause<QueryT["selectClause"]>, table: TableT, row: InsertSelectRow<QueryT, TableT>, columnAlias: keyof InsertSelectRow<QueryT, TableT>, required: true): InsertSelectRow<QueryT, TableT>[keyof InsertSelectRow<QueryT, TableT>];
    export function cleanInsertSelectColumn<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable>(allowedColumnRef: ColumnRefUtil.FromSelectClause<QueryT["selectClause"]>, table: TableT, row: InsertSelectRow<QueryT, TableT>, columnAlias: keyof InsertSelectRow<QueryT, TableT>, required: false): InsertSelectRow<QueryT, TableT>[keyof InsertSelectRow<QueryT, TableT>] | undefined;
}
declare module "insert-select/util/operation/clean-insert-select-row" {
    import { ITable } from "table/index";
    import { InsertSelectRow } from "insert-select/insert-select-row";
    import { QueryBaseUtil } from "query-base/index";
    /**
     * + Removes excess properties.
     * + Removes properties with value `undefined`.
     * + Checks required properties are there.
     */
    export function cleanInsertSelectRow<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable>(query: QueryT, table: TableT, row: InsertSelectRow<QueryT, TableT>): InsertSelectRow<QueryT, TableT>;
}
declare module "insert-select/util/operation/index" {
    export * from "insert-select/util/operation/clean-insert-select-column";
    export * from "insert-select/util/operation/clean-insert-select-row";
}
declare module "insert-select/util/constructor/insert-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { ITable } from "table/index";
    import { InsertSelectDelegate } from "insert-select/insert-select-delegate";
    import { InsertSelectRow } from "insert-select/insert-select-row";
    export function insertSelect<QueryT extends QueryBaseUtil.AfterSelectClause, TableT extends ITable>(query: QueryT, table: TableT, delegate: InsertSelectDelegate<QueryT, TableT>): InsertSelectRow<QueryT, TableT>;
}
declare module "insert-select/util/constructor/index" {
    export * from "insert-select/util/constructor/insert-select";
}
declare module "insert-select/util/index" {
    export * from "insert-select/util/constructor/index";
    export * from "insert-select/util/operation/index";
}
declare module "insert-select/index" {
    export * from "insert-select/insert-select-delegate";
    export * from "insert-select/insert-select-row";
    import * as InsertSelectUtil from "insert-select/util/index";
    export { InsertSelectUtil, };
}
declare module "unified-query/query-impl" {
    import * as tm from "type-mapping";
    import { ExtraQueryData, QueryData, IQuery } from "unified-query/query";
    import { WhereClause, WhereDelegate } from "where-clause/index";
    import { GroupByDelegate, GroupByClauseUtil } from "group-by-clause/index";
    import { HavingClause, HavingDelegate } from "having-clause/index";
    import { OrderByClause } from "order-by-clause/index";
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause } from "select-clause/index";
    import { BuiltInExpr_NonAggregate, AnyBuiltInExpr, AnySubqueryExpr } from "built-in-expr/index";
    import { OnDelegate, OnClauseUtil } from "on-clause/index";
    import { ITable, TableUtil, TableWithPrimaryKey, InsertableTable, DeletableTable } from "table/index";
    import { ColumnUtil } from "column/index";
    import { JoinArrayUtil } from "join/index";
    import { SuperKey_NonUnion } from "super-key/index";
    import { PrimaryKey_NonUnion } from "primary-key/index";
    import { PartialRow_NonUnion } from "partial-row/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    /**
     * @todo Rename to `UnifiedQueryUtil` or something
     */
    import * as QueryUtil from "unified-query/util/index";
    import * as TypeUtil from "type-util/index";
    import * as ExprLib from "expr-library/index";
    import { CompoundQueryOrderByClause, CompoundQueryOrderByDelegate } from "compound-query-order-by-clause/index";
    import { QueryBaseUtil } from "query-base/index";
    import { CompoundQueryClauseUtil } from "compound-query-clause/index";
    import { ExecutionUtil, SelectConnection, IsolableSelectConnection, InsertSelectConnection, InsertManyResult, InsertIgnoreSelectConnection, InsertIgnoreManyResult, ReplaceSelectConnection, ReplaceManyResult } from "execution/index";
    import { SortDirection } from "sort-direction/index";
    import { InsertSelectDelegate } from "insert-select/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    export class Query<DataT extends QueryData> implements IQuery<DataT> {
        readonly fromClause: DataT["fromClause"];
        readonly selectClause: DataT["selectClause"];
        readonly limitClause: DataT["limitClause"];
        readonly compoundQueryClause: DataT["compoundQueryClause"];
        readonly compoundQueryLimitClause: DataT["compoundQueryLimitClause"];
        readonly mapDelegate: DataT["mapDelegate"];
        readonly groupByClause: DataT["groupByClause"];
        readonly whereClause: WhereClause | undefined;
        readonly havingClause: HavingClause | undefined;
        readonly orderByClause: OrderByClause | undefined;
        readonly compoundQueryOrderByClause: CompoundQueryOrderByClause | undefined;
        readonly isDistinct: boolean;
        constructor(data: DataT, extraData: ExtraQueryData);
        limit<MaxRowCountT extends bigint>(maxRowCount: MaxRowCountT): (QueryUtil.LimitBigInt<this, MaxRowCountT>);
        limit(maxRowCount: 0): (QueryUtil.LimitNumber0<this>);
        limit(maxRowCount: 1): (QueryUtil.LimitNumber1<this>);
        limit(maxRowCount: 0 | 1): (QueryUtil.LimitNumber0Or1<this>);
        limit(maxRowCount: number | bigint): (QueryUtil.LimitNumber<this>);
        offset<OffsetT extends bigint>(offset: OffsetT): (QueryUtil.OffsetBigInt<this, OffsetT>);
        offset(offset: number | bigint): (QueryUtil.OffsetNumber<this>);
        compoundQueryLimit<MaxRowCountT extends bigint>(maxRowCount: MaxRowCountT): (QueryUtil.CompoundQueryLimitBigInt<this, MaxRowCountT>);
        compoundQueryLimit(maxRowCount: 0): (QueryUtil.CompoundQueryLimitNumber0<this>);
        compoundQueryLimit(maxRowCount: 1): (QueryUtil.CompoundQueryLimitNumber1<this>);
        compoundQueryLimit(maxRowCount: 0 | 1): (QueryUtil.CompoundQueryLimitNumber0Or1<this>);
        compoundQueryLimit(maxRowCount: number | bigint): (QueryUtil.CompoundQueryLimitNumber<this>);
        compoundQueryOffset<OffsetT extends bigint>(offset: OffsetT): (QueryUtil.CompoundQueryOffsetBigInt<this, OffsetT>);
        compoundQueryOffset(offset: number | bigint): (QueryUtil.CompoundQueryOffsetNumber<this>);
        requireOuterQueryJoins<AliasedTablesT extends readonly IAliasedTable[]>(...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<this["fromClause"], AliasedTablesT>)): (QueryUtil.RequireOuterQueryJoins<this, AliasedTablesT>);
        requireNullableOuterQueryJoins<AliasedTablesT extends readonly IAliasedTable[]>(...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<this["fromClause"], AliasedTablesT>)): (QueryUtil.RequireNullableOuterQueryJoins<this, AliasedTablesT>);
        from<AliasedTableT extends IAliasedTable>(this: Extract<this, QueryUtil.BeforeFromClause>, aliasedTable: (AliasedTableT & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.BeforeFromClause>, AliasedTableT>)): (QueryUtil.From<Extract<this, QueryUtil.BeforeFromClause>, AliasedTableT>);
        crossJoin<AliasedTableT extends IAliasedTable>(this: Extract<this, QueryUtil.AfterFromClause>, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>)): (QueryUtil.CrossJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>);
        groupBy<GroupByT extends readonly ColumnIdentifierUtil.FromColumnRef<GroupByClauseUtil.AllowedColumnIdentifierRef<Extract<this, QueryUtil.AfterFromClause>["fromClause"]>>[]>(this: Extract<this, QueryUtil.AfterFromClause>, groupByDelegate: GroupByDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], GroupByT>): (QueryUtil.GroupBy<Extract<this, QueryUtil.AfterFromClause>, GroupByT>);
        having(this: Extract<this, QueryUtil.AfterGroupByClause>, havingDelegate: HavingDelegate<Extract<this, QueryUtil.AfterGroupByClause>["fromClause"], Extract<this, QueryUtil.AfterGroupByClause>["groupByClause"]>): (QueryUtil.Having<Extract<this, QueryUtil.AfterGroupByClause>>);
        innerJoinUsingCandidateKey<SrcT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(this: Extract<this, QueryUtil.AfterFromClause>, srcDelegate: FromClauseUtil.InnerJoinUsingCandidateKeySrcDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (QueryUtil.InnerJoinUsingCandidateKey<Extract<this, QueryUtil.AfterFromClause>, DstT>);
        innerJoinUsingPrimaryKey<SrcT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number], DstT extends TableWithPrimaryKey>(this: Extract<this, QueryUtil.AfterFromClause>, srcDelegate: FromClauseUtil.InnerJoinUsingPrimaryKeySrcDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (QueryUtil.InnerJoinUsingPrimaryKey<Extract<this, QueryUtil.AfterFromClause>, DstT>);
        innerJoin<AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(this: Extract<this, QueryUtil.AfterFromClause>, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>), onDelegate: OnDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], AliasedTableT, (RawOnClauseT & OnClauseUtil.AssertNoOuterQueryUsedRef<Extract<this, QueryUtil.AfterFromClause>["fromClause"], RawOnClauseT>)>): (QueryUtil.InnerJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>);
        leftJoinUsingCandidateKey<SrcT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(this: Extract<this, QueryUtil.AfterFromClause>, srcDelegate: FromClauseUtil.LeftJoinUsingCandidateKeySrcDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (QueryUtil.LeftJoinUsingCandidateKey<Extract<this, QueryUtil.AfterFromClause>, DstT>);
        leftJoinUsingPrimaryKey<SrcT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number], DstT extends TableWithPrimaryKey>(this: Extract<this, QueryUtil.AfterFromClause>, srcDelegate: FromClauseUtil.LeftJoinUsingPrimaryKeySrcDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (QueryUtil.LeftJoinUsingPrimaryKey<Extract<this, QueryUtil.AfterFromClause>, DstT>);
        leftJoin<AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(this: Extract<this, QueryUtil.AfterFromClause>, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & QueryUtil.AssertValidCurrentJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>), onDelegate: OnDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], AliasedTableT, (RawOnClauseT & OnClauseUtil.AssertNoOuterQueryUsedRef<Extract<this, QueryUtil.AfterFromClause>["fromClause"], RawOnClauseT>)>): (QueryUtil.LeftJoin<Extract<this, QueryUtil.AfterFromClause>, AliasedTableT>);
        orderBy(orderByDelegate: QueryUtil.QueryOrderByDelegate<this>): (QueryUtil.OrderBy<this>);
        selectValue<BuiltInExprT extends AnyBuiltInExpr>(this: Extract<this, QueryUtil.BeforeCompoundQueryClause>, selectValueDelegate: QueryUtil.QuerySelectValueDelegate<Extract<this, QueryUtil.BeforeCompoundQueryClause>, BuiltInExprT>): (QueryUtil.SelectValue<Extract<this, QueryUtil.BeforeCompoundQueryClause>, BuiltInExprT>);
        select<SelectsT extends SelectClause>(this: Extract<this, QueryUtil.BeforeCompoundQueryClause>, selectDelegate: QueryUtil.QuerySelectDelegate<Extract<this, QueryUtil.BeforeCompoundQueryClause>, SelectsT>): (QueryUtil.Select<Extract<this, QueryUtil.BeforeCompoundQueryClause>, SelectsT>);
        compoundQueryOrderBy(this: Extract<this, QueryUtil.AfterSelectClause>, compoundQueryOrderByDelegate: CompoundQueryOrderByDelegate<Extract<this, QueryUtil.AfterSelectClause>["selectClause"]>): (QueryUtil.CompoundQueryOrderBy<Extract<this, QueryUtil.AfterSelectClause>>);
        unionDistinct<TargetQueryT extends QueryBaseUtil.AfterSelectClause>(this: Extract<this, QueryUtil.AfterSelectClause>, targetQuery: (TargetQueryT & CompoundQueryClauseUtil.AssertCompatible<Extract<this, QueryUtil.AfterSelectClause>["fromClause"], Extract<this, QueryUtil.AfterSelectClause>["selectClause"], TargetQueryT>)): (QueryUtil.CompoundQuery<Extract<this, QueryUtil.AfterSelectClause>, TargetQueryT>);
        unionAll<TargetQueryT extends QueryBaseUtil.AfterSelectClause>(this: Extract<this, QueryUtil.AfterSelectClause>, targetQuery: (TargetQueryT & CompoundQueryClauseUtil.AssertCompatible<Extract<this, QueryUtil.AfterSelectClause>["fromClause"], Extract<this, QueryUtil.AfterSelectClause>["selectClause"], TargetQueryT>)): (QueryUtil.CompoundQuery<Extract<this, QueryUtil.AfterSelectClause>, TargetQueryT>);
        whereEqCandidateKey<TableT extends JoinArrayUtil.ExtractWithCandidateKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqCandidateKeyDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], TableT>, TypeUtil.StrictUnion<CandidateKey_NonUnion<TableT>>] : never)): (QueryUtil.WhereEqCandidateKey<Extract<this, QueryUtil.AfterFromClause>>);
        whereEqColumns<TableT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number]>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (TableT extends Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number] ? [FromClauseUtil.WhereEqColumnsDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], TableT>, PartialRow_NonUnion<TableT>] : never)): (QueryUtil.WhereEqColumns<Extract<this, QueryUtil.AfterFromClause>>);
        whereEqInnerQueryPrimaryKey<SrcT extends Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"]["outerQueryJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"]["currentJoins"], SrcT["columns"]>>(this: Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>, srcDelegate: (FromClauseUtil.WhereEqInnerQueryPrimaryKeySrcDelegate<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"], SrcT>), dstDelegate: (FromClauseUtil.WhereEqInnerQueryPrimaryKeyDstDelegate<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"], SrcT, DstT>)): (QueryUtil.WhereEqInnerQueryPrimaryKey<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>>);
        whereEqOuterQueryPrimaryKey<SrcT extends Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"]["outerQueryJoins"], SrcT["columns"]>>(this: Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for
         * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        srcDelegate: (SrcT extends Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"]["currentJoins"][number] ? (FromClauseUtil.WhereEqOuterQueryPrimaryKeySrcDelegate<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"], SrcT>) : never), dstDelegate: (FromClauseUtil.WhereEqOuterQueryPrimaryKeyDstDelegate<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>["fromClause"], SrcT, DstT>)): (QueryUtil.WhereEqOuterQueryPrimaryKey<Extract<this, QueryUtil.Correlated & QueryUtil.AfterFromClause>>);
        whereEqPrimaryKey<TableT extends JoinArrayUtil.ExtractWithPrimaryKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (TableT extends JoinArrayUtil.ExtractWithPrimaryKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqPrimaryKeyDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], TableT>, PrimaryKey_NonUnion<TableT>] : never)): (QueryUtil.WhereEqPrimaryKey<Extract<this, QueryUtil.AfterFromClause>>);
        whereEqSuperKey<TableT extends JoinArrayUtil.ExtractWithCandidateKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqSuperKeyDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], TableT>, SuperKey_NonUnion<TableT>] : never)): (QueryUtil.WhereEqSuperKey<Extract<this, QueryUtil.AfterFromClause>>);
        whereEq<ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereEqDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>> ? [FromClauseUtil.WhereEqDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], ColumnT>, ValueT] : never)): (QueryUtil.WhereEq<Extract<this, QueryUtil.AfterFromClause>, ColumnT, ValueT>);
        whereIsNotNull<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>>(this: Extract<this, QueryUtil.AfterFromClause>, whereIsNotNullDelegate: FromClauseUtil.WhereIsNotNullDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], ColumnT>): (QueryUtil.WhereIsNotNull<Extract<this, QueryUtil.AfterFromClause>, ColumnT>);
        whereIsNull<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>>>(this: Extract<this, QueryUtil.AfterFromClause>, whereIsNullDelegate: FromClauseUtil.WhereIsNullDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], ColumnT>): (QueryUtil.WhereIsNull<Extract<this, QueryUtil.AfterFromClause>, ColumnT>);
        whereNullSafeEq<ColumnT extends ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null>(this: Extract<this, QueryUtil.AfterFromClause>, 
        /**
         * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args: (ColumnT extends ColumnUtil.FromJoinArray<Extract<this, QueryUtil.AfterFromClause>["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereNullSafeEqDelegate<Extract<this, QueryUtil.AfterFromClause>["fromClause"], ColumnT>, ValueT] : never)): (QueryUtil.WhereNullSafeEq<Extract<this, QueryUtil.AfterFromClause>, ColumnT, ValueT>);
        where(whereDelegate: WhereDelegate<this["fromClause"]>): (QueryUtil.Where<this>);
        as<AliasT extends string>(this: Extract<this, QueryUtil.AfterSelectClause>, alias: AliasT & QueryBaseUtil.AssertAliasable<Extract<this, QueryUtil.AfterSelectClause>>): (QueryBaseUtil.As<Extract<this, QueryUtil.AfterSelectClause>, AliasT>);
        correlate(): QueryUtil.Correlate<this>;
        /**
         * @todo Maybe implement `selectDistinct()` as a convenience method?
         */
        distinct(): QueryUtil.Distinct<this>;
        /**
         * Convenience method for,
         * ```ts
         *  tsql.coalesce(myQuery.limit(1), myDefaultValue);
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).coalesce(myDefaultValue);
         * ```
         */
        coalesce<DefaultValueT extends AnyBuiltInExpr>(this: Extract<this, AnySubqueryExpr>, defaultValue: DefaultValueT): (QueryBaseUtil.Coalesce<Extract<this, AnySubqueryExpr>, DefaultValueT>);
        /**
         * Convenience method for,
         * ```ts
         *  tsql.throwIfNull(myQuery.limit(1));
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).throwIfNull();
         * ```
         */
        throwIfNull(this: Extract<this, AnySubqueryExpr>): (QueryBaseUtil.ThrowIfNull<Extract<this, AnySubqueryExpr>>);
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).asc();
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).asc();
         * ```
         */
        asc(this: Extract<this, AnySubqueryExpr>): (QueryBaseUtil.Asc<Extract<this, AnySubqueryExpr>>);
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).desc();
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).desc();
         * ```
         */
        desc(this: Extract<this, AnySubqueryExpr>): (QueryBaseUtil.Desc<Extract<this, AnySubqueryExpr>>);
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).sort(sortDirection);
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).sort(sortDirection);
         * ```
         */
        sort(this: Extract<this, AnySubqueryExpr>, sortDirection: SortDirection): (QueryBaseUtil.Sort<Extract<this, AnySubqueryExpr>>);
        map<NxtReturnT>(this: Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Unmapped>, mapDelegate: QueryUtil.InitialMapDelegate<Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Unmapped>, NxtReturnT>): (QueryUtil.MapInitial<Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Unmapped>, NxtReturnT>);
        map<NxtReturnT>(this: Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Mapped>, mapDelegate: QueryUtil.ComposedMapDelegate<Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Mapped>, NxtReturnT>): (QueryUtil.MapCompose<Extract<this, QueryUtil.AfterSelectClause & QueryUtil.NonCorrelated & QueryUtil.Mapped>, NxtReturnT>);
        fetchAllMapped(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated & QueryBaseUtil.Mapped)>, connection: IsolableSelectConnection): (Promise<ExecutionUtil.MappedResultSet<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated & QueryBaseUtil.Mapped)>>>);
        fetchAllUnmappedFlattened(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection): (Promise<ExecutionUtil.UnmappedFlattenedResultSet<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        fetchAllUnmapped(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection): (Promise<ExecutionUtil.UnmappedResultSet<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        fetchAll(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>): (Promise<ExecutionUtil.FetchedResultSet<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        fetchOneOrUndefined(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>): (Promise<undefined | ExecutionUtil.FetchedRow<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        fetchOneOr<DefaultValueT>(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>, defaultValue: DefaultValueT): (Promise<DefaultValueT | ExecutionUtil.FetchedRow<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        fetchOne(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>): (ExecutionUtil.FetchOneReturnType<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>);
        fetchValueArray(this: Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection): (Promise<QueryBaseUtil.TypeOfSelectItem<Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>>[]>);
        fetchValueOrUndefined(this: Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection): (Promise<undefined | QueryBaseUtil.TypeOfSelectItem<Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>>>);
        fetchValueOr<DefaultValueT>(this: Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection, defaultValue: DefaultValueT): (Promise<DefaultValueT | QueryBaseUtil.TypeOfSelectItem<Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>>>);
        fetchValue(this: Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>, connection: SelectConnection): (ExecutionUtil.FetchValueReturnType<Extract<this, (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated)>>);
        count(this: Extract<this, QueryBaseUtil.NonCorrelated>, connection: SelectConnection): Promise<bigint>;
        paginate(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>, rawArgs: ExecutionUtil.RawPaginateArgs): (Promise<ExecutionUtil.Paginate<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>>);
        exists(this: Extract<this, QueryUtil.NonCorrelated & (QueryUtil.AfterFromClause | QueryUtil.AfterSelectClause)>, connection: SelectConnection): Promise<boolean>;
        assertExists(this: Extract<this, QueryUtil.NonCorrelated & (QueryUtil.AfterFromClause | QueryUtil.AfterSelectClause)>, connection: SelectConnection): Promise<void>;
        emulatedCursor(this: Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>, connection: ExecutionUtil.FetchAllConnection<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>, 
        /**
         * If set, determines the starting `page` of the cursor.
         * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
         */
        rawArgs?: ExecutionUtil.RawPaginateArgs): (ExecutionUtil.EmulatedCursor<Extract<this, (QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated)>>);
        insert<TableT extends InsertableTable>(this: Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, connection: InsertSelectConnection, table: TableT, rowDelegate: InsertSelectDelegate<Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, TableT>): Promise<InsertManyResult>;
        insertIgnore<TableT extends InsertableTable>(this: Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, connection: InsertIgnoreSelectConnection, table: TableT, rowDelegate: InsertSelectDelegate<Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, TableT>): Promise<InsertIgnoreManyResult>;
        replace<TableT extends InsertableTable & DeletableTable>(this: Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, connection: ReplaceSelectConnection, table: TableT, rowDelegate: InsertSelectDelegate<Extract<this, QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>, TableT>): Promise<ReplaceManyResult>;
    }
}
declare module "unified-query/util/constructor/new-instance" {
    import { FromClauseUtil } from "from-clause/index";
    import { Query } from "unified-query/query-impl";
    export type NewInstance = Query<{
        fromClause: FromClauseUtil.NewInstance;
        selectClause: undefined;
        limitClause: undefined;
        compoundQueryClause: undefined;
        compoundQueryLimitClause: undefined;
        mapDelegate: undefined;
        groupByClause: undefined;
    }>;
    export function newInstance(): NewInstance;
}
declare module "unified-query/util/constructor/index" {
    export * from "unified-query/util/constructor/new-instance";
}
declare module "unified-query/util/helper-type/after-from-clause" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface AfterFromClause extends QueryBaseUtil.AfterFromClause, IQuery {
    }
}
declare module "unified-query/util/helper-type/after-group-by-clause" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface AfterGroupByClause extends QueryBaseUtil.AfterGroupByClause, IQuery {
    }
}
declare module "unified-query/util/helper-type/after-select-clause" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface AfterSelectClause extends QueryBaseUtil.AfterSelectClause, IQuery {
    }
}
declare module "unified-query/util/helper-type/before-from-clause" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface BeforeFromClause extends QueryBaseUtil.BeforeFromClause, IQuery<QueryBaseUtil.BeforeFromClauseData> {
    }
}
declare module "unified-query/util/helper-type/before-compound-query-clause" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface BeforeCompoundQueryClause extends QueryBaseUtil.BeforeCompoundQueryClause, IQuery<QueryBaseUtil.BeforeCompoundQueryClauseData> {
    }
}
declare module "unified-query/util/helper-type/correlated" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface Correlated extends QueryBaseUtil.Correlated, IQuery {
    }
}
declare module "unified-query/util/helper-type/mapped" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface Mapped extends QueryBaseUtil.Mapped, IQuery {
    }
}
declare module "unified-query/util/helper-type/non-correlated" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface NonCorrelated extends QueryBaseUtil.NonCorrelated, IQuery<QueryBaseUtil.NonCorrelatedData> {
    }
}
declare module "unified-query/util/helper-type/unmapped" {
    import { QueryBaseUtil } from "query-base/index";
    import { IQuery } from "unified-query/query";
    export interface Unmapped extends QueryBaseUtil.Unmapped, IQuery<QueryBaseUtil.UnmappedData> {
    }
}
declare module "unified-query/util/helper-type/index" {
    export * from "unified-query/util/helper-type/after-from-clause";
    export * from "unified-query/util/helper-type/after-group-by-clause";
    export * from "unified-query/util/helper-type/after-select-clause";
    export * from "unified-query/util/helper-type/before-from-clause";
    export * from "unified-query/util/helper-type/before-compound-query-clause";
    export * from "unified-query/util/helper-type/correlated";
    export * from "unified-query/util/helper-type/mapped";
    export * from "unified-query/util/helper-type/non-correlated";
    export * from "unified-query/util/helper-type/unmapped";
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit-bigint" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryLimitBigIntImpl<MaxRowCountT extends bigint, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.LimitBigInt<CompoundQueryLimitClauseT, MaxRowCountT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryLimitBigInt<QueryT extends IQuery, MaxRowCountT extends bigint> = CompoundQueryLimitBigIntImpl<MaxRowCountT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0-or-1" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryLimitNumber0Or1Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.LimitNumber0Or1<CompoundQueryLimitClauseT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryLimitNumber0Or1<QueryT extends IQuery> = CompoundQueryLimitNumber0Or1Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryLimitNumber0Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.LimitNumber0<CompoundQueryLimitClauseT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryLimitNumber0<QueryT extends IQuery> = CompoundQueryLimitNumber0Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit-number-1" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryLimitNumber1Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.LimitNumber1<CompoundQueryLimitClauseT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryLimitNumber1<QueryT extends IQuery> = CompoundQueryLimitNumber1Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit-number" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryLimitNumberImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.LimitNumber<CompoundQueryLimitClauseT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryLimitNumber<QueryT extends IQuery> = CompoundQueryLimitNumberImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-limit/compound-query-limit" {
    import { IQuery } from "unified-query/query";
    import { CompoundQueryLimitBigInt } from "unified-query/util/operation/compound-query-limit/compound-query-limit-bigint";
    import { CompoundQueryLimitNumber } from "unified-query/util/operation/compound-query-limit/compound-query-limit-number";
    import { CompoundQueryLimitNumber0 } from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0";
    import { CompoundQueryLimitNumber1 } from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-1";
    import { CompoundQueryLimitNumber0Or1 } from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0-or-1";
    export function compoundQueryLimit<QueryT extends IQuery, MaxRowCountT extends bigint>(query: QueryT, maxRowCount: MaxRowCountT): (CompoundQueryLimitBigInt<QueryT, MaxRowCountT>);
    export function compoundQueryLimit<QueryT extends IQuery>(query: QueryT, maxRowCount: 0): (CompoundQueryLimitNumber0<QueryT>);
    export function compoundQueryLimit<QueryT extends IQuery>(query: QueryT, maxRowCount: 1): (CompoundQueryLimitNumber1<QueryT>);
    export function compoundQueryLimit<QueryT extends IQuery>(query: QueryT, maxRowCount: 0 | 1): (CompoundQueryLimitNumber0Or1<QueryT>);
    export function compoundQueryLimit<QueryT extends IQuery>(query: QueryT, maxRowCount: number | bigint): (CompoundQueryLimitNumber<QueryT>);
}
declare module "unified-query/util/operation/compound-query-limit/index" {
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit-bigint";
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0-or-1";
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-0";
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit-number-1";
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit-number";
    export * from "unified-query/util/operation/compound-query-limit/compound-query-limit";
}
declare module "unified-query/util/operation/compound-query-offset/compound-query-offset-bigint" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryOffsetBigIntImpl<OffsetT extends bigint, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.OffsetBigInt<CompoundQueryLimitClauseT, OffsetT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryOffsetBigInt<QueryT extends IQuery, OffsetT extends bigint> = CompoundQueryOffsetBigIntImpl<OffsetT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-offset/compound-query-offset-number" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryOffsetNumberImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: LimitClauseUtil.OffsetNumber<CompoundQueryLimitClauseT>;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type CompoundQueryOffsetNumber<QueryT extends IQuery> = CompoundQueryOffsetNumberImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
}
declare module "unified-query/util/operation/compound-query-offset/compound-query-offset" {
    import { IQuery } from "unified-query/query";
    import { CompoundQueryOffsetBigInt } from "unified-query/util/operation/compound-query-offset/compound-query-offset-bigint";
    import { CompoundQueryOffsetNumber } from "unified-query/util/operation/compound-query-offset/compound-query-offset-number";
    export function compoundQueryOffset<QueryT extends IQuery, OffsetT extends bigint>(query: QueryT, offset: OffsetT): (CompoundQueryOffsetBigInt<QueryT, OffsetT>);
    export function compoundQueryOffset<QueryT extends IQuery>(query: QueryT, offset: number | bigint): (CompoundQueryOffsetNumber<QueryT>);
}
declare module "unified-query/util/operation/compound-query-offset/index" {
    export * from "unified-query/util/operation/compound-query-offset/compound-query-offset-bigint";
    export * from "unified-query/util/operation/compound-query-offset/compound-query-offset-number";
    export * from "unified-query/util/operation/compound-query-offset/compound-query-offset";
}
declare module "unified-query/util/operation/limit/limit-bigint" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LimitBigIntImpl<MaxRowCountT extends bigint, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.LimitBigInt<LimitClauseT, MaxRowCountT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type LimitBigInt<QueryT extends IQuery, MaxRowCountT extends bigint> = (LimitBigIntImpl<MaxRowCountT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/limit/limit-number-0-or-1" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LimitNumber0Or1Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.LimitNumber0Or1<LimitClauseT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type LimitNumber0Or1<QueryT extends IQuery> = (LimitNumber0Or1Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/limit/limit-number-0" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LimitNumber0Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.LimitNumber0<LimitClauseT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type LimitNumber0<QueryT extends IQuery> = (LimitNumber0Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/limit/limit-number-1" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LimitNumber1Impl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.LimitNumber1<LimitClauseT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type LimitNumber1<QueryT extends IQuery> = (LimitNumber1Impl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/limit/limit-number" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LimitNumberImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.LimitNumber<LimitClauseT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type LimitNumber<QueryT extends IQuery> = (LimitNumberImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/limit/limit" {
    import { IQuery } from "unified-query/query";
    import { LimitBigInt } from "unified-query/util/operation/limit/limit-bigint";
    import { LimitNumber } from "unified-query/util/operation/limit/limit-number";
    import { LimitNumber0 } from "unified-query/util/operation/limit/limit-number-0";
    import { LimitNumber1 } from "unified-query/util/operation/limit/limit-number-1";
    import { LimitNumber0Or1 } from "unified-query/util/operation/limit/limit-number-0-or-1";
    export function limit<QueryT extends IQuery, MaxRowCountT extends bigint>(query: QueryT, maxRowCount: MaxRowCountT): (LimitBigInt<QueryT, MaxRowCountT>);
    export function limit<QueryT extends IQuery>(query: QueryT, maxRowCount: 0): (LimitNumber0<QueryT>);
    export function limit<QueryT extends IQuery>(query: QueryT, maxRowCount: 1): (LimitNumber1<QueryT>);
    export function limit<QueryT extends IQuery>(query: QueryT, maxRowCount: 0 | 1): (LimitNumber0Or1<QueryT>);
    export function limit<QueryT extends IQuery>(query: QueryT, maxRowCount: number | bigint): (LimitNumber<QueryT>);
}
declare module "unified-query/util/operation/limit/index" {
    export * from "unified-query/util/operation/limit/limit-bigint";
    export * from "unified-query/util/operation/limit/limit-number-0-or-1";
    export * from "unified-query/util/operation/limit/limit-number-0";
    export * from "unified-query/util/operation/limit/limit-number-1";
    export * from "unified-query/util/operation/limit/limit-number";
    export * from "unified-query/util/operation/limit/limit";
}
declare module "unified-query/util/operation/map/map-compose" {
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { MapDelegate } from "map-delegate/index";
    import { ExecutionUtil } from "execution/index";
    import { AfterSelectClause, NonCorrelated, Mapped } from "unified-query/util/helper-type/index";
    import { TypeOfAwait, BetterReturnType } from "type-util/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type MapComposeImpl<NewMapDelegateT extends MapDelegate, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: NewMapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type MapCompose<QueryT extends AfterSelectClause & NonCorrelated & Mapped, NxtReturnT> = (MapComposeImpl<MapDelegate<never, never, Promise<TypeOfAwait<NxtReturnT>>>, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["groupByClause"]>);
    export type ComposedMapDelegate<QueryT extends AfterSelectClause & NonCorrelated & Mapped, NxtReturnT> = MapDelegate<TypeOfAwait<BetterReturnType<QueryT["mapDelegate"]>>, ExecutionUtil.UnmappedRow<QueryT>, NxtReturnT>;
    export function mapCompose<QueryT extends AfterSelectClause & NonCorrelated & Mapped, NxtReturnT>(query: QueryT, mapDelegate: ComposedMapDelegate<QueryT, NxtReturnT>): (MapCompose<QueryT, NxtReturnT>);
}
declare module "unified-query/util/operation/map/map-initial" {
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { MapDelegate } from "map-delegate/index";
    import { ExecutionUtil } from "execution/index";
    import { AfterSelectClause, NonCorrelated, Unmapped } from "unified-query/util/helper-type/index";
    export type InitialMapDelegate<QueryT extends AfterSelectClause & NonCorrelated & Unmapped, NxtReturnT> = MapDelegate<ExecutionUtil.UnmappedRow<QueryT>, ExecutionUtil.UnmappedRow<QueryT>, NxtReturnT>;
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type MapInitialImpl<NewMapDelegateT extends MapDelegate, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: NewMapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type MapInitial<QueryT extends AfterSelectClause & NonCorrelated & Unmapped, NxtReturnT> = (MapInitialImpl<
    /**
     * Erase some compile-time data, we are only interested in the return type.
     */
    MapDelegate<never, never, NxtReturnT>, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["groupByClause"]>);
    export function mapInitial<QueryT extends AfterSelectClause & NonCorrelated & Unmapped, NxtReturnT>(query: QueryT, mapDelegate: InitialMapDelegate<QueryT, NxtReturnT>): (MapInitial<QueryT, NxtReturnT>);
}
declare module "unified-query/util/operation/map/map" {
    import { AfterSelectClause, NonCorrelated, Unmapped, Mapped } from "unified-query/util/helper-type/index";
    import { InitialMapDelegate, MapInitial } from "unified-query/util/operation/map/map-initial";
    import { ComposedMapDelegate, MapCompose } from "unified-query/util/operation/map/map-compose";
    export function map<QueryT extends AfterSelectClause & NonCorrelated & Unmapped, NxtReturnT>(query: QueryT, mapDelegate: InitialMapDelegate<QueryT, NxtReturnT>): (MapInitial<QueryT, NxtReturnT>);
    export function map<QueryT extends AfterSelectClause & NonCorrelated & Mapped, NxtReturnT>(query: QueryT, mapDelegate: ComposedMapDelegate<QueryT, NxtReturnT>): (MapCompose<QueryT, NxtReturnT>);
}
declare module "unified-query/util/operation/map/index" {
    export * from "unified-query/util/operation/map/map-compose";
    export * from "unified-query/util/operation/map/map-initial";
    export * from "unified-query/util/operation/map/map";
}
declare module "unified-query/util/operation/offset/offset-bigint" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type OffsetBigIntImpl<OffsetT extends bigint, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.OffsetBigInt<LimitClauseT, OffsetT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type OffsetBigInt<QueryT extends IQuery, OffsetT extends bigint> = (OffsetBigIntImpl<OffsetT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/offset/offset-number" {
    import { LimitClauseUtil } from "limit-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type OffsetNumberImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseUtil.OffsetNumber<LimitClauseT>;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type OffsetNumber<QueryT extends IQuery> = (OffsetNumberImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
}
declare module "unified-query/util/operation/offset/offset" {
    import { IQuery } from "unified-query/query";
    import { OffsetBigInt } from "unified-query/util/operation/offset/offset-bigint";
    import { OffsetNumber } from "unified-query/util/operation/offset/offset-number";
    export function offset<QueryT extends IQuery, OffsetT extends bigint>(query: QueryT, offset: OffsetT): (OffsetBigInt<QueryT, OffsetT>);
    export function offset<QueryT extends IQuery>(query: QueryT, offset: number | bigint): (OffsetNumber<QueryT>);
}
declare module "unified-query/util/operation/offset/index" {
    export * from "unified-query/util/operation/offset/offset-bigint";
    export * from "unified-query/util/operation/offset/offset-number";
    export * from "unified-query/util/operation/offset/offset";
}
declare module "unified-query/util/operation/compound-query-order-by" {
    import { CompoundQueryOrderByDelegate } from "compound-query-order-by-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { AfterSelectClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryOrderByImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type CompoundQueryOrderBy<QueryT extends IQuery> = (CompoundQueryOrderByImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function compoundQueryOrderBy<QueryT extends AfterSelectClause>(query: QueryT, compoundQueryOrderByDelegate: CompoundQueryOrderByDelegate<QueryT["selectClause"]>): (CompoundQueryOrderBy<QueryT>);
}
declare module "unified-query/util/operation/compound-query" {
    import { Query } from "unified-query/query-impl";
    import { CompoundQueryClause, CompoundQueryClauseUtil } from "compound-query-clause/index";
    import { QueryBaseUtil } from "query-base/index";
    import { SelectClauseUtil, SelectClause } from "select-clause/index";
    import { CompoundQueryType } from "compound-query/index";
    import { AfterSelectClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CompoundQueryImpl<TargetSelectClauseT extends SelectClause, FromClauseT extends AfterSelectClause["fromClause"], SelectClauseT extends AfterSelectClause["selectClause"], LimitClauseT extends AfterSelectClause["limitClause"], CompoundQueryLimitClauseT extends AfterSelectClause["compoundQueryLimitClause"], MapDelegateT extends AfterSelectClause["mapDelegate"], GroupByClauseT extends AfterSelectClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseUtil.LeftCompound<SelectClauseT, TargetSelectClauseT>;
        limitClause: LimitClauseT;
        /**
         * We don't need to have a specific type here
         */
        compoundQueryClause: CompoundQueryClause;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type CompoundQuery<QueryT extends AfterSelectClause, TargetQueryT extends QueryBaseUtil.AfterSelectClause> = (CompoundQueryImpl<TargetQueryT["selectClause"], QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function compoundQuery<QueryT extends AfterSelectClause, TargetQueryT extends QueryBaseUtil.AfterSelectClause>(query: QueryT, compoundQueryType: CompoundQueryType, isDistinct: boolean, targetQuery: (TargetQueryT & CompoundQueryClauseUtil.AssertCompatible<QueryT["fromClause"], QueryT["selectClause"], TargetQueryT>)): (CompoundQuery<QueryT, TargetQueryT>);
}
declare module "unified-query/util/operation/correlate" {
    import { FromClauseUtil } from "from-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    export type Correlate<QueryT extends Pick<IQuery, "fromClause">> = Query<{
        fromClause: FromClauseUtil.Correlate<QueryT["fromClause"]>;
        selectClause: undefined;
        limitClause: undefined;
        compoundQueryClause: undefined;
        compoundQueryLimitClause: undefined;
        mapDelegate: undefined;
        groupByClause: undefined;
    }>;
    /**
     * @todo A reference to the `query` needs to be added to the following,
     * + `OnDelegate`
     * + `HavingDelegate`
     * + `OrderByDelegate`
     * + `SelectDelegate`
     * + `WhereDelegate`
     *
     * Basically, anywhere a correlated subquery is allowed.
     */
    export function correlate<QueryT extends Pick<IQuery, "fromClause">>(query: QueryT): (Correlate<QueryT>);
}
declare module "unified-query/util/predicate/assert-valid-current-join" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IQuery } from "unified-query/query";
    export type AssertValidCurrentJoin<QueryT extends IQuery, AliasedTableT extends IAliasedTable> = (FromClauseUtil.AssertValidCurrentJoinBase<QueryT["fromClause"], AliasedTableT>
    /**
     * In MySQL 5.7, derived tables cannot reference parent query tables.
     * This is not a SQL limitation. It is a MySQL limitation.
     *
     * SQLite 3.28 and PostgreSQL 9.4 have no problems with it.
     * Gdi MySQL.
     */
     & FromClauseUtil.AssertNoUsedRef<AliasedTableT>
    /**
     * MySQL 5.7 does not support lateral derived tables.
     */
     & FromClauseUtil.AssertNotLateral<AliasedTableT>);
    export function assertValidJoinTarget(query: IQuery, aliasedTable: IAliasedTable): void;
}
declare module "unified-query/util/predicate/index" {
    export * from "unified-query/util/predicate/assert-valid-current-join";
}
declare module "unified-query/util/operation/cross-join" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type CrossJoinImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseUtil.CrossJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type CrossJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = (CrossJoinImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function crossJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable>(query: QueryT, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & AssertValidCurrentJoin<QueryT, AliasedTableT>)): (CrossJoin<QueryT, AliasedTableT>);
}
declare module "unified-query/util/operation/distinct" {
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type DistinctImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type Distinct<QueryT extends IQuery> = (DistinctImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function distinct<QueryT extends IQuery>(query: QueryT): (Distinct<QueryT>);
}
declare module "unified-query/util/operation/from" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { BeforeFromClause } from "unified-query/util/helper-type/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    export type From<QueryT extends BeforeFromClause, AliasedTableT extends IAliasedTable> = (Query<{
        fromClause: FromClauseUtil.From<QueryT["fromClause"], AliasedTableT>;
        selectClause: QueryT["selectClause"];
        limitClause: QueryT["limitClause"];
        compoundQueryClause: QueryT["compoundQueryClause"];
        compoundQueryLimitClause: QueryT["compoundQueryLimitClause"];
        mapDelegate: QueryT["mapDelegate"];
        groupByClause: QueryT["groupByClause"];
    }>);
    export function from<QueryT extends BeforeFromClause, AliasedTableT extends IAliasedTable>(query: QueryT, aliasedTable: (AliasedTableT & AssertValidCurrentJoin<QueryT, AliasedTableT>)): (From<QueryT, AliasedTableT>);
}
declare module "unified-query/util/operation/group-by" {
    import { GroupByDelegate, GroupByClauseUtil, GroupByClause } from "group-by-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type GroupByImpl<GroupByT extends GroupByClause, FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseUtil.GroupBy<GroupByClauseT, GroupByT>;
    }>);
    export type GroupBy<QueryT extends IQuery, GroupByT extends GroupByClause> = (GroupByImpl<GroupByT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function groupBy<QueryT extends AfterFromClause, GroupByT extends readonly ColumnIdentifierUtil.FromColumnRef<GroupByClauseUtil.AllowedColumnIdentifierRef<QueryT["fromClause"]>>[]>(query: QueryT, groupByDelegate: GroupByDelegate<QueryT["fromClause"], GroupByT>): (GroupBy<QueryT, GroupByT>);
}
declare module "unified-query/util/operation/having" {
    import { HavingDelegate } from "having-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { QueryUtil } from "unified-query/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type HavingImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type Having<QueryT extends IQuery> = (HavingImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function having<QueryT extends QueryUtil.AfterGroupByClause>(query: QueryT, havingDelegate: HavingDelegate<QueryT["fromClause"], QueryT["groupByClause"]>): (Having<QueryT>);
}
declare module "unified-query/util/operation/inner-join-using-candidate-key" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { TableUtil, ITable } from "table/index";
    import * as ExprLib from "expr-library/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingCandidateKeyImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.InnerJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type InnerJoinUsingCandidateKey<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinUsingCandidateKeyImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function innerJoinUsingCandidateKey<QueryT extends AfterFromClause, SrcT extends QueryT["fromClause"]["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(query: QueryT, srcDelegate: FromClauseUtil.InnerJoinUsingCandidateKeySrcDelegate<QueryT["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & AssertValidCurrentJoin<QueryT, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (InnerJoinUsingCandidateKey<QueryT, DstT>);
}
declare module "unified-query/util/operation/inner-join-using-primary-key" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { TableWithPrimaryKey, TableUtil } from "table/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinUsingPrimaryKeyImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.InnerJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type InnerJoinUsingPrimaryKey<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinUsingPrimaryKeyImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function innerJoinUsingPrimaryKey<QueryT extends AfterFromClause, SrcT extends QueryT["fromClause"]["currentJoins"][number], DstT extends TableWithPrimaryKey>(query: QueryT, srcDelegate: FromClauseUtil.InnerJoinUsingPrimaryKeySrcDelegate<QueryT["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & AssertValidCurrentJoin<QueryT, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (InnerJoinUsingPrimaryKey<QueryT, DstT>);
}
declare module "unified-query/util/operation/inner-join" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    import { OnDelegate, OnClauseUtil } from "on-clause/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type InnerJoinImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.InnerJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type InnerJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = InnerJoinImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function innerJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(query: QueryT, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & AssertValidCurrentJoin<QueryT, AliasedTableT>), onDelegate: OnDelegate<QueryT["fromClause"], AliasedTableT, (RawOnClauseT & OnClauseUtil.AssertNoOuterQueryUsedRef<QueryT["fromClause"], RawOnClauseT>)>): (InnerJoin<QueryT, AliasedTableT>);
}
declare module "unified-query/util/operation/left-join-using-candidate-key" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { TableUtil, ITable } from "table/index";
    import * as ExprLib from "expr-library/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingCandidateKeyImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.LeftJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type LeftJoinUsingCandidateKey<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinUsingCandidateKeyImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function leftJoinUsingCandidateKey<QueryT extends AfterFromClause, SrcT extends QueryT["fromClause"]["currentJoins"][number], DstT extends ITable, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(query: QueryT, srcDelegate: FromClauseUtil.LeftJoinUsingCandidateKeySrcDelegate<QueryT["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & AssertValidCurrentJoin<QueryT, DstT>), eqCandidateKeyOfTableDelegate: ExprLib.EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>): (LeftJoinUsingCandidateKey<QueryT, DstT>);
}
declare module "unified-query/util/operation/left-join-using-primary-key" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { TableWithPrimaryKey, TableUtil } from "table/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinUsingPrimaryKeyImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.LeftJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type LeftJoinUsingPrimaryKey<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinUsingPrimaryKeyImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function leftJoinUsingPrimaryKey<QueryT extends AfterFromClause, SrcT extends QueryT["fromClause"]["currentJoins"][number], DstT extends TableWithPrimaryKey>(query: QueryT, srcDelegate: FromClauseUtil.LeftJoinUsingPrimaryKeySrcDelegate<QueryT["fromClause"], SrcT>, aliasedTable: (DstT & TypeUtil.AssertNonUnion<DstT> & AssertValidCurrentJoin<QueryT, DstT> & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)): (LeftJoinUsingPrimaryKey<QueryT, DstT>);
}
declare module "unified-query/util/operation/left-join" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import * as TypeUtil from "type-util/index";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    import { OnDelegate, OnClauseUtil } from "on-clause/index";
    import { Query } from "unified-query/query-impl";
    import { AssertValidCurrentJoin } from "unified-query/util/predicate/index";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type LeftJoinImpl<AliasedTableT extends IAliasedTable, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = Query<{
        fromClause: FromClauseUtil.LeftJoin<FromClauseT, AliasedTableT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>;
    export type LeftJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable> = LeftJoinImpl<AliasedTableT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>;
    export function leftJoin<QueryT extends AfterFromClause, AliasedTableT extends IAliasedTable, RawOnClauseT extends BuiltInExpr_NonAggregate<boolean>>(query: QueryT, aliasedTable: (AliasedTableT & TypeUtil.AssertNonUnion<AliasedTableT> & AssertValidCurrentJoin<QueryT, AliasedTableT>), onDelegate: OnDelegate<QueryT["fromClause"], AliasedTableT, (RawOnClauseT & OnClauseUtil.AssertNoOuterQueryUsedRef<QueryT["fromClause"], RawOnClauseT>)>): (LeftJoin<QueryT, AliasedTableT>);
}
declare module "unified-query/util/operation/order-by" {
    import { OrderByDelegateColumns, OrderByDelegateReturnType } from "order-by-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    import { Correlate } from "unified-query/util/operation/correlate";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type OrderByImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type OrderBy<QueryT extends IQuery> = (OrderByImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export type QueryOrderByDelegate<QueryT extends IQuery> = (columns: OrderByDelegateColumns<QueryT["fromClause"], QueryT["selectClause"]>, subquery: Correlate<QueryT>) => OrderByDelegateReturnType<QueryT["fromClause"], QueryT["groupByClause"], QueryT["selectClause"]>;
    export function orderBy<QueryT extends IQuery>(query: QueryT, orderByDelegate: QueryOrderByDelegate<QueryT>): (OrderBy<QueryT>);
}
declare module "unified-query/util/operation/require-nullable-outer-query-joins" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IQuery } from "unified-query/query";
    import { Query } from "unified-query/query-impl";
    export type RequireNullableOuterQueryJoins<QueryT extends IQuery, AliasedTablesT extends readonly IAliasedTable[]> = (Query<{
        fromClause: FromClauseUtil.RequireNullableOuterQueryJoins<QueryT["fromClause"], AliasedTablesT>;
        selectClause: QueryT["selectClause"];
        limitClause: QueryT["limitClause"];
        compoundQueryClause: QueryT["compoundQueryClause"];
        compoundQueryLimitClause: QueryT["compoundQueryLimitClause"];
        mapDelegate: QueryT["mapDelegate"];
        groupByClause: QueryT["groupByClause"];
    }>);
    export function requireNullableOuterQueryJoins<QueryT extends IQuery, AliasedTablesT extends readonly IAliasedTable[]>(query: QueryT, ...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<QueryT["fromClause"], AliasedTablesT>)): (RequireNullableOuterQueryJoins<QueryT, AliasedTablesT>);
}
declare module "unified-query/util/operation/require-outer-query-joins" {
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IQuery } from "unified-query/query";
    import { Query } from "unified-query/query-impl";
    import { NewInstance } from "unified-query/util/constructor/index";
    export type NewInstanceWithOuterQueryJoins<AliasedTablesT extends readonly IAliasedTable[]> = Query<{
        fromClause: FromClauseUtil.NewInstanceWithOuterQueryJoins<false, AliasedTablesT>;
        selectClause: NewInstance["selectClause"];
        limitClause: NewInstance["limitClause"];
        compoundQueryClause: NewInstance["compoundQueryClause"];
        compoundQueryLimitClause: NewInstance["compoundQueryLimitClause"];
        mapDelegate: NewInstance["mapDelegate"];
        groupByClause: NewInstance["groupByClause"];
    }>;
    export type RequireOuterQueryJoins<QueryT extends IQuery, AliasedTablesT extends readonly IAliasedTable[]> = (Query<{
        fromClause: FromClauseUtil.RequireOuterQueryJoins<QueryT["fromClause"], AliasedTablesT>;
        selectClause: QueryT["selectClause"];
        limitClause: QueryT["limitClause"];
        compoundQueryClause: QueryT["compoundQueryClause"];
        compoundQueryLimitClause: QueryT["compoundQueryLimitClause"];
        mapDelegate: QueryT["mapDelegate"];
        groupByClause: QueryT["groupByClause"];
    }>);
    export function requireOuterQueryJoins<QueryT extends IQuery, AliasedTablesT extends readonly IAliasedTable[]>(query: QueryT, ...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<QueryT["fromClause"], AliasedTablesT>)): (RequireOuterQueryJoins<QueryT, AliasedTablesT>);
}
declare module "unified-query/util/operation/select" {
    import { SelectClause, SelectClauseUtil, SelectDelegateColumns, SelectDelegateReturnType } from "select-clause/index";
    import { Query } from "unified-query/query-impl";
    import { BeforeCompoundQueryClause } from "unified-query/util/helper-type/index";
    import { Correlate } from "unified-query/util/operation/correlate";
    import { BeforeSelectClause } from "query-base/util/index";
    import { GroupByClause } from "group-by-clause/index";
    import { IExprSelectItem } from "expr-select-item/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type SelectNoSelectClauseImpl<SelectsT extends SelectClause, FromClauseT extends BeforeCompoundQueryClause["fromClause"], LimitClauseT extends BeforeCompoundQueryClause["limitClause"], CompoundQueryClauseT extends BeforeCompoundQueryClause["compoundQueryClause"], CompoundQueryLimitClauseT extends BeforeCompoundQueryClause["compoundQueryLimitClause"], MapDelegateT extends BeforeCompoundQueryClause["mapDelegate"], GroupByClauseT extends BeforeCompoundQueryClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectsT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type SelectNoSelectClause<QueryT extends BeforeCompoundQueryClause & BeforeSelectClause, SelectsT extends SelectClause> = (SelectNoSelectClauseImpl<SelectsT, QueryT["fromClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type SelectImpl<SelectsT extends SelectClause, FromClauseT extends BeforeCompoundQueryClause["fromClause"], SelectClauseT extends BeforeCompoundQueryClause["selectClause"], LimitClauseT extends BeforeCompoundQueryClause["limitClause"], CompoundQueryClauseT extends BeforeCompoundQueryClause["compoundQueryClause"], CompoundQueryLimitClauseT extends BeforeCompoundQueryClause["compoundQueryLimitClause"], MapDelegateT extends BeforeCompoundQueryClause["mapDelegate"], GroupByClauseT extends BeforeCompoundQueryClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseUtil.Select<SelectClauseT, SelectsT>;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: (GroupByClauseT extends GroupByClause ? GroupByClauseT : (true extends Extract<SelectsT[number], IExprSelectItem>["isAggregate"] ? [] : undefined));
    }>);
    export type Select<QueryT extends BeforeCompoundQueryClause, SelectsT extends SelectClause> = (SelectImpl<SelectsT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export type QuerySelectDelegate<QueryT extends BeforeCompoundQueryClause, SelectsT extends SelectClause> = (columns: SelectDelegateColumns<QueryT["fromClause"]>, subquery: Correlate<QueryT>) => SelectDelegateReturnType<QueryT["fromClause"], QueryT["groupByClause"], QueryT["selectClause"], SelectsT>;
    export function select<QueryT extends BeforeCompoundQueryClause, SelectsT extends SelectClause>(query: QueryT, selectDelegate: QuerySelectDelegate<QueryT, SelectsT>): (Select<QueryT, SelectsT>);
}
declare module "unified-query/util/operation/select-value" {
    import { SelectClauseUtil, SelectDelegateColumns, SelectValueDelegateReturnType } from "select-clause/index";
    import { BeforeCompoundQueryClause } from "unified-query/util/helper-type/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { Select } from "unified-query/util/operation/select";
    import { Correlate } from "unified-query/util/operation/correlate";
    export type SelectValue<QueryT extends BeforeCompoundQueryClause, BuiltInExprT extends AnyBuiltInExpr> = (Select<QueryT, SelectClauseUtil.ValueFromBuiltInExpr<BuiltInExprT>>);
    export type QuerySelectValueDelegate<QueryT extends BeforeCompoundQueryClause, BuiltInExprT extends AnyBuiltInExpr> = (columns: SelectDelegateColumns<QueryT["fromClause"]>, subquery: Correlate<QueryT>) => SelectValueDelegateReturnType<QueryT["fromClause"], QueryT["selectClause"], BuiltInExprT>;
    /**
     * @todo Rename to `selectScalar`?
     */
    export function selectValue<QueryT extends BeforeCompoundQueryClause, BuiltInExprT extends AnyBuiltInExpr>(query: QueryT, selectValueDelegate: QuerySelectValueDelegate<QueryT, BuiltInExprT>): (SelectValue<QueryT, BuiltInExprT>);
}
declare module "unified-query/util/operation/where-eq-candidate-key" {
    import { FromClauseUtil } from "from-clause/index";
    import { JoinArrayUtil } from "join/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import * as TypeUtil from "type-util/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqCandidateKeyImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqCandidateKey<QueryT extends AfterFromClause> = (WhereEqCandidateKeyImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqCandidateKey<QueryT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithCandidateKey<QueryT["fromClause"]["currentJoins"]>>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<QueryT["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqCandidateKeyDelegate<QueryT["fromClause"], TableT>, TypeUtil.StrictUnion<CandidateKey_NonUnion<TableT>>] : never)): (WhereEqCandidateKey<QueryT>);
}
declare module "unified-query/util/operation/where-eq-columns" {
    import { FromClauseUtil } from "from-clause/index";
    import { PartialRow_NonUnion } from "partial-row/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqColumnsImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqColumns<QueryT extends AfterFromClause> = (WhereEqColumnsImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqColumns<QueryT extends AfterFromClause, TableT extends QueryT["fromClause"]["currentJoins"][number]>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends QueryT["fromClause"]["currentJoins"][number] ? [FromClauseUtil.WhereEqColumnsDelegate<QueryT["fromClause"], TableT>, PartialRow_NonUnion<TableT>] : never)): (WhereEqColumns<QueryT>);
}
declare module "unified-query/util/operation/where-eq-inner-query-primary-key" {
    import { FromClauseUtil } from "from-clause/index";
    import { JoinArrayUtil } from "join/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause, Correlated } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqInnerQueryPrimaryKeyImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqInnerQueryPrimaryKey<QueryT extends AfterFromClause> = (WhereEqInnerQueryPrimaryKeyImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqInnerQueryPrimaryKey<QueryT extends (Correlated & AfterFromClause), SrcT extends QueryT["fromClause"]["outerQueryJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<QueryT["fromClause"]["currentJoins"], SrcT["columns"]>>(query: QueryT, srcDelegate: FromClauseUtil.WhereEqInnerQueryPrimaryKeySrcDelegate<QueryT["fromClause"], SrcT>, dstDelegate: (FromClauseUtil.WhereEqInnerQueryPrimaryKeyDstDelegate<QueryT["fromClause"], SrcT, DstT>)): (WhereEqInnerQueryPrimaryKey<QueryT>);
}
declare module "unified-query/util/operation/where-eq-outer-query-primary-key" {
    import { FromClauseUtil } from "from-clause/index";
    import { JoinArrayUtil } from "join/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause, Correlated } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqOuterQueryPrimaryKeyImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqOuterQueryPrimaryKey<QueryT extends AfterFromClause> = (WhereEqOuterQueryPrimaryKeyImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqOuterQueryPrimaryKey<QueryT extends (Correlated & AfterFromClause), SrcT extends QueryT["fromClause"]["currentJoins"][number], DstT extends JoinArrayUtil.ExtractWithNullSafeComparablePrimaryKey<QueryT["fromClause"]["outerQueryJoins"], SrcT["columns"]>>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate: (SrcT extends QueryT["fromClause"]["currentJoins"][number] ? FromClauseUtil.WhereEqOuterQueryPrimaryKeySrcDelegate<QueryT["fromClause"], SrcT> : never), dstDelegate: (FromClauseUtil.WhereEqOuterQueryPrimaryKeyDstDelegate<QueryT["fromClause"], SrcT, DstT>)): (WhereEqOuterQueryPrimaryKey<QueryT>);
}
declare module "unified-query/util/operation/where-eq-primary-key" {
    import { FromClauseUtil } from "from-clause/index";
    import { JoinArrayUtil } from "join/index";
    import { PrimaryKey_NonUnion } from "primary-key/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqPrimaryKeyImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqPrimaryKey<QueryT extends AfterFromClause> = (WhereEqPrimaryKeyImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqPrimaryKey<QueryT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithPrimaryKey<QueryT["fromClause"]["currentJoins"]>>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithPrimaryKey<QueryT["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqPrimaryKeyDelegate<QueryT["fromClause"], TableT>, PrimaryKey_NonUnion<TableT>] : never)): (WhereEqPrimaryKey<QueryT>);
}
declare module "unified-query/util/operation/where-eq-super-key" {
    import { FromClauseUtil } from "from-clause/index";
    import { JoinArrayUtil } from "join/index";
    import { SuperKey_NonUnion } from "super-key/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqSuperKeyImpl<FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEqSuperKey<QueryT extends AfterFromClause> = (WhereEqSuperKeyImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEqSuperKey<QueryT extends AfterFromClause, TableT extends JoinArrayUtil.ExtractWithCandidateKey<QueryT["fromClause"]["currentJoins"]>>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (TableT extends JoinArrayUtil.ExtractWithCandidateKey<QueryT["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereEqSuperKeyDelegate<QueryT["fromClause"], TableT>, SuperKey_NonUnion<TableT>] : never)): (WhereEqSuperKey<QueryT>);
}
declare module "unified-query/util/operation/where-eq" {
    import * as tm from "type-mapping";
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnUtil } from "column/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereEqImpl<ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseUtil.WhereEq<FromClauseT, ColumnT, ValueT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereEq<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>> = (WhereEqImpl<ColumnT, ValueT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereEq<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>, ValueT extends tm.OutputOf<ColumnT["mapper"]>>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (ColumnT extends ColumnUtil.ExtractNonNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>> ? [FromClauseUtil.WhereEqDelegate<QueryT["fromClause"], ColumnT>, ValueT] : never)): (WhereEq<QueryT, ColumnT, ValueT>);
}
declare module "unified-query/util/operation/where-is-not-null" {
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnUtil } from "column/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNotNullImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseUtil.WhereIsNotNull<FromClauseT, ColumnT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereIsNotNull<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>> = (WhereIsNotNullImpl<ColumnT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereIsNotNull<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>>(query: QueryT, whereIsNotNullDelegate: FromClauseUtil.WhereIsNotNullDelegate<QueryT["fromClause"], ColumnT>): (WhereIsNotNull<QueryT, ColumnT>);
}
declare module "unified-query/util/operation/where-is-null" {
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnUtil } from "column/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereIsNullImpl<ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>>, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseUtil.WhereIsNull<FromClauseT, ColumnT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereIsNull<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>> = (WhereIsNullImpl<ColumnT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereIsNull<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.ExtractNullable<ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>>>(query: QueryT, whereIsNullDelegate: FromClauseUtil.WhereIsNullDelegate<QueryT["fromClause"], ColumnT>): (WhereIsNull<QueryT, ColumnT>);
}
declare module "unified-query/util/operation/where-null-safe-eq" {
    import * as tm from "type-mapping";
    import { FromClauseUtil } from "from-clause/index";
    import { ColumnUtil } from "column/index";
    import { Query } from "unified-query/query-impl";
    import { AfterFromClause } from "unified-query/util/helper-type/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereNullSafeEqImpl<ColumnT extends ColumnUtil.FromJoinArray<FromClauseT["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null, FromClauseT extends AfterFromClause["fromClause"], SelectClauseT extends AfterFromClause["selectClause"], LimitClauseT extends AfterFromClause["limitClause"], CompoundQueryClauseT extends AfterFromClause["compoundQueryClause"], CompoundQueryLimitClauseT extends AfterFromClause["compoundQueryLimitClause"], MapDelegateT extends AfterFromClause["mapDelegate"], GroupByClauseT extends AfterFromClause["groupByClause"]> = (Query<{
        fromClause: FromClauseUtil.WhereNullSafeEq<FromClauseT, ColumnT, ValueT>;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type WhereNullSafeEq<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null> = (WhereNullSafeEqImpl<ColumnT, ValueT, QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function whereNullSafeEq<QueryT extends AfterFromClause, ColumnT extends ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]>, ValueT extends tm.OutputOf<ColumnT["mapper"]> | null>(query: QueryT, 
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args: (ColumnT extends ColumnUtil.FromJoinArray<QueryT["fromClause"]["currentJoins"]> ? [FromClauseUtil.WhereNullSafeEqDelegate<QueryT["fromClause"], ColumnT>, ValueT] : never)): (WhereNullSafeEq<QueryT, ColumnT, ValueT>);
}
declare module "unified-query/util/operation/where" {
    import { WhereDelegate } from "where-clause/index";
    import { Query } from "unified-query/query-impl";
    import { IQuery } from "unified-query/query";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WhereImpl<FromClauseT extends IQuery["fromClause"], SelectClauseT extends IQuery["selectClause"], LimitClauseT extends IQuery["limitClause"], CompoundQueryClauseT extends IQuery["compoundQueryClause"], CompoundQueryLimitClauseT extends IQuery["compoundQueryLimitClause"], MapDelegateT extends IQuery["mapDelegate"], GroupByClauseT extends IQuery["groupByClause"]> = (Query<{
        fromClause: FromClauseT;
        selectClause: SelectClauseT;
        limitClause: LimitClauseT;
        compoundQueryClause: CompoundQueryClauseT;
        compoundQueryLimitClause: CompoundQueryLimitClauseT;
        mapDelegate: MapDelegateT;
        groupByClause: GroupByClauseT;
    }>);
    export type Where<QueryT extends IQuery> = (WhereImpl<QueryT["fromClause"], QueryT["selectClause"], QueryT["limitClause"], QueryT["compoundQueryClause"], QueryT["compoundQueryLimitClause"], QueryT["mapDelegate"], QueryT["groupByClause"]>);
    export function where<QueryT extends IQuery>(query: QueryT, whereDelegate: WhereDelegate<QueryT["fromClause"]>): (Where<QueryT>);
}
declare module "unified-query/util/operation/index" {
    export * from "unified-query/util/operation/compound-query-limit/index";
    export * from "unified-query/util/operation/compound-query-offset/index";
    export * from "unified-query/util/operation/limit/index";
    export * from "unified-query/util/operation/map/index";
    export * from "unified-query/util/operation/offset/index";
    export * from "unified-query/util/operation/compound-query-order-by";
    export * from "unified-query/util/operation/compound-query";
    export * from "unified-query/util/operation/correlate";
    export * from "unified-query/util/operation/cross-join";
    export * from "unified-query/util/operation/distinct";
    export * from "unified-query/util/operation/from";
    export * from "unified-query/util/operation/group-by";
    export * from "unified-query/util/operation/having";
    export * from "unified-query/util/operation/inner-join-using-candidate-key";
    export * from "unified-query/util/operation/inner-join-using-primary-key";
    export * from "unified-query/util/operation/inner-join";
    export * from "unified-query/util/operation/left-join-using-candidate-key";
    export * from "unified-query/util/operation/left-join-using-primary-key";
    export * from "unified-query/util/operation/left-join";
    export * from "unified-query/util/operation/order-by";
    export * from "unified-query/util/operation/require-nullable-outer-query-joins";
    export * from "unified-query/util/operation/require-outer-query-joins";
    export * from "unified-query/util/operation/select-value";
    export * from "unified-query/util/operation/select";
    export * from "unified-query/util/operation/where-eq-candidate-key";
    export * from "unified-query/util/operation/where-eq-columns";
    export * from "unified-query/util/operation/where-eq-inner-query-primary-key";
    export * from "unified-query/util/operation/where-eq-outer-query-primary-key";
    export * from "unified-query/util/operation/where-eq-primary-key";
    export * from "unified-query/util/operation/where-eq-super-key";
    export * from "unified-query/util/operation/where-eq";
    export * from "unified-query/util/operation/where-is-not-null";
    export * from "unified-query/util/operation/where-is-null";
    export * from "unified-query/util/operation/where-null-safe-eq";
    export * from "unified-query/util/operation/where";
}
declare module "unified-query/util/index" {
    export * from "unified-query/util/constructor/index";
    export * from "unified-query/util/helper-type/index";
    export * from "unified-query/util/operation/index";
    export * from "unified-query/util/predicate/index";
}
declare module "unified-query/convenience" {
    import * as QueryUtil from "unified-query/util/index";
    import { IAliasedTable } from "aliased-table/index";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectClause, SelectDelegate, SelectValueDelegate } from "select-clause/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    export function from<AliasedTableT extends IAliasedTable>(aliasedTable: (AliasedTableT & QueryUtil.AssertValidCurrentJoin<QueryUtil.NewInstance, AliasedTableT>)): (QueryUtil.From<QueryUtil.NewInstance, AliasedTableT>);
    export function requireOuterQueryJoins<AliasedTablesT extends readonly IAliasedTable[]>(...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<QueryUtil.NewInstance["fromClause"], AliasedTablesT>)): (QueryUtil.RequireOuterQueryJoins<QueryUtil.NewInstance, AliasedTablesT>);
    export function requireNullableOuterQueryJoins<AliasedTablesT extends readonly IAliasedTable[]>(...aliasedTables: (AliasedTablesT & FromClauseUtil.AssertValidOuterQueryJoins<QueryUtil.NewInstance["fromClause"], AliasedTablesT>)): (QueryUtil.RequireNullableOuterQueryJoins<QueryUtil.NewInstance, AliasedTablesT>);
    export function select<SelectsT extends SelectClause>(selectDelegate: SelectDelegate<QueryUtil.NewInstance["fromClause"], QueryUtil.NewInstance["groupByClause"], QueryUtil.NewInstance["selectClause"], SelectsT>): (QueryUtil.Select<QueryUtil.NewInstance, SelectsT>);
    export function selectValue<BuiltInExprT extends AnyBuiltInExpr>(selectValueDelegate: SelectValueDelegate<QueryUtil.NewInstance["fromClause"], QueryUtil.NewInstance["selectClause"], BuiltInExprT>): (QueryUtil.SelectValue<QueryUtil.NewInstance, BuiltInExprT>);
}
declare module "unified-query/index" {
    export * from "unified-query/convenience";
    export * from "unified-query/query-impl";
    export * from "unified-query/query";
    import * as QueryUtil from "unified-query/util/index";
    export { QueryUtil, };
}
declare module "execution/util/operation/impl/try-set-limit-2" {
    import { IQueryBase } from "query-base/index";
    /**
     * We use `LIMIT 2`,
     * because if we fetch more than one row,
     * we've messed up.
     *
     * But I don't want to fetch 1 million rows if we mess up.
     * This limits our failure.
     *
     * @todo Better naming
     */
    export function trySetLimit2<QueryT extends IQueryBase>(query: QueryT): QueryT;
}
declare module "execution/util/operation/impl/fetch-all-unmapped-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedResultSet } from "execution/util/helper-type/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchAllUnmappedImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<{
        sql: string;
        resultSet: UnmappedResultSet<QueryT>;
    }>);
}
declare module "execution/util/operation/impl/fetch-value-array-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchValueArrayImpl<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<{
        sql: string;
        resultSet: QueryBaseUtil.TypeOfSelectItem<QueryT>[];
    }>);
}
declare module "execution/util/operation/impl/fetch-value-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export interface FetchValueImplPromise<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated> extends Promise<{
        sql: string;
        value: QueryBaseUtil.TypeOfSelectItem<QueryT>;
    }> {
        or<DefaultValueT>(defaultValue: DefaultValueT): Promise<{
            sql: string;
            value: QueryBaseUtil.TypeOfSelectItem<QueryT> | DefaultValueT;
        }>;
        orUndefined(): Promise<{
            sql: string;
            value: QueryBaseUtil.TypeOfSelectItem<QueryT> | undefined;
        }>;
    }
    export function fetchValueImpl<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (FetchValueImplPromise<QueryT>);
}
declare module "execution/util/operation/impl/exists-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function existsImpl(query: QueryBaseUtil.NonCorrelated & (QueryBaseUtil.AfterFromClause | QueryBaseUtil.AfterSelectClause), connection: SelectConnection): (Promise<{
        sql: string;
        exists: boolean;
    }>);
}
declare module "execution/util/operation/impl/fetch-all-mapped-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { MappedResultSet } from "execution/util/helper-type/index";
    import { IsolableSelectConnection } from "execution/connection/index";
    export function fetchAllMappedImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated & QueryBaseUtil.Mapped>(query: QueryT, 
    /**
     * We need a full `IConnection` to pass to the `MapDelegate`.
     * However, ideally, it would only need to use transaction and `SELECT` statements...
     */
    connection: IsolableSelectConnection): (Promise<{
        sql: string;
        resultSet: MappedResultSet<QueryT>;
    }>);
}
declare module "execution/util/operation/impl/fetch-all-unmapped-flattened-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedFlattenedResultSet } from "execution/util/helper-type/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchAllUnmappedFlattenedImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<{
        sql: string;
        resultSet: UnmappedFlattenedResultSet<QueryT>;
    }>);
}
declare module "execution/util/operation/impl/fetch-all-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchAllConnection, FetchedResultSet } from "execution/util/helper-type/index";
    export function fetchAllImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>): (Promise<{
        sql: string;
        resultSet: FetchedResultSet<QueryT>;
    }>);
}
declare module "execution/util/operation/impl/fetch-one-impl" {
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { QueryBaseUtil } from "query-base/index";
    export interface FetchOneImplPromise<RowT extends unknown> extends Promise<{
        sql: string;
        row: RowT;
    }> {
        or<DefaultValueT>(defaultValue: DefaultValueT): Promise<{
            sql: string;
            row: RowT | DefaultValueT;
        }>;
        orUndefined(): Promise<{
            sql: string;
            row: RowT | undefined;
        }>;
    }
    export type FetchOneImplResult<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = FetchOneImplPromise<FetchedRow<QueryT>>;
    export function fetchOneImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>): (FetchOneImplResult<QueryT>);
}
declare module "execution/util/operation/impl/fetch-one-or-impl" {
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { QueryBaseUtil } from "query-base/index";
    export function fetchOneOrImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, DefaultValueT>(query: QueryT, connection: FetchAllConnection<QueryT>, defaultValue: DefaultValueT): (Promise<{
        sql: string;
        row: FetchedRow<QueryT> | DefaultValueT;
    }>);
}
declare module "execution/util/operation/impl/fetch-value-or-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchValueOrImpl<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated, DefaultValueT>(query: QueryT, connection: SelectConnection, defaultValue: DefaultValueT): (Promise<{
        sql: string;
        value: QueryBaseUtil.TypeOfSelectItem<QueryT> | DefaultValueT;
    }>);
}
declare module "execution/util/operation/impl/index" {
    export * from "execution/util/operation/impl/ensure-one-or";
    export * from "execution/util/operation/impl/ensure-one";
    export * from "execution/util/operation/impl/exists-impl";
    export * from "execution/util/operation/impl/fetch-all-mapped-impl";
    export * from "execution/util/operation/impl/fetch-all-unmapped-flattened-impl";
    export * from "execution/util/operation/impl/fetch-all-unmapped-impl";
    export * from "execution/util/operation/impl/fetch-all-impl";
    export * from "execution/util/operation/impl/fetch-one-or-impl";
    export * from "execution/util/operation/impl/fetch-one-impl";
    export * from "execution/util/operation/impl/fetch-value-array-impl";
    export * from "execution/util/operation/impl/fetch-value-or-impl";
    export * from "execution/util/operation/impl/fetch-value-impl";
    export * from "execution/util/operation/impl/try-set-limit-2";
}
declare module "execution/util/operation/fetch-value" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export interface FetchValuePromise<ValueT> extends Promise<ValueT> {
        or<DefaultValueT>(defaultValue: DefaultValueT): Promise<ValueT | DefaultValueT>;
        orUndefined(): Promise<ValueT | undefined>;
    }
    export type FetchValueReturnType<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated> = FetchValuePromise<QueryBaseUtil.TypeOfSelectItem<QueryT>>;
    export function fetchValue<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): FetchValueReturnType<QueryT>;
}
declare module "execution/util/operation/count" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    /**
     * @todo Optimize this further?
     * Or keep trusting DBMS execution engine?
     */
    export function count(query: QueryBaseUtil.NonCorrelated, connection: SelectConnection): Promise<bigint>;
}
declare module "execution/util/operation/paginate/remove-paginate-args" {
    import { QueryBaseUtil, IQueryBase } from "query-base/index";
    export function removePaginateArgs<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT): (Pick<QueryT, Exclude<keyof IQueryBase, "limitClause" | "compoundQueryLimitClause">> & Pick<IQueryBase, "limitClause" | "compoundQueryLimitClause">);
}
declare module "execution/util/operation/paginate/paginate" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { RawPaginateArgs } from "execution/util/operation/paginate/paginate-args";
    export interface PaginateInfo {
        rowsFound: bigint;
        pagesFound: bigint;
        page: bigint;
        rowsPerPage: bigint;
        rowOffset: bigint;
    }
    export interface PaginateResult<T> {
        info: PaginateInfo;
        rows: T[];
    }
    export type Paginate<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = (PaginateResult<FetchedRow<QueryT>>);
    export function paginate<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>, rawArgs: RawPaginateArgs): Promise<Paginate<QueryT>>;
}
declare module "execution/util/operation/paginate/index" {
    export * from "execution/util/operation/paginate/apply-paginate-args";
    export * from "execution/util/operation/paginate/paginate-args";
    export * from "execution/util/operation/paginate/paginate";
    export * from "execution/util/operation/paginate/remove-paginate-args";
}
declare module "execution/util/operation/emulated-cursor/emulated-cursor" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { RawPaginateArgs } from "execution/util/operation/paginate/index";
    export type EmulatedCursor<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = AsyncIterableIterator<FetchedRow<QueryT>>;
    /**
     * Considerations:
     * + MySQL **does not** support cursors at the protocol level
     *   + https://github.com/sidorares/node-mysql2/issues/1014
     *   + https://github.com/sidorares/node-mysql2/pull/822#issuecomment-409415308
     *   + https://github.com/sidorares/node-mysql2/blob/9404163b0dc4bdc24f6dddd18144532f41115842/lib/commands/query.js#L239
     *   + https://github.com/mysqljs/mysql/issues/274
     * + Cursors are useful for processing large amounts of data without loading everything into memory at once
     * + Cursors can prevent out-of-memory exceptions, since data is loaded in batches
     *
     * -----
     *
     * Since cursors are not natively supported (by MySQL), we emulate it using pagination.
     * So, we use the `LIMIT` and `OFFSET` clauses, and load rows in batches as we iterate.
     *
     * -----
     *
     * ### Preventing Duplicate Items
     *
     * ```ts
     *  const cursor = myQuery.emulatedCursor();
     *  for await (const row of cursor) {
     *      console.log(row);
     *      //snip operations on `row`
     *  }
     * ```
     *
     * Given the above, we might be expecting output like,
     * ```ts
     * //batch 1
     * > { rowId : 1 }
     * > { rowId : 2 }
     *
     * //batch 2
     * > { rowId : 3 }
     * > { rowId : 4 }
     *
     * //batch n
     * > etc.
     * ```
     *
     * We might actually get,
     * ```ts
     * //batch 1
     * > { rowId : 1 }
     * > { rowId : 2 }
     *
     * //batch 2
     * > { rowId : 2 } //This is a duplicate item, what gives?
     * > { rowId : 3 }
     *
     * //batch 3
     * > { rowId : 4 }
     * > { rowId : 5 }
     *
     * //batch n
     * > etc.
     * ```
     *
     * This can happen for a variety of reasons,
     * + Missing `ORDER BY` clause
     *   + Without an `ORDER BY` clause, the order that rows are returned in is undefined behaviour.
     *   + Rows are retrieved in batches and a row may appear in multiple batches.
     *   + To fix, add an `ORDER BY` clause
     *
     * + Non-unique ordering
     *   + The `ORDER BY` clause may not guarantee a unique ordering
     *   + To fix, modify the `ORDER BY` clause and guarantee a unique ordering
     *
     * + Not using a transaction
     *   + A different connection may have inserted a row into the table you are iterating over
     *
     *     The new row may have pushed other rows "down" the table,
     *     causing the next retrieved batch to contain rows already seen.
     *
     *   + To fix, use the cursor in a transaction
     *
     * + Modifying the table being iterated over
     *   + `INSERT/DELETE/UPDATE` statements may modify the table you are iterating over.
     *   + Consider buffering mutations into a temporary table first,
     *     then apply the mutations after you are done iterating.
     *   + Consider performing your mutations in a way that does not interfere with your `ORDER BY` clause.
     *
     * -----
     *
     * With an `ORDER BY` clause that guarantees a unique ordering, you can pretend the above `cursor` code is,
     * ```ts
     * declare const cursor : MyRowT[];
     * for (const row of cursor) {
     *      console.log(row);
     *      //snip operations on `row`
     * }
     * ```
     *
     * Modifying the `cursor` array may cause unexpected behaviour during iteration.
     *
     * There are ways to safely iterate and modify an array at the same time,
     * like iterating backwards while adding elements to the end of the array.
     *
     * -----
     *
     * ### Preventing Infinite Loops
     *
     * ```ts
     *  const cursor = myQuery.emulatedCursor();
     *  for await (const row of cursor) {
     *      console.log(row);
     *      const nextRowId = row.rowId+1;
     *      //INSERT INTO myTable (rowId) VALUES(:nextRowId)
     *  }
     * ```
     *
     * Given the above, it is possible for the loop to never terminate.
     * Or, rather, it will terminate after it uses all the disk space it has access to.
     *
     * -----
     *
     * The above code is similar to the following,
     * ```ts
     *  arr = [1];
     *  for (const i of arr) {
     *      console.log(i);
     *      arr.push(i+1);
     *  }
     * ```
     *
     * This will result in an infinite loop (or crash when out of memory).
     */
    export function emulatedCursor<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>, 
    /**
     * If set, determines the starting `page` of the cursor.
     * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
     */
    rawArgs?: RawPaginateArgs): EmulatedCursor<QueryT>;
}
declare module "execution/util/operation/emulated-cursor/emulated-cursor-impl" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { RawPaginateArgs } from "execution/util/operation/paginate/index";
    import { EmulatedCursor } from "execution/util/operation/emulated-cursor/emulated-cursor";
    export class EmulatedCursorImpl<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> implements EmulatedCursor<QueryT> {
        private readonly query;
        private readonly connection;
        private readonly startPage;
        private readonly rowsPerPage;
        private readonly rowOffset;
        /**
         * This is a number because we'll be performing
         * array index access.
         */
        private rowIndex;
        private buffer;
        private BigInt;
        constructor(query: QueryT, connection: FetchAllConnection<QueryT>, rawArgs: RawPaginateArgs);
        private getOrFetchBuffer;
        private tryGetNextRow;
        private tryFetchNextPage;
        next(): Promise<IteratorResult<FetchedRow<QueryT>>>;
        [Symbol.asyncIterator](): this;
    }
}
declare module "execution/util/operation/emulated-cursor/index" {
    export * from "execution/util/operation/emulated-cursor/emulated-cursor-impl";
    export * from "execution/util/operation/emulated-cursor/emulated-cursor";
}
declare module "execution/util/operation/assert-exists" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function assertExists(query: QueryBaseUtil.NonCorrelated & (QueryBaseUtil.AfterFromClause | QueryBaseUtil.AfterSelectClause), connection: SelectConnection): Promise<void>;
}
declare module "execution/util/operation/exists" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function exists(query: QueryBaseUtil.NonCorrelated & (QueryBaseUtil.AfterFromClause | QueryBaseUtil.AfterSelectClause), connection: SelectConnection): Promise<boolean>;
}
declare module "execution/util/operation/fetch-all-mapped" {
    import { QueryBaseUtil } from "query-base/index";
    import { MappedResultSet } from "execution/util/helper-type/index";
    import { IsolableSelectConnection } from "execution/connection/index";
    export function fetchAllMapped<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated & QueryBaseUtil.Mapped>(query: QueryT, 
    /**
     * We need a full `IConnection` to pass to the `MapDelegate`.
     * However, ideally, it would only need to use transaction and `SELECT` statements...
     */
    connection: IsolableSelectConnection): Promise<MappedResultSet<QueryT>>;
}
declare module "execution/util/operation/fetch-all-unmapped-flattened" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedFlattenedResultSet } from "execution/util/helper-type/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchAllUnmappedFlattened<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): Promise<UnmappedFlattenedResultSet<QueryT>>;
}
declare module "execution/util/operation/fetch-all-unmapped" {
    import { QueryBaseUtil } from "query-base/index";
    import { UnmappedResultSet } from "execution/util/helper-type/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchAllUnmapped<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<UnmappedResultSet<QueryT>>);
}
declare module "execution/util/operation/fetch-all" {
    import { QueryBaseUtil } from "query-base/index";
    import { FetchAllConnection, FetchedResultSet } from "execution/util/helper-type/index";
    /**
     * Combines `fetchAllUnmappedFlattened()` and `fetchAllMapped()` for convenience.
     */
    export function fetchAll<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>): Promise<FetchedResultSet<QueryT>>;
}
declare module "execution/util/operation/fetch-one-or-undefined" {
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { QueryBaseUtil } from "query-base/index";
    export function fetchOneOrUndefined<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>): Promise<FetchedRow<QueryT> | undefined>;
}
declare module "execution/util/operation/fetch-one-or" {
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { QueryBaseUtil } from "query-base/index";
    export function fetchOneOr<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, DefaultValueT>(query: QueryT, connection: FetchAllConnection<QueryT>, defaultValue: DefaultValueT): Promise<FetchedRow<QueryT> | DefaultValueT>;
}
declare module "execution/util/operation/fetch-one" {
    import { FetchAllConnection, FetchedRow } from "execution/util/helper-type/index";
    import { QueryBaseUtil } from "query-base/index";
    export interface FetchOnePromise<RowT> extends Promise<RowT> {
        or<DefaultValueT>(defaultValue: DefaultValueT): Promise<RowT | DefaultValueT>;
        orUndefined(): Promise<RowT | undefined>;
    }
    export type FetchOneReturnType<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated> = FetchOnePromise<FetchedRow<QueryT>>;
    export function fetchOne<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: FetchAllConnection<QueryT>): FetchOneReturnType<QueryT>;
}
declare module "execution/util/operation/fetch-value-array" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchValueArray<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<QueryBaseUtil.TypeOfSelectItem<QueryT>[]>);
}
declare module "execution/util/operation/fetch-value-or-undefined" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchValueOrUndefined<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated>(query: QueryT, connection: SelectConnection): (Promise<QueryBaseUtil.TypeOfSelectItem<QueryT> | undefined>);
}
declare module "execution/util/operation/fetch-value-or" {
    import { QueryBaseUtil } from "query-base/index";
    import { SelectConnection } from "execution/connection/index";
    export function fetchValueOr<QueryT extends QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.NonCorrelated, DefaultValueT>(query: QueryT, connection: SelectConnection, defaultValue: DefaultValueT): (Promise<QueryBaseUtil.TypeOfSelectItem<QueryT> | DefaultValueT>);
}
declare module "execution/util/operation/index" {
    export * from "execution/util/operation/emulated-cursor/index";
    export * from "execution/util/operation/impl/index";
    export * from "execution/util/operation/paginate/index";
    export * from "execution/util/operation/assert-exists";
    export * from "execution/util/operation/count";
    export * from "execution/util/operation/exists";
    export * from "execution/util/operation/fetch-all-mapped";
    export * from "execution/util/operation/fetch-all-unmapped-flattened";
    export * from "execution/util/operation/fetch-all-unmapped";
    export * from "execution/util/operation/fetch-all";
    export * from "execution/util/operation/fetch-one-or-undefined";
    export * from "execution/util/operation/fetch-one-or";
    export * from "execution/util/operation/fetch-one";
    export * from "execution/util/operation/fetch-value-array";
    export * from "execution/util/operation/fetch-value-or-undefined";
    export * from "execution/util/operation/fetch-value-or";
    export * from "execution/util/operation/fetch-value";
}
declare module "execution/util/operation-delete/delete" {
    import { DeletableTable } from "table/index";
    import { WhereDelegate, WhereClause } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { DeleteResult, DeleteConnection } from "execution/connection/index";
    export function deleteImplNoEvent<TableT extends DeletableTable>(table: TableT, connection: DeleteConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): (Promise<{
        whereClause: WhereClause;
        deleteResult: DeleteResult;
    }>);
    function del<TableT extends DeletableTable>(table: TableT, connection: DeleteConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): Promise<DeleteResult>;
    export { del as delete, };
}
declare module "isolation-level" {
    /**
     * Isolation levels ranked from weakest to strongest,
     * 1. `READ_UNCOMMITTED`
     * 2. `READ_COMMITTED`
     * 3. `REPEATABLE_READ`
     * 4. `SERIALIZABLE`
     *
     * https://github.com/AnyhowStep/tsql/issues/14
     */
    export enum IsolationLevel {
        READ_UNCOMMITTED = "READ_UNCOMMITTED",
        READ_COMMITTED = "READ_COMMITTED",
        REPEATABLE_READ = "REPEATABLE_READ",
        SERIALIZABLE = "SERIALIZABLE"
    }
    export namespace IsolationLevelUtil {
        /**
         * Is isolation level `a` weaker than `b`?
         */
        function isWeakerThan(a: IsolationLevel, b: IsolationLevel): boolean;
    }
}
declare module "execution/util/operation-delete/delete-one" {
    import { DeletableTable } from "table/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IsolableDeleteConnection } from "execution/connection/index";
    export interface DeleteOneResult {
        query: {
            sql: string;
        };
        deletedRowCount: 1n;
        /**
         * @todo MySQL sometimes gives a `warningCount` value `> 0` for
         * `DELETE` statements. Recall why.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export function deleteOne<TableT extends DeletableTable>(table: TableT, connection: IsolableDeleteConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): Promise<DeleteOneResult>;
}
declare module "execution/util/operation-delete/delete-zero-or-one" {
    import { DeletableTable } from "table/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IsolableDeleteConnection } from "execution/connection/index";
    export interface DeleteZeroOrOneResult {
        query: {
            sql: string;
        };
        deletedRowCount: 0n | 1n;
        /**
         * @todo MySQL sometimes gives a `warningCount` value `> 0` for
         * `DELETE` statements. Recall why.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export function deleteZeroOrOne<TableT extends DeletableTable>(table: TableT, connection: IsolableDeleteConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): Promise<DeleteZeroOrOneResult>;
}
declare module "execution/util/operation-delete/index" {
    export * from "execution/util/operation-delete/delete-one";
    export * from "execution/util/operation-delete/delete-zero-or-one";
    export * from "execution/util/operation-delete/delete";
}
declare module "execution/util/operation-insert/insert-one" {
    import { ITable, TableWithAutoIncrement, InsertableTable } from "table/index";
    import { InsertOneConnection, InsertOneResult, IConnection } from "execution/connection/index";
    import { CustomInsertRow, BuiltInInsertRow } from "insert/index";
    import { InsertOneEvent, InsertEvent } from "event/index";
    export type InsertOneResultWithAutoIncrement<AutoIncrementColumnAlias extends string> = InsertOneResult & {
        autoIncrementId: bigint;
    } & {
        [columnAlias in AutoIncrementColumnAlias]: bigint;
    };
    export type InsertOneWithAutoIncrementReturnType<TableT extends TableWithAutoIncrement> = InsertOneResultWithAutoIncrement<TableT["autoIncrement"]>;
    export function insertOneImplNoEvent<TableT extends ITable & InsertableTable>(table: TableT, connection: InsertOneConnection, row: CustomInsertRow<TableT>): (Promise<{
        insertRow: BuiltInInsertRow<TableT>;
        insertResult: (TableT extends TableWithAutoIncrement ? InsertOneWithAutoIncrementReturnType<TableT> : InsertOneResult);
    }>);
    export function createInsertOneEvents<TableT extends ITable & InsertableTable>(table: TableT, fullConnection: IConnection, insertRow: BuiltInInsertRow<TableT>, insertResult: InsertOneResult): ({
        insertEvent: InsertEvent<TableT>;
        insertOneEvent: InsertOneEvent<TableT>;
    });
    /**
     * Only inserts one row
     * ```sql
     *  INSERT INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     */
    export function insertOne<TableT extends ITable & InsertableTable>(table: TableT, connection: InsertOneConnection, row: CustomInsertRow<TableT>): (Promise<TableT extends TableWithAutoIncrement ? InsertOneWithAutoIncrementReturnType<TableT> : InsertOneResult>);
}
declare module "execution/util/operation-insert/insert-and-fetch" {
    import { ITable, TableWithAutoIncrement, InsertableTable, TableUtil } from "table/index";
    import { IsolableInsertOneConnection } from "execution/connection/index";
    import { CustomInsertRow, CustomInsertRowWithCandidateKey } from "insert/index";
    import { Identity, AssertSubsetOwnEnumerableKeys } from "type-util/index";
    import { CustomExprUtil } from "custom-expr/index";
    export type InsertAndFetchRow<TableT extends InsertableTable> = TableT extends TableWithAutoIncrement ? CustomInsertRow<TableT> : CustomInsertRowWithCandidateKey<TableT>;
    export type InsertedAndFetchedRow<TableT extends InsertableTable, RowT extends InsertAndFetchRow<TableT>> = Identity<{
        readonly [columnAlias in TableUtil.ColumnAlias<TableT>]: (columnAlias extends keyof RowT ? (undefined extends RowT[columnAlias] ? TableUtil.ColumnType<TableT, columnAlias> : CustomExprUtil.TypeOf<RowT[columnAlias]>) : TableUtil.ColumnType<TableT, columnAlias>);
    }>;
    /**
     * Added for `TablePerTypeUtil.insertAndFetch()`,
     * which needs to set `explicitAutoIncrementValueEnabled : true`,
     * to synchronize autoIncrement column values across the table hierarchy.
     */
    export interface InsertAndFetchOptions {
        explicitAutoIncrementValueEnabled?: boolean;
    }
    /**
     * Convenience method for
     * ```ts
     *  connection.transactionIfNotInOne(IsolationLevel.REPEATABLE_READ, async (connection) => {
     *      await table.insertOne(connection, ...);
     *      return table.fetchOne(connection, ...);
     *  });
     * ```
     */
    export function insertAndFetch<TableT extends ITable & InsertableTable, RowT extends InsertAndFetchRow<TableT>>(table: TableT, connection: IsolableInsertOneConnection, row: RowT & AssertSubsetOwnEnumerableKeys<RowT, InsertAndFetchRow<TableT>>, insertAndFetchOptions?: InsertAndFetchOptions): (Promise<InsertedAndFetchedRow<TableT, RowT>>);
}
declare module "execution/util/operation-insert/insert-ignore-many" {
    import { ITable, InsertableTable } from "table/index";
    import { InsertIgnoreManyConnection, InsertIgnoreManyResult } from "execution/connection/index";
    import { CustomInsertRow } from "insert/index";
    /**
     * Inserts zero-to-many rows
     * ```sql
     *  INSERT IGNORE INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    export function insertIgnoreMany<TableT extends ITable & InsertableTable>(table: TableT, connection: InsertIgnoreManyConnection, rows: readonly CustomInsertRow<TableT>[]): (Promise<InsertIgnoreManyResult>);
}
declare module "execution/util/operation-insert/insert-ignore-one" {
    import { ITable, TableWithAutoIncrement, InsertableTable } from "table/index";
    import { IgnoredInsertOneResult, InsertIgnoreOneResult, InsertIgnoreOneConnection } from "execution/connection/index";
    import { CustomInsertRow } from "insert/index";
    import { InsertOneResultWithAutoIncrement } from "execution/util/operation-insert/insert-one";
    import { Identity } from "type-util/index";
    export type IgnoredInsertOneResultWithAutoIncrement<AutoIncrementColumnAlias extends string> = Identity<IgnoredInsertOneResult & {
        [columnAlias in AutoIncrementColumnAlias]: undefined;
    }>;
    export type InsertIgnoreOneResultWithAutoIncrement<AutoIncrementColumnAlias extends string> = IgnoredInsertOneResultWithAutoIncrement<AutoIncrementColumnAlias> | InsertOneResultWithAutoIncrement<AutoIncrementColumnAlias>;
    export type InsertIgnoreOneWithAutoIncrementReturnType<TableT extends TableWithAutoIncrement> = InsertIgnoreOneResultWithAutoIncrement<TableT["autoIncrement"]>;
    /**
     * Only inserts zero or one row
     * ```sql
     *  INSERT IGNORE INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     */
    export function insertIgnoreOne<TableT extends ITable & InsertableTable>(table: TableT, connection: InsertIgnoreOneConnection, row: CustomInsertRow<TableT>): (Promise<TableT extends TableWithAutoIncrement ? InsertIgnoreOneWithAutoIncrementReturnType<TableT> : InsertIgnoreOneResult>);
}
declare module "execution/util/operation-insert/insert-many" {
    import { ITable, InsertableTable } from "table/index";
    import { InsertManyResult, InsertManyConnection } from "execution/connection/index";
    import { CustomInsertRow } from "insert/index";
    /**
     * Inserts zero-to-many rows
     * ```sql
     *  INSERT INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    export function insertMany<TableT extends ITable & InsertableTable>(table: TableT, connection: InsertManyConnection, rows: readonly CustomInsertRow<TableT>[]): (Promise<InsertManyResult>);
}
declare module "execution/util/operation-insert/replace-many" {
    import { InsertableTable, DeletableTable } from "table/index";
    import { ReplaceManyConnection, ReplaceManyResult } from "execution/connection/index";
    import { CustomInsertRow } from "insert/index";
    /**
     * Inserts/Replaces zero-to-many rows
     * ```sql
     *  REPLACE INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    export function replaceMany<TableT extends InsertableTable & DeletableTable>(table: TableT, connection: ReplaceManyConnection, rows: readonly CustomInsertRow<TableT>[]): (Promise<ReplaceManyResult>);
}
declare module "execution/util/operation-insert/replace-one" {
    import { InsertableTable, DeletableTable, TableWithAutoIncrement } from "table/index";
    import { ReplaceOneResult, ReplaceOneConnection, IConnection } from "execution/connection/index";
    import { CustomInsertRow, BuiltInInsertRow } from "insert/index";
    import { ReplaceEvent, ReplaceOneEvent } from "event/index";
    export type ReplaceOneResultWithAutoIncrement<AutoIncrementColumnAlias extends string> = ReplaceOneResult & {
        autoIncrementId: bigint;
    } & {
        [columnAlias in AutoIncrementColumnAlias]: bigint;
    };
    export type ReplaceOneWithAutoIncrementReturnType<TableT extends TableWithAutoIncrement> = ReplaceOneResultWithAutoIncrement<TableT["autoIncrement"]>;
    export function replaceOneImplNoEvent<TableT extends InsertableTable & DeletableTable>(table: TableT, connection: ReplaceOneConnection, row: CustomInsertRow<TableT>): (Promise<{
        insertRow: BuiltInInsertRow<TableT>;
        replaceResult: (TableT extends TableWithAutoIncrement ? ReplaceOneWithAutoIncrementReturnType<TableT> : ReplaceOneResult);
    }>);
    export function createReplaceOneEvents<TableT extends InsertableTable & DeletableTable>(table: TableT, fullConnection: IConnection, insertRow: BuiltInInsertRow<TableT>, replaceResult: ReplaceOneResult): ({
        replaceEvent: ReplaceEvent<TableT>;
        replaceOneEvent: ReplaceOneEvent<TableT>;
    });
    /**
     * Only inserts/replaces one row
     * ```sql
     *  REPLACE INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     *
     * The table must allow both `INSERT` and `DELETE`.
     * Replacing a row is essentially deleting the old row and inserting a new row.
     */
    export function replaceOne<TableT extends InsertableTable & DeletableTable>(table: TableT, connection: ReplaceOneConnection, row: CustomInsertRow<TableT>): (Promise<TableT extends TableWithAutoIncrement ? ReplaceOneWithAutoIncrementReturnType<TableT> : ReplaceOneResult>);
}
declare module "execution/util/operation-insert/index" {
    export * from "execution/util/operation-insert/insert-and-fetch";
    export * from "execution/util/operation-insert/insert-ignore-many";
    export * from "execution/util/operation-insert/insert-ignore-one";
    export * from "execution/util/operation-insert/insert-many";
    export * from "execution/util/operation-insert/insert-one";
    export * from "execution/util/operation-insert/replace-many";
    export * from "execution/util/operation-insert/replace-one";
}
declare module "execution/util/operation-insert-select/insert-ignore-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable } from "table/index";
    import { InsertSelectDelegate } from "insert-select/index";
    import { InsertIgnoreManyResult, InsertIgnoreSelectConnection } from "execution/connection/index";
    export function insertIgnoreSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable>(connection: InsertIgnoreSelectConnection, query: QueryT, table: TableT, rowDelegate: InsertSelectDelegate<QueryT, TableT>): Promise<InsertIgnoreManyResult>;
}
declare module "execution/util/operation-insert-select/insert-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable } from "table/index";
    import { InsertSelectDelegate } from "insert-select/index";
    import { InsertSelectConnection, InsertManyResult } from "execution/connection/index";
    export function insertSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable>(connection: InsertSelectConnection, query: QueryT, table: TableT, rowDelegate: InsertSelectDelegate<QueryT, TableT>): Promise<InsertManyResult>;
}
declare module "execution/util/operation-insert-select/replace-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable, DeletableTable } from "table/index";
    import { InsertSelectDelegate } from "insert-select/index";
    import { ReplaceManyResult, ReplaceSelectConnection } from "execution/connection/index";
    export function replaceSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable & DeletableTable>(connection: ReplaceSelectConnection, query: QueryT, table: TableT, rowDelegate: InsertSelectDelegate<QueryT, TableT>): Promise<ReplaceManyResult>;
}
declare module "execution/util/operation-insert-select/index" {
    export * from "execution/util/operation-insert-select/insert-ignore-select";
    export * from "execution/util/operation-insert-select/insert-select";
    export * from "execution/util/operation-insert-select/replace-select";
}
declare module "execution/util/operation-update/update" {
    import { ITable } from "table/index";
    import { WhereDelegate, WhereClause } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { UpdateConnection, UpdateResult } from "execution/connection/index";
    import { AssignmentMapDelegate, BuiltInAssignmentMap, CustomAssignmentMap } from "update/index";
    export function updateImplNoEvent<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: UpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): (Promise<{
        whereClause: WhereClause;
        assignmentMap: BuiltInAssignmentMap<TableT>;
        updateResult: UpdateResult;
    }>);
    export function update<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: UpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateResult>;
}
declare module "execution/util/operation-update/update-one" {
    import { ITable } from "table/index";
    import { WhereDelegate, WhereClause } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, BuiltInAssignmentMap, CustomAssignmentMap } from "update/index";
    export interface UpdateOneResult {
        query: {
            sql: string;
        };
        foundRowCount: 1n;
        updatedRowCount: 0n | 1n;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export function updateOneImplNoEvent<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        whereClause: WhereClause;
        assignmentMap: BuiltInAssignmentMap<TableT>;
        updateResult: UpdateOneResult;
    }>;
    export function updateOne<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateOneResult>;
}
declare module "execution/util/operation-update/update-and-fetch-one-impl" {
    import { ITable, TableUtil } from "table/index";
    import { IsolableUpdateConnection, IsolatedUpdateConnection } from "execution/connection/index";
    import { CustomAssignmentMap, BuiltInAssignmentMap } from "update/index";
    import { Identity } from "type-util/index";
    import { UpdateOneResult } from "execution/util/operation-update/update-one";
    import { CustomExprUtil } from "custom-expr/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    export type UpdatedAndFetchedRow<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>> = Identity<{
        readonly [columnAlias in TableUtil.ColumnAlias<TableT>]: (columnAlias extends keyof AssignmentMapT ? (undefined extends AssignmentMapT[columnAlias] ? TableUtil.ColumnType<TableT, columnAlias> : CustomExprUtil.TypeOf<AssignmentMapT[columnAlias]>) : TableUtil.ColumnType<TableT, columnAlias>);
    }>;
    export type UpdateAndFetchOneResult<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>> = Identity<UpdateOneResult & {
        row: UpdatedAndFetchedRow<TableT, AssignmentMapT>;
    }>;
    /**
     * This should not be called directly by users.
     *
     * A lot can go wrong here...
     */
    export function updateAndFetchOneImpl<TableT extends ITable, 
    /**
     * This is `updateAndFetchOneImpl()` because we only accept `BuiltInAssignmentMap`.
     * We do not accept `CustomAssignmentMap`.
     */
    AssignmentMapT extends BuiltInAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, initCallback: (connection: IsolatedUpdateConnection) => Promise<{
        /**
         * We need two separate `WHERE` clauses because
         * the `UPDATE` statement may change the unique identifier
         * of the row.
         */
        updateWhereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>;
        fetchWhereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>;
        assignmentMap: AssignmentMapT;
    }>): Promise<UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-one-by-candidate-key" {
    import { ITable, TableUtil } from "table/index";
    import { IsolableUpdateConnection, SelectConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, CustomAssignmentMap } from "update/index";
    import { CandidateKey_NonUnion, CandidateKey_Input } from "candidate-key/index";
    import { StrictUnion, Identity } from "type-util/index";
    import { CustomExpr_MapCorrelatedOrUndefined } from "custom-expr/index";
    import { RowNotFoundError } from "error/index";
    import { UpdateAndFetchOneResult } from "execution/util/operation-update/update-and-fetch-one-impl";
    export type UpdateAndFetchOneByCandidateKeyAssignmentMapImpl<TableT extends ITable> = Identity<{
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (CustomExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    }>;
    export type UpdateAndFetchOneByCandidateKeyAssignmentMap<TableT extends ITable> = Extract<
    /**
     * @todo Investigate assignability
     */
    UpdateAndFetchOneByCandidateKeyAssignmentMapImpl<TableT>, CustomAssignmentMap<TableT>>;
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    export function __updateAndFetchOneByCandidateKeyHelper<TableT extends ITable, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TableT>>, AssignmentMapT extends UpdateAndFetchOneByCandidateKeyAssignmentMap<TableT>>(table: TableT, connection: SelectConnection, candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        success: false;
        rowNotFoundError: RowNotFoundError;
    } | {
        success: true;
        curCandidateKey: StrictUnion<CandidateKey_Input<TableT>>;
        assignmentMap: UpdateAndFetchOneByCandidateKeyAssignmentMap<TableT>;
        newCandidateKey: StrictUnion<CandidateKey_Input<TableT>>;
    }>;
    export function updateAndFetchOneByCandidateKey<TableT extends ITable, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TableT>>, AssignmentMapT extends UpdateAndFetchOneByCandidateKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-one-by-primary-key" {
    import { TableUtil, TableWithPrimaryKey } from "table/index";
    import { IsolableUpdateConnection, SelectConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, CustomAssignmentMap } from "update/index";
    import { Identity } from "type-util/index";
    import { CustomExpr_MapCorrelatedOrUndefined } from "custom-expr/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { RowNotFoundError } from "error/index";
    import { UpdateAndFetchOneResult } from "execution/util/operation-update/update-and-fetch-one-impl";
    export type UpdateAndFetchOneByPrimaryKeyAssignmentMapImpl<TableT extends TableWithPrimaryKey> = Identity<{
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (CustomExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    }>;
    export type UpdateAndFetchOneByPrimaryKeyAssignmentMap<TableT extends TableWithPrimaryKey> = Extract<
    /**
     * @todo Investigate assignability
     */
    UpdateAndFetchOneByPrimaryKeyAssignmentMapImpl<TableT>, CustomAssignmentMap<TableT>>;
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    export function __updateAndFetchOneByPrimaryKeyHelper<TableT extends TableWithPrimaryKey, AssignmentMapT extends UpdateAndFetchOneByPrimaryKeyAssignmentMap<TableT>>(table: TableT, connection: SelectConnection, primaryKey: PrimaryKey_Input<TableT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        success: false;
        rowNotFoundError: RowNotFoundError;
    } | {
        success: true;
        curPrimaryKey: PrimaryKey_Input<TableT>;
        assignmentMap: UpdateAndFetchOneByPrimaryKeyAssignmentMap<TableT>;
        newPrimaryKey: PrimaryKey_Input<TableT>;
    }>;
    export function updateAndFetchOneByPrimaryKey<TableT extends TableWithPrimaryKey, AssignmentMapT extends UpdateAndFetchOneByPrimaryKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<TableT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-one-by-super-key" {
    import { ITable, TableUtil } from "table/index";
    import { IsolableUpdateConnection, SelectConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, CustomAssignmentMap } from "update/index";
    import { AssertNonUnion, Identity } from "type-util/index";
    import { CustomExpr_MapCorrelatedOrUndefined } from "custom-expr/index";
    import { SuperKey_Input } from "super-key/index";
    import { RowNotFoundError } from "error/index";
    import { UpdateAndFetchOneResult } from "execution/util/operation-update/update-and-fetch-one-impl";
    export type UpdateAndFetchOneBySuperKeyAssignmentMapImpl<TableT extends ITable> = Identity<{
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (CustomExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    }>;
    export type UpdateAndFetchOneBySuperKeyAssignmentMap<TableT extends ITable> = Extract<
    /**
     * @todo Investigate assignability
     */
    UpdateAndFetchOneBySuperKeyAssignmentMapImpl<TableT>, CustomAssignmentMap<TableT>>;
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    export function __updateAndFetchOneBySuperKeyHelper<TableT extends ITable, SuperKeyT extends SuperKey_Input<TableT>, AssignmentMapT extends UpdateAndFetchOneBySuperKeyAssignmentMap<TableT>>(table: TableT, connection: SelectConnection, superKey: SuperKeyT & AssertNonUnion<SuperKeyT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        success: false;
        rowNotFoundError: RowNotFoundError;
    } | {
        success: true;
        curSuperKey: SuperKey_Input<TableT>;
        assignmentMap: UpdateAndFetchOneBySuperKeyAssignmentMap<TableT>;
        newSuperKey: SuperKey_Input<TableT>;
    }>;
    export function updateAndFetchOneBySuperKey<TableT extends ITable, SuperKeyT extends SuperKey_Input<TableT>, AssignmentMapT extends UpdateAndFetchOneBySuperKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, superKey: SuperKeyT & AssertNonUnion<SuperKeyT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-one" {
    import { ITable, TableUtil } from "table/index";
    import { IsolableUpdateConnection, SelectConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, CustomAssignmentMap } from "update/index";
    import { Identity, StrictUnion } from "type-util/index";
    import { CustomExpr_MapCorrelatedOrUndefined } from "custom-expr/index";
    import { RowNotFoundError } from "error/index";
    import { UpdateAndFetchOneResult } from "execution/util/operation-update/update-and-fetch-one-impl";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { CandidateKey_Input } from "candidate-key/index";
    export type UpdateAndFetchOneAssignmentMapImpl<TableT extends Pick<ITable, "columns" | "mutableColumns">> = Identity<{
        readonly [columnAlias in TableT["mutableColumns"][number]]?: (CustomExpr_MapCorrelatedOrUndefined<TableT["columns"], ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    } & {
        readonly [columnAlias in Exclude<TableUtil.ColumnAlias<TableT>, TableT["mutableColumns"][number]>]?: undefined;
    }>;
    export type UpdateAndFetchOneAssignmentMap<TableT extends Pick<ITable, "columns" | "mutableColumns">> = Extract<
    /**
     * @todo Investigate assignability
     */
    UpdateAndFetchOneAssignmentMapImpl<TableT>, CustomAssignmentMap<TableT>>;
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    export function __updateAndFetchOneHelper<TableT extends ITable, AssignmentMapT extends UpdateAndFetchOneAssignmentMap<TableT>>(table: TableT & TableUtil.AssertHasCandidateKey<TableT>, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        success: false;
        rowNotFoundError: RowNotFoundError;
    } | {
        success: true;
        curCandidateKey: StrictUnion<CandidateKey_Input<TableT>>;
        assignmentMap: UpdateAndFetchOneAssignmentMap<TableT>;
        newCandidateKey: StrictUnion<CandidateKey_Input<TableT>>;
    }>;
    export function updateAndFetchOne<TableT extends ITable, AssignmentMapT extends UpdateAndFetchOneAssignmentMap<TableT>>(table: TableT & TableUtil.AssertHasCandidateKey<TableT>, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-zero-or-one" {
    import { ITable } from "table/index";
    import { WhereDelegate, WhereClause } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate, BuiltInAssignmentMap, CustomAssignmentMap } from "update/index";
    import { UpdateOneResult } from "execution/util/operation-update/update-one";
    export interface NotFoundUpdateResult {
        query: {
            sql: string;
        };
        foundRowCount: 0n;
        updatedRowCount: 0n;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export type UpdateZeroOrOneResult = NotFoundUpdateResult | UpdateOneResult;
    export function updateZeroOrOneImplNoEvent<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<{
        whereClause: WhereClause;
        assignmentMap: BuiltInAssignmentMap<TableT>;
        updateResult: UpdateZeroOrOneResult;
    }>;
    export function updateZeroOrOne<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateZeroOrOneResult>;
}
declare module "execution/util/operation-update/update-and-fetch-zero-or-one-impl" {
    import { ITable } from "table/index";
    import { IsolableUpdateConnection, IsolatedUpdateConnection } from "execution/connection/index";
    import { CustomAssignmentMap, BuiltInAssignmentMap } from "update/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { NotFoundUpdateResult } from "execution/util/operation-update/update-zero-or-one";
    import { UpdateAndFetchOneResult } from "execution/util/operation-update/update-and-fetch-one-impl";
    import { Identity } from "type-util/index";
    import { RowNotFoundError } from "error/index";
    export interface NotFoundUpdateAndFetchResult extends NotFoundUpdateResult {
        row: undefined;
    }
    export type UpdateAndFetchZeroOrOneResult<TableT extends ITable, AssignmentMapT extends CustomAssignmentMap<TableT>> = Identity<NotFoundUpdateAndFetchResult | UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
    /**
     * This should not be called directly by users.
     *
     * A lot can go wrong here...
     */
    export function updateAndFetchZeroOrOneImpl<TableT extends ITable, 
    /**
     * This is `updateAndFetchZeroOrOneImpl()` because we only accept `BuiltInAssignmentMap`.
     * We do not accept `CustomAssignmentMap`.
     */
    AssignmentMapT extends BuiltInAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, initCallback: (connection: IsolatedUpdateConnection) => Promise<{
        success: false;
        rowNotFoundError: RowNotFoundError;
    } | {
        success: true;
        /**
         * We need two separate `WHERE` clauses because
         * the `UPDATE` statement may change the unique identifier
         * of the row.
         */
        updateWhereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>;
        fetchWhereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>;
        assignmentMap: AssignmentMapT;
    }>): Promise<UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key" {
    import { ITable } from "table/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate } from "update/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    import { UpdateAndFetchOneByCandidateKeyAssignmentMap } from "execution/util/operation-update/update-and-fetch-one-by-candidate-key";
    import { UpdateAndFetchZeroOrOneResult } from "execution/util/operation-update/update-and-fetch-zero-or-one-impl";
    export function updateAndFetchZeroOrOneByCandidateKey<TableT extends ITable, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TableT>>, AssignmentMapT extends UpdateAndFetchOneByCandidateKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key" {
    import { TableWithPrimaryKey } from "table/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate } from "update/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { UpdateAndFetchOneByPrimaryKeyAssignmentMap } from "execution/util/operation-update/update-and-fetch-one-by-primary-key";
    import { UpdateAndFetchZeroOrOneResult } from "execution/util/operation-update/update-and-fetch-zero-or-one-impl";
    export function updateAndFetchZeroOrOneByPrimaryKey<TableT extends TableWithPrimaryKey, AssignmentMapT extends UpdateAndFetchOneByPrimaryKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<TableT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key" {
    import { ITable } from "table/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate } from "update/index";
    import { AssertNonUnion } from "type-util/index";
    import { SuperKey_Input } from "super-key/index";
    import { UpdateAndFetchOneBySuperKeyAssignmentMap } from "execution/util/operation-update/update-and-fetch-one-by-super-key";
    import { UpdateAndFetchZeroOrOneResult } from "execution/util/operation-update/update-and-fetch-zero-or-one-impl";
    export function updateAndFetchZeroOrOneBySuperKey<TableT extends ITable, SuperKeyT extends SuperKey_Input<TableT>, AssignmentMapT extends UpdateAndFetchOneBySuperKeyAssignmentMap<TableT>>(table: TableT, connection: IsolableUpdateConnection, superKey: SuperKeyT & AssertNonUnion<SuperKeyT>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/update-and-fetch-zero-or-one" {
    import { ITable, TableUtil } from "table/index";
    import { IsolableUpdateConnection } from "execution/connection/index";
    import { AssignmentMapDelegate } from "update/index";
    import { UpdateAndFetchZeroOrOneResult } from "execution/util/operation-update/update-and-fetch-zero-or-one-impl";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { UpdateAndFetchOneAssignmentMap } from "execution/util/operation-update/update-and-fetch-one";
    export function updateAndFetchZeroOrOne<TableT extends ITable, AssignmentMapT extends UpdateAndFetchOneAssignmentMap<TableT>>(table: TableT & TableUtil.AssertHasCandidateKey<TableT>, connection: IsolableUpdateConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
}
declare module "execution/util/operation-update/index" {
    export * from "execution/util/operation-update/update-and-fetch-one-by-candidate-key";
    export * from "execution/util/operation-update/update-and-fetch-one-by-primary-key";
    export * from "execution/util/operation-update/update-and-fetch-one-by-super-key";
    export * from "execution/util/operation-update/update-and-fetch-one-impl";
    export * from "execution/util/operation-update/update-and-fetch-one";
    export * from "execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key";
    export * from "execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key";
    export * from "execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key";
    export * from "execution/util/operation-update/update-and-fetch-zero-or-one-impl";
    export * from "execution/util/operation-update/update-and-fetch-zero-or-one";
    export * from "execution/util/operation-update/update-one";
    export * from "execution/util/operation-update/update-zero-or-one";
    export * from "execution/util/operation-update/update";
}
declare module "execution/util/index" {
    export * from "execution/util/helper-type/index";
    export * from "execution/util/operation/index";
    export * from "execution/util/operation-delete/index";
    export * from "execution/util/operation-insert/index";
    export * from "execution/util/operation-insert-select/index";
    export * from "execution/util/operation-update/index";
    export * from "execution/util/predicate/index";
}
declare module "event/update-and-fetch-event" {
    import { IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInAssignmentMap } from "update/index";
    import { IEventBase, EventBase } from "event/event-base";
    import { UpdateOneResult } from "execution/util/index";
    import { Row_Output } from "row/index";
    export interface IUpdateAndFetchEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly assignmentMap: BuiltInAssignmentMap<TableT>;
        readonly updateResult: (UpdateOneResult & {
            row: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
        });
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IUpdateAndFetchEvent<T>;
    }
    export class UpdateAndFetchEvent<TableT extends ITable> extends EventBase implements IUpdateAndFetchEvent<TableT> {
        readonly table: TableT;
        readonly assignmentMap: BuiltInAssignmentMap<TableT>;
        readonly updateResult: (UpdateOneResult & {
            row: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
        });
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly assignmentMap: BuiltInAssignmentMap<TableT>;
            readonly updateResult: (UpdateOneResult & {
                row: (ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>);
            });
        });
        isFor<T extends ITable>(table: T): this is IUpdateAndFetchEvent<T>;
    }
}
declare module "event/delete-event" {
    import { IConnection, DeleteResult } from "execution/index";
    import { ITable } from "table/index";
    import { IEventBase, EventBase } from "event/event-base";
    import { WhereClause } from "where-clause/index";
    export interface IDeleteEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly whereClause: WhereClause;
        readonly deleteResult: DeleteResult;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IDeleteEvent<T>;
    }
    export class DeleteEvent<TableT extends ITable> extends EventBase implements IDeleteEvent<TableT> {
        readonly table: TableT;
        readonly whereClause: WhereClause;
        readonly deleteResult: DeleteResult;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly whereClause: WhereClause;
            readonly deleteResult: DeleteResult;
        });
        isFor<T extends ITable>(table: T): this is IDeleteEvent<T>;
    }
}
declare module "event/replace-one-event" {
    import { ReplaceOneResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { CandidateKey_Output } from "candidate-key/index";
    import { Row_Output } from "row/index";
    import { IEventBase, EventBase } from "event/event-base";
    export interface IReplaceOneEvent<TableT extends ITable> extends IEventBase {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly replaceResult: ReplaceOneResult;
        /**
         * If we can get the `candidateKey` from the `insertRow`, this will be set.
         * This is only possible if at least one candidate key is set using just
         * value expressions, on the `insertRow`.
         */
        readonly candidateKey: undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>);
        /**
         * This may throw for a number of reasons,
         * + `candidateKey` is `undefined` (cannot be derived from `insertRow`)
         * + Row was updated to a different `candidateKey` value before initial fetch
         * + Connection released
         * + etc.
         *
         * First call to `getOrFetch()` fetches the row.
         * Subsequent calls return a cached copy of the row.
         */
        getOrFetch(): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IReplaceOneEvent<T>;
    }
    export class ReplaceOneEvent<TableT extends ITable> extends EventBase implements IReplaceOneEvent<TableT> {
        readonly table: TableT;
        readonly insertRow: BuiltInInsertRow<TableT>;
        readonly replaceResult: ReplaceOneResult;
        private candidateKeyCache;
        readonly candidateKey: undefined | (ITable extends TableT ? Record<string, unknown> : CandidateKey_Output<TableT>);
        private fetchPromise;
        getOrFetch(): Promise<(ITable extends TableT ? Record<string, unknown> : Row_Output<TableT>)>;
        constructor(args: {
            readonly connection: IConnection;
            readonly table: TableT;
            readonly insertRow: BuiltInInsertRow<TableT>;
            readonly replaceResult: ReplaceOneResult;
        });
        isFor<T extends ITable>(table: T): this is IReplaceOneEvent<T>;
    }
}
declare module "event/insert-select-event" {
    import { InsertManyResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { IEventBase, EventBase } from "event/event-base";
    import { QueryBaseUtil } from "query-base/index";
    export interface IInsertSelectEvent<TableT extends ITable> extends IEventBase {
        readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
        readonly table: TableT;
        /**
         * @todo More precise type for this.
         */
        readonly insertSelectRow: Record<string, unknown>;
        readonly insertResult: InsertManyResult;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IInsertSelectEvent<T>;
    }
    export class InsertSelectEvent<TableT extends ITable> extends EventBase implements IInsertSelectEvent<TableT> {
        readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
        readonly table: TableT;
        /**
         * @todo More precise type for this.
         */
        readonly insertSelectRow: Record<string, unknown>;
        readonly insertResult: InsertManyResult;
        constructor(args: {
            readonly connection: IConnection;
            readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
            readonly table: TableT;
            readonly insertSelectRow: Record<string, unknown>;
            readonly insertResult: InsertManyResult;
        });
        isFor<T extends ITable>(table: T): this is IInsertSelectEvent<T>;
    }
}
declare module "event/replace-select-event" {
    import { ReplaceManyResult, IConnection } from "execution/index";
    import { ITable } from "table/index";
    import { IEventBase, EventBase } from "event/event-base";
    import { QueryBaseUtil } from "query-base/index";
    export interface IReplaceSelectEvent<TableT extends ITable> extends IEventBase {
        readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
        readonly table: TableT;
        /**
         * @todo More precise type for this.
         */
        readonly replaceSelectRow: Record<string, unknown>;
        readonly replaceResult: ReplaceManyResult;
        /**
         * Internally, it does a `this.table === table` check.
         */
        isFor<T extends ITable>(table: T): this is IReplaceSelectEvent<T>;
    }
    export class ReplaceSelectEvent<TableT extends ITable> extends EventBase implements IReplaceSelectEvent<TableT> {
        readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
        readonly table: TableT;
        /**
         * @todo More precise type for this.
         */
        readonly replaceSelectRow: Record<string, unknown>;
        readonly replaceResult: ReplaceManyResult;
        constructor(args: {
            readonly connection: IConnection;
            readonly query: QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated;
            readonly table: TableT;
            readonly replaceSelectRow: Record<string, unknown>;
            readonly replaceResult: ReplaceManyResult;
        });
        isFor<T extends ITable>(table: T): this is IReplaceSelectEvent<T>;
    }
}
declare module "event/connection-event-emitter-collection" {
    import { IPool } from "execution/index";
    import { ITable } from "table/index";
    import { IConnectionEventEmitter, ConnectionEventEmitter } from "event/connection-event-emitter";
    import { IInsertEvent } from "event/insert-event";
    import { IInsertOneEvent } from "event/insert-one-event";
    import { IInsertAndFetchEvent } from "event/insert-and-fetch-event";
    import { IReplaceEvent } from "event/replace-event";
    import { IUpdateEvent } from "event/update-event";
    import { IUpdateAndFetchEvent } from "event/update-and-fetch-event";
    import { IDeleteEvent } from "event/delete-event";
    import { IReplaceOneEvent } from "event/replace-one-event";
    import { IInsertSelectEvent } from "event/insert-select-event";
    import { IReplaceSelectEvent } from "event/replace-select-event";
    export interface IConnectionEventEmitterCollection {
        readonly onInsert: IConnectionEventEmitter<IInsertEvent<ITable>>;
        readonly onInsertOne: IConnectionEventEmitter<IInsertOneEvent<ITable>>;
        readonly onInsertAndFetch: IConnectionEventEmitter<IInsertAndFetchEvent<ITable>>;
        readonly onInsertSelect: IConnectionEventEmitter<IInsertSelectEvent<ITable>>;
        readonly onReplace: IConnectionEventEmitter<IReplaceEvent<ITable>>;
        readonly onReplaceOne: IConnectionEventEmitter<IReplaceOneEvent<ITable>>;
        readonly onReplaceSelect: IConnectionEventEmitter<IReplaceSelectEvent<ITable>>;
        readonly onUpdate: IConnectionEventEmitter<IUpdateEvent<ITable>>;
        readonly onUpdateAndFetch: IConnectionEventEmitter<IUpdateAndFetchEvent<ITable>>;
        readonly onDelete: IConnectionEventEmitter<IDeleteEvent<ITable>>;
        savepoint(): void;
        releaseSavepoint(): void;
        rollbackToSavepoint(): {
            syncErrors: unknown[];
        };
        commit(): {
            syncErrors: unknown[];
        };
        rollback(): {
            syncErrors: unknown[];
        };
    }
    export class ConnectionEventEmitterCollection implements IConnectionEventEmitterCollection {
        /**
         * We want to avoid mutating arrays because it may mess up our loops.
         * We might add/remove events while invoking a handler.
         */
        private transactionListenerCollections;
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is created
         */
        savepoint(): void;
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is released
         */
        releaseSavepoint(): void;
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is rolled back
         */
        rollbackToSavepoint(): {
            syncErrors: unknown[];
        };
        readonly onInsert: IConnectionEventEmitter<IInsertEvent<ITable>>;
        readonly onInsertOne: ConnectionEventEmitter<IInsertOneEvent<ITable>>;
        readonly onInsertAndFetch: IConnectionEventEmitter<IInsertAndFetchEvent<ITable>>;
        readonly onInsertSelect: IConnectionEventEmitter<IInsertSelectEvent<ITable>>;
        readonly onReplace: IConnectionEventEmitter<IReplaceEvent<ITable>>;
        readonly onReplaceOne: IConnectionEventEmitter<IReplaceOneEvent<ITable>>;
        readonly onReplaceSelect: IConnectionEventEmitter<IReplaceSelectEvent<ITable>>;
        readonly onUpdate: ConnectionEventEmitter<IUpdateEvent<ITable>>;
        readonly onUpdateAndFetch: ConnectionEventEmitter<IUpdateAndFetchEvent<ITable>>;
        readonly onDelete: IConnectionEventEmitter<IDeleteEvent<ITable>>;
        private readonly addTransactionListenerCollectionImpl;
        constructor(pool: IPool);
        /**
         * This should not throw
         *
         * Used when a transaction is committed
         */
        commit(): {
            syncErrors: unknown[];
        };
        /**
         * This should not throw
         *
         * Used when a transaction is rolled back
         */
        rollback(): {
            syncErrors: unknown[];
        };
    }
}
declare module "event/index" {
    export * from "event/connection-event-emitter-collection";
    export * from "event/connection-event-emitter";
    export * from "event/delete-event";
    export * from "event/event-base";
    export * from "event/event-handler";
    export * from "event/insert-and-fetch-event";
    export * from "event/insert-event";
    export * from "event/insert-one-event";
    export * from "event/insert-select-event";
    export * from "event/pool-event-emitter";
    export * from "event/replace-event";
    export * from "event/replace-one-event";
    export * from "event/replace-select-event";
    export * from "event/transaction-listener-collection";
    export * from "event/update-and-fetch-event";
    export * from "event/update-event";
}
declare module "execution/connection/component/delete" {
    import { DeletableTable } from "table/index";
    import { WhereClause } from "where-clause/index";
    export interface DeleteResult {
        query: {
            sql: string;
        };
        deletedRowCount: bigint;
        /**
         * @todo MySQL sometimes gives a `warningCount` value `> 0` for
         * `DELETE` statements. Recall why.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface Delete {
        delete(table: DeletableTable, whereClause: WhereClause): Promise<DeleteResult>;
    }
}
declare module "transaction-access-mode" {
    /**
     * Transaction access modes ranked from least to most permissive,
     * 1. `READ_ONLY`
     * 2. `READ_WRITE`
     *
     * https://github.com/AnyhowStep/tsql/issues/14
     */
    export enum TransactionAccessMode {
        READ_ONLY = "READ_ONLY",
        READ_WRITE = "READ_WRITE"
    }
    export namespace TransactionAccessModeUtil {
        /**
         * Is transaction access mode `a` less permissive than `b`?
         */
        function isLessPermissiveThan(a: TransactionAccessMode, b: TransactionAccessMode): boolean;
    }
}
declare module "execution/connection/component/in-transaction" {
    import { IsolationLevel } from "isolation-level";
    import { TransactionAccessMode } from "transaction-access-mode";
    export interface InTransaction {
        rollback(): Promise<void>;
        commit(): Promise<void>;
        getMinimumIsolationLevel(): IsolationLevel;
        getTransactionAccessMode(): TransactionAccessMode;
    }
}
declare module "execution/connection/component/insert-ignore-many" {
    import { InsertableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    export interface InsertIgnoreManyResult {
        query: {
            /**
             * Is an empty string if no rows were inserted.
             */
            sql: string;
        };
        insertedRowCount: bigint;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface InsertIgnoreMany {
        /**
         * This does not allow custom data types.
         * All custom data types must be wrapped by an expression.
         */
        insertIgnoreMany<TableT extends InsertableTable>(table: TableT, rows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]]): Promise<InsertIgnoreManyResult>;
    }
}
declare module "execution/connection/component/insert-one" {
    import { InsertableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    export interface InsertOneResult {
        query: {
            sql: string;
        };
        insertedRowCount: 1n;
        /**
         * If the table has an `AUTO_INCREMENT`/`SERIAL` column, it returns `> 0n`.
         * Else, it returns `undefined`.
         *
         * If multiple rows are inserted, there is no guarantee that `insertId` will be set.
         *
         * -----
         *
         * If you explicitly set the value of the `AUTO_INCREMENT` column,
         * should there be a guarantee that it is set to the explicit value?
         *
         * Using MySQL's `LAST_INSERT_ID()` returns `0`, in this case.
         * But the library should be able to infer...
         */
        autoIncrementId: bigint | undefined;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface InsertOne {
        /**
         * This does not allow custom data types.
         * All custom data types must be wrapped by an expression.
         */
        insertOne<TableT extends InsertableTable>(table: TableT, row: BuiltInInsertRow<TableT>): Promise<InsertOneResult>;
    }
}
declare module "execution/connection/component/insert-ignore-one" {
    import { InsertableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    import { InsertOneResult } from "execution/connection/component/insert-one";
    export interface IgnoredInsertOneResult {
        query: {
            sql: string;
        };
        insertedRowCount: 0n;
        /**
         * No rows were inserted. So, there cannot be an `autoIncrementId`.
         */
        autoIncrementId: undefined;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export type InsertIgnoreOneResult = IgnoredInsertOneResult | InsertOneResult;
    export interface InsertIgnoreOne {
        /**
         * This does not allow custom data types.
         * All custom data types must be wrapped by an expression.
         */
        insertIgnoreOne<TableT extends InsertableTable>(table: TableT, row: BuiltInInsertRow<TableT>): Promise<InsertIgnoreOneResult>;
    }
}
declare module "execution/connection/component/insert-ignore-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable } from "table/index";
    import { InsertSelectRow } from "insert-select/index";
    import { InsertIgnoreManyResult } from "execution/connection/component/insert-ignore-many";
    export interface InsertIgnoreSelect {
        insertIgnoreSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable>(query: QueryT, table: TableT, row: InsertSelectRow<QueryT, TableT>): Promise<InsertIgnoreManyResult>;
    }
}
declare module "execution/connection/component/insert-many" {
    import { InsertableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    export interface InsertManyResult {
        query: {
            /**
             * Is an empty string if no rows were inserted.
             */
            sql: string;
        };
        insertedRowCount: bigint;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface InsertMany {
        /**
         * This does not allow custom data types.
         * All custom data types must be wrapped by an expression.
         */
        insertMany<TableT extends InsertableTable>(table: TableT, rows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]]): Promise<InsertManyResult>;
    }
}
declare module "execution/connection/component/insert-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable } from "table/index";
    import { InsertSelectRow } from "insert-select/index";
    import { InsertManyResult } from "execution/connection/component/insert-many";
    export interface InsertSelect {
        insertSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable>(query: QueryT, table: TableT, row: InsertSelectRow<QueryT, TableT>): Promise<InsertManyResult>;
    }
}
declare module "execution/connection/component/is-deallocated" {
    export interface IsDeallocated {
        /**
         * Tells you if the underlying connection has been returned to the pool.
         * If this connection has been deallocated,
         * attempts to use it will throw an error.
         */
        isDeallocated(): boolean;
    }
}
declare module "execution/connection/component/is-in-transaction" {
    export interface IsInTransaction<ConnectionT> {
        /**
         * Tells you if this connection is in a transaction.
         */
        isInTransaction(): this is ConnectionT;
    }
}
declare module "execution/connection/component/lockable" {
    export interface LockCallback<LockT, ResultT> {
        (connection: LockT): Promise<ResultT>;
    }
    export interface Lockable<LockT> {
        lock<ResultT>(callback: LockCallback<LockT, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/raw-query" {
    export interface RawQueryResult {
        query: {
            sql: string;
        };
        results: unknown | undefined;
        columns: string[] | undefined;
    }
    export interface RawQuery {
        rawQuery(sql: string): Promise<RawQueryResult>;
    }
}
declare module "execution/connection/isolable-connection" {
    import { Lockable, TryGetFullConnection, TransactionIfNotInOne, ReadOnlyTransactionIfNotInOne, InsertOne, Select, InTransaction, IsInTransaction, TryFetchGeneratedColumnExpression, Update, Delete, Savepoint } from "execution/connection/component/index";
    /**
     * + Allows `SELECT` statements
     * +
     */
    export interface IsolableSelectConnection extends Lockable<IsolableSelectConnection>, ReadOnlyTransactionIfNotInOne, IsInTransaction<IsolatedSelectConnection>, Select {
    }
    export interface IsolatedSelectConnection extends Lockable<IsolatedSelectConnection>, ReadOnlyTransactionIfNotInOne, InTransaction, IsInTransaction<IsolatedSelectConnection>, Select {
    }
    /**
     * + Allows `SELECT/INSERT` statements
     * +
     */
    export interface IsolableInsertOneConnection extends Lockable<IsolableInsertOneConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedInsertOneConnection>, IsInTransaction<IsolatedInsertOneConnection>, Select, InsertOne, TryFetchGeneratedColumnExpression, TryGetFullConnection {
    }
    export interface IsolatedInsertOneConnection extends Lockable<IsolatedInsertOneConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedInsertOneConnection>, IsInTransaction<IsolatedInsertOneConnection>, InTransaction, Savepoint<IsolatedInsertOneConnection>, Select, InsertOne, TryFetchGeneratedColumnExpression, TryGetFullConnection {
    }
    /**
     * + Allows `SELECT/DELETE` statements
     * +
     */
    export interface IsolableDeleteConnection extends Lockable<IsolableDeleteConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedDeleteConnection>, IsInTransaction<IsolatedDeleteConnection>, Select, Delete, TryGetFullConnection {
    }
    export interface IsolatedDeleteConnection extends Lockable<IsolatedDeleteConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedDeleteConnection>, IsInTransaction<IsolatedDeleteConnection>, InTransaction, Savepoint<IsolatedDeleteConnection>, Select, Delete, TryFetchGeneratedColumnExpression, TryGetFullConnection {
    }
    /**
     * + Allows `SELECT/UPDATE` statements
     * +
     */
    export interface IsolableUpdateConnection extends Lockable<IsolableUpdateConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedUpdateConnection>, IsInTransaction<IsolatedUpdateConnection>, Select, Update, TryGetFullConnection {
    }
    export interface IsolatedUpdateConnection extends Lockable<IsolatedUpdateConnection>, ReadOnlyTransactionIfNotInOne, TransactionIfNotInOne<IsolatedUpdateConnection>, IsInTransaction<IsolatedUpdateConnection>, InTransaction, Savepoint<IsolatedUpdateConnection>, Select, Update, TryGetFullConnection {
    }
}
declare module "execution/connection/component/read-only-transaction-if-not-in-one" {
    import { LockCallback } from "execution/connection/component/lockable";
    import { IsolationLevel } from "isolation-level";
    import { IsolatedSelectConnection } from "execution/connection/isolable-connection";
    export interface ReadOnlyTransactionIfNotInOne {
        readOnlyTransactionIfNotInOne<ResultT>(callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
        readOnlyTransactionIfNotInOne<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/read-only-transaction" {
    import { LockCallback } from "execution/connection/component/lockable";
    import { IsolationLevel } from "isolation-level";
    import { IsolatedSelectConnection } from "execution/connection/isolable-connection";
    export interface ReadOnlyTransaction {
        readOnlyTransaction<ResultT>(callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
        readOnlyTransaction<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/replace-many" {
    import { InsertableTable, DeletableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    export interface ReplaceManyResult {
        query: {
            sql: string;
        };
        /**
         * We can't tell if the row was inserted, or if it was replaced.
         */
        insertedOrReplacedRowCount: bigint;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface ReplaceMany {
        replaceMany<TableT extends InsertableTable & DeletableTable>(table: TableT, rows: readonly [BuiltInInsertRow<TableT>, ...BuiltInInsertRow<TableT>[]]): Promise<ReplaceManyResult>;
    }
}
declare module "execution/connection/component/replace-one" {
    import { InsertableTable, DeletableTable } from "table/index";
    import { BuiltInInsertRow } from "insert/index";
    export interface ReplaceOneResult {
        query: {
            sql: string;
        };
        /**
         * We can't tell if the row was inserted, or if it was replaced.
         */
        insertedOrReplacedRowCount: 1n;
        /**
         * If the table has an `AUTO_INCREMENT`/`SERIAL` column, it returns `> 0n`.
         * Else, it returns `undefined`.
         *
         * If multiple rows are inserted, there is no guarantee that `insertId` will be set.
         *
         * -----
         *
         * If you explicitly set the value of the `AUTO_INCREMENT` column,
         * should there be a guarantee that it is set to the explicit value?
         *
         * Using MySQL's `LAST_INSERT_ID()` returns `0`, in this case.
         * But the library should be able to infer...
         */
        autoIncrementId: bigint | undefined;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface ReplaceOne {
        replaceOne<TableT extends InsertableTable & DeletableTable>(table: TableT, row: BuiltInInsertRow<TableT>): Promise<ReplaceOneResult>;
    }
}
declare module "execution/connection/component/replace-select" {
    import { QueryBaseUtil } from "query-base/index";
    import { InsertableTable, DeletableTable } from "table/index";
    import { InsertSelectRow } from "insert-select/index";
    import { ReplaceManyResult } from "execution/connection/component/replace-many";
    export interface ReplaceSelect {
        replaceSelect<QueryT extends QueryBaseUtil.AfterSelectClause & QueryBaseUtil.NonCorrelated, TableT extends InsertableTable & DeletableTable>(query: QueryT, table: TableT, row: InsertSelectRow<QueryT, TableT>): Promise<ReplaceManyResult>;
    }
}
declare module "execution/connection/component/savepoint" {
    import { LockCallback } from "execution/connection/component/lockable";
    export interface InSavepoint {
        rollbackToSavepoint(): Promise<void>;
        releaseSavepoint(): Promise<void>;
    }
    export interface Savepoint<LockT> {
        savepoint<ResultT>(callback: LockCallback<LockT & InSavepoint, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/select" {
    import { IQueryBase } from "query-base/index";
    export interface SelectResult {
        query: {
            sql: string;
        };
        rows: Record<string, unknown>[];
        columns: string[];
    }
    export interface Select {
        select(query: IQueryBase): Promise<SelectResult>;
    }
}
declare module "execution/connection/component/transaction-if-not-in-one" {
    import { LockCallback } from "execution/connection/component/lockable";
    import { IsolationLevel } from "isolation-level";
    export interface TransactionIfNotInOne<ConnectionT> {
        transactionIfNotInOne<ResultT>(callback: LockCallback<ConnectionT, ResultT>): Promise<ResultT>;
        transactionIfNotInOne<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<ConnectionT, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/transaction" {
    import { LockCallback } from "execution/connection/component/lockable";
    import { IsolationLevel } from "isolation-level";
    export interface Transaction<ConnectionT> {
        transaction<ResultT>(callback: LockCallback<ConnectionT, ResultT>): Promise<ResultT>;
        transaction<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<ConnectionT, ResultT>): Promise<ResultT>;
    }
}
declare module "execution/connection/component/try-fetch-generated-column-expression" {
    export interface TryFetchGeneratedColumnExpression {
        /**
         *
         * @param schemaAlias - If `undefined`, it uses the implied schema of the connection
         * @param tableAlias
         * @param columnAlias
         *
         * @returns A SQL string that is the generated column's expression
         */
        tryFetchGeneratedColumnExpression(schemaAlias: string | undefined, tableAlias: string, columnAlias: string): Promise<string | undefined>;
    }
}
declare module "schema-introspection/candidate-key-meta" {
    export interface CandidateKeyMeta {
        /**
         * The name of the candidate key
         */
        candidateKeyName: string;
        /**
         * The columns that are part of this candidate key
         */
        columnAliases: readonly string[];
    }
}
declare module "schema-introspection/column-meta" {
    /**
     * For now, it only has enough information that we can validate the table declarations.
     *
     * In the future, we should modify this to have enough information
     * to generate the table declarations.
     */
    export interface ColumnMeta {
        columnAlias: string;
        isAutoIncrement: boolean;
        isNullable: boolean;
        /**
         * If `undefined`, there is no explicit default value.
         */
        explicitDefaultValue: string | undefined;
        /**
         * If `undefined`, there is no generation expression.
         */
        generationExpression: string | undefined;
    }
}
declare module "schema-introspection/table-meta" {
    import { ColumnMeta } from "schema-introspection/column-meta";
    import { CandidateKeyMeta } from "schema-introspection/candidate-key-meta";
    export interface TableMeta {
        tableAlias: string;
        columns: readonly ColumnMeta[];
        candidateKeys: readonly CandidateKeyMeta[];
        primaryKey: CandidateKeyMeta | undefined;
    }
}
declare module "schema-introspection/schema-meta" {
    import { TableMeta } from "schema-introspection/table-meta";
    export interface SchemaMeta {
        schemaAlias: string;
        tables: readonly TableMeta[];
    }
}
declare module "schema-introspection/index" {
    /**
     * @todo Come up with better names?
     */
    export * from "schema-introspection/candidate-key-meta";
    export * from "schema-introspection/column-meta";
    export * from "schema-introspection/schema-meta";
    export * from "schema-introspection/table-meta";
}
declare module "execution/connection/component/try-fetch-schema-meta" {
    import { SchemaMeta } from "schema-introspection/index";
    export interface TryFetchSchemaMeta {
        /**
         *
         * @param schemaAlias - If `undefined`, it uses the implied schema of the connection
         */
        tryFetchSchemaMeta(schemaAlias: string | undefined): Promise<SchemaMeta | undefined>;
    }
}
declare module "execution/connection/component/try-get-full-connection" {
    import { IConnection } from "execution/connection/connection";
    export interface TryGetFullConnection {
        tryGetFullConnection(): IConnection | undefined;
    }
}
declare module "execution/connection/component/update" {
    import { ITable } from "table/index";
    import { WhereClause } from "where-clause/index";
    import { BuiltInAssignmentMap } from "update/index";
    export interface UpdateResult {
        query: {
            sql: string;
        };
        foundRowCount: bigint;
        /**
         * You cannot trust this number for SQLite.
         * SQLite thinks that all found rows are updated, even if you set `x = x`.
         *
         * @todo Consider renaming this to `unreliableUpdatedRowCount`?
         */
        updatedRowCount: bigint;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export interface Update {
        update<TableT extends ITable>(table: TableT, whereClause: WhereClause, assignmentMap: BuiltInAssignmentMap<TableT>): Promise<UpdateResult>;
    }
}
declare module "execution/connection/component/index" {
    export * from "execution/connection/component/delete";
    export * from "execution/connection/component/in-transaction";
    export * from "execution/connection/component/insert-ignore-many";
    export * from "execution/connection/component/insert-ignore-one";
    export * from "execution/connection/component/insert-ignore-select";
    export * from "execution/connection/component/insert-many";
    export * from "execution/connection/component/insert-one";
    export * from "execution/connection/component/insert-select";
    export * from "execution/connection/component/is-deallocated";
    export * from "execution/connection/component/is-in-transaction";
    export * from "execution/connection/component/lockable";
    export * from "execution/connection/component/raw-query";
    export * from "execution/connection/component/read-only-transaction-if-not-in-one";
    export * from "execution/connection/component/read-only-transaction";
    export * from "execution/connection/component/replace-many";
    export * from "execution/connection/component/replace-one";
    export * from "execution/connection/component/replace-select";
    export * from "execution/connection/component/savepoint";
    export * from "execution/connection/component/select";
    export * from "execution/connection/component/transaction-if-not-in-one";
    export * from "execution/connection/component/transaction";
    export * from "execution/connection/component/try-fetch-generated-column-expression";
    export * from "execution/connection/component/try-fetch-schema-meta";
    export * from "execution/connection/component/try-get-full-connection";
    export * from "execution/connection/component/update";
}
declare module "execution/pool/pool" {
    import { IConnection, ITransactionConnection, IsolatedSelectConnection } from "execution/connection/index";
    import { ITable } from "table/index";
    import { IPoolEventEmitter, IInsertEvent, IInsertOneEvent, IUpdateEvent, IUpdateAndFetchEvent, IDeleteEvent, IInsertAndFetchEvent, IReplaceEvent, IReplaceOneEvent, IInsertSelectEvent, IReplaceSelectEvent } from "event/index";
    import { IsolationLevel } from "isolation-level";
    import { LockCallback } from "execution/connection/component/index";
    export type ConnectionCallback<ResultT> = ((connection: IConnection) => Promise<ResultT>);
    export interface IPool {
        acquire<ResultT>(callback: ConnectionCallback<ResultT>): Promise<ResultT>;
        acquireTransaction<ResultT>(callback: LockCallback<ITransactionConnection, ResultT>): Promise<ResultT>;
        acquireTransaction<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<ITransactionConnection, ResultT>): Promise<ResultT>;
        acquireReadOnlyTransaction<ResultT>(callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
        acquireReadOnlyTransaction<ResultT>(minimumIsolationLevel: IsolationLevel, callback: LockCallback<IsolatedSelectConnection, ResultT>): Promise<ResultT>;
        disconnect(): Promise<void>;
        /**
         * Returns `true` if the pool has been disconnected,
         * or is disconnecting.
         *
         * Attempts to use the pool when deallocated will throw an error.
         */
        isDeallocated(): boolean;
        readonly onInsert: IPoolEventEmitter<IInsertEvent<ITable>>;
        readonly onInsertOne: IPoolEventEmitter<IInsertOneEvent<ITable>>;
        readonly onInsertAndFetch: IPoolEventEmitter<IInsertAndFetchEvent<ITable>>;
        readonly onInsertSelect: IPoolEventEmitter<IInsertSelectEvent<ITable>>;
        readonly onReplace: IPoolEventEmitter<IReplaceEvent<ITable>>;
        readonly onReplaceOne: IPoolEventEmitter<IReplaceOneEvent<ITable>>;
        readonly onReplaceSelect: IPoolEventEmitter<IReplaceSelectEvent<ITable>>;
        readonly onUpdate: IPoolEventEmitter<IUpdateEvent<ITable>>;
        readonly onUpdateAndFetch: IPoolEventEmitter<IUpdateAndFetchEvent<ITable>>;
        readonly onDelete: IPoolEventEmitter<IDeleteEvent<ITable>>;
    }
}
declare module "execution/pool/index" {
    export * from "execution/pool/pool";
}
declare module "execution/connection/connection" {
    import { IPool } from "execution/pool/index";
    import { IConnectionEventEmitterCollection } from "event/index";
    import { TryGetFullConnection, Lockable, TransactionIfNotInOne, ReadOnlyTransactionIfNotInOne, RawQuery, Select, InsertOne, InsertMany, InsertIgnoreOne, InsertIgnoreMany, ReplaceOne, ReplaceMany, InsertSelect, InsertIgnoreSelect, ReplaceSelect, Delete, Update, Transaction, InTransaction, IsInTransaction, ReadOnlyTransaction, TryFetchSchemaMeta, TryFetchGeneratedColumnExpression, Savepoint, IsDeallocated } from "execution/connection/component/index";
    export interface IConnection extends TryGetFullConnection, Lockable<IConnection>, TransactionIfNotInOne<ITransactionConnection>, ReadOnlyTransactionIfNotInOne, RawQuery, Select, InsertOne, InsertMany, InsertIgnoreOne, InsertIgnoreMany, ReplaceOne, ReplaceMany, InsertSelect, InsertIgnoreSelect, ReplaceSelect, Delete, Update, TryFetchSchemaMeta, TryFetchGeneratedColumnExpression, Transaction<ITransactionConnection>, ReadOnlyTransaction, IsInTransaction<ITransactionConnection>, IsDeallocated {
        readonly pool: IPool;
        readonly eventEmitters: IConnectionEventEmitterCollection;
    }
    /**
     * @todo Rename to `IIsolatedConnection`?
     */
    export interface ITransactionConnection extends TryGetFullConnection, Lockable<ITransactionConnection>, TransactionIfNotInOne<ITransactionConnection>, ReadOnlyTransactionIfNotInOne, RawQuery, Select, InsertOne, InsertMany, InsertIgnoreOne, InsertIgnoreMany, ReplaceOne, ReplaceMany, InsertSelect, InsertIgnoreSelect, ReplaceSelect, Delete, Update, TryFetchSchemaMeta, TryFetchGeneratedColumnExpression, Transaction<ITransactionConnection>, ReadOnlyTransaction, InTransaction, IsInTransaction<ITransactionConnection>, Savepoint<ITransactionConnection>, IsDeallocated {
        readonly pool: IPool;
        readonly eventEmitters: IConnectionEventEmitterCollection;
    }
    /**
     * Only `SELECT` statements can be executed by this connection.
     */
    export interface SelectConnection extends Lockable<SelectConnection>, Select {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertOneConnection extends TryGetFullConnection, Lockable<InsertOneConnection>, Select, InsertOne {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertManyConnection extends TryGetFullConnection, Lockable<InsertManyConnection>, Select, InsertMany {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertIgnoreOneConnection extends TryGetFullConnection, Lockable<InsertIgnoreOneConnection>, Select, InsertIgnoreOne {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertIgnoreManyConnection extends TryGetFullConnection, Lockable<InsertIgnoreManyConnection>, Select, InsertIgnoreMany {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface ReplaceOneConnection extends TryGetFullConnection, Lockable<ReplaceOneConnection>, Select, ReplaceOne {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface ReplaceManyConnection extends TryGetFullConnection, Lockable<ReplaceManyConnection>, Select, ReplaceMany {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertSelectConnection extends TryGetFullConnection, Lockable<InsertSelectConnection>, Select, InsertSelect {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface InsertIgnoreSelectConnection extends TryGetFullConnection, Lockable<InsertIgnoreSelectConnection>, Select, InsertIgnoreSelect {
    }
    /**
     * `INSERT` and `SELECT` statements can be executed by this connection.
     */
    export interface ReplaceSelectConnection extends TryGetFullConnection, Lockable<ReplaceSelectConnection>, Select, ReplaceSelect {
    }
    /**
     * `DELETE` and `SELECT` statements can be executed by this connection.
     */
    export interface DeleteConnection extends TryGetFullConnection, Lockable<DeleteConnection>, Select, Delete {
    }
    /**
     * `UPDATE` and `SELECT` statements can be executed by this connection.
     */
    export interface UpdateConnection extends TryGetFullConnection, Lockable<UpdateConnection>, Select, Update {
    }
}
declare module "execution/connection/index" {
    export * from "execution/connection/connection";
    export * from "execution/connection/isolable-connection";
    import { DeleteResult, InsertIgnoreManyResult, IgnoredInsertOneResult, InsertIgnoreOneResult, InsertManyResult, InsertOneResult, ReplaceManyResult, ReplaceOneResult, SelectResult, UpdateResult, RawQueryResult, LockCallback } from "execution/connection/component/index";
    export { DeleteResult, InsertIgnoreManyResult, IgnoredInsertOneResult, InsertIgnoreOneResult, InsertManyResult, InsertOneResult, ReplaceManyResult, ReplaceOneResult, SelectResult, UpdateResult, RawQueryResult, LockCallback, };
    import * as ConnectionComponent from "execution/connection/component/index";
    export { ConnectionComponent };
}
declare module "execution/index" {
    export * from "execution/connection/index";
    export * from "execution/pool/index";
    import { DeleteOneResult, DeleteZeroOrOneResult } from "execution/util/index";
    export { DeleteOneResult, DeleteZeroOrOneResult, };
    import * as ExecutionUtil from "execution/util/index";
    export { ExecutionUtil, };
}
declare module "table/util/execution/assert-exists" {
    import { SelectConnection } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { ITable } from "table/table";
    export function assertExists<TableT extends ITable>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): (Promise<void>);
}
declare module "table/util/execution/exists" {
    import { SelectConnection } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { ITable } from "table/table";
    export function exists<TableT extends ITable>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): (Promise<boolean>);
}
declare module "table/util/execution/fetch-one" {
    import { SelectConnection, ExecutionUtil } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { Row } from "row/index";
    import { SelectClause, SelectDelegate } from "select-clause/index";
    import { QueryUtil } from "unified-query/index";
    import { ITable } from "table/table";
    export function fetchOne<TableT extends ITable>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): ExecutionUtil.FetchOnePromise<Row<TableT>>;
    export function fetchOne<TableT extends ITable, SelectsT extends SelectClause>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, selectDelegate: SelectDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>, undefined, undefined, SelectsT>): (ExecutionUtil.FetchOneReturnType<QueryUtil.Select<QueryUtil.From<QueryUtil.NewInstance, TableT>, SelectsT>>);
    /**
     * Not meant to be invoked directly
     */
    export function __fetchOneHelper<TableT extends ITable>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, selectDelegate?: (...args: any[]) => any[]): ExecutionUtil.FetchOnePromise<any>;
}
declare module "table/util/execution/fetch-value" {
    import { SelectConnection, ExecutionUtil } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectValueDelegate, SelectClauseUtil } from "select-clause/index";
    import { QueryUtil } from "unified-query/index";
    import { ITable } from "table/table";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    export function fetchValue<TableT extends ITable, BuiltInExprT extends AnyBuiltInExpr>(table: TableT, connection: SelectConnection, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>, selectValueDelegate: SelectValueDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>, undefined, BuiltInExprT>): ExecutionUtil.FetchValueReturnType<
    /**
     * @todo Report assignability bug to TS issues page
     */
    QueryUtil.SelectNoSelectClause<QueryUtil.From<QueryUtil.NewInstance, TableT>, SelectClauseUtil.ValueFromBuiltInExpr<BuiltInExprT>>>;
}
declare module "table/util/execution/index" {
    export * from "table/util/execution/assert-exists";
    export * from "table/util/execution/exists";
    export * from "table/util/execution/fetch-one";
    export * from "table/util/execution/fetch-value";
}
declare module "table/util/query/column-alias" {
    import { ITable } from "table/table";
    import { ColumnMapUtil } from "column-map/index";
    export type ColumnAlias<TableT extends Pick<ITable, "columns">> = ColumnMapUtil.ColumnAlias<TableT["columns"]>;
    /**
     * @todo Pluralize this and others where relevant?
     * Be more consistent with pluralization.
     */
    export function columnAlias<TableT extends ITable>(table: TableT): ColumnAlias<TableT>[];
}
declare module "table/util/query/extract-candidate-keys-in-common" {
    import { ITable } from "table/table";
    import { KeyArrayUtil } from "key/index";
    /**
     * Returns the candidate keys of `TableT`.
     * If `TableT` is a union, then it returns the candidate keys that may be found
     * in all elements.
     *
     * + Assumes `TableT` may be a union
     */
    export type ExtractCandidateKeysInCommon<TableT extends Pick<ITable, "candidateKeys">> = (KeyArrayUtil.ExtractKeysInCommon<TableT["candidateKeys"]>);
}
declare module "table/util/query/extract-candidate-keys-with-column-alias-in-table" {
    import { ITable } from "table/table";
    import { KeyUtil } from "key/index";
    import { ExtractCandidateKeysInCommon } from "table/util/query/extract-candidate-keys-in-common";
    /**
     * + Assumes `CandidateKeysT` may be a union
     * + Assumes `ColumnAliasesT` may be a union
     * + Meant for input/write/contravariant positions.
     *
     * Extracts all candidate keys of `CandidateKeysT` with matching column aliases in `ColumnAliasesT`
     */
    export type ExtractCandidateKeysWithColumnAliasInTable_Input<CandidateKeysT extends Pick<ITable, "candidateKeys">, ColumnAliasesT extends Pick<ITable, "columns">> = (KeyUtil.ExtractIfInColumnMap<ExtractCandidateKeysInCommon<CandidateKeysT>, ColumnAliasesT["columns"]>);
    /**
     * + Assumes `CandidateKeysT` may be a union
     * + Assumes `ColumnAliasesT` may be a union
     * + Meant for output/read/covariant positions.
     *
     * Extracts all candidate keys of `CandidateKeysT` with matching column aliases in `ColumnAliasesT`
     */
    export type ExtractCandidateKeysWithColumnAliasInTable_Output<CandidateKeysT extends Pick<ITable, "candidateKeys">, ColumnAliasesT extends Pick<ITable, "columns">> = (CandidateKeysT extends Pick<ITable, "candidateKeys"> ? (ColumnAliasesT extends Pick<ITable, "columns"> ? ExtractCandidateKeysWithColumnAliasInTable_Input<CandidateKeysT, ColumnAliasesT> : never) : never);
    export function extractCandidateKeysWithColumnAliasInTable<CandidateKeysT extends Pick<ITable, "candidateKeys">, ColumnAliasesT extends Pick<ITable, "columns">>(candidateKeysTable: CandidateKeysT, columnAliasesTable: ColumnAliasesT): (ExtractCandidateKeysWithColumnAliasInTable_Output<CandidateKeysT, ColumnAliasesT>[]);
}
declare module "table/util/query/column-arrays-from-candidate-keys" {
    import { ITable } from "table/table";
    import { ColumnMap } from "column-map/index";
    import { Key } from "key/index";
    import { ColumnUtil } from "column/index";
    import { ExtractCandidateKeysWithColumnAliasInTable_Input } from "table/util/query/extract-candidate-keys-with-column-alias-in-table";
    /**
     *
     * + Assumes `SrcMapT` may be a union
     * + Assumes `ValidKeyT` may be a union
     * + Assumes `ValidKeyT` was obtained with `ExtractValidKey<SrcMapT, DstMapT>`
     */
    type ColumnArraysFromCandidateKeysImpl<SrcMapT extends ColumnMap, ValidKeyT extends Key> = (ValidKeyT extends Key ? (readonly (ColumnUtil.FromColumnMap<Pick<SrcMapT, ValidKeyT[number]>>)[]
    /**
     * Hack to force TS to infer a non-empty tuple type, rather than array type.
     * This is required to catch the following case,
     * ```ts
     *  const myTable = table("myTable")
     *      .addColumns({
     *          outerTableIdA : tm.mysql.bigIntUnsigned(),
     *          outerTableIdB : tm.mysql.boolean(),
     *          otherColumn : tm.mysql.varChar(),
     *      });
     *  const outerTable = table("outerTable")
     *      .addColumns({
     *          outerTableIdA : tm.mysql.bigIntUnsigned(),
     *          outerTableIdB : tm.mysql.boolean(),
     *          outerColumn : tm.mysql.varChar(),
     *      })
     *      .setPrimaryKey(c => [c.outerTableIdA, c.outerTableIdB]);
     *  eqCandidateKeyOfTable(
     *      myTable,
     *      outerTable,
     *      c => (
     *          //Without the "infer tuple" hack,
     *          //TS will infer,
     *          //(typeof c.outerTableIdA|typeof c.outerTableIdB)[]
     *          //This will pass the compile-time check but throw a run-time error
     *          //because [outerTableIdA] is not a candidate key.
     *          //Only [outerTableIdA, outerTableIdB] is a candidate key.
     *          Math.random() > 0.5 ?
     *          [c.outerTableIdA, c.outerTableIdB] :
     *          [c.outerTableIdA]
     *      )
     *  )
     * ```
     */
     & {
        "0": unknown;
    }) : never);
    /**
     * + Assumes `SrcT` may be a union
     * + Assumes `DstT` may be a union
     *
     * For each "compatible" candidate key in `DstT`,
     * it returns an array of columns from `SrcT`
     * that have column aliases from the candidate key
     *
     */
    export type ColumnArraysFromCandidateKeys<SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "candidateKeys">> = (ColumnArraysFromCandidateKeysImpl<SrcT["columns"], ExtractCandidateKeysWithColumnAliasInTable_Input<DstT, SrcT>>);
}
declare module "table/util/query/column-type" {
    import { ITable } from "table/table";
    export type ColumnType<TableT extends ITable, ColumnAliasT extends string> = ReturnType<TableT["columns"][ColumnAliasT]["mapper"]>;
}
declare module "table/util/query/explicit-auto-increment" {
    import { ITable } from "table/table";
    /**
     * Auto-increment column is explicit if `explicitAutoIncrementValueEnabled` is true.
     */
    export type ExplicitAutoIncrement<TableT extends Pick<ITable, "autoIncrement" | "explicitAutoIncrementValueEnabled">> = (TableT["explicitAutoIncrementValueEnabled"] extends true ? Extract<TableT["autoIncrement"], string> : never);
    /**
     * Auto-increment column is **implicit** if `explicitAutoIncrementValueEnabled` is `false` or `boolean`.
     */
    export type ImplicitAutoIncrement<TableT extends Pick<ITable, "autoIncrement" | "explicitAutoIncrementValueEnabled">> = (false extends TableT["explicitAutoIncrementValueEnabled"] ? Extract<TableT["autoIncrement"], string> : never);
    export function isExplicitAutoIncrement<TableT extends Pick<ITable, "autoIncrement" | "explicitAutoIncrementValueEnabled">>(table: TableT, columnAlias: string): columnAlias is ExplicitAutoIncrement<TableT>;
    export function isImplicitAutoIncrement<TableT extends Pick<ITable, "autoIncrement" | "explicitAutoIncrementValueEnabled">>(table: TableT, columnAlias: string): columnAlias is ImplicitAutoIncrement<TableT>;
}
declare module "table/util/query/extract-candidate-keys-with-column-alias-in-one-of-column-array" {
    import { ITable } from "table/table";
    import { KeyUtil } from "key/index";
    import { ExtractCandidateKeysInCommon } from "table/util/query/extract-candidate-keys-in-common";
    import { IColumn } from "column/index";
    /**
     * + Assumes `CandidateKeysT` may be a union
     * + Assumes `ColumnAliasesT` may be a union
     *
     * Extracts all candidate keys of `CandidateKeysT` with matching column aliases in one of `ColumnAliasesT`
     */
    export type ExtractCandidateKeysWithColumnAliasInOneOfColumnArray<CandidateKeysT extends Pick<ITable, "candidateKeys">, ColumnAliasesT extends readonly Pick<IColumn, "columnAlias">[]> = (ColumnAliasesT extends readonly Pick<IColumn, "columnAlias">[] ? KeyUtil.ExtractIfInKeyArray<ExtractCandidateKeysInCommon<CandidateKeysT>, KeyUtil.FromColumnArray<ColumnAliasesT>[]> : never);
}
declare module "table/util/query/extract-with-column-alias" {
    import { ITable } from "table/table";
    export type ExtractWithColumnAlias<TableT extends ITable, ColumnAliasT extends string> = TableT extends ITable ? (ColumnAliasT extends Extract<keyof TableT["columns"], string> ? TableT : never) : never;
}
declare module "table/util/query/extract-with-generated-column-alias" {
    import { ITable } from "table/table";
    export type ExtractWithGeneratedColumnAlias<TableT extends ITable, ColumnAliasT extends string> = TableT extends ITable ? (ColumnAliasT extends TableT["generatedColumns"][number] ? TableT : never) : never;
}
declare module "table/util/query/insertable-column-alias" {
    import { ITable } from "table/table";
    import { ColumnMapUtil } from "column-map/index";
    import { ImplicitAutoIncrement } from "table/util/query/explicit-auto-increment";
    export type InsertableColumnAlias<TableT extends ITable> = Exclude<ColumnMapUtil.ColumnAlias<TableT["columns"]>, (TableT["generatedColumns"][number] | ImplicitAutoIncrement<TableT>)>;
    export function isInsertableColumnAlias<TableT extends ITable>(table: TableT, columnAlias: string): columnAlias is InsertableColumnAlias<TableT>;
    export function insertableColumnAlias<TableT extends ITable>(table: TableT): InsertableColumnAlias<TableT>[];
}
declare module "table/util/query/optional-column-alias" {
    import { ITable } from "table/table";
    import { ExplicitAutoIncrement } from "table/util/query/explicit-auto-increment";
    export type OptionalColumnAlias<TableT extends ITable> = ExplicitAutoIncrement<TableT> | Exclude<(TableT["nullableColumns"][number] | TableT["explicitDefaultValueColumns"][number]), (TableT["generatedColumns"][number])>;
    export function isOptionalColumnAlias<TableT extends ITable>(table: TableT, columnAlias: string): columnAlias is OptionalColumnAlias<TableT>;
    export function optionalColumnAlias<TableT extends ITable>(table: TableT): OptionalColumnAlias<TableT>[];
}
declare module "table/util/query/required-column-alias" {
    import { ITable } from "table/table";
    import { ColumnMapUtil } from "column-map/index";
    export type RequiredColumnAlias<TableT extends ITable> = Exclude<ColumnMapUtil.ColumnAlias<TableT["columns"]>, (TableT["generatedColumns"][number] | TableT["nullableColumns"][number] | TableT["explicitDefaultValueColumns"][number] | TableT["autoIncrement"])>;
    export function isRequiredColumnAlias<TableT extends ITable>(table: TableT, columnAlias: string): columnAlias is RequiredColumnAlias<TableT>;
    export function requiredColumnAlias<TableT extends ITable>(table: TableT): RequiredColumnAlias<TableT>[];
}
declare module "table/util/query/try-get-schema-name" {
    import { ITable } from "table/table";
    export function tryGetSchemaName(table: ITable): string | undefined;
}
declare module "table/util/query/index" {
    export * from "table/util/query/column-alias";
    export * from "table/util/query/column-arrays-from-candidate-keys";
    export * from "table/util/query/column-type";
    export * from "table/util/query/explicit-auto-increment";
    export * from "table/util/query/extract-candidate-keys-in-common";
    export * from "table/util/query/extract-candidate-keys-with-column-alias-in-one-of-column-array";
    export * from "table/util/query/extract-candidate-keys-with-column-alias-in-table";
    export * from "table/util/query/extract-with-column-alias";
    export * from "table/util/query/extract-with-generated-column-alias";
    export * from "table/util/query/insertable-column-alias";
    export * from "table/util/query/optional-column-alias";
    export * from "table/util/query/required-column-alias";
    export * from "table/util/query/try-get-schema-name";
}
declare module "table/util/operation/add-all-mutable" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ImplicitAutoIncrement } from "table/util/query/index";
    /**
     * Helper type to get all column aliases that can be mutable.
     *
     * + Generated columns cannot be mutable.
     * + Auto-increment column is mutable if `explicitAutoIncrementValueEnabled` is true.
     */
    export type AddAllMutableColumnAlias<TableT extends Pick<ITable, "columns" | "generatedColumns" | "autoIncrement" | "explicitAutoIncrementValueEnabled">> = (Exclude<Extract<keyof TableT["columns"], string>, TableT["generatedColumns"][number] | ImplicitAutoIncrement<TableT>>);
    /**
     * Makes all non-generated columns mutable.
     *
     * + Mutable columns may be modified with `UPDATE` statements using this library.
     * + Immutable columns may not be modified with this library
     *   (but could still be modified outside of this library)
     */
    export type AddAllMutable<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        /**
         * All non-generated columns are now mutable.
         */
        mutableColumns: readonly AddAllMutableColumnAlias<TableT>[];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Makes all non-generated columns, and non-implicit auto-increment mutable.
     *
     * + Mutable columns may be modified with `UPDATE` statements using this library.
     * + Immutable columns may not be modified with this library
     *   (but could still be modified outside of this library)
     *
     * @param table
     */
    export function addAllMutable<TableT extends ITable>(table: TableT): (AddAllMutable<TableT>);
}
declare module "table/util/predicate/assert-delete-enabled" {
    import { ITable, DeletableTable } from "table/table";
    export function isDeleteEnabled(table: ITable): table is DeletableTable;
    export function assertDeleteEnabled(table: ITable): void;
}
declare module "table/util/predicate/assert-has-candidate-key" {
    import { ITable } from "table/table";
    import { CompileError } from "compile-error/index";
    export type AssertHasCandidateKey<TableT extends ITable> = TableT["candidateKeys"][number] extends never ? CompileError<[TableT["alias"], "must have a candidate key"]> : unknown;
    export function assertHasCandidateKey(table: ITable): void;
}
declare module "table/util/predicate/assert-has-column-identifiers" {
    import { ITable } from "table/table";
    import { IColumn } from "column/index";
    /**
     * A run-time check mostly for JS-land users.
     *
     * Checks that the `table` contains all `columns` passed through,
     * using just the `tableAlias` and `columnAlias`.
     *
     * @param table
     * @param columns
     */
    export function assertHasColumnIdentifiers(table: Pick<ITable, "columns">, columns: readonly IColumn[]): void;
}
declare module "table/util/predicate/has-null-safe-comparable-primary-key" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/index";
    import { IsNullSafeComparable } from "type-util/index";
    import { TableWithPrimaryKey } from "table/table";
    /**
     * Returns `true` if all primary key columns of `TableT`
     * are **null-safe** comparable with columns in `ColumnMapT` that have the same name
     *
     * Assumes `TableT` is not a union
     */
    export type HasNullSafeComparablePrimaryKey<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">, ColumnMapT extends ColumnMap> = ({
        [k in TableT["primaryKey"][number]]: (k extends Extract<keyof ColumnMapT, string> ? IsNullSafeComparable<tm.OutputOf<TableT["columns"][k]["mapper"]>, tm.OutputOf<ColumnMapT[k]["mapper"]>> : false);
    }[TableT["primaryKey"][number]]);
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring PK columns and `columnMap` columns
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    export function hasNullSafeComparablePrimaryKey(table: Pick<TableWithPrimaryKey, "columns" | "primaryKey">, columnMap: ColumnMap): boolean;
}
declare module "table/util/predicate/assert-has-null-safe-comparable-primary-key" {
    import { ColumnMap } from "column-map/index";
    import { TableWithPrimaryKey } from "table/table";
    import { HasNullSafeComparablePrimaryKey } from "table/util/predicate/has-null-safe-comparable-primary-key";
    import { CompileError, CompileOk } from "compile-error/index";
    import { TypeMapUtil } from "type-map/index";
    import { Writable, DistributePick, ToUnknownIfCompileOk } from "type-util/index";
    /**
     * Returns `unknown` if all primary key columns of `TableT`
     * are **null-safe** comparable with columns in `ColumnMapT` that have the same name
     *
     * Assumes `TableT` is not a union
     */
    export type AssertHasNullSafeComparablePrimaryKey<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">, ColumnMapT extends ColumnMap> = ToUnknownIfCompileOk<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey"> ? (HasNullSafeComparablePrimaryKey<TableT, ColumnMapT> extends true ? CompileOk : CompileError<[Writable<TypeMapUtil.FromColumnMap<DistributePick<TableT["columns"], TableT["primaryKey"][number]>>>, "is not null-safe comparable to", Writable<TypeMapUtil.FromColumnMap<Pick<ColumnMapT, Extract<TableT["primaryKey"][number], keyof ColumnMapT>>>>]>) : never>;
    export function assertHasNullSafeComparablePrimaryKey(table: Pick<TableWithPrimaryKey, "columns" | "primaryKey">, columnMap: ColumnMap): void;
}
declare module "table/util/predicate/assert-insert-enabled" {
    import { ITable, InsertableTable } from "table/table";
    export function isInsertEnabled(table: ITable): table is InsertableTable;
    export function assertInsertEnabled(table: ITable): void;
}
declare module "table/util/predicate/has-explicit-default-value" {
    import { ITable } from "table/table";
    /**
     * Assumes `TableT` may be a union type
     */
    export type HasExplicitDefaultValue<TableT extends ITable, ColumnAliasT extends string> = TableT extends ITable ? (ColumnAliasT extends TableT["explicitDefaultValueColumns"][number] ? true : false) : never;
}
declare module "table/util/predicate/is-nullable" {
    import { ITable } from "table/table";
    /**
     * Assumes `TableT` may be a union type
     */
    export type IsNullable<TableT extends ITable, ColumnAliasT extends string> = TableT extends ITable ? (ColumnAliasT extends TableT["nullableColumns"][number] ? true : false) : never;
}
declare module "table/util/predicate/is-mutable" {
    import { ITable } from "table/table";
    /**
     * Assumes `TableT` may be a union type
     */
    export type IsMutable<TableT extends ITable, ColumnAliasT extends string> = TableT extends ITable ? (ColumnAliasT extends TableT["mutableColumns"][number] ? true : false) : never;
}
declare module "table/util/predicate/is-table" {
    import { ITable } from "table/table";
    /**
     * Actually only checks if it has all the properties of `ITable`.
     *
     * So, if it has all the properties but they're of the wrong data type...
     */
    export function isTable(mixed: unknown): mixed is ITable;
}
declare module "table/util/predicate/index" {
    export * from "table/util/predicate/assert-delete-enabled";
    export * from "table/util/predicate/assert-has-candidate-key";
    export * from "table/util/predicate/assert-has-column-identifiers";
    export * from "table/util/predicate/assert-has-null-safe-comparable-primary-key";
    export * from "table/util/predicate/assert-insert-enabled";
    export * from "table/util/predicate/has-explicit-default-value";
    export * from "table/util/predicate/has-null-safe-comparable-primary-key";
    export * from "table/util/predicate/is-nullable";
    export * from "table/util/predicate/is-mutable";
    export * from "table/util/predicate/is-table";
}
declare module "table/util/operation/add-candidate-key" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { CompileError } from "compile-error/index";
    import { ColumnUtil, IColumn } from "column/index";
    import { KeyUtil, KeyArrayUtil } from "key/index";
    /**
     * This delegate returns a candidate key
     */
    export type AddCandidateKeyDelegate<TableT extends Pick<ITable, "columns">, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = ((columnMap: TableT["columns"]) => KeyT);
    export type AssertNotEmptyKey<KeyT extends readonly IColumn[]> = (KeyT[number] extends never ? CompileError<["Key cannot be empty"]> : unknown);
    export function assertNotEmptyKey(columns: readonly IColumn[]): void;
    export type AssertNotSubKey<TableT extends Pick<ITable, "candidateKeys" | "columns">, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (KeyArrayUtil.FindSuperKey<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>> extends never ? unknown : CompileError<[KeyUtil.FromColumnArray<KeyT>, "is a sub key of", KeyArrayUtil.FindSuperKey<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>>]>);
    export function assertNotSubKey(table: Pick<ITable, "candidateKeys" | "columns">, columns: readonly IColumn[]): void;
    export type AssertNotSuperKey<TableT extends Pick<ITable, "candidateKeys" | "columns">, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (KeyArrayUtil.FindSubKey<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>> extends never ? unknown : CompileError<[KeyUtil.FromColumnArray<KeyT>, "is a super key of", KeyArrayUtil.FindSubKey<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>>]>);
    export function assertNotSuperKey(table: Pick<ITable, "candidateKeys" | "columns">, columns: readonly IColumn[]): void;
    /**
     * The new candidate key, `KeyT`, must not be a super key or sub key
     * of an existing candidate key.
     *
     * Otherwise, either the new or existing key is not a candidate key
     * **by definition**.
     *
     * The definition of a candidate key is a
     * **smallest** possible set of columns that
     * uniquely identifies a row in a table.
     *
     * There may be multiple such sets.
     */
    export type AssertValidCandidateKey<TableT extends Pick<ITable, "candidateKeys" | "columns">, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (AssertNotEmptyKey<KeyT> & AssertNotSubKey<TableT, KeyT> & AssertNotSuperKey<TableT, KeyT>);
    export function assertValidCandidateKey(table: Pick<ITable, "candidateKeys" | "columns">, columns: readonly IColumn[]): void;
    /**
     * Adds a candidate key to the table.
     *
     * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
     *
     * + A table may have zero-to-many candidate keys. (recommended to have at least one)
     * + A candidate key cannot be a subset of other candidate keys.
     * + A candidate key cannot be a superset of other candidate keys.
     * + A candidate key can intersect other candidate keys.
     * + A candidate key can be disjoint from other candidate keys.
     */
    export type AddCandidateKey<TableT extends ITable, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: KeyArrayUtil.Append<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>>;
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Adds a candidate key to the table.
     *
     * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
     *
     * + A table may have zero-to-many candidate keys. (recommended to have at least one)
     * + A candidate key cannot be a subset of other candidate keys.
     * + A candidate key cannot be a superset of other candidate keys.
     * + A candidate key can intersect other candidate keys.
     * + A candidate key can be disjoint from other candidate keys.
     *
     * @param table
     * @param delegate
     */
    export function addCandidateKey<TableT extends ITable, KeyT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]>(table: TableT, delegate: (AddCandidateKeyDelegate<TableT, (KeyT & AssertValidCandidateKey<TableT, KeyT>)>)): (AddCandidateKey<TableT, KeyT>);
}
declare module "table/util/operation/add-columns-from-field-array" {
    import * as tm from "type-mapping";
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnMapUtil } from "column-map/index";
    export type AddColumnsFromFieldArray<TableT extends ITable, FieldsT extends readonly tm.AnyField[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: ColumnMapUtil.Intersect<TableT["columns"], ColumnMapUtil.FromFieldArray<TableT["alias"], FieldsT>>;
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: ColumnMapUtil.NullableColumnAlias<ColumnMapUtil.Intersect<TableT["columns"], ColumnMapUtil.FromFieldArray<TableT["alias"], FieldsT>>>[];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Converts an array of fields to columns of the table
     *
     * @param table
     * @param fields
     *
     * @deprecated
     */
    export function addColumnsFromFieldArray<TableT extends ITable, FieldsT extends readonly tm.AnyField[]>(table: TableT, fields: FieldsT): (AddColumnsFromFieldArray<TableT, FieldsT>);
}
declare module "mapper-map/mapper-map" {
    import * as tm from "type-mapping";
    export type MapperMap = {
        readonly [columnAlias: string]: tm.AnySafeMapper;
    };
}
declare module "mapper-map/util/query/nullable-key" {
    import * as tm from "type-mapping";
    import { MapperMap } from "mapper-map/mapper-map";
    export type NullableKey<MapT extends MapperMap> = ({
        [columnAlias in Extract<keyof MapT, string>]: (null extends tm.OutputOf<MapT[columnAlias]> ? columnAlias : never);
    }[Extract<keyof MapT, string>]);
    export function nullableKeys<MapT extends MapperMap>(map: MapT): (NullableKey<MapT>[]);
}
declare module "mapper-map/util/query/index" {
    export * from "mapper-map/util/query/nullable-key";
}
declare module "mapper-map/util/index" {
    export * from "mapper-map/util/query/index";
}
declare module "mapper-map/index" {
    export * from "mapper-map/mapper-map";
    import * as MapperMapUtil from "mapper-map/util/index";
    export { MapperMapUtil, };
}
declare module "table/util/operation/add-columns-from-mapper-map" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { MapperMap } from "mapper-map/index";
    import { ColumnMapUtil } from "column-map/index";
    export type AddColumnsFromMapperMap<TableT extends ITable, MapperMapT extends MapperMap> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: ColumnMapUtil.Intersect<TableT["columns"], ColumnMapUtil.FromMapperMap<TableT["alias"], MapperMapT>>;
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: ColumnMapUtil.NullableColumnAlias<ColumnMapUtil.Intersect<TableT["columns"], ColumnMapUtil.FromMapperMap<TableT["alias"], MapperMapT>>>[];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Converts a map of `columnAlias -> mapper` to columns of the table
     *
     * @param table
     * @param mapperMap
     */
    export function addColumnsFromMapperMap<TableT extends ITable, MapperMapT extends MapperMap>(table: TableT, mapperMap: MapperMapT): (AddColumnsFromMapperMap<TableT, MapperMapT>);
}
declare module "table/util/operation/add-columns" {
    import * as sd from "type-mapping";
    import { ITable } from "table/table";
    import { MapperMap } from "mapper-map/index";
    import { AddColumnsFromFieldArray } from "table/util/operation/add-columns-from-field-array";
    import { AddColumnsFromMapperMap } from "table/util/operation/add-columns-from-mapper-map";
    /**
     * Adds columns to the table
     *
     * @deprecated
     */
    export function addColumns<TableT extends ITable, FieldsT extends sd.AnyField[]>(table: TableT, fields: FieldsT): (AddColumnsFromFieldArray<TableT, FieldsT>);
    /**
     * Adds columns to the table
     */
    export function addColumns<TableT extends ITable, MapperMapT extends MapperMap>(table: TableT, assertMap: MapperMapT): (AddColumnsFromMapperMap<TableT, MapperMapT>);
}
declare module "table/util/operation/add-explicit-default-value" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    /**
     * + Generated columns have implicit default values
     * + nullable columns have implicit default values
     * + `AUTO_INCREMENT` columns have implicit default values
     */
    export type AddExplicitDefaultValueColumnAlias<TableT extends Pick<ITable, "columns" | "generatedColumns" | "nullableColumns" | "autoIncrement" | "explicitDefaultValueColumns">> = (Exclude<Extract<keyof TableT["columns"], string>, (TableT["generatedColumns"][number] | TableT["autoIncrement"] | TableT["explicitDefaultValueColumns"][number])>);
    export type AddExplicitDefaultValueColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "nullableColumns" | "autoIncrement" | "explicitDefaultValueColumns">> = ({
        readonly [columnAlias in AddExplicitDefaultValueColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function addExplicitDefaultValueColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "nullableColumns" | "autoIncrement" | "explicitDefaultValueColumns">>(table: TableT): (AddExplicitDefaultValueColumnMap<TableT>);
    export type AddExplicitDefaultValueDelegate<TableT extends Pick<ITable, "columns" | "generatedColumns" | "nullableColumns" | "autoIncrement" | "explicitDefaultValueColumns">, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddExplicitDefaultValueColumnMap<TableT>>[]> = ((columnMap: AddExplicitDefaultValueColumnMap<TableT>) => ColumnsT);
    export type AddExplicitDefaultValue<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddExplicitDefaultValueColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        /**
         * Our new columns with explicit default values
         */
        explicitDefaultValueColumns: KeyUtil.Concat<TableT["explicitDefaultValueColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Tells the library that these columns have explicit `DEFAULT` values.
     *
     * An example of an "explicit" default value,
     * ```sql
     * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
     * ```
     *
     * + Columns with server default values are optional with `INSERT` statements.
     * + Generated columns have implicit default values.
     * + Nullable columns have implicit default values.
     * + `AUTO_INCREMENT` columns have implicit default values
     *
     * -----
     *
     * @param table
     * @param delegate
     */
    export function addExplicitDefaultValue<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddExplicitDefaultValueColumnMap<TableT>>[]>(table: TableT, delegate: (AddExplicitDefaultValueDelegate<TableT, ColumnsT>)): (AddExplicitDefaultValue<TableT, ColumnsT>);
}
declare module "table/util/operation/add-generated" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    export type AddGeneratedColumnAlias<TableT extends Pick<ITable, "columns" | "generatedColumns" | "autoIncrement">> = (Exclude<Extract<keyof TableT["columns"], string>, TableT["generatedColumns"][number]
    /**
     * A column cannot be both auto-increment and generated
     */
     | TableT["autoIncrement"]>);
    export type AddGeneratedColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "autoIncrement">> = ({
        readonly [columnAlias in AddGeneratedColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function addGeneratedColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "autoIncrement">>(table: TableT): (AddGeneratedColumnMap<TableT>);
    export type AddGeneratedDelegate<TableT extends Pick<ITable, "columns" | "generatedColumns" | "autoIncrement">, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddGeneratedColumnMap<TableT>>[]> = ((columnMap: AddGeneratedColumnMap<TableT>) => ColumnsT);
    export type AddGenerated<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddGeneratedColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        /**
         * Our new generated columns.
         */
        generatedColumns: KeyUtil.Concat<TableT["generatedColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        nullableColumns: TableT["nullableColumns"];
        /**
         * Generated columns have implicit default values.
         * Not explicit.
         */
        explicitDefaultValueColumns: KeyUtil.Subtract<TableT["explicitDefaultValueColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        /**
         * Generated columns cannot be mutable.
         * Their value is controlled by the database server.
         */
        mutableColumns: KeyUtil.Subtract<TableT["mutableColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Adds a `GENERATED` column to the table.
     *
     * + Setting generated column values will not be allowed with `INSERT` statements.
     * + Updating generated column values will also not be allowed with `UPDATE` statements.
     *
     * @param table
     * @param delegate
     */
    export function addGenerated<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddGeneratedColumnMap<TableT>>[]>(table: TableT, delegate: (AddGeneratedDelegate<TableT, ColumnsT>)): (AddGenerated<TableT, ColumnsT>);
}
declare module "table/util/operation/add-mutable" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    import { ImplicitAutoIncrement } from "table/util/query/index";
    /**
     * + Generated columns cannot be mutable.
     * + Auto-increment columns marked implicit cannot be mutable.
     */
    export type AddMutableColumnAlias<TableT extends Pick<ITable, "columns" | "generatedColumns" | "mutableColumns" | "autoIncrement" | "explicitAutoIncrementValueEnabled">> = (Exclude<Extract<keyof TableT["columns"], string>, (TableT["generatedColumns"][number] | TableT["mutableColumns"][number] | ImplicitAutoIncrement<TableT>)>);
    export type AddMutableColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "mutableColumns" | "autoIncrement" | "explicitAutoIncrementValueEnabled">> = ({
        readonly [columnAlias in AddMutableColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function addMutableColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns" | "mutableColumns" | "autoIncrement" | "explicitAutoIncrementValueEnabled">>(table: TableT): (AddMutableColumnMap<TableT>);
    export type AddMutableDelegate<TableT extends Pick<ITable, "columns" | "generatedColumns" | "mutableColumns" | "autoIncrement" | "explicitAutoIncrementValueEnabled">, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddMutableColumnMap<TableT>>[]> = ((columnMap: AddMutableColumnMap<TableT>) => ColumnsT);
    export type AddMutable<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddMutableColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        /**
         * Our new mutable columns
         */
        mutableColumns: KeyUtil.Concat<TableT["mutableColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Lets these columns be updated through this library.
     *
     * @param table
     * @param delegate
     */
    export function addMutable<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<AddMutableColumnMap<TableT>>[]>(table: TableT, delegate: (AddMutableDelegate<TableT, ColumnsT>)): (AddMutable<TableT, ColumnsT>);
}
declare module "table/util/operation/as" {
    import { ITable } from "table/table";
    import { ColumnMapUtil } from "column-map/index";
    import { Table } from "table/table-impl";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type AsImpl<NewTableAliasT extends string, IsLateralT extends ITable["isLateral"], ColumnsT extends ITable["columns"], UsedRefT extends ITable["usedRef"], AutoIncrementT extends ITable["autoIncrement"], IdT extends ITable["id"], PrimaryKeyT extends ITable["primaryKey"], CandidateKeysT extends ITable["candidateKeys"], InsertEnabledT extends ITable["insertEnabled"], DeleteEnabledT extends ITable["deleteEnabled"], GeneratedColumnsT extends ITable["generatedColumns"], NullableColumnsT extends ITable["nullableColumns"], ExplicitDefaultValueColumnsT extends ITable["explicitDefaultValueColumns"], MutableColumnsT extends ITable["mutableColumns"], AllowExplicitAutoIncrementValueT extends ITable["explicitAutoIncrementValueEnabled"]> = Table<{
        isLateral: IsLateralT;
        alias: NewTableAliasT;
        columns: ColumnMapUtil.WithTableAlias<ColumnsT, NewTableAliasT>;
        usedRef: UsedRefT;
        autoIncrement: AutoIncrementT;
        id: IdT;
        primaryKey: PrimaryKeyT;
        candidateKeys: CandidateKeysT;
        insertEnabled: InsertEnabledT;
        deleteEnabled: DeleteEnabledT;
        generatedColumns: GeneratedColumnsT;
        nullableColumns: NullableColumnsT;
        explicitDefaultValueColumns: ExplicitDefaultValueColumnsT;
        mutableColumns: MutableColumnsT;
        explicitAutoIncrementValueEnabled: AllowExplicitAutoIncrementValueT;
    }>;
    export type As<TableT extends ITable, NewTableAliasT extends string> = AsImpl<NewTableAliasT, TableT["isLateral"], TableT["columns"], TableT["usedRef"], TableT["autoIncrement"], TableT["id"], TableT["primaryKey"], TableT["candidateKeys"], TableT["insertEnabled"], TableT["deleteEnabled"], TableT["generatedColumns"], TableT["nullableColumns"], TableT["explicitDefaultValueColumns"], TableT["mutableColumns"], TableT["explicitAutoIncrementValueEnabled"]>;
    /**
     * Aliases a table reference in a query.
     *
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable AS aliasedTable
     * ```
     */
    export function as<TableT extends ITable, NewTableAliasT extends string>(table: TableT, newTableAlias: NewTableAliasT): (As<TableT, NewTableAliasT>);
}
declare module "table/util/operation/disable-delete" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    /**
     * @todo Add `EnableDelete`? Will it even ever see use?
     */
    export type DisableDelete<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: false;
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Prevents rows of this table from being deleted through this library.
     *
     * Good for look-up tables, or append-only tables.
     *
     * @param table
     */
    export function disableDelete<TableT extends ITable>(table: TableT): (DisableDelete<TableT>);
}
declare module "table/util/operation/disable-insert" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type DisableInsert<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: false;
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Prevents rows from being inserted through this library.
     *
     * Good for look-up tables.
     *
     * @param table
     */
    export function disableInsert<TableT extends ITable>(table: TableT): (DisableInsert<TableT>);
}
declare module "table/util/operation/enable-explicit-auto-increment-value" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type EnableExplicitAutoIncrementValue<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: true;
    }>);
    /**
     * Allows explicit values for auto-increment columns.
     */
    export function enableExplicitAutoIncrementValue<TableT extends ITable>(table: TableT): (EnableExplicitAutoIncrementValue<TableT>);
}
declare module "table/util/operation/enable-insert" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type EnableInsert<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: true;
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    export function enableInsert<TableT extends ITable>(table: TableT): (EnableInsert<TableT>);
}
declare module "table/util/operation/pick-columns" {
    import { ITable } from "table/table";
    import { AliasedTable } from "aliased-table/index";
    import { ColumnUtil } from "column/index";
    import { ExpandPick } from "type-util/index";
    export type PickColumnsDelegate<TableT extends Pick<ITable, "columns">, NewColumnsT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (columnMap: TableT["columns"]) => NewColumnsT;
    export type PickColumns<TableT extends ITable, NewColumnsT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]> = (AliasedTable<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: ExpandPick<TableT["columns"], NewColumnsT[number]["columnAlias"]>;
        usedRef: TableT["usedRef"];
    }>);
    export function pickColumns<TableT extends ITable, NewColumnsT extends readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]>(table: TableT, delegate: (PickColumnsDelegate<TableT, NewColumnsT>)): (PickColumns<TableT, NewColumnsT>);
}
declare module "table/util/operation/remove-all-mutable" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type RemoveAllMutable<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        /**
         * No columns are mutable
         */
        mutableColumns: readonly [];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Makes all columns immutable.
     *
     * @param table
     */
    export function removeAllMutable<TableT extends ITable>(table: TableT): (RemoveAllMutable<TableT>);
}
declare module "table/util/operation/remove-explicit-default-value" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    export type RemoveExplicitDefaultValueColumnAlias<TableT extends Pick<ITable, "columns" | "explicitDefaultValueColumns">> = (Extract<keyof TableT["columns"], TableT["explicitDefaultValueColumns"][number]>);
    export type RemoveExplicitDefaultValueColumnMap<TableT extends Pick<ITable, "columns" | "explicitDefaultValueColumns">> = ({
        readonly [columnAlias in RemoveExplicitDefaultValueColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function removeExplicitDefaultValueColumnMap<TableT extends Pick<ITable, "columns" | "explicitDefaultValueColumns">>(table: TableT): (RemoveExplicitDefaultValueColumnMap<TableT>);
    export type RemoveExplicitDefaultValueDelegate<TableT extends Pick<ITable, "columns" | "explicitDefaultValueColumns">, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveExplicitDefaultValueColumnMap<TableT>>[]> = ((columnMap: RemoveExplicitDefaultValueColumnMap<TableT>) => ColumnsT);
    export type RemoveExplicitDefaultValue<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveExplicitDefaultValueColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        /**
         * Subtract from `explicitDefaultValueColumns`
         */
        explicitDefaultValueColumns: KeyUtil.Subtract<TableT["explicitDefaultValueColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Removes columns from the set of columns with explicit `DEFAULT` values
     *
     * @param table
     * @param delegate
     */
    export function removeExplicitDefaultValue<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveExplicitDefaultValueColumnMap<TableT>>[]>(table: TableT, delegate: (RemoveExplicitDefaultValueDelegate<TableT, ColumnsT>)): (RemoveExplicitDefaultValue<TableT, ColumnsT>);
}
declare module "table/util/operation/remove-generated" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    export type RemoveGeneratedColumnAlias<TableT extends Pick<ITable, "columns" | "generatedColumns">> = (Extract<keyof TableT["columns"], TableT["generatedColumns"][number]>);
    export type RemoveGeneratedColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns">> = ({
        readonly [columnAlias in RemoveGeneratedColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function removeGeneratedColumnMap<TableT extends Pick<ITable, "columns" | "generatedColumns">>(table: TableT): (RemoveGeneratedColumnMap<TableT>);
    export type RemoveGeneratedDelegate<TableT extends Pick<ITable, "columns" | "generatedColumns">, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveGeneratedColumnMap<TableT>>[]> = ((columnMap: RemoveGeneratedColumnMap<TableT>) => ColumnsT);
    export type RemoveGenerated<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveGeneratedColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        /**
         * Subtract from `generatedColumns`
         */
        generatedColumns: KeyUtil.Subtract<TableT["generatedColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        /**
         * The column is no longer generated and you may make it
         * mutable by using `.addMutable()`
         */
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Removes columns from the set of `GENERATED` columns.
     *
     * @param table
     * @param delegate
     */
    export function removeGenerated<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveGeneratedColumnMap<TableT>>[]>(table: TableT, delegate: (RemoveGeneratedDelegate<TableT, ColumnsT>)): (RemoveGenerated<TableT, ColumnsT>);
}
declare module "table/util/operation/remove-mutable" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil } from "column/index";
    import { KeyUtil } from "key/index";
    export type RemoveMutableColumnAlias<TableT extends Pick<ITable, "columns" | "mutableColumns">> = (Extract<keyof TableT["columns"], TableT["mutableColumns"][number]>);
    export type RemoveMutableColumnMap<TableT extends Pick<ITable, "columns" | "mutableColumns">> = ({
        readonly [columnAlias in RemoveMutableColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function removeMutableColumnMap<TableT extends Pick<ITable, "columns" | "mutableColumns">>(table: TableT): (RemoveMutableColumnMap<TableT>);
    export type RemoveMutableDelegate<TableT extends Pick<ITable, "columns" | "mutableColumns">, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveMutableColumnMap<TableT>>[]> = ((columnMap: RemoveMutableColumnMap<TableT>) => ColumnsT);
    export type RemoveMutable<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveMutableColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        /**
         * Subtract from `mutableColumns`
         */
        mutableColumns: KeyUtil.Subtract<TableT["mutableColumns"], KeyUtil.FromColumnArray<ColumnsT>>;
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Removes columns from the set of mutable columns.
     *
     * You will not be able to update them through this library.
     *
     * @param table
     * @param delegate
     */
    export function removeMutable<TableT extends ITable, ColumnsT extends readonly ColumnUtil.FromColumnMap<RemoveMutableColumnMap<TableT>>[]>(table: TableT, delegate: (RemoveMutableDelegate<TableT, ColumnsT>)): (RemoveMutable<TableT, ColumnsT>);
}
declare module "table/util/operation/set-primary-key" {
    import * as tm from "type-mapping";
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil, IColumn } from "column/index";
    import { AssertValidCandidateKey } from "table/util/operation/add-candidate-key";
    import { KeyArrayUtil, KeyUtil } from "key/index";
    import { ReadOnlyPick } from "type-util/index";
    /**
     * @todo Allow custom data types for primary key.
     * The downside of this is that checking for `NULL` values will become harder.
     */
    export type SetPrimaryKeyColumnAlias<TableT extends Pick<ITable, "columns">> = ({
        [columnAlias in Extract<keyof TableT["columns"], string>]: (null extends tm.OutputOf<TableT["columns"][columnAlias]["mapper"]> ? 
        /**
         * Cannot be nullable
         */
        never : columnAlias);
    }[Extract<keyof TableT["columns"], string>]);
    export type SetPrimaryKeyColumnMap<TableT extends Pick<ITable, "columns">> = ReadOnlyPick<TableT["columns"], SetPrimaryKeyColumnAlias<TableT>>;
    export function setPrimaryKeyColumnMap<TableT extends Pick<ITable, "columns">>(table: TableT): (SetPrimaryKeyColumnMap<TableT>);
    export type SetPrimaryKeyDelegate<TableT extends Pick<ITable, "columns" | "candidateKeys">, KeyT extends readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]> = ((columnMap: SetPrimaryKeyColumnMap<TableT>) => (KeyT));
    export type AssertValidPrimaryKey<TableT extends Pick<ITable, "columns" | "candidateKeys">, KeyT extends readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]> = (AssertValidCandidateKey<TableT, Extract<KeyT, readonly ColumnUtil.FromColumnMap<TableT["columns"]>[]>>);
    export function assertValidPrimaryKey(table: Pick<ITable, "candidateKeys" | "columns">, columns: readonly IColumn[]): void;
    export type SetPrimaryKey<TableT extends ITable, KeyT extends readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: (KeyUtil.FromColumnArray<KeyT>);
        candidateKeys: KeyArrayUtil.Append<TableT["candidateKeys"], KeyUtil.FromColumnArray<KeyT>>;
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Sets the `PRIMARY KEY` of the table.
     *
     * In MySQL, a `PRIMARY KEY` is just a candidate key
     * where all its columns are non-nullable.
     *
     * -----
     *
     * + `PRIMARY KEY` columns cannot be nullable
     * + `PRIMARY KEY` columns must be a candidate key
     */
    export function setPrimaryKey<TableT extends ITable, KeyT extends readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]>(table: TableT, delegate: (SetPrimaryKeyDelegate<TableT, (KeyT & AssertValidPrimaryKey<TableT, KeyT>)>)): (SetPrimaryKey<TableT, KeyT>);
}
declare module "table/util/operation/set-auto-increment" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { IAnonymousColumn, ColumnUtil, IColumn } from "column/index";
    import { KeyArrayUtil, KeyUtil } from "key/index";
    import { AssertValidPrimaryKey, SetPrimaryKeyColumnMap } from "table/util/operation/set-primary-key";
    export type SetAutoIncrementColumnAlias<TableT extends Pick<ITable, "columns" | "candidateKeys">> = ({
        [columnAlias in Extract<keyof TableT["columns"], string>]: (TableT["columns"][columnAlias] extends IAnonymousColumn<number | string | bigint> ? (columnAlias extends TableT["candidateKeys"][number][number] ? 
        /**
         * Columns already a part of a candidate key cannot be `AUTO_INCREMENT`
         */
        never : columnAlias) : 
        /**
         * Only `number|string|bigint` allowed
         */
        never);
    }[Extract<keyof TableT["columns"], string>]);
    export type SetAutoIncrementColumnMap<TableT extends Pick<ITable, "columns" | "candidateKeys">> = ({
        readonly [columnName in SetAutoIncrementColumnAlias<TableT>]: (TableT["columns"][columnName]);
    });
    export function setAutoIncrementColumnMap<TableT extends Pick<ITable, "columns" | "candidateKeys">>(table: TableT): (SetAutoIncrementColumnMap<TableT>);
    export type SetAutoIncrementDelegate<TableT extends Pick<ITable, "columns" | "candidateKeys">, AutoIncrementT extends ColumnUtil.FromColumnMap<SetAutoIncrementColumnMap<TableT>>> = ((columnMap: SetAutoIncrementColumnMap<TableT>) => (AutoIncrementT));
    export type AssertValidAutoIncrement<TableT extends Pick<ITable, "columns" | "candidateKeys">, AutoIncrementT extends ColumnUtil.FromColumnMap<SetAutoIncrementColumnMap<TableT>>> = (AssertValidPrimaryKey<TableT, Extract<AutoIncrementT[], readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]>>);
    export function assertValidAutoIncrement(table: Pick<ITable, "candidateKeys" | "columns">, autoIncrement: IColumn): void;
    export type SetAutoIncrement<TableT extends ITable, AutoIncrementT extends ColumnUtil.FromColumnMap<SetAutoIncrementColumnMap<TableT>>> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        /**
         * This is now our `AUTO_INCREMENT` column.
         */
        autoIncrement: AutoIncrementT["columnAlias"];
        /**
         * By default, we make the `AUTO_INCREMENT` column
         * the one-column-identifier.
         *
         * You may overwrite it by calling,
         * `.setId()`
         */
        id: AutoIncrementT["columnAlias"];
        /**
         * By default, we make the `AUTO_INCREMENT` column
         * the primary key.
         *
         * Usually, your `AUTO_INCREMENT` column is also the primary key.
         * There is almost no reason for you to set anything else as the primary key.
         *
         * You may overwrite it by calling,
         * `.setPrimaryKey()`
         */
        primaryKey: KeyUtil.FromColumn<AutoIncrementT>;
        /**
         * A set containing the `AUTO_INCREMENT` column
         * is a candidate key.
         */
        candidateKeys: KeyArrayUtil.Append<TableT["candidateKeys"], KeyUtil.FromColumn<AutoIncrementT>>;
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        /**
         * `AUTO_INCREMENT` columns cannot be generated.
         */
        generatedColumns: KeyUtil.Remove<TableT["generatedColumns"], AutoIncrementT["columnAlias"]>;
        nullableColumns: TableT["nullableColumns"];
        /**
         * `AUTO_INCREMENT` columns have implicit default values.
         */
        explicitDefaultValueColumns: KeyUtil.Remove<TableT["explicitDefaultValueColumns"], AutoIncrementT["columnAlias"]>;
        /**
         * By default, we make the `AUTO_INCREMENT` column
         * non-mutable.
         *
         * It's just safer to deny updates to it by default.
         *
         * You may make it mutable again by calling,
         *
         * 1. `.enableExplicitAutoIncrementValue()` to make the column
         *    allow explicit values; implicit auto-increment columns cannot be mutable.
         * 1. `.addMutable()` to make the column mutable.
         */
        mutableColumns: KeyUtil.Remove<TableT["mutableColumns"], AutoIncrementT["columnAlias"]>;
        /**
         * By default, we make the `AUTO_INCREMENT` column
         * behave like a generated column.
         *
         * Technically, an `AUTO_INCREMENT` column is
         * not a generated column.
         *
         * However, in most cases, the auto-increment column behaves like a generated column.
         *
         * + You do not set the `AUTO_INCREMENT` value on `INSERT`
         * + You do not set the `AUTO_INCREMENT` value on `UPDATE`
         *
         * You may allow explicit values by calling,
         * `.enableExplicitAutoIncrementValue()`
         */
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Designates one column as the `AUTO_INCREMENT` column.
     *
     * -----
     *
     * + `AUTO_INCREMENT` columns cannot be nullable
     * + `AUTO_INCREMENT` columns must be a candidate key
     * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
     * + The `number|string|bigint` requirement is only a compile-time constraint
     *
     * @todo Consider having run-time checks to see if it allows 1,2,3,4,5,... ?
     */
    export function setAutoIncrement<TableT extends ITable, AutoIncrementT extends ColumnUtil.FromColumnMap<SetAutoIncrementColumnMap<TableT>>>(table: TableT, delegate: (SetAutoIncrementDelegate<TableT, (AutoIncrementT & AssertValidAutoIncrement<TableT, AutoIncrementT>)>)): (SetAutoIncrement<TableT, AutoIncrementT>);
}
declare module "table/util/operation/set-id" {
    import * as tm from "type-mapping";
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnUtil, IColumn } from "column/index";
    import { KeyArrayUtil, KeyUtil } from "key/index";
    import { AssertValidPrimaryKey, SetPrimaryKeyColumnMap } from "table/util/operation/set-primary-key";
    export type SetIdColumnAlias<TableT extends Pick<ITable, "columns" | "candidateKeys">> = ({
        [columnAlias in Extract<keyof TableT["columns"], string>]: (null extends tm.OutputOf<TableT["columns"][columnAlias]["mapper"]> ? 
        /**
         * Cannot be nullable
         */
        never : (columnAlias extends TableT["candidateKeys"][number][number] ? 
        /**
         * Columns already a part of a candidate key cannot be `id-column`
         */
        never : columnAlias));
    }[Extract<keyof TableT["columns"], string>]);
    export type SetIdColumnMap<TableT extends Pick<ITable, "columns" | "candidateKeys">> = ({
        readonly [columnAlias in SetIdColumnAlias<TableT>]: (TableT["columns"][columnAlias]);
    });
    export function setIdColumnMap<TableT extends Pick<ITable, "columns" | "candidateKeys">>(table: TableT): (SetIdColumnMap<TableT>);
    export type SetIdDelegate<TableT extends Pick<ITable, "columns" | "candidateKeys">, IdT extends ColumnUtil.FromColumnMap<SetIdColumnMap<TableT>>> = ((columnMap: SetIdColumnMap<TableT>) => (IdT));
    export type AssertValidId<TableT extends Pick<ITable, "columns" | "candidateKeys">, IdT extends ColumnUtil.FromColumnMap<SetIdColumnMap<TableT>>> = (AssertValidPrimaryKey<TableT, Extract<IdT[], readonly ColumnUtil.FromColumnMap<SetPrimaryKeyColumnMap<TableT>>[]>>);
    export function assertValidId(table: Pick<ITable, "candidateKeys" | "columns">, id: IColumn): void;
    export type SetId<TableT extends ITable, IdT extends ColumnUtil.FromColumnMap<SetIdColumnMap<TableT>>> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        /**
         * This is now our `id-column`
         */
        id: IdT["columnAlias"];
        /**
         * By default, we make the `id-column`
         * the primary key.
         *
         * Usually, your `id-column` is also the primary key.
         * There is almost no reason for you to set anything else as the primary key.
         *
         * You may overwrite it by calling,
         * `.setPrimaryKey()`
         */
        primaryKey: KeyUtil.FromColumn<IdT>;
        /**
         * A set containing the `id-column`
         * is a candidate key.
         */
        candidateKeys: KeyArrayUtil.Append<TableT["candidateKeys"], KeyUtil.FromColumn<IdT>>;
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Sets a column as the single-column identifier for this table.
     *
     * -----
     *
     * + `id-column`s cannot be nullable
     * + `id-column`s must be a candidate key
     * + `id-column`s must be a `PRIMARY KEY`
     *
     */
    export function setId<TableT extends ITable, IdT extends ColumnUtil.FromColumnMap<SetIdColumnMap<TableT>>>(table: TableT, delegate: (SetIdDelegate<TableT, (IdT & AssertValidId<TableT, IdT>)>)): (SetId<TableT, IdT>);
}
declare module "table/util/operation/set-schema-name" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    export type SetSchemaName<TableT extends ITable> = (Table<{
        isLateral: TableT["isLateral"];
        alias: TableT["alias"];
        columns: TableT["columns"];
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Sets the `schema` that this table belongs to.
     *
     * This is usually not required because the schema used
     * will be the one your database connection session is using.
     *
     * -----
     *
     * This library does not support cross-schema compile-time safe queries.
     *
     * However, if you **do** need cross-schema support,
     * this library can support it somewhat.
     *
     * -----
     *
     * @param table
     * @param newSchemaName
     */
    export function setSchemaName<TableT extends ITable>(table: TableT, newSchemaName: string): (SetSchemaName<TableT>);
}
declare module "table/util/operation/set-table-alias" {
    import { ITable } from "table/table";
    import { Table } from "table/table-impl";
    import { ColumnMapUtil } from "column-map/index";
    export type SetTableAlias<TableT extends ITable, NewTableAliasT extends string> = (Table<{
        isLateral: TableT["isLateral"];
        alias: NewTableAliasT;
        columns: ColumnMapUtil.WithTableAlias<TableT["columns"], NewTableAliasT>;
        usedRef: TableT["usedRef"];
        autoIncrement: TableT["autoIncrement"];
        id: TableT["id"];
        primaryKey: TableT["primaryKey"];
        candidateKeys: TableT["candidateKeys"];
        insertEnabled: TableT["insertEnabled"];
        deleteEnabled: TableT["deleteEnabled"];
        generatedColumns: TableT["generatedColumns"];
        nullableColumns: TableT["nullableColumns"];
        explicitDefaultValueColumns: TableT["explicitDefaultValueColumns"];
        mutableColumns: TableT["mutableColumns"];
        explicitAutoIncrementValueEnabled: TableT["explicitAutoIncrementValueEnabled"];
    }>);
    /**
     * Changes the alias of the table.
     *
     * Useful if you have multiple tables with exactly the same structure.
     *
     * This is different from `.as()`!
     *
     * -----
     *
     * You will have to call `.setSchemaName()` again if you called it before.
     *
     * @param table
     * @param newTableAlias
     */
    export function setTableAlias<TableT extends ITable, NewTableAliasT extends string>(table: TableT, newTableAlias: NewTableAliasT): (SetTableAlias<TableT, NewTableAliasT>);
}
declare module "table/util/operation/index" {
    export * from "table/util/operation/add-all-mutable";
    export * from "table/util/operation/add-candidate-key";
    export * from "table/util/operation/add-columns-from-field-array";
    export * from "table/util/operation/add-columns-from-mapper-map";
    export * from "table/util/operation/add-columns";
    export * from "table/util/operation/add-explicit-default-value";
    export * from "table/util/operation/add-generated";
    export * from "table/util/operation/add-mutable";
    export * from "table/util/operation/as";
    export * from "table/util/operation/disable-delete";
    export * from "table/util/operation/disable-insert";
    export * from "table/util/operation/enable-explicit-auto-increment-value";
    export * from "table/util/operation/enable-insert";
    export * from "table/util/operation/pick-columns";
    export * from "table/util/operation/remove-all-mutable";
    export * from "table/util/operation/remove-explicit-default-value";
    export * from "table/util/operation/remove-generated";
    export * from "table/util/operation/remove-mutable";
    export * from "table/util/operation/set-auto-increment";
    export * from "table/util/operation/set-id";
    export * from "table/util/operation/set-primary-key";
    export * from "table/util/operation/set-schema-name";
    export * from "table/util/operation/set-table-alias";
}
declare module "table/util/index" {
    export * from "table/util/constructor/index";
    export * from "table/util/execution/index";
    export * from "table/util/operation/index";
    export * from "table/util/predicate/index";
    export * from "table/util/query/index";
}
declare module "table-where/table-where" {
    import { ITable, DeletableTable } from "table/table";
    import { WhereDelegate } from "where-clause/index";
    import { ExecutionUtil, SelectConnection, DeleteConnection, IsolableDeleteConnection, DeleteResult, DeleteOneResult, DeleteZeroOrOneResult, UpdateConnection, UpdateResult, IsolableUpdateConnection } from "execution/index";
    import { Row_NonUnion } from "row/index";
    import { SelectClause, SelectDelegate, SelectValueDelegate, SelectClauseUtil } from "select-clause/index";
    import { FromClauseUtil } from "from-clause/index";
    import { QueryUtil } from "unified-query/index";
    import { TableUtil } from "table/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { AssignmentMapDelegate, CustomAssignmentMap } from "update/index";
    import { ExpandPick } from "type-util/index";
    import { UpdateOneResult, UpdateZeroOrOneResult } from "execution/util/index";
    /**
     * @todo Implement something like `TableWhereOrderBy`?
     *
     * `.fetchAll()` is not provided here
     * because "proper" usage would minimally require,
     * + `ORDER BY` clause - For deterministic ordering
     * + `LIMIT` clause - To prevent accidental OOMs
     *
     * `.paginate()`, `.emulatedCursor()` are not provided here
     * because "proper" usage of them would minimally require,
     * + `ORDER BY` clause - For deterministic ordering
     *
     */
    /**
     * @todo Better name
     * This is basically a `table` + `WHERE` clause.
     */
    export class TableWhere<TableT extends ITable> {
        readonly table: TableT;
        readonly whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>;
        constructor(table: TableT, whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>);
        where(whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>>): TableWhere<TableT>;
        assertExists(connection: SelectConnection): Promise<void>;
        exists(connection: SelectConnection): Promise<boolean>;
        fetchOne(connection: SelectConnection): ExecutionUtil.FetchOnePromise<Row_NonUnion<TableT>>;
        fetchOne<SelectsT extends SelectClause>(connection: SelectConnection, selectDelegate: SelectDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>, undefined, undefined, SelectsT>): ExecutionUtil.FetchOneReturnType<QueryUtil.Select<QueryUtil.From<QueryUtil.NewInstance, TableT>, SelectsT>>;
        fetchValue<BuiltInExprT extends AnyBuiltInExpr>(connection: SelectConnection, selectValueDelegate: SelectValueDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, TableT>, undefined, BuiltInExprT>): ExecutionUtil.FetchValueReturnType<
        /**
         * @todo Report assignability bug to TS issues page
         */
        QueryUtil.SelectNoSelectClause<QueryUtil.From<QueryUtil.NewInstance, TableT>, SelectClauseUtil.ValueFromBuiltInExpr<BuiltInExprT>>>;
        delete(this: Extract<this, {
            table: DeletableTable;
        }>, connection: DeleteConnection): Promise<DeleteResult>;
        deleteOne(this: Extract<this, {
            table: DeletableTable;
        }>, connection: IsolableDeleteConnection): Promise<DeleteOneResult>;
        deleteZeroOrOne(this: Extract<this, {
            table: DeletableTable;
        }>, connection: IsolableDeleteConnection): Promise<DeleteZeroOrOneResult>;
        update<AssignmentMapT extends CustomAssignmentMap<TableT>>(connection: UpdateConnection, assignmentMapDelegate: AssignmentMapDelegate<ExpandPick<TableT, "columns" | "mutableColumns">, AssignmentMapT>): Promise<UpdateResult>;
        updateOne<AssignmentMapT extends CustomAssignmentMap<TableT>>(connection: IsolableUpdateConnection, assignmentMapDelegate: AssignmentMapDelegate<ExpandPick<TableT, "columns" | "mutableColumns">, AssignmentMapT>): Promise<UpdateOneResult>;
        updateZeroOrOne<AssignmentMapT extends CustomAssignmentMap<TableT>>(connection: IsolableUpdateConnection, assignmentMapDelegate: AssignmentMapDelegate<ExpandPick<TableT, "columns" | "mutableColumns">, AssignmentMapT>): Promise<UpdateZeroOrOneResult>;
        /**
         * The `table` must have at least one `candidateKey` to use this method.
         *
         * Internally,
         * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
         * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
         *    (if the candidate key will not be updated, this step is skipped)
         * 3. Run the `UPDATE` statement.
         * 4. Fetch the row using the new candidate key.
         *
         * This algorithm will probably fail if you have triggers that modify the candidate key
         * `ON UPDATE`.
         */
        updateAndFetchOne<AssignmentMapT extends ExecutionUtil.UpdateAndFetchOneAssignmentMap<TableT>>(this: Extract<this, {
            table: TableT & TableUtil.AssertHasCandidateKey<TableT>;
        }>, connection: IsolableUpdateConnection, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<ExecutionUtil.UpdateAndFetchOneResult<TableT, AssignmentMapT>>;
        /**
         * The `table` must have at least one `candidateKey` to use this method.
         *
         * Internally,
         * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
         * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
         *    (if the candidate key will not be updated, this step is skipped)
         * 3. Run the `UPDATE` statement.
         * 4. Fetch the row using the new candidate key (if any were found during the `UPDATE`)
         *
         * This algorithm will probably fail if you have triggers that modify the candidate key
         * `ON UPDATE`.
         */
        updateAndFetchZeroOrOne<AssignmentMapT extends ExecutionUtil.UpdateAndFetchOneAssignmentMap<TableT>>(this: Extract<this, {
            table: TableT & TableUtil.AssertHasCandidateKey<TableT>;
        }>, connection: IsolableUpdateConnection, assignmentMapDelegate: AssignmentMapDelegate<TableT, AssignmentMapT>): Promise<ExecutionUtil.UpdateAndFetchZeroOrOneResult<TableT, AssignmentMapT>>;
    }
}
declare module "table-where/index" {
    export * from "table-where/table-where";
}
declare module "table/table-impl" {
    import * as tm from "type-mapping";
    import { TableData, ITable, TableWithPrimaryKey, DeletableTable, InsertableTable, TableWithAutoIncrement } from "table/table";
    import * as TableUtil from "table/util/index";
    import { MapperMap } from "mapper-map/index";
    import { Ast } from "ast/index";
    import { ColumnUtil } from "column/index";
    import { ExecutionUtil, InsertOneConnection, InsertOneResult, InsertIgnoreOneResult, InsertIgnoreOneConnection, ReplaceOneResult, ReplaceOneConnection, ReplaceManyResult, ReplaceManyConnection, InsertIgnoreManyResult, InsertIgnoreManyConnection, InsertManyResult, InsertManyConnection, IsolableInsertOneConnection } from "execution/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion, AssertSubsetOwnEnumerableKeys } from "type-util/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { SuperKey_Input } from "super-key/index";
    import { FromClauseUtil } from "from-clause/index";
    import { WhereDelegate } from "where-clause/index";
    import { CustomInsertRow } from "insert/index";
    import { InsertOneWithAutoIncrementReturnType, InsertIgnoreOneWithAutoIncrementReturnType, ReplaceOneWithAutoIncrementReturnType } from "execution/util/index";
    import { TableWhere } from "table-where/index";
    export class Table<DataT extends TableData> implements ITable {
        readonly isLateral: DataT["isLateral"];
        readonly alias: DataT["alias"];
        readonly columns: DataT["columns"];
        readonly usedRef: DataT["usedRef"];
        readonly unaliasedAst: Ast;
        readonly insertEnabled: DataT["insertEnabled"];
        readonly deleteEnabled: DataT["deleteEnabled"];
        readonly autoIncrement: DataT["autoIncrement"];
        readonly id: DataT["id"];
        readonly primaryKey: DataT["primaryKey"];
        readonly candidateKeys: DataT["candidateKeys"];
        readonly generatedColumns: DataT["generatedColumns"];
        readonly nullableColumns: DataT["nullableColumns"];
        readonly explicitDefaultValueColumns: DataT["explicitDefaultValueColumns"];
        readonly mutableColumns: DataT["mutableColumns"];
        readonly explicitAutoIncrementValueEnabled: DataT["explicitAutoIncrementValueEnabled"];
        /**
         * You should never need to explicitly instantiate a `Table`.
         * Use `table()` instead.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data: DataT, unaliasedAst: Ast);
        /**
         * Makes all non-generated columns mutable.
         *
         * + Mutable columns may be modified with `UPDATE` statements using this library.
         * + Immutable columns may not be modified with this library
         *   (but could still be modified outside of this library)
         */
        addAllMutable(): TableUtil.AddAllMutable<this>;
        /**
         * Adds a candidate key to the table.
         *
         * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
         *
         * + A table may have zero-to-many candidate keys. (recommended to have at least one)
         * + A candidate key cannot be a subset of other candidate keys.
         * + A candidate key cannot be a superset of other candidate keys.
         * + A candidate key can intersect other candidate keys.
         * + A candidate key can be disjoint from other candidate keys.
         */
        addCandidateKey<KeyT extends readonly ColumnUtil.FromColumnMap<this["columns"]>[]>(delegate: (TableUtil.AddCandidateKeyDelegate<this, (KeyT & TableUtil.AssertValidCandidateKey<this, KeyT>)>)): (TableUtil.AddCandidateKey<this, KeyT>);
        /**
         * Adds columns to the table
         *
         * @deprecated
         */
        addColumns<FieldsT extends tm.AnyField[]>(fields: FieldsT): (TableUtil.AddColumnsFromFieldArray<this, FieldsT>);
        /**
         * Adds columns to the table
         */
        addColumns<MapperMapT extends MapperMap>(mapperMap: MapperMapT): (TableUtil.AddColumnsFromMapperMap<this, MapperMapT>);
        /**
         * Tells the library that these columns have explicit `DEFAULT` values.
         *
         * An example of an "explicit" default value,
         * ```sql
         * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
         * ```
         *
         * + Columns with server default values are optional with `INSERT` statements.
         * + Generated columns have implicit default values.
         * + Nullable columns have implicit default values.
         * + `AUTO_INCREMENT` columns have implicit default values
         */
        addExplicitDefaultValue<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.AddExplicitDefaultValueColumnMap<this>>[]>(delegate: (TableUtil.AddExplicitDefaultValueDelegate<this, ColumnsT>)): (TableUtil.AddExplicitDefaultValue<this, ColumnsT>);
        /**
         * Adds a `GENERATED` column to the table.
         *
         * + Setting generated column values will not be allowed with `INSERT` statements.
         * + Updating generated column values will also not be allowed with `UPDATE` statements.
         */
        addGenerated<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.AddGeneratedColumnMap<this>>[]>(delegate: (TableUtil.AddGeneratedDelegate<this, ColumnsT>)): (TableUtil.AddGenerated<this, ColumnsT>);
        /**
         * Lets these columns be updated through this library.
         */
        addMutable<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.AddMutableColumnMap<this>>[]>(delegate: (TableUtil.AddMutableDelegate<this, ColumnsT>)): (TableUtil.AddMutable<this, ColumnsT>);
        /**
         * Aliases a table reference in a query.
         *
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable AS aliasedTable
         * ```
         */
        as<NewTableAliasT extends string>(newTableAlias: NewTableAliasT): TableUtil.As<this, NewTableAliasT>;
        /**
         * Prevents rows of this table from being deleted through this library.
         *
         * Good for look-up tables, or append-only tables.
         */
        disableDelete(): TableUtil.DisableDelete<this>;
        /**
         * Prevents rows from being inserted through this library.
         *
         * Good for look-up tables.
         */
        disableInsert(): TableUtil.DisableInsert<this>;
        /**
         * The opposite of `disableInsert()`.
         * You really shouldn't need to use this as tables allow insert by default.
         */
        enableInsert(): TableUtil.EnableInsert<this>;
        /**
         * Makes all columns immutable.
         */
        removeAllMutable(): TableUtil.RemoveAllMutable<this>;
        /**
         * Removes columns from the set of columns with explicit `DEFAULT` values
         *
         */
        removeExplicitDefaultValue<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.RemoveExplicitDefaultValueColumnMap<this>>[]>(delegate: (TableUtil.RemoveExplicitDefaultValueDelegate<this, ColumnsT>)): (TableUtil.RemoveExplicitDefaultValue<this, ColumnsT>);
        /**
         * Removes columns from the set of `GENERATED` columns.
         *
         */
        removeGenerated<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.RemoveGeneratedColumnMap<this>>[]>(delegate: (TableUtil.RemoveGeneratedDelegate<this, ColumnsT>)): (TableUtil.RemoveGenerated<this, ColumnsT>);
        /**
         * Removes columns from the set of mutable columns.
         *
         * You will not be able to update them through this library.
         *
         */
        removeMutable<ColumnsT extends readonly ColumnUtil.FromColumnMap<TableUtil.RemoveMutableColumnMap<this>>[]>(delegate: (TableUtil.RemoveMutableDelegate<this, ColumnsT>)): (TableUtil.RemoveMutable<this, ColumnsT>);
        /**
         * Designates one column as the `AUTO_INCREMENT` column.
         *
         * -----
         *
         * + `AUTO_INCREMENT` columns cannot be nullable
         * + `AUTO_INCREMENT` columns must be a candidate key
         * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
         * + The `number|string|bigint` requirement is only a compile-time constraint
         */
        setAutoIncrement<AutoIncrementT extends ColumnUtil.FromColumnMap<TableUtil.SetAutoIncrementColumnMap<this>>>(delegate: (TableUtil.SetAutoIncrementDelegate<this, (AutoIncrementT & TableUtil.AssertValidAutoIncrement<this, AutoIncrementT>)>)): (TableUtil.SetAutoIncrement<this, AutoIncrementT>);
        enableExplicitAutoIncrementValue(): (TableUtil.EnableExplicitAutoIncrementValue<this>);
        /**
         * Sets a column as the single-column identifier for this table.
         *
         * -----
         *
         * + `id-column`s cannot be nullable
         * + `id-column`s must be a candidate key
         * + `id-column`s must be a `PRIMARY KEY`
         *
         */
        setId<IdT extends ColumnUtil.FromColumnMap<TableUtil.SetIdColumnMap<this>>>(delegate: (TableUtil.SetIdDelegate<this, (IdT & TableUtil.AssertValidId<this, IdT>)>)): (TableUtil.SetId<this, IdT>);
        /**
         * Sets the `PRIMARY KEY` of the table.
         *
         * In MySQL, a `PRIMARY KEY` is just a candidate key
         * where all its columns are non-nullable.
         *
         * -----
         *
         * + `PRIMARY KEY` columns cannot be nullable
         * + `PRIMARY KEY` columns must be a candidate key
         */
        setPrimaryKey<KeyT extends readonly ColumnUtil.FromColumnMap<TableUtil.SetPrimaryKeyColumnMap<this>>[]>(delegate: (TableUtil.SetPrimaryKeyDelegate<this, (KeyT & TableUtil.AssertValidPrimaryKey<this, KeyT>)>)): (TableUtil.SetPrimaryKey<this, KeyT>);
        /**
         * Sets the `schema` that this table belongs to.
         *
         * This is usually not required because the schema used
         * will be the one your database connection session is using.
         *
         * -----
         *
         * This library does not support cross-schema compile-time safe queries.
         *
         * However, if you **do** need cross-schema support,
         * this library can support it somewhat.
         */
        setSchemaName(newSchemaName: string): (TableUtil.SetSchemaName<this>);
        /**
         * Changes the alias of the table.
         *
         * Useful if you have multiple tables with exactly the same structure.
         *
         * This is different from `.as()`!
         *
         * -----
         *
         * You will have to call `.setSchemaName()` again if you called it before.
         */
        setTableAlias<NewTableAliasT extends string>(newTableAlias: NewTableAliasT): TableUtil.SetTableAlias<this, NewTableAliasT>;
        pickColumns<NewColumnsT extends readonly ColumnUtil.FromColumnMap<this["columns"]>[]>(delegate: (TableUtil.PickColumnsDelegate<this, NewColumnsT>)): (TableUtil.PickColumns<this, NewColumnsT>);
        insertOne(this: Extract<this, InsertableTable>, connection: InsertOneConnection, row: CustomInsertRow<Extract<this, InsertableTable>>): Promise<this extends TableWithAutoIncrement ? InsertOneWithAutoIncrementReturnType<Extract<this, TableWithAutoIncrement>> : InsertOneResult>;
        insertMany(this: Extract<this, InsertableTable>, connection: InsertManyConnection, rows: readonly CustomInsertRow<Extract<this, InsertableTable>>[]): Promise<InsertManyResult>;
        insertIgnoreOne(this: Extract<this, InsertableTable>, connection: InsertIgnoreOneConnection, row: CustomInsertRow<Extract<this, InsertableTable>>): Promise<this extends TableWithAutoIncrement ? InsertIgnoreOneWithAutoIncrementReturnType<Extract<this, TableWithAutoIncrement>> : InsertIgnoreOneResult>;
        insertIgnoreMany(this: Extract<this, InsertableTable>, connection: InsertIgnoreManyConnection, rows: readonly CustomInsertRow<Extract<this, InsertableTable>>[]): Promise<InsertIgnoreManyResult>;
        replaceOne(this: Extract<this, InsertableTable & DeletableTable>, connection: ReplaceOneConnection, row: CustomInsertRow<Extract<this, InsertableTable & DeletableTable>>): Promise<this extends TableWithAutoIncrement ? ReplaceOneWithAutoIncrementReturnType<Extract<this, TableWithAutoIncrement>> : ReplaceOneResult>;
        replaceMany(this: Extract<this, InsertableTable & DeletableTable>, connection: ReplaceManyConnection, rows: readonly CustomInsertRow<Extract<this, InsertableTable & DeletableTable>>[]): Promise<ReplaceManyResult>;
        insertAndFetch<RowT extends ExecutionUtil.InsertAndFetchRow<Extract<this, InsertableTable>>>(this: Extract<this, InsertableTable>, connection: IsolableInsertOneConnection, row: (RowT & AssertSubsetOwnEnumerableKeys<RowT, ExecutionUtil.InsertAndFetchRow<Extract<this, InsertableTable>>>)): (Promise<ExecutionUtil.InsertedAndFetchedRow<Extract<this, InsertableTable>, RowT>>);
        where(whereDelegate: WhereDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, this>>): TableWhere<this>;
        whereEqCandidateKey(candidateKey: StrictUnion<CandidateKey_NonUnion<this>>): TableWhere<this>;
        whereEqPrimaryKey(this: Extract<this, TableWithPrimaryKey>, primaryKey: PrimaryKey_Input<Extract<this, TableWithPrimaryKey>>): TableWhere<this>;
        whereEqSuperKey(superKey: SuperKey_Input<this>): TableWhere<this>;
    }
}
declare module "table/index" {
    export * from "table/table-impl";
    export * from "table/table";
    import * as TableUtil from "table/util/index";
    export { TableUtil, };
    import { fromTableAlias as table } from "table/util/index";
    export { 
    /**
     * Convenience function to instantiate a table.
     */
    table, };
}
declare module "data-type/util/operation/evaluate-columns" {
    import { ITable } from "table/index";
    import { Identity } from "type-util/index";
    import { CustomExpr_NonCorrelated } from "custom-expr/index";
    import { SelectConnection } from "execution/index";
    /**
     * This allows custom data types
     */
    export type EvaluateColumnsInputRow<TableT extends ITable, ColumnAliasT extends string> = Identity<{
        readonly [columnAlias in ColumnAliasT]: (CustomExpr_NonCorrelated<ReturnType<TableT["columns"][columnAlias]["mapper"]>>);
    }>;
    export type EvaluateColumnsOutputRow<TableT extends ITable, ColumnAliasT extends string> = Identity<{
        readonly [columnAlias in ColumnAliasT]: (ReturnType<TableT["columns"][columnAlias]["mapper"]>);
    }>;
    export type TryEvaluateColumnsResult<TableT extends ITable, ColumnAliasT extends string> = Identity<{
        outputRow: EvaluateColumnsOutputRow<TableT, ColumnAliasT>;
        success: true;
    } | {
        success: false;
        error: Error;
    }>;
    export function tryEvaluateColumns<TableT extends ITable, ColumnAliasT extends string>(table: TableT, connection: SelectConnection, name: string, columnAliases: readonly ColumnAliasT[], row: EvaluateColumnsInputRow<TableT, ColumnAliasT>): Promise<TryEvaluateColumnsResult<TableT, ColumnAliasT>>;
}
declare module "data-type/util/operation/evaluate-primary-key" {
    import { TableWithPrimaryKey } from "table/index";
    import { SelectConnection } from "execution/index";
    import { EvaluateColumnsInputRow, TryEvaluateColumnsResult } from "data-type/util/operation/evaluate-columns";
    /**
     * This allows custom data types
     */
    export type EvaluatePrimaryKeyInputRow<TableT extends TableWithPrimaryKey> = EvaluateColumnsInputRow<TableT, TableT["primaryKey"][number]>;
    export type TryEvaluatePrimaryKeyResult<TableT extends TableWithPrimaryKey> = TryEvaluateColumnsResult<TableT, TableT["primaryKey"][number]>;
    export function tryEvaluatePrimaryKey<TableT extends TableWithPrimaryKey>(table: TableT, connection: SelectConnection, row: EvaluatePrimaryKeyInputRow<TableT>): Promise<TryEvaluatePrimaryKeyResult<TableT>>;
}
declare module "data-type/util/operation/evaluate-candidate-key" {
    import { ITable } from "table/index";
    import { SelectConnection } from "execution/index";
    import { EvaluateColumnsInputRow, TryEvaluateColumnsResult } from "data-type/util/operation/evaluate-columns";
    export type EvaluateCandidateKeyInputRowImpl<TableT extends ITable, CandidateKeyT extends readonly string[]> = CandidateKeyT extends readonly string[] ? EvaluateColumnsInputRow<TableT, CandidateKeyT[number]> : never;
    export type TryEvaluateCandidateKeyResultImpl<TableT extends ITable, CandidateKeyT extends readonly string[]> = CandidateKeyT extends readonly [] ? TryEvaluateColumnsResult<TableT, CandidateKeyT[number]> : never;
    /**
     * This allows custom data types
     */
    export type EvaluateCandidateKeyInputRow<TableT extends ITable> = EvaluateCandidateKeyInputRowImpl<TableT, TableT["candidateKeys"][number]>;
    export type TryEvaluateCandidateKeyResult<TableT extends ITable> = TryEvaluateCandidateKeyResultImpl<TableT, TableT["candidateKeys"][number]>;
    export function tryEvaluateCandidateKey<TableT extends ITable>(table: TableT, connection: SelectConnection, row: EvaluateCandidateKeyInputRow<TableT>): Promise<TryEvaluateCandidateKeyResult<TableT>>;
    export function tryEvaluateCandidateKeyPreferPrimaryKey<TableT extends ITable>(table: TableT, connection: SelectConnection, row: EvaluateCandidateKeyInputRow<TableT>): Promise<TryEvaluateCandidateKeyResult<TableT>>;
}
declare module "built-in-expr/util/query/is-aggregate" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { IQueryBase } from "query-base/index";
    export type HasNonUnitIsAggregate<BuiltInExprT extends AnyBuiltInExpr | IQueryBase> = 
    /**
     * Could be `IExpr|IExprSelectItem`
     */
    BuiltInExprT extends {
        isAggregate: boolean;
    } ? (boolean extends BuiltInExprT["isAggregate"] ? true : false) : false;
    export type IsAggregate<BuiltInExprT extends AnyBuiltInExpr | IQueryBase> = 
    /**
     * Could be `IExpr|IExprSelectItem` or `ExprColumn`, if it came from the `SELECT` clause.
     */
    BuiltInExprT extends {
        isAggregate: boolean;
    } ? BuiltInExprT["isAggregate"] : false;
    export function isAggregate<BuiltInExprT extends AnyBuiltInExpr | IQueryBase>(builtInExpr: BuiltInExprT): (IsAggregate<BuiltInExprT>);
}
declare module "built-in-expr/util/query/type-of" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { BuiltInValueExpr } from "built-in-value-expr/index";
    import { IExpr } from "expr/index";
    import { IColumn } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { QueryBaseUtil } from "query-base/index";
    export type TypeOf<BuiltInExprT extends AnyBuiltInExpr> = BuiltInExprT extends BuiltInValueExpr ? BuiltInExprT : BuiltInExprT extends IExpr ? tm.OutputOf<BuiltInExprT["mapper"]> : BuiltInExprT extends IColumn ? tm.OutputOf<BuiltInExprT["mapper"]> : BuiltInExprT extends QueryBaseUtil.OneSelectItem<unknown> & QueryBaseUtil.ZeroOrOneRow ? QueryBaseUtil.TypeOf<BuiltInExprT> : BuiltInExprT extends IExprSelectItem ? tm.OutputOf<BuiltInExprT["mapper"]> : never;
}
declare module "built-in-expr/util/query/mapper" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { TypeOf } from "built-in-expr/util/query/type-of";
    export type Mapper<BuiltInExprT extends AnyBuiltInExpr> = (tm.SafeMapper<TypeOf<BuiltInExprT>>);
    export function mapper<BuiltInExprT extends AnyBuiltInExpr>(builtInExpr: BuiltInExprT): (Mapper<BuiltInExprT>);
}
declare module "built-in-expr/util/query/used-ref" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { BuiltInValueExpr } from "built-in-value-expr/index";
    import { UsedRefUtil, IUsedRef } from "used-ref/index";
    import { IColumn } from "column/index";
    import { IQueryBase } from "query-base/index";
    /**
     * Conditional types seem to reduce the amount of nesting allowed
     * before hitting the max instantiation depth.
     *
     * @todo Refactor this to not require conditional types?
     * Seems impossible.
     */
    export type UsedRef<BuiltInExprT extends AnyBuiltInExpr | IQueryBase> = (
    /**
     * This implementation is the same as the implementation commented out below.
     * For some reason, this implementation is more efficient in terms of instantiation depth used.
     */
    Extract<Exclude<BuiltInExprT, (BuiltInValueExpr | IColumn | IQueryBase)>["usedRef"], IUsedRef> | (BuiltInExprT extends IColumn ? UsedRefUtil.FromColumn<BuiltInExprT> : BuiltInExprT extends IQueryBase ? UsedRefUtil.FromFromClause<BuiltInExprT["fromClause"]> : BuiltInExprT extends BuiltInValueExpr ? IUsedRef<{}> : never));
    export function usedRef<BuiltInExprT extends AnyBuiltInExpr | IQueryBase>(builtInExpr: BuiltInExprT): (UsedRef<BuiltInExprT>);
}
declare module "built-in-expr/util/query/index" {
    export * from "built-in-expr/util/query/is-aggregate";
    export * from "built-in-expr/util/query/mapper";
    export * from "built-in-expr/util/query/type-of";
    export * from "built-in-expr/util/query/used-ref";
}
declare module "built-in-expr/util/predicate/assert-non-aggregate" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    export function assertNonAggregate(name: string, builtInExpr: AnyBuiltInExpr): void;
    export function assertAllNonAggregate(name: string, builtInExprArr: readonly AnyBuiltInExpr[]): void;
}
declare module "built-in-expr/util/predicate/assert-non-null" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { TypeOf } from "built-in-expr/util/query/index";
    import { CompileError } from "compile-error/index";
    export type AssertNonNull<ExprT extends AnyBuiltInExpr> = null extends TypeOf<ExprT> ? CompileError<["Expression must not be nullable", TypeOf<ExprT>]> : unknown;
    /**
     * @todo Rename to `assertNonNullable`
     */
    export function assertNonNull(name: string, builtInExpr: AnyBuiltInExpr): void;
}
declare module "built-in-expr/util/predicate/is-any-non-value-expr" {
    import { AnyNonValueExpr } from "built-in-expr/built-in-expr";
    export function isAnyNonValueExpr(mixed: unknown): mixed is AnyNonValueExpr;
}
declare module "built-in-expr/util/predicate/is-any-subquery-expr" {
    import { AnySubqueryExpr } from "built-in-expr/built-in-expr";
    export function isAnySubqueryExpr(x: unknown): x is AnySubqueryExpr;
}
declare module "built-in-expr/util/predicate/is-built-in-expr" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    export function isBuiltInExpr(raw: unknown): raw is AnyBuiltInExpr;
}
declare module "built-in-expr/util/predicate/index" {
    export * from "built-in-expr/util/predicate/assert-non-aggregate";
    export * from "built-in-expr/util/predicate/assert-non-null";
    export * from "built-in-expr/util/predicate/is-any-non-value-expr";
    export * from "built-in-expr/util/predicate/is-any-subquery-expr";
    export * from "built-in-expr/util/predicate/is-built-in-expr";
}
declare module "built-in-expr/util/constructor/from-value-expr" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonCorrelated_NonAggregate } from "built-in-expr/index";
    import { IAnonymousColumn } from "column/index";
    /**
     * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
     * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
     */
    export function fromValueExpr<TypeT>(mapper: tm.SafeMapper<TypeT> | IAnonymousColumn<TypeT>, value: TypeT): BuiltInExpr_NonCorrelated_NonAggregate<TypeT>;
}
declare module "built-in-expr/util/constructor/from-custom-expr-map-correlated" {
    import * as tm from "type-mapping";
    import { IAnonymousColumn } from "column/index";
    import { BuiltInExpr_MapCorrelated } from "built-in-expr/built-in-expr";
    import { ColumnMap } from "column-map/index";
    import { CustomExpr_MapCorrelated } from "custom-expr/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
     * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
     */
    export function fromCustomExpr_MapCorrelated<ColumnMapT extends ColumnMap, TypeT>(mapper: tm.SafeMapper<TypeT> | IAnonymousColumn<TypeT>, allowed: UsedRefUtil.FromColumnMap<ColumnMapT>, customExpr: CustomExpr_MapCorrelated<ColumnMapT, TypeT>): BuiltInExpr_MapCorrelated<ColumnMapT, TypeT>;
}
declare module "built-in-expr/util/constructor/index" {
    export * from "built-in-expr/util/constructor/from-custom-expr-map-correlated";
    export * from "built-in-expr/util/constructor/from-value-expr";
}
declare module "built-in-expr/util/operation/build-ast" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { Ast } from "ast/index";
    import { QueryBaseUtil } from "query-base/index";
    /**
     * + `bigint` is considered a `signed bigint` by this library.
     * +`DECIMAL` is not supported by this function.
     * +`BIGINT UNSIGNED` is not supported by this function.
     */
    export function buildAst(builtInExpr: AnyBuiltInExpr | QueryBaseUtil.OneSelectItem<any>): Ast;
}
declare module "built-in-expr/util/operation/intersect-used-ref" {
    import { AnyBuiltInExpr } from "built-in-expr/built-in-expr";
    import { UsedRef } from "built-in-expr/util/query/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IQueryBase } from "query-base/index";
    import { TryReuseExistingType } from "type-util/index";
    import { IExpr } from "expr/index";
    import { IExprSelectItem } from "expr-select-item/index";
    /**
     * Assumes `U` is a union
     *
     * @todo Seems to only allow chaining 16 times.
     * @todo Find a way to increase the limit to 60 or more
     * Seems impossible.
     */
    export type IntersectUsedRef<U extends AnyBuiltInExpr | IQueryBase> = TryReuseExistingType<Extract<U, IExpr | IExprSelectItem>["usedRef"], UsedRefUtil.Intersect<UsedRef<U>>>;
    export function intersectUsedRef<ArrT extends readonly (AnyBuiltInExpr | IQueryBase)[]>(...arr: ArrT): (IntersectUsedRef<ArrT[number]>);
}
declare module "built-in-expr/util/operation/index" {
    export * from "built-in-expr/util/operation/build-ast";
    export * from "built-in-expr/util/operation/intersect-used-ref";
}
declare module "built-in-expr/util/index" {
    export * from "built-in-expr/util/constructor/index";
    export * from "built-in-expr/util/operation/index";
    export * from "built-in-expr/util/predicate/index";
    export * from "built-in-expr/util/query/index";
}
declare module "data-type/util/operation/evaluate-custom-expr" {
    import { IAnonymousColumn } from "column/index";
    import { CustomExpr_NonCorrelated } from "custom-expr/index";
    import { SelectConnection } from "execution/index";
    /**
     * Given a type `T`, we may have a `CustomExpr_NonCorrelated<T>`.
     *
     * This may be `T` itself, or `IExpr<T>` or `IColumn<T>` or
     * any other non-`T`.
     *
     * However, we **want** `T`.
     * This function helps us resolve non-`T` types to `T` itself.
     */
    export function evaluateCustomExpr<T>(column: IAnonymousColumn<T>, connection: SelectConnection, customExpr: CustomExpr_NonCorrelated<T>): Promise<T>;
}
declare module "data-type/util/operation/evaluate-insertable-candidate-key" {
    import { ITable, TableUtil } from "table/index";
    import { SelectConnection } from "execution/index";
    import { EvaluateColumnsInputRow, TryEvaluateColumnsResult } from "data-type/util/operation/evaluate-columns";
    import { KeyUtil } from "key/index";
    export type EvaluateInsertableCandidateKeyInputRowImpl<TableT extends ITable, CandidateKeyT extends readonly string[]> = CandidateKeyT extends readonly string[] ? (KeyUtil.IsSubKey<CandidateKeyT, TableUtil.InsertableColumnAlias<TableT>[]> extends true ? EvaluateColumnsInputRow<TableT, CandidateKeyT[number]> : never) : never;
    export type TryEvaluateInsertableCandidateKeyResultImpl<TableT extends ITable, CandidateKeyT extends readonly string[]> = CandidateKeyT extends readonly string[] ? (KeyUtil.IsSubKey<CandidateKeyT, TableUtil.InsertableColumnAlias<TableT>[]> extends true ? TryEvaluateColumnsResult<TableT, CandidateKeyT[number]> : never) : never;
    /**
     * This allows custom data types
     */
    export type EvaluateInsertableCandidateKeyInputRow<TableT extends ITable> = EvaluateInsertableCandidateKeyInputRowImpl<TableT, TableT["candidateKeys"][number]>;
    export type TryEvaluateInsertableCandidateKeyResult<TableT extends ITable> = TryEvaluateInsertableCandidateKeyResultImpl<TableT, TableT["candidateKeys"][number]>;
    export function tryEvaluateInsertableCandidateKey<TableT extends ITable>(table: TableT, connection: SelectConnection, row: EvaluateInsertableCandidateKeyInputRow<TableT>): Promise<TryEvaluateInsertableCandidateKeyResult<TableT>>;
    export function tryEvaluateInsertableCandidateKeyPreferPrimaryKey<TableT extends ITable>(table: TableT, connection: SelectConnection, row: EvaluateInsertableCandidateKeyInputRow<TableT>): Promise<TryEvaluateInsertableCandidateKeyResult<TableT>>;
}
declare module "data-type/util/predicate/is-data-type" {
    import * as tm from "type-mapping";
    import { IDataType } from "data-type/data-type";
    export function isDataType<TypeT>(raw: tm.SafeMapper<TypeT>): raw is IDataType<TypeT>;
    export function isDataType(raw: unknown): raw is IDataType<unknown>;
}
declare module "data-type/util/predicate/is-null-safe-equal" {
    import * as tm from "type-mapping";
    import { IAnonymousColumn } from "column/index";
    /**
     * If `mapper` is `IDataType`, it uses `mapper.isNullSafeEqual()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`,
     * but may not be suitable for custom data types.
     */
    export function isNullSafeEqual<TypeT>(mapper: tm.SafeMapper<TypeT> | IAnonymousColumn<TypeT>, a: TypeT, b: TypeT): boolean;
}
declare module "data-type/util/predicate/index" {
    export * from "data-type/util/predicate/is-data-type";
    export * from "data-type/util/predicate/is-null-safe-equal";
}
declare module "data-type/util/operation/intersect" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export type Merge<TypeA, TypeB> = DataType<TypeA & TypeB>;
    /**
     * @todo Implement something more efficient to generalize intersect `N` mappers.
     *
     * This runs a `mixed` value through both `mapperA` and `mapperB`.
     * Then, it checks that both mapped results are equal.
     *
     * It **does not** try to "deep-merge" both mapped results.
     *
     * So, you cannot combine mappers for `{x:number}` and `{y:number}`
     * and hope to have a value of type `{x:number, y:number}` during run-time.
     *
     * it will just throw a run-time error because a value of exactly type `{x:number}`
     * is not equal to a value of exactly type `{y:number}`.
     */
    export function intersect<TypeA, TypeB>(mapperA: tm.SafeMapper<TypeA>, mapperB: tm.SafeMapper<TypeB>): (Merge<TypeA, TypeB>);
}
declare module "data-type/util/operation/index" {
    export * from "data-type/util/operation/evaluate-candidate-key";
    export * from "data-type/util/operation/evaluate-columns";
    export * from "data-type/util/operation/evaluate-custom-expr";
    export * from "data-type/util/operation/evaluate-insertable-candidate-key";
    export * from "data-type/util/operation/evaluate-primary-key";
    export * from "data-type/util/operation/intersect";
}
declare module "data-type/util/index" {
    export * from "data-type/util/constructor/index";
    export * from "data-type/util/operation/index";
    export * from "data-type/util/predicate/index";
}
declare module "data-type/non-built-in-value-expr/decimal" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    import { Decimal } from "decimal/index";
    export function makeDecimalDataType(mapperFactory: (
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision: number | bigint, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint) => tm.SafeMapper<Decimal>): ((
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision: number | bigint, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint, extraMapper?: tm.Mapper<Decimal, Decimal>) => DataType<Decimal>);
    /**
     * Fixed-point number.
     *
     * + MySQL      : `DECIMAL(p, s)`
     * + PostgreSQL : `DECIMAL(p, s)`
     * + SQLite     : -NA-; Should be emulated using `TEXT` and custom functions.
     *
     * @param precision
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     *
     * @param scale
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     *
     * @param extraMapper
     */
    export const dtDecimal: (precision: number | bigint, scale: number | bigint, extraMapper?: tm.Mapper<tm.mysql.Decimal, tm.mysql.Decimal> | undefined) => DataType<tm.mysql.Decimal>;
}
declare module "data-type/non-built-in-value-expr/index" {
    export * from "data-type/non-built-in-value-expr/decimal";
}
declare module "data-type/built-in-value-expr/blob" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeBlobDataType(mapperFactory: {
        (desiredLengthMin: number, desiredLengthMax: number): tm.FluentMapper<tm.SafeMapper<Uint8Array>>;
        (desiredLengthMax: number): tm.FluentMapper<tm.SafeMapper<Uint8Array>>;
        (): tm.FluentMapper<tm.SafeMapper<Uint8Array>>;
        maxLength: number;
    }): ({
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array>): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array>): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array>): DataType<Uint8Array>;
        maxLength: number;
    });
    /**
     * + MySQL      : `BINARY`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `BINARY` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    export const dtBinary: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
    /**
     * + MySQL      : `VARBINARY`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `VARBINARY` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    export const dtVarBinary: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `TINY BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `TINY BLOB` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    export const dtTinyBlob: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `BLOB` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    export const dtBlob: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `MEDIUM BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `MEDIUM BLOB` data type.
     * + Max length: `16,777,215`; `(2^24)-1`
     */
    export const dtMediumBlob: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `LONG BLOB`
     * + PostgreSQL : `LO` (Large Object)
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `LONG BLOB` data type.
     * + Max length: `4,294,967,295`; `(2^32)-1`
     *
     * -----
     *
     * `bytea` supports up to 1GB. So, we cannot use `bytea`.
     *
     * https://dba.stackexchange.com/questions/127270/what-are-the-limits-of-postgresqls-large-object-facility
     * > A large object cannot exceed 4TB for PostgreSQL 9.3 or newer, or 2GB for older versions.
     * > This is based on the [release notes](https://www.postgresql.org/docs/9.3/release-9-3.html)
     *
     * From the release notes,
     * > Increase the maximum size of large objects from 2GB to 4TB (Nozomi Anzai, Yugo Nagata)
     *
     * -----
     *
     * Realistically, SQLite should support this,
     * https://www.sqlite.org/limits.html
     *
     * However, it is possible that the underlying implementation
     * may be restricted from having a `Uint8Array` of that length.
     */
    export const dtLongBlob: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        (extraMapper?: tm.Mapper<Uint8Array, Uint8Array> | undefined): DataType<Uint8Array>;
        maxLength: number;
    };
}
declare module "data-type/built-in-value-expr/boolean" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeBooleanDataType(mapper: tm.SafeMapper<boolean>): ((extraMapper?: tm.Mapper<boolean, boolean>) => DataType<boolean>);
    /**
     * + MySQL      : `TINYINT` (Emulates `boolean`)
     * + PostgreSQL : `boolean`
     * + SQLite     : `INTEGER` (Emulates `boolean`)
     */
    export const dtBoolean: (extraMapper?: tm.Mapper<boolean, boolean> | undefined) => DataType<boolean>;
}
declare module "data-type/built-in-value-expr/date-time" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeDateTimeDataType(mapperFactory: (fractionalSecondPrecision: 0 | 1 | 2 | 3) => tm.SafeMapper<Date>): ((fractionalSecondPrecision: 0 | 1 | 2 | 3, extraMapper?: tm.Mapper<Date, Date>) => DataType<Date>);
    /**
     * + MySQL      : `DATETIME`
     * + PostgreSQL : `TIMESTAMP`
     * + SQLite     : `TEXT` (Emulates `DATETIME`)
     *
     * SQLite only supports up to millisecond precision.
     *
     * JS only supports up to millisecond precision.
     *
     * + `0` = second
     * + `1` = deci-second
     * + `2` = centi-second
     * + `3` = millisecond
     *
     * @param fractionalSecondPrecision - `3` is recommended; millisecond precision.
     */
    export const dtDateTime: (fractionalSecondPrecision: 0 | 2 | 3 | 1, extraMapper?: tm.Mapper<Date, Date> | undefined) => DataType<Date>;
}
declare module "data-type/built-in-value-expr/double" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeDoubleDataType(mapper: tm.SafeMapper<number>): ((extraMapper?: tm.Mapper<number, number>) => DataType<number>);
    /**
     * 8-byte floating point number.
     *
     * + MySQL      : `DOUBLE`
     * + PostgreSQL : `double precision`
     * + SQLite     : `REAL`; is actually 8-byte floating point number
     *
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    export const dtDouble: (extraMapper?: tm.Mapper<number, number> | undefined) => DataType<number>;
    /**
     * 4-byte floating point number.
     *
     * JS does not have a 4-byte floating point number type.
     * So, attempting to use `FLOAT` will cause a loss in precision.
     *
     * + MySQL      : `FLOAT`
     * + PostgreSQL : `real`
     * + SQLite     : `REAL`; does not actually have 4-byte floating point numbers
     *
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    export const dtFloat: (extraMapper?: tm.Mapper<number, number> | undefined) => DataType<number>;
}
declare module "data-type/built-in-value-expr/integer" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeIntegerDataType(mapper: tm.SafeMapper<bigint>): ((extraMapper?: tm.Mapper<bigint, bigint>) => DataType<bigint>);
    /**
     * 1-byte integer.
     *
     * + MySQL      : `TINYINT SIGNED`
     * + PostgreSQL : `smallint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `TINYINT SIGNED` data type.
     * + Min: -128; `-(2^7)`
     * + Max:  127; `(2^7)-1`
     */
    export const dtTinyIntSigned: (extraMapper?: tm.Mapper<bigint, bigint> | undefined) => DataType<bigint>;
    /**
     * 2-byte integer.
     *
     * + MySQL      : `SMALLINT SIGNED`
     * + PostgreSQL : `smallint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `SMALLINT SIGNED` data type.
     * + Min: -32,768; `-(2^15)`
     * + Max:  32,767; `(2^15)-1`
     */
    export const dtSmallIntSigned: (extraMapper?: tm.Mapper<bigint, bigint> | undefined) => DataType<bigint>;
    /**
     * 3-byte integer.
     *
     * + MySQL      : `MEDIUMINT SIGNED`
     * + PostgreSQL : `integer`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `MEDIUMINT SIGNED` data type.
     * + Min: -8,388,608; `-(2^23)`
     * + Max:  8,388,607; `(2^23)-1`
     */
    export const dtMediumIntSigned: (extraMapper?: tm.Mapper<bigint, bigint> | undefined) => DataType<bigint>;
    /**
     * 4-byte integer.
     *
     * + MySQL      : `INT SIGNED`
     * + PostgreSQL : `integer`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `INT SIGNED` data type.
     * + Min: -2,147,483,648; `-(2^31)`
     * + Max:  2,147,483,647; `(2^31)-1`
     */
    export const dtIntSigned: (extraMapper?: tm.Mapper<bigint, bigint> | undefined) => DataType<bigint>;
    /**
     * 8-byte integer.
     *
     * + MySQL      : `BIGINT SIGNED`
     * + PostgreSQL : `bigint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `BIGINT SIGNED` data type.
     * + Min: -9,223,372,036,854,775,808; `-(2^63)`
     * + Max:  9,223,372,036,854,775,807; `(2^63)-1`
     */
    export const dtBigIntSigned: (extraMapper?: tm.Mapper<bigint, bigint> | undefined) => DataType<bigint>;
}
declare module "data-type/built-in-value-expr/text" {
    import * as tm from "type-mapping";
    import { DataType } from "data-type/data-type-impl";
    export function makeTextDataType(mapperFactory: {
        (desiredLengthMin: number, desiredLengthMax: number): tm.FluentMapper<tm.SafeMapper<string>>;
        (desiredLengthMax: number): tm.FluentMapper<tm.SafeMapper<string>>;
        (): tm.FluentMapper<tm.SafeMapper<string>>;
        maxLength: number;
    }): ({
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string>): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string>): DataType<string>;
        (extraMapper?: tm.Mapper<string, string>): DataType<string>;
        maxLength: number;
    });
    /**
     * + MySQL      : `CHAR`
     * + PostgreSQL : `CHAR`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `CHAR` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    export const dtChar: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
    /**
     * + MySQL      : `VARCHAR`
     * + PostgreSQL : `VARCHAR`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `VARCHAR` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    export const dtVarChar: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
    /**
     * + MySQL      : `TINY TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `TINY TEXT` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    export const dtTinyText: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
    /**
     * + MySQL      : `TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `TEXT` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    export const dtText: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
    /**
     * + MySQL      : `MEDIUM TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `MEDIUM TEXT` data type.
     * + Max length: `16,777,215`; `(2^24)-1`
     */
    export const dtMediumText: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
    /**
     * + MySQL      : `LONG TEXT`
     * + PostgreSQL : -NA-
     * + SQLite     : `TEXT`
     *
     * This corresponds to MySQL's `LONG TEXT` data type.
     * + Max length: `4,294,967,295`; `(2^32)-1`
     *
     * -----
     *
     * `text` supports up to 1GB. So, we cannot use `text`.
     *
     * https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F
     *
     * > Maximum size for a field? 1 GB
     *
     * -----
     *
     * Realistically, SQLite should support this,
     * https://www.sqlite.org/limits.html
     *
     * However, it is possible that the underlying implementation
     * may be restricted from having a `string` of that length.
     */
    export const dtLongText: {
        (desiredLengthMin: number, desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (desiredLengthMax: number, extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        (extraMapper?: tm.Mapper<string, string> | undefined): DataType<string>;
        maxLength: number;
    };
}
declare module "data-type/built-in-value-expr/index" {
    export * from "data-type/built-in-value-expr/blob";
    export * from "data-type/built-in-value-expr/boolean";
    export * from "data-type/built-in-value-expr/date-time";
    export * from "data-type/built-in-value-expr/double";
    export * from "data-type/built-in-value-expr/integer";
    export * from "data-type/built-in-value-expr/text";
}
declare module "data-type/index" {
    export * from "data-type/non-built-in-value-expr/index";
    export * from "data-type/built-in-value-expr/index";
    export * from "data-type/data-type-impl";
    export * from "data-type/data-type";
    import * as DataTypeUtil from "data-type/util/index";
    export { DataTypeUtil, };
}
declare module "column-map/util/operation/left-intersect" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import { Column } from "column/index";
    import { Identity } from "type-util/index";
    type LeftIntersectImpl<MapA extends ColumnMap, MapB extends ColumnMap, ColumnAliasT extends keyof MapA> = Identity<{
        readonly [columnAlias in ColumnAliasT]: (columnAlias extends keyof MapB ? Column<{
            tableAlias: MapA[columnAlias]["tableAlias"];
            columnAlias: MapA[columnAlias]["columnAlias"];
            mapper: tm.SafeMapper<tm.OutputOf<MapA[columnAlias]["mapper"]> & tm.OutputOf<MapB[columnAlias]["mapper"]>>;
        }> : MapA[columnAlias]);
    }>;
    export type LeftIntersect<MapA extends ColumnMap, MapB extends ColumnMap> = LeftIntersectImpl<MapA, MapB, Extract<keyof MapA, string>>;
    export function leftIntersect<MapA extends ColumnMap, MapB extends ColumnMap>(mapA: MapA, mapB: MapB): (LeftIntersect<MapA, MapB>);
}
declare module "column-map/util/operation/intersect" {
    import { ColumnMap } from "column-map/column-map";
    import { LeftIntersect } from "column-map/util/operation/left-intersect";
    import { Merge, ReadOnlyPick } from "type-util/index";
    export type IntersectImpl<MapA extends ColumnMap, MapB extends ColumnMap> = (LeftIntersect<MapA, MapB> & ReadOnlyPick<MapB, Exclude<Extract<keyof MapB, string>, keyof MapA>>);
    export type Intersect<MapA extends ColumnMap, MapB extends ColumnMap> = (Merge<IntersectImpl<MapA, MapB>>);
    export function intersect<MapA extends ColumnMap, MapB extends ColumnMap>(mapA: MapA, mapB: MapB): (Intersect<MapA, MapB>);
}
declare module "column-map/util/operation/omit" {
    import { ColumnMap } from "column-map/column-map";
    export function omit<MapT extends ColumnMap, ArrT extends readonly string[]>(map: MapT, arr: ArrT): Omit<MapT, ArrT[number]>;
}
declare module "column-map/util/operation/pick" {
    import { ColumnMap } from "column-map/column-map";
    export function pick<MapT extends ColumnMap, ArrT extends readonly string[]>(map: MapT, arr: ArrT): Pick<MapT, ArrT[number]>;
}
declare module "column-map/util/operation/replace-column" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import { ColumnUtil } from "column/index";
    export type ReplaceColumn<MapT extends ColumnMap, ColumnAliasT extends string, TypeT> = (MapT extends ColumnMap ? {
        readonly [columnAlias in Extract<keyof MapT, string>]: (columnAlias extends ColumnAliasT ? ColumnUtil.WithType<MapT[columnAlias], TypeT> : MapT[columnAlias]);
    } : never);
    export function replaceColumn<MapT extends ColumnMap, ColumnAliasT extends string, TypeT>(map: MapT, columnAlias: ColumnAliasT, mapper: tm.SafeMapper<TypeT>): (ReplaceColumn<MapT, ColumnAliasT, TypeT>);
}
declare module "column-map/util/operation/to-nullable" {
    import { ColumnMap } from "column-map/column-map";
    import { ColumnUtil } from "column/index";
    export type ToNullable<ColumnMapT extends ColumnMap> = ({
        readonly [columnAlias in keyof ColumnMapT]: (ColumnUtil.ToNullable<ColumnMapT[columnAlias]>);
    });
    export function toNullable<ColumnMapT extends ColumnMap>(columnMap: ColumnMapT): ToNullable<ColumnMapT>;
}
declare module "column-map/util/operation/with-table-alias" {
    import { ColumnMap } from "column-map/column-map";
    import { ColumnUtil } from "column/index";
    import { Identity } from "type-util/index";
    type WithTableAliasImpl<ColumnMapT extends ColumnMap, NewTableAliasT extends string, ColumnAliasT extends keyof ColumnMapT> = Identity<{
        readonly [columnAlias in ColumnAliasT]: (ColumnUtil.WithTableAlias<ColumnMapT[columnAlias], NewTableAliasT>);
    }>;
    export type WithTableAlias<ColumnMapT extends ColumnMap, NewTableAliasT extends string> = WithTableAliasImpl<ColumnMapT, NewTableAliasT, Extract<keyof ColumnMapT, string>>;
    export function withTableAlias<ColumnMapT extends ColumnMap, NewTableAliasT extends string>(columnMap: ColumnMapT, newTableAlias: NewTableAliasT): (WithTableAlias<ColumnMapT, NewTableAliasT>);
}
declare module "column-map/util/operation/index" {
    export * from "column-map/util/operation/compound";
    export * from "column-map/util/operation/intersect";
    export * from "column-map/util/operation/left-compound";
    export * from "column-map/util/operation/left-intersect";
    export * from "column-map/util/operation/omit";
    export * from "column-map/util/operation/pick";
    export * from "column-map/util/operation/replace-column";
    export * from "column-map/util/operation/to-nullable";
    export * from "column-map/util/operation/with-table-alias";
}
declare module "column-map/util/constructor/from-join" {
    import { ToNullable } from "column-map/util/operation/index";
    import { IJoin } from "join/index";
    export type FromJoin<JoinT extends IJoin> = (JoinT extends IJoin ? (true extends JoinT["nullable"] ? 
    /**
     * We use nullable columns because when using `LEFT/RIGHT JOIN`s,
     * the columns can become `null`, and we still want to allow joining
     * `null` with `int` columns
     */
    ToNullable<JoinT["columns"]> : JoinT["columns"]) : never);
    export function fromJoin<JoinT extends IJoin>(join: JoinT): FromJoin<JoinT>;
}
declare module "column-map/util/constructor/from-mapper-map" {
    import * as tm from "type-mapping";
    import { Column } from "column/index";
    import { MapperMap } from "mapper-map/index";
    import { Identity } from "type-util/index";
    type FromMapperMapImpl<TableAliasT extends string, MapperMapT extends MapperMap, ColumnAliasT extends keyof MapperMapT> = Identity<{
        readonly [columnAlias in ColumnAliasT]: (Column<{
            tableAlias: TableAliasT;
            columnAlias: Extract<columnAlias, string>;
            /**
             * We erase the type of the `mapper` and
             * replace it with `SafeMapper`.
             *
             * This can save us a lot of emit time.
             */
            mapper: tm.SafeMapper<tm.OutputOf<MapperMapT[columnAlias]>>;
        }>);
    }>;
    export type FromMapperMap<TableAliasT extends string, MapperMapT extends MapperMap> = (FromMapperMapImpl<TableAliasT, MapperMapT, Extract<keyof MapperMapT, string>>);
    export function fromMapperMap<TableAliasT extends string, MapperMapT extends MapperMap>(tableAlias: TableAliasT, mapperMap: MapperMapT): (FromMapperMap<TableAliasT, MapperMapT>);
}
declare module "column-map/util/query/column-alias-with-type" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    export type ColumnAliasWithType<MapT extends ColumnMap, TypeT> = (MapT extends ColumnMap ? {
        [columnAlias in Extract<keyof MapT, string>]: (tm.OutputOf<MapT[columnAlias]["mapper"]> extends TypeT ? columnAlias : never);
    }[Extract<keyof MapT, string>] : never);
}
declare module "column-map/util/query/column-alias" {
    import { ColumnMap } from "column-map/column-map";
    export type ColumnAlias<MapT extends ColumnMap> = (MapT extends ColumnMap ? Extract<keyof MapT, string> : never);
    export function columnAlias<MapT extends ColumnMap>(map: MapT): ColumnAlias<MapT>[];
}
declare module "column-map/util/query/extract-column-identifier" {
    import { ColumnMap } from "column-map/column-map";
    import { ColumnIdentifier } from "column-identifier/index";
    import { Identity } from "type-util/index";
    /**
     * Does not check `tableAlias`
     */
    export type ExtractColumnIdentifier_ColumnAlias<MapT extends ColumnMap, ColumnIdentifierT extends ColumnIdentifier> = {
        [columnAlias in Extract<keyof MapT, string>]: (columnAlias extends ColumnIdentifierT["columnAlias"] ? columnAlias : never);
    }[Extract<keyof MapT, string>];
    /**
     * Does not check `tableAlias`
     */
    export type ExtractColumnIdentifier_Mutable<MapT extends ColumnMap, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        [columnAlias in ExtractColumnIdentifier_ColumnAlias<MapT, ColumnIdentifierT>]: (MapT[columnAlias]);
    }>;
    /**
     * Does not check `tableAlias`
     */
    export type ExtractColumnIdentifier<MapT extends ColumnMap, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        readonly [columnAlias in ExtractColumnIdentifier_ColumnAlias<MapT, ColumnIdentifierT>]: (MapT[columnAlias]);
    }>;
    /**
     * Does not check `tableAlias`
     */
    export function extractColumnIdentifiers<MapT extends ColumnMap, ColumnIdentifierT extends ColumnIdentifier>(map: MapT, columnIdentifiers: readonly ColumnIdentifierT[]): (ExtractColumnIdentifier<MapT, ColumnIdentifierT>);
}
declare module "column-map/util/query/non-nullable-column-alias" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    export type NonNullableColumnAlias<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        [columnAlias in Extract<keyof MapT, string>]: (null extends tm.OutputOf<MapT[columnAlias]["mapper"]> ? never : columnAlias);
    }[Extract<keyof MapT, string>] : never);
    export function nonNullableColumnAliases<MapT extends ColumnMap>(map: MapT): NonNullableColumnAlias<MapT>[];
}
declare module "column-map/util/query/extract-non-nullable" {
    import { ColumnMap } from "column-map/column-map";
    import { NonNullableColumnAlias } from "column-map/util/query/non-nullable-column-alias";
    export type ExtractNonNullable<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        readonly [columnAlias in NonNullableColumnAlias<MapT>]: (MapT[columnAlias]);
    } : never);
    export function extractNonNullable<MapT extends ColumnMap>(map: MapT): (ExtractNonNullable<MapT>);
}
declare module "column-map/util/query/nullable-column-alias" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    export type NullableColumnAlias<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        [columnAlias in Extract<keyof MapT, string>]: (null extends tm.OutputOf<MapT[columnAlias]["mapper"]> ? columnAlias : never);
    }[Extract<keyof MapT, string>] : never);
    export function nullableColumnAliases<MapT extends ColumnMap>(map: MapT): NullableColumnAlias<MapT>[];
}
declare module "column-map/util/query/extract-nullable" {
    import { ColumnMap } from "column-map/column-map";
    import { NullableColumnAlias } from "column-map/util/query/nullable-column-alias";
    export type ExtractNullable<MapT extends ColumnMap> = (MapT extends ColumnMap ? {
        readonly [columnAlias in NullableColumnAlias<MapT>]: (MapT[columnAlias]);
    } : never);
    export function extractNullable<MapT extends ColumnMap>(map: MapT): (ExtractNullable<MapT>);
}
declare module "column-map/util/query/extract-with-type" {
    import { ColumnMap } from "column-map/column-map";
    import { ColumnAliasWithType } from "column-map/util/query/column-alias-with-type";
    export type ExtractWithType<MapT extends ColumnMap, TypeT> = (MapT extends ColumnMap ? {
        readonly [columnAlias in ColumnAliasWithType<MapT, TypeT>]: (MapT[columnAlias]);
    } : never);
}
declare module "column-map/util/query/find-with-column-alias" {
    import { ColumnMap } from "column-map/column-map";
    /**
     * Used for unions of ColumnMap
     *
     * `(A|B)[columnAlias]` will likely give you unknown or similar
     */
    export type FindWithColumnAlias<ColumnMapT extends ColumnMap, ColumnAliasT extends string> = (ColumnMapT extends ColumnMap ? (ColumnAliasT extends keyof ColumnMapT ? ColumnMapT[ColumnAliasT] : never) : never);
}
declare module "column-map/util/query/find-with-table-alias" {
    import { ColumnMap } from "column-map/column-map";
    export type FindWithTableAlias<ColumnMapT extends ColumnMap, TableAliasT extends string> = (ColumnMapT extends ColumnMap ? Extract<ColumnMapT[Extract<keyof ColumnMapT, string>], {
        tableAlias: TableAliasT;
    }> : never);
}
declare module "column-map/util/query/mapper" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import { TypeMapUtil } from "type-map/index";
    export type Mapper<MapT extends ColumnMap> = (MapT extends ColumnMap ? tm.SafeMapper<TypeMapUtil.FromColumnMap<MapT>> : never);
    export function mapper<MapT extends ColumnMap>(map: MapT): Mapper<MapT>;
}
declare module "column-map/util/query/partial-mapper" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import { TypeMapUtil } from "type-map/index";
    export type PartialMapper<MapT extends ColumnMap> = (MapT extends ColumnMap ? tm.SafeMapper<Partial<TypeMapUtil.FromColumnMap<MapT>>> : never);
    export function partialMapper<MapT extends ColumnMap>(map: MapT): PartialMapper<MapT>;
}
declare module "column-map/util/query/table-alias" {
    import { ColumnMap } from "column-map/column-map";
    export type TableAlias<MapT extends ColumnMap> = (MapT extends ColumnMap ? MapT[Extract<keyof MapT, string>]["tableAlias"] : never);
    /**
     * Returns the **first** table alias found.
     *
     * All columns in a `ColumnMap` should have the same table alias.
     * If multiple table aliases exist, the one it returns is arbitrary.
     *
     * If no columns exist, it throws an error.
     */
    export function tableAlias<MapT extends ColumnMap>(map: MapT): (TableAlias<MapT>);
}
declare module "column-map/util/query/index" {
    export * from "column-map/util/query/column-alias-with-type";
    export * from "column-map/util/query/column-alias";
    export * from "column-map/util/query/extract-column-identifier";
    export * from "column-map/util/query/extract-non-nullable";
    export * from "column-map/util/query/extract-nullable";
    export * from "column-map/util/query/extract-with-type";
    export * from "column-map/util/query/find-with-column-alias";
    export * from "column-map/util/query/find-with-table-alias";
    export * from "column-map/util/query/mapper";
    export * from "column-map/util/query/non-nullable-column-alias";
    export * from "column-map/util/query/nullable-column-alias";
    export * from "column-map/util/query/partial-mapper";
    export * from "column-map/util/query/table-alias";
}
declare module "column-map/util/constructor/from-expr-select-item" {
    import { IExprSelectItem } from "expr-select-item/index";
    import { FromColumn } from "column-map/util/constructor/from-column";
    import { ColumnUtil } from "column/index";
    export type FromExprSelectItem<ItemT extends IExprSelectItem> = FromColumn<ColumnUtil.FromExprSelectItem<ItemT>>;
    export function fromExprSelectItem<ItemT extends IExprSelectItem>(item: ItemT): (FromExprSelectItem<ItemT>);
}
declare module "column-map/util/constructor/from-column-ref" {
    import { ColumnRef, ColumnRefUtil } from "column-ref/index";
    export type FromColumnRef<RefT extends ColumnRef> = RefT extends ColumnRef ? {
        [columnAlias in ColumnRefUtil.ColumnAlias<RefT>]: (ColumnRefUtil.FindWithColumnAlias<RefT, columnAlias>);
    } : never;
    export function fromColumnRef<RefT extends ColumnRef>(ref: RefT): (FromColumnRef<RefT>);
}
declare module "column-map/util/predicate/is-null-safe-comparable" {
    import * as tm from "type-mapping";
    import { ColumnMap } from "column-map/column-map";
    import * as TypeUtil from "type-util/index";
    /**
     * Returns `true` if all columns of `A`
     * are **null-safe** comparable with columns in `B` that have the same name
     *
     * The column aliases of `A` must be a subset of the column aliases of `B`,
     * or the result will never `extends true`
     *
     * + Assumes `A` is not a union
     * + Assumes `B` is not a union
     */
    export type IsNullSafeComparable<A extends ColumnMap, B extends ColumnMap> = ({
        [k in Extract<keyof A, string>]: (k extends Extract<keyof B, string> ? TypeUtil.IsNullSafeComparable<tm.OutputOf<A[k]["mapper"]>, tm.OutputOf<B[k]["mapper"]>> : false);
    }[Extract<keyof A, string>]);
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring columns in `a` and columns in `b`
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    export function isNullSafeComparable(a: ColumnMap, b: ColumnMap): boolean;
}
declare module "column-map/util/predicate/assert-is-null-safe-comparable" {
    import { ColumnMap } from "column-map/column-map";
    import { IsNullSafeComparable } from "column-map/util/predicate/is-null-safe-comparable";
    import { CompileError } from "compile-error/index";
    import { TypeMapUtil } from "type-map/index";
    import { Writable } from "type-util/index";
    /**
     * Returns `unknown` if all columns of `A`
     * are **null-safe** comparable with columns in `B` that have the same name
     *
     * The column aliases of `A` must be a subset of the column aliases of `B`,
     * or the result will never `extends unknown`
     *
     * + Assumes `A` is not a union
     * + Assumes `B` is not a union
     */
    export type AssertIsNullSafeComparable<A extends ColumnMap, B extends ColumnMap> = (IsNullSafeComparable<A, B> extends true ? unknown : CompileError<[Writable<TypeMapUtil.FromColumnMap<A>>, "is not null-safe comparable to", Writable<TypeMapUtil.FromColumnMap<B>>]>);
    export function assertIsNullSafeComparable(a: ColumnMap, b: ColumnMap): void;
}
declare module "column-map/util/predicate/assert-is-null-safe-comparable-if-same-own-enumerable-keys" {
    import { ColumnMap } from "column-map/column-map";
    import { AssertSameOwnEnumerableKeys } from "type-util/index";
    import { AssertIsNullSafeComparable } from "column-map/util/predicate/assert-is-null-safe-comparable";
    /**
     * + Assumes `SrcMapT` is not a union
     * + Assumes `DstMapT` may be a union
     *
     * If `SrcMapT` and `DstMapT` have the same keys,
     * it asserts if they are **null-safe** comparable.
     *
     * Otherwise, it performs no assertion.
     */
    export type AssertIsNullSafeComparableIfSameOwnEnumerableKeys_NonUnion<SrcMapT extends ColumnMap, DstMapT extends ColumnMap> = DstMapT extends ColumnMap ? (unknown extends AssertSameOwnEnumerableKeys<SrcMapT, DstMapT> ? AssertIsNullSafeComparable<SrcMapT, DstMapT> : unknown) : never;
}
declare module "column-map/util/predicate/has-column-alias" {
    import { ColumnMap } from "column-map/column-map";
    export function hasColumnAlias<MapT extends ColumnMap>(map: MapT, columnAlias: string): columnAlias is Extract<keyof MapT, string>;
}
declare module "column-map/util/predicate/is-column-map" {
    import { ColumnMap } from "column-map/column-map";
    export function isColumnMap(mixed: unknown): mixed is ColumnMap;
}
declare module "column-map/util/predicate/index" {
    export * from "column-map/util/predicate/assert-is-null-safe-comparable-if-same-own-enumerable-keys";
    export * from "column-map/util/predicate/assert-is-null-safe-comparable";
    export * from "column-map/util/predicate/has-column-alias";
    export * from "column-map/util/predicate/is-column-map";
    export * from "column-map/util/predicate/is-null-safe-comparable";
}
declare module "column-map/util/constructor/from-select-item" {
    import { SelectItem } from "select-item/index";
    import { IColumn } from "column/column";
    import { FromColumn } from "column-map/util/constructor/from-column";
    import { IExprSelectItem } from "expr-select-item/index";
    import { ColumnMap } from "column-map/column-map";
    import { ColumnRef } from "column-ref/index";
    import { FromExprSelectItem } from "column-map/util/constructor/from-expr-select-item";
    import { FromColumnRef } from "column-map/util/constructor/from-column-ref";
    export type FromSelectItem<ItemT extends SelectItem> = ItemT extends IColumn ? FromColumn<ItemT> : ItemT extends IExprSelectItem ? FromExprSelectItem<ItemT> : ItemT extends ColumnMap ? ItemT : ItemT extends ColumnRef ? FromColumnRef<ItemT> : never;
    export function fromSelectItem<ItemT extends SelectItem>(item: ItemT): FromSelectItem<ItemT>;
}
declare module "column-map/util/constructor/from-select-clause" {
    import { SelectClause, SelectClauseUtil } from "select-clause/index";
    import { IColumn } from "column/column";
    import { ColumnUtil } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { ColumnAlias, FindWithColumnAlias } from "column-map/util/query/index";
    import { ColumnMap } from "column-map/column-map";
    import { ColumnRefUtil, ColumnRef } from "column-ref/index";
    import { Identity } from "type-util/index";
    export type FromSelectClause<SelectClauseT extends SelectClause, TableAliasT extends string> = Identity<{
        readonly [columnAlias in SelectClauseUtil.ColumnAlias<SelectClauseT>]: (columnAlias extends Extract<SelectClauseT[number], IColumn>["columnAlias"] ? ColumnUtil.WithTableAlias<Extract<SelectClauseT[number], {
            columnAlias: columnAlias;
        }>, TableAliasT> : columnAlias extends Extract<SelectClauseT[number], IExprSelectItem>["alias"] ? ColumnUtil.WithTableAlias<ColumnUtil.FromExprSelectItem<Extract<SelectClauseT[number], {
            alias: columnAlias;
        }>>, TableAliasT> : columnAlias extends ColumnAlias<Extract<SelectClauseT[number], ColumnMap>> ? ColumnUtil.WithTableAlias<FindWithColumnAlias<Extract<SelectClauseT[number], ColumnMap>, columnAlias>, TableAliasT> : columnAlias extends ColumnRefUtil.ColumnAlias<Extract<SelectClauseT[number], ColumnRef>> ? ColumnUtil.WithTableAlias<ColumnRefUtil.FindWithColumnAlias<Extract<SelectClauseT[number], ColumnRef>, columnAlias>, TableAliasT> : never);
    }>;
    /**
     * Assumes no duplicate `columnAlias` in `SelectClauseT`
     */
    export function fromSelectClause<SelectClauseT extends SelectClause, TableAliasT extends string>(selectsClause: SelectClauseT, tableAlias: TableAliasT, preserveUnaliasedAst: boolean): FromSelectClause<SelectClauseT, TableAliasT>;
}
declare module "column-map/util/constructor/index" {
    export * from "column-map/util/constructor/from-column-array";
    export * from "column-map/util/constructor/from-column-union";
    export * from "column-map/util/constructor/from-column";
    export * from "column-map/util/constructor/from-field-array";
    export * from "column-map/util/constructor/from-join";
    export * from "column-map/util/constructor/from-mapper-map";
    export * from "column-map/util/constructor/from-select-clause";
}
declare module "column-map/util/index" {
    export * from "column-map/util/constructor/index";
    export * from "column-map/util/operation/index";
    export * from "column-map/util/predicate/index";
    export * from "column-map/util/query/index";
}
declare module "column-map/index" {
    export * from "column-map/column-map";
    import * as ColumnMapUtil from "column-map/util/index";
    export { ColumnMapUtil, };
}
declare module "column/util/constructor/from-column-map" {
    import { ColumnMap } from "column-map/index";
    export type FromColumnMap<ColumnMapT extends ColumnMap> = (ColumnMapT extends ColumnMap ? ColumnMapT[Extract<keyof ColumnMapT, string>] : never);
    export function fromColumnMap<ColumnMapT extends ColumnMap>(map: ColumnMapT): (FromColumnMap<ColumnMapT>[]);
}
declare module "column/util/constructor/from-column-ref" {
    import { ColumnRef } from "column-ref/index";
    import { FromColumnMap } from "column/util/constructor/from-column-map";
    export type FromColumnRef<ColumnRefT extends ColumnRef> = (ColumnRefT extends ColumnRef ? FromColumnMap<ColumnRefT[keyof ColumnRefT]> : never);
    export function fromColumnRef<ColumnRefT extends ColumnRef>(ref: ColumnRefT): (FromColumnRef<ColumnRefT>[]);
}
declare module "expr-column/expr-column" {
    import { ColumnData, IColumn } from "column/index";
    export interface ExprColumnData extends ColumnData {
        readonly isAggregate: boolean;
    }
    export interface IExprColumn<DataT extends ExprColumnData = ExprColumnData> extends IColumn<DataT> {
        readonly isAggregate: DataT["isAggregate"];
    }
}
declare module "expr-column/expr-column-impl" {
    import { ExprColumnData, IExprColumn } from "expr-column/expr-column";
    import { ColumnUtil } from "column/index";
    import { SortDirection } from "sort-direction/index";
    import { Ast } from "ast/index";
    export class ExprColumn<DataT extends ExprColumnData> implements IExprColumn<DataT> {
        readonly tableAlias: DataT["tableAlias"];
        readonly columnAlias: DataT["columnAlias"];
        readonly mapper: DataT["mapper"];
        readonly isAggregate: DataT["isAggregate"];
        readonly unaliasedAst: undefined | Ast;
        /**
         * You should never need to explicitly instantiate an `ExprColumn`.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data: DataT, unaliasedAst: undefined | Ast);
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC
         * ```
         */
        asc(): ColumnUtil.Asc<this>;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn DESC
         * ```
         */
        desc(): ColumnUtil.Desc<this>;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC,
         *  myTable.myOtherColumn DESC
         * ```
         */
        sort(sortDirection: SortDirection): ColumnUtil.Sort<this>;
    }
}
declare module "expr-column/util/predicate/is-expr-column" {
    import { IExprColumn } from "expr-column/expr-column";
    export function isExprColumn(raw: unknown): raw is IExprColumn;
}
declare module "expr-column/util/predicate/index" {
    export * from "expr-column/util/predicate/is-expr-column";
}
declare module "expr-column/util/index" {
    export * from "expr-column/util/predicate/index";
}
declare module "expr-column/index" {
    export * from "expr-column/expr-column-impl";
    export * from "expr-column/expr-column";
    import * as ExprColumnUtil from "expr-column/util/index";
    export { ExprColumnUtil };
}
declare module "column/util/constructor/from-expr-select-item" {
    import { IExprSelectItem } from "expr-select-item/index";
    import { ExprColumn } from "expr-column/index";
    export type FromExprSelectItem<ExprSelectItemT extends IExprSelectItem> = (ExprSelectItemT extends IExprSelectItem ? ExprColumn<{
        tableAlias: ExprSelectItemT["tableAlias"];
        columnAlias: ExprSelectItemT["alias"];
        mapper: ExprSelectItemT["mapper"];
        isAggregate: ExprSelectItemT["isAggregate"];
    }> : never);
    export function fromExprSelectItem<ExprSelectItemT extends IExprSelectItem>(exprSelectItem: ExprSelectItemT): FromExprSelectItem<ExprSelectItemT>;
}
declare module "column/util/constructor/from-join" {
    import { IJoin } from "join/index";
    import { ColumnMapUtil } from "column-map/index";
    import { FromColumnMap } from "column/util/constructor/from-column-map";
    export type FromJoin<JoinT extends IJoin> = (JoinT extends IJoin ? FromColumnMap<ColumnMapUtil.FromJoin<JoinT>> : never);
    export function fromJoin<JoinT extends IJoin>(join: JoinT): (FromJoin<JoinT>[]);
}
declare module "column/util/constructor/from-join-array" {
    import { IJoin } from "join/index";
    import { FromJoin } from "column/util/constructor/from-join";
    export type FromJoinArray<JoinsT extends readonly IJoin[]> = (JoinsT extends readonly IJoin[] ? FromJoin<JoinsT[number]> : never);
    export function fromJoinArray<JoinsT extends readonly IJoin[]>(joins: JoinsT): (FromJoinArray<JoinsT>[]);
}
declare module "column/util/constructor/from-select-item" {
    import { SelectItem } from "select-item/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { FromExprSelectItem } from "column/util/constructor/from-expr-select-item";
    import { ColumnRef } from "column-ref/index";
    import { FromColumnRef } from "column/util/constructor/from-column-ref";
    import { ColumnMap } from "column-map/index";
    import { FromColumnMap } from "column/util/constructor/from-column-map";
    import { IColumn } from "column/index";
    /**
     * + Assumes `SelectItemT` may be union
     */
    export type FromSelectItem<SelectItemT extends SelectItem> = (
    /**
     * Ordered from most likely to least likely
     */
    SelectItemT extends IExprSelectItem ? FromExprSelectItem<SelectItemT> : SelectItemT extends ColumnMap ? FromColumnMap<SelectItemT> : SelectItemT extends ColumnRef ? FromColumnRef<SelectItemT> : SelectItemT extends IColumn ? SelectItemT : never);
    export function fromSelectItem<SelectItemT extends SelectItem>(selectItem: SelectItemT): (FromSelectItem<SelectItemT>[]);
}
declare module "column/util/constructor/from-select-clause" {
    import { SelectClause } from "select-clause/index";
    import { FromSelectItem } from "column/util/constructor/from-select-item";
    /**
     * For output positions
     */
    export type FromSelectClause<SelectClauseT extends SelectClause> = (SelectClauseT extends SelectClause ? FromSelectItem<SelectClauseT[number]> : never);
    /**
     * Does not remove duplicate identifiers
     *
     * @param selectClause
     */
    export function fromSelectClause<SelectClauseT extends SelectClause>(selectClause: SelectClauseT): (FromSelectClause<SelectClauseT>[]);
}
declare module "column/util/constructor/index" {
    export * from "column/util/constructor/from-column-map";
    export * from "column/util/constructor/from-column-ref";
    export * from "column/util/constructor/from-expr-select-item";
    export * from "column/util/constructor/from-join-array";
    export * from "column/util/constructor/from-join";
    export * from "column/util/constructor/from-select-clause";
    export * from "column/util/constructor/from-select-item";
}
declare module "column/util/operation/build-ast" {
    import { IColumn } from "column/column";
    import { IdentifierNode } from "ast/index";
    export function buildAst({ tableAlias, columnAlias, unaliasedAst, }: IColumn): IdentifierNode;
}
declare module "aliased-expr/aliased-expr-impl" {
    import { ExprImpl } from "expr/index";
    import { IExprSelectItem, ExprSelectItemData } from "expr-select-item/index";
    import { Ast } from "ast/index";
    /**
     * An aliased expression
     *
     * ```sql
     *  SELECT
     *      (1+2) AS x --This is an `AliasedExpr`
     * ```
     *
     * -----
     *
     * ### Using `AliasedExpr` as "normal" expression
     *
     * Normally, you cannot use an aliased expression as a "normal" expression.
     *
     * This is usually invalid,
     * ```sql
     *  SELECT
     *      (((1+2) AS x) + 3) AS y
     * ```
     *
     * However, `tsql` allows this!
     *
     * When the query is generated, it extracts the inner unaliased expression,
     *
     * ```sql
     *  SELECT
     *      ((1+2) + 3) AS y
     * ```
     *
     * -----
     *
     * Allowing the above lets us write composable expressions that
     * can also be used in `SELECT` clauses more consistently!
     *
     * For example,
     * ```ts
     *  function x () {
     *      return tsql.add(1, 2).as("x");
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //SELECT (1+2) AS x, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     * If we did not allow aliased expressions to be used as "normal" expressions,
     * we would have an increased risk of typos,
     *
     * ```ts
     *  function x () {
     *      //Removed `.as("x")`
     *      return tsql.add(1, 2);
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x().as("x"),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //Intended: SELECT (1+2) AS x, (1+2+3+4+5) AS y
     *  //Actual  : SELECT (1+2) AS typo, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x().as("typo"),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     * -----
     *
     * ### Re-aliasing
     *
     * Normally, you can only alias an expression once,
     * ```sql
     *  SELECT
     *      (1+2) AS x AS y --Error: Cannot alias an expression more than once!
     * ```
     *
     * However, `tsql` allows this!
     *
     * When the query is generated, it uses the **last** set alias,
     * ```sql
     *  SELECT
     *      (1+2) AS y
     * ```
     *
     * -----
     *
     * With re-aliasing, you can set a **default alias** for your composable expressions.
     * Then, when you want a different alias, you can change it.
     *
     * For example,
     * ```ts
     *  function x () {
     *      //Default alias is `x`
     *      return tsql.add(1, 2).as("x");
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //SELECT (1+2) AS realiased, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x().as("realiased"),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     */
    export class AliasedExpr<DataT extends ExprSelectItemData> extends ExprImpl<ReturnType<DataT["mapper"]>, DataT["usedRef"], DataT["isAggregate"]> implements IExprSelectItem<DataT> {
        readonly tableAlias: DataT["tableAlias"];
        readonly alias: DataT["alias"];
        readonly unaliasedAst: Ast;
        constructor(data: DataT, ast: Ast);
    }
}
declare module "aliased-expr/index" {
    export * from "aliased-expr/aliased-expr-impl";
}
declare module "column/util/operation/as" {
    import { IColumn } from "column/column";
    import { UsedRefUtil } from "used-ref/index";
    import { AliasedExpr } from "aliased-expr/index";
    export type As<ColumnT extends IColumn, AliasT extends string> = AliasedExpr<{
        mapper: ColumnT["mapper"];
        /**
         * Consider the following.
         * ```ts
         *  const table = tsql.table(
         *      "table",
         *      {
         *          x : tm.mysql.boolean(),
         *          y : tm.mysql.varChar(),
         *          z : tm.mysql.boolean(),
         *      }
         *  );
         *
         *  tsql.from(table)
         *      .select(c => [c.z.as("x")])
         *      .having(c => c.x)
         * ```
         *
         * `c.x` in the `HAVING` clause is now ambiguous!
         *
         * Is it `c.z AS x`? Or regular `c.x`?
         *
         * Because of this, you cannot alias to something that hides
         * a column in the FROM/JOIN clauses.
         *
         * -----
         *
         * At the moment, we don't allow the `tableAlias` to change
         * to lower the probability of hiding.
         */
        tableAlias: ColumnT["tableAlias"];
        alias: AliasT;
        usedRef: UsedRefUtil.FromColumn<ColumnT>;
        isAggregate: false;
    }>;
    export function as<ColumnT extends IColumn, AliasT extends string>(column: ColumnT, alias: AliasT): As<ColumnT, AliasT>;
}
declare module "column/util/operation/asc" {
    import { IColumn } from "column/column";
    import { SortDirection } from "sort-direction/index";
    export type Asc<ColumnT extends IColumn> = (readonly [ColumnT, SortDirection.ASC]);
    export function asc<ColumnT extends IColumn>(column: ColumnT): Asc<ColumnT>;
}
declare module "column/util/operation/desc" {
    import { IColumn } from "column/column";
    import { SortDirection } from "sort-direction/index";
    export type Desc<ColumnT extends IColumn> = (readonly [ColumnT, SortDirection.DESC]);
    export function desc<ColumnT extends IColumn>(column: ColumnT): Desc<ColumnT>;
}
declare module "column/util/operation/sort" {
    import { IColumn } from "column/column";
    import { SortDirection } from "sort-direction/index";
    export type Sort<ColumnT extends IColumn> = (readonly [ColumnT, SortDirection]);
    export function sort<ColumnT extends IColumn>(column: ColumnT, sortDirection: SortDirection): Sort<ColumnT>;
}
declare module "column/util/operation/to-non-nullable" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    import { Column } from "column/column-impl";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type ToNonNullableImpl<TableAliasT extends IColumn["tableAlias"], ColumnAliasT extends IColumn["columnAlias"], MapperT extends IColumn["mapper"]> = (Column<{
        tableAlias: TableAliasT;
        columnAlias: ColumnAliasT;
        mapper: tm.SafeMapper<Exclude<tm.OutputOf<MapperT>, null>>;
    }>);
    /**
     * Used to implement narrowing functions
     */
    export type ToNonNullable<ColumnT extends IColumn> = (ColumnT extends IColumn ? ToNonNullableImpl<ColumnT["tableAlias"], ColumnT["columnAlias"], ColumnT["mapper"]> : never);
    export function toNonNullable<ColumnT extends IColumn>({ tableAlias, columnAlias, mapper, unaliasedAst, }: ColumnT): (ToNonNullable<ColumnT>);
}
declare module "column/util/operation/to-nullable" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    import { Column } from "column/column-impl";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type ToNullableImpl<TableAliasT extends IColumn["tableAlias"], ColumnAliasT extends IColumn["columnAlias"], MapperT extends IColumn["mapper"]> = (Column<{
        tableAlias: TableAliasT;
        columnAlias: ColumnAliasT;
        mapper: tm.SafeMapper<null | tm.OutputOf<MapperT>>;
    }>);
    export type ToNullable<ColumnT extends IColumn> = (ColumnT extends IColumn ? ToNullableImpl<ColumnT["tableAlias"], ColumnT["columnAlias"], ColumnT["mapper"]> : never);
    export function toNullable<ColumnT extends IColumn>({ tableAlias, columnAlias, mapper, unaliasedAst, }: ColumnT): (ToNullable<ColumnT>);
}
declare module "column/util/operation/to-error-message-friendly-type" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    /**
     * Used to generate nicer looking error messages
     */
    export type ToErrorMessageFriendlyType<ColumnT extends IColumn> = (ColumnT extends IColumn ? ([ColumnT["tableAlias"], ColumnT["columnAlias"], tm.OutputOf<ColumnT["mapper"]>]) : never);
}
declare module "column/util/operation/with-table-alias" {
    import { IColumn } from "column/column";
    import { Column } from "column/column-impl";
    /**
     * Used to implement the `AS` clause,
     *
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable AS aliased
     * ```
     */
    export type WithTableAlias<ColumnT extends IColumn, NewTableAliasT extends string> = (ColumnT extends IColumn ? Column<{
        tableAlias: NewTableAliasT;
        columnAlias: ColumnT["columnAlias"];
        mapper: ColumnT["mapper"];
    }> : never);
    export function withTableAlias<ColumnT extends IColumn, NewTableAliasT extends string>({ columnAlias, mapper, unaliasedAst, }: ColumnT, newTableAlias: NewTableAliasT): (WithTableAlias<ColumnT, NewTableAliasT>);
}
declare module "column/util/operation/with-type" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    import { Column } from "column/column-impl";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WithTypeImpl<TypeT, TableAliasT extends string, ColumnAliasT extends string> = (Column<{
        tableAlias: TableAliasT;
        columnAlias: ColumnAliasT;
        mapper: tm.SafeMapper<TypeT>;
    }>);
    /**
     * Used to narrow the type of a column
     */
    export type WithType<ColumnT extends IColumn, TypeT> = (ColumnT extends IColumn ? WithTypeImpl<TypeT, ColumnT["tableAlias"], ColumnT["columnAlias"]> : never);
    export function withType<ColumnT extends IColumn, TypeT>({ tableAlias, columnAlias, unaliasedAst, }: ColumnT, newMapper: tm.SafeMapper<TypeT>): (WithType<ColumnT, TypeT>);
}
declare module "column/util/operation/with-unaliased-ast" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    import { Column } from "column/column-impl";
    import { TryReuseExistingType } from "type-util/index";
    import { Ast } from "ast/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type WithUnaliasedAstImpl<TableAliasT extends string, ColumnAliasT extends string, MapperT extends tm.AnySafeMapper> = (Column<{
        tableAlias: TableAliasT;
        columnAlias: ColumnAliasT;
        mapper: MapperT;
    }>);
    /**
     * Used to narrow the type of a column
     */
    export type WithUnaliasedAst<ColumnT extends IColumn> = (ColumnT extends IColumn ? TryReuseExistingType<ColumnT, WithUnaliasedAstImpl<ColumnT["tableAlias"], ColumnT["columnAlias"], ColumnT["mapper"]>> : never);
    export function withUnaliasedAst<ColumnT extends IColumn>({ tableAlias, columnAlias, mapper, }: ColumnT, unaliasedAst: Ast | undefined): (WithUnaliasedAst<ColumnT>);
}
declare module "column/util/operation/index" {
    export * from "column/util/operation/as";
    export * from "column/util/operation/asc";
    export * from "column/util/operation/build-ast";
    export * from "column/util/operation/desc";
    export * from "column/util/operation/sort";
    export * from "column/util/operation/to-non-nullable";
    export * from "column/util/operation/to-nullable";
    export * from "column/util/operation/to-error-message-friendly-type";
    export * from "column/util/operation/with-table-alias";
    export * from "column/util/operation/with-type";
    export * from "column/util/operation/with-unaliased-ast";
}
declare module "column/util/predicate/is-column" {
    import { IColumn } from "column/column";
    export function isColumn(raw: unknown): raw is IColumn;
}
declare module "column/util/predicate/index" {
    export * from "column/util/predicate/is-column";
}
declare module "column/util/query/extract-non-nullable" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    export type ExtractNonNullable<ColumnT extends IColumn> = (ColumnT extends IColumn ? (null extends tm.OutputOf<ColumnT["mapper"]> ? never : ColumnT) : never);
}
declare module "column/util/query/extract-nullable" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    export type ExtractNullable<ColumnT extends IColumn> = (ColumnT extends IColumn ? (null extends tm.OutputOf<ColumnT["mapper"]> ? ColumnT : never) : never);
    export function extractNullable<ColumnsT extends readonly IColumn[]>(columns: ColumnsT): (ExtractNullable<ColumnsT[number]>[]);
}
declare module "column/util/query/extract-with-column-alias" {
    import { IColumn } from "column/column";
    export type ExtractWithColumnAlias<ColumnT extends IColumn, ColumnAliasT extends string> = (ColumnT extends IColumn ? (ColumnT["columnAlias"] extends ColumnAliasT ? ColumnT : never) : never);
}
declare module "column/util/query/extract-with-table-alias" {
    import { IColumn } from "column/column";
    export type ExtractWithTableAlias<ColumnT extends IColumn, TableAliasT extends string> = (ColumnT extends IColumn ? (ColumnT["tableAlias"] extends TableAliasT ? ColumnT : never) : never);
}
declare module "column/util/query/extract-with-type" {
    import * as tm from "type-mapping";
    import { IColumn } from "column/column";
    export type ExtractWithType<ColumnT extends IColumn, TypeT> = (ColumnT extends IColumn ? (tm.OutputOf<ColumnT["mapper"]> extends TypeT ? ColumnT : never) : never);
}
declare module "column/util/query/index" {
    export * from "column/util/query/extract-non-nullable";
    export * from "column/util/query/extract-nullable";
    export * from "column/util/query/extract-with-column-alias";
    export * from "column/util/query/extract-with-table-alias";
    export * from "column/util/query/extract-with-type";
}
declare module "column/util/index" {
    export * from "column/util/constructor/index";
    export * from "column/util/operation/index";
    export * from "column/util/predicate/index";
    export * from "column/util/query/index";
}
declare module "column/column-impl" {
    import { ColumnData, IColumn } from "column/column";
    import * as ColumnUtil from "column/util/index";
    import { SortDirection } from "sort-direction/index";
    import { Ast } from "ast/index";
    export class Column<DataT extends ColumnData> implements IColumn<DataT> {
        readonly tableAlias: DataT["tableAlias"];
        readonly columnAlias: DataT["columnAlias"];
        readonly mapper: DataT["mapper"];
        readonly unaliasedAst: undefined | Ast;
        /**
         * You should never need to explicitly instantiate a `Column`.
         * Use `myTable.addColumns()` instead.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data: DataT, unaliasedAst: undefined | Ast);
        /**
         * ```sql
         * SELECT
         *  myTable.myColumn AS alias
         * FROM
         *  myTable
         * ```
         *
         * @param alias - The new column name
         */
        as<AliasT extends string>(alias: AliasT): ColumnUtil.As<this, AliasT>;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC
         * ```
         */
        asc(): ColumnUtil.Asc<this>;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn DESC
         * ```
         */
        desc(): ColumnUtil.Desc<this>;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC,
         *  myTable.myOtherColumn DESC
         * ```
         */
        sort(sortDirection: SortDirection): ColumnUtil.Sort<this>;
    }
}
declare module "column/array-util/constructor/from-column-map" {
    import * as ColumnUtil from "column/util/index";
    import { ColumnMap } from "column-map/index";
    export type FromColumnMap<ColumnMapT extends ColumnMap> = (ColumnMapT extends ColumnMap ? ColumnUtil.FromColumnMap<ColumnMapT>[] : never);
    export function fromColumnMap<ColumnMapT extends ColumnMap>(columnMap: ColumnMapT): (FromColumnMap<ColumnMapT>);
    export function fromColumnMapArray<ColumnMapT extends ColumnMap>(columnMapArr: readonly ColumnMapT[]): (FromColumnMap<ColumnMapT>);
}
declare module "column/array-util/constructor/index" {
    export * from "column/array-util/constructor/from-column-map";
}
declare module "column/array-util/index" {
    export * from "column/array-util/constructor/index";
}
declare module "column/index" {
    export * from "column/column-impl";
    export * from "column/column";
    import * as ColumnArrayUtil from "column/array-util/index";
    import * as ColumnUtil from "column/util/index";
    export { ColumnArrayUtil, ColumnUtil, };
}
declare module "select-item/select-item" {
    import { IColumn, IAnonymousColumn } from "column/index";
    import { ColumnMap } from "column-map/index";
    import { IExprSelectItem, IAnonymousExprSelectItem } from "expr-select-item/index";
    import { ColumnRef } from "column-ref/index";
    export type SingleValueSelectItem = (IColumn | IExprSelectItem);
    export type AnonymousSingleValueSelectItem<TypeT> = (IAnonymousColumn<TypeT> | IAnonymousExprSelectItem<TypeT, boolean>);
    export type SelectItem = (SingleValueSelectItem | ColumnMap | ColumnRef);
}
declare module "select-item/util/predicate/is-single-value-select-item" {
    import { SingleValueSelectItem } from "select-item/select-item";
    export function isSingleValueSelectItem(x: unknown): x is SingleValueSelectItem;
}
declare module "select-item/util/predicate/index" {
    export * from "select-item/util/predicate/is-single-value-select-item";
}
declare module "select-item/util/query/column-alias" {
    import { SelectItem } from "select-item/select-item";
    import { IColumn } from "column/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { ColumnMap, ColumnMapUtil } from "column-map/index";
    import { ColumnRef, ColumnRefUtil } from "column-ref/index";
    export type ColumnAlias<ItemT extends SelectItem> = ItemT extends IColumn ? ItemT["columnAlias"] : ItemT extends IExprSelectItem ? ItemT["alias"] : ItemT extends ColumnMap ? ColumnMapUtil.ColumnAlias<ItemT> : ItemT extends ColumnRef ? ColumnRefUtil.ColumnAlias<ItemT> : never;
    export function columnAlias(item: SelectItem): string[];
}
declare module "select-item/util/query/type-of" {
    import * as tm from "type-mapping";
    import { SingleValueSelectItem } from "select-item/select-item";
    export type TypeOf<ItemT extends SingleValueSelectItem> = (tm.OutputOf<ItemT["mapper"]>);
}
declare module "select-item/util/query/index" {
    export * from "select-item/util/query/column-alias";
    export * from "select-item/util/query/type-of";
}
declare module "select-item/util/index" {
    export * from "select-item/util/predicate/index";
    export * from "select-item/util/query/index";
}
declare module "select-item/index" {
    export * from "select-item/select-item";
    import * as SelectItemUtil from "select-item/util/index";
    export { SelectItemUtil, };
}
declare module "select-clause/select-clause" {
    import { SelectItem } from "select-item/index";
    export type SelectClause = readonly SelectItem[];
}
declare module "select-clause/util/constructor/value-from-built-in-expr" {
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { IColumn } from "column/index";
    export const SELECT_VALUE_ALIAS = "value";
    export type ValueFromBuiltInExpr<BuiltInExprT extends AnyBuiltInExpr> = 
    /**
     * We could use `BuiltInExprT extends IColumn|IExprSelectItem` but we won't.
     * This is intentional.
     *
     * The `IColumn|IExprSelectItem` may have different aliases and we want to be sure to check that.
     */
    [BuiltInExprT] extends [boolean] ? [ExprUtil.As<ExprUtil.FromBuiltInExpr<BuiltInExprT>, typeof SELECT_VALUE_ALIAS>] : BuiltInExprT extends IColumn ? [BuiltInExprT] : BuiltInExprT extends IExprSelectItem ? [BuiltInExprT] : [ExprUtil.As<ExprUtil.FromBuiltInExpr<BuiltInExprT>, typeof SELECT_VALUE_ALIAS>];
    export function valueFromBuiltInExpr<BuiltInExprT extends AnyBuiltInExpr>(builtInExpr: BuiltInExprT): (ValueFromBuiltInExpr<BuiltInExprT>);
}
declare module "select-clause/util/constructor/index" {
    export * from "select-clause/util/constructor/value-from-built-in-expr";
}
declare module "select-clause/util/operation/left-compound" {
    import * as tm from "type-mapping";
    import { SelectClause } from "select-clause/select-clause";
    import { IColumn, ColumnUtil } from "column/index";
    import { IExprSelectItem, ExprSelectItemUtil } from "expr-select-item/index";
    import { ColumnMap, ColumnMapUtil } from "column-map/index";
    import { ColumnRef, ColumnRefUtil } from "column-ref/index";
    import { SelectItem } from "select-item/index";
    /**
     * The type of columns is unioned, not intersected.
     *
     * This is used to implement `CompoundQueryClauseUtil.compoundQuery()`
     *
     * @todo Better name?
     */
    export type LeftCompoundImpl<A extends SelectClause, B extends SelectClause> = {
        [index in keyof A]: (A[index] extends IColumn ? (B[Extract<index, keyof B>] extends IColumn | IExprSelectItem ? ColumnUtil.WithType<A[index], (tm.OutputOf<A[index]["mapper"]> | tm.OutputOf<B[Extract<index, keyof B>]["mapper"]>)> : never) : A[index] extends IExprSelectItem ? (B[Extract<index, keyof B>] extends IColumn | IExprSelectItem ? ExprSelectItemUtil.WithType<A[index], (tm.OutputOf<A[index]["mapper"]> | tm.OutputOf<B[Extract<index, keyof B>]["mapper"]>)> : never) : A[index] extends ColumnMap ? (B[Extract<index, keyof B>] extends ColumnMap ? ColumnMapUtil.Compound<A[index], B[Extract<index, keyof B>]> : never) : A[index] extends ColumnRef ? (B[Extract<index, keyof B>] extends ColumnRef ? ColumnRefUtil.Compound<A[index], B[Extract<index, keyof B>]> : never) : never);
    };
    export type LeftCompound<A extends SelectClause, B extends SelectClause> = Extract<LeftCompoundImpl<A, B>, SelectItem[]>;
    /**
     * Assumes `A` is shorter than, or the same length as `B`
     */
    export function leftCompound<A extends SelectClause, B extends SelectClause>(a: A, b: B): (LeftCompound<A, B>);
}
declare module "select-clause/select-value-delegate" {
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/select-clause";
    import * as SelectClauseUtil from "select-clause/util/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { SelectDelegateColumns } from "select-clause/select-delegate";
    import { Identity } from "type-util/index";
    export type SelectValueDelegateReturnType<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined, BuiltInExprT extends AnyBuiltInExpr> = Identity<BuiltInExprT & SelectClauseUtil.AssertValidUsedRef<FromClauseT, SelectClauseUtil.ValueFromBuiltInExpr<BuiltInExprT>> & SelectClauseUtil.AssertValidColumnIdentifier<SelectClauseT, SelectClauseUtil.ValueFromBuiltInExpr<BuiltInExprT>>>;
    export type SelectValueDelegate<FromClauseT extends IFromClause, SelectClauseT extends SelectClause | undefined, BuiltInExprT extends AnyBuiltInExpr> = (columns: SelectDelegateColumns<FromClauseT>) => SelectValueDelegateReturnType<FromClauseT, SelectClauseT, BuiltInExprT>;
}
declare module "select-clause/util/query/allowed-non-aggregate-used-ref" {
    import { IFromClause } from "from-clause/index";
    import { GroupByClause } from "group-by-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IJoin } from "join/index";
    import { Merge } from "type-util/index";
    export type AllowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = Merge<ColumnRefUtil.FromJoinArray<FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"] : []> & ColumnRefUtil.ExtractColumnIdentifier<ColumnRefUtil.FromJoinArray<FromClauseT["currentJoins"] extends readonly IJoin[] ? FromClauseT["currentJoins"] : []>, GroupByClauseT[number]>>;
    export type AllowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause> = UsedRefUtil.FromColumnRef<AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT>>;
    export function allowedNonAggregateColumnRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT): (AllowedNonAggregateColumnRef<FromClauseT, GroupByClauseT>);
    export function allowedNonAggregateUsedRef<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT): (AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>);
}
declare module "select-clause/util/query/allowed-used-ref" {
    import { IFromClause, FromClauseUtil } from "from-clause/index";
    export type AllowedColumnRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedColumnRef<FromClauseT, {
        isLateral: true;
    }>);
    export type AllowedUsedRef<FromClauseT extends IFromClause> = (FromClauseUtil.AllowedUsedRef<FromClauseT, {
        isLateral: true;
    }>);
    export function allowedColumnRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedColumnRef<FromClauseT>);
    export function allowedUsedRef<FromClauseT extends IFromClause>(fromClause: FromClauseT): (AllowedUsedRef<FromClauseT>);
}
declare module "select-clause/util/query/column-alias" {
    import { SelectClause } from "select-clause/select-clause";
    import { SelectItemUtil, SelectItem } from "select-item/index";
    export type ColumnAlias<SelectClauseT extends SelectClause> = {
        [index in Extract<keyof SelectClauseT, string>]: (SelectClauseT[index] extends SelectItem ? SelectItemUtil.ColumnAlias<SelectClauseT[index]> : never);
    }[Extract<keyof SelectClauseT, string>];
}
declare module "select-clause/util/query/column-alias-ignore-index" {
    import { SelectClause } from "select-clause/select-clause";
    import { SelectItemUtil, SelectItem } from "select-item/index";
    export type ColumnAliasIgnoreIndex<SelectClauseT extends SelectClause, IgnoreT extends keyof SelectClauseT> = {
        [index in Extract<keyof SelectClauseT, string>]: (index extends IgnoreT ? never : SelectClauseT[index] extends SelectItem ? SelectItemUtil.ColumnAlias<SelectClauseT[index]> : never);
    }[Extract<keyof SelectClauseT, string>];
}
declare module "select-clause/util/query/duplicate-column-alias" {
    import { SelectClause } from "select-clause/select-clause";
    import { SelectItemUtil, SelectItem } from "select-item/index";
    import { ColumnRef, ColumnRefUtil } from "column-ref/index";
    import { ColumnAliasIgnoreIndex } from "select-clause/util/query/column-alias-ignore-index";
    export type DuplicateColumnAlias<SelectClauseT extends SelectClause> = {
        [index in Extract<keyof SelectClauseT, string>]: (SelectClauseT[index] extends SelectItem ? (Extract<SelectItemUtil.ColumnAlias<SelectClauseT[index]>, ColumnAliasIgnoreIndex<SelectClauseT, index>>
        /**
         * This is needed because the `ColumnRef` may have
         * duplicate `columnAlias` within itself
         */
         | (SelectClauseT[index] extends ColumnRef ? ColumnRefUtil.DuplicateColumnAlias<SelectClauseT[index]> : never)) : never);
    }[Extract<keyof SelectClauseT, string>];
    export function duplicateColumnAlias<SelectClauseT extends SelectClause>(selectClause: SelectClause): (DuplicateColumnAlias<SelectClauseT>[]);
}
declare module "select-clause/util/query/index" {
    export * from "select-clause/util/query/allowed-non-aggregate-used-ref";
    export * from "select-clause/util/query/allowed-used-ref";
    export * from "select-clause/util/query/column-alias";
    export * from "select-clause/util/query/duplicate-column-alias";
}
declare module "select-clause/util/predicate/assert-valid-column-identifier" {
    import { SelectItem } from "select-item/index";
    import { ToUnknownIfAllPropertiesNever } from "type-util/index";
    import { SelectClause } from "select-clause/select-clause";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { CompileError } from "compile-error/index";
    type AssertDisjointColumnIdentifier<SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause> = SelectClauseT extends SelectClause ? (Extract<ColumnIdentifierUtil.FromSelectItem<SelectsT[number]>, ColumnIdentifierUtil.FromSelectItem<SelectClauseT[number]>> extends never ? unknown : CompileError<["Identifiers already used in SELECT clause; consider aliasing", ColumnIdentifierUtil.ToErrorMessageFriendlyType<Extract<ColumnIdentifierUtil.FromSelectItem<SelectsT[number]>, ColumnIdentifierUtil.FromSelectItem<SelectClauseT[number]>>>]>) : unknown;
    type ExtractSelectItemNotAtIndex<SelectsT extends SelectClause, IndexT extends keyof SelectsT> = {
        [index in Extract<keyof SelectsT, string>]: (index extends IndexT ? never : SelectsT[index] extends SelectItem ? SelectsT[index] : never);
    }[Extract<keyof SelectsT, string>];
    /**
     * + Assumes `SelectsT` is a non-empty tuple
     */
    type AssertNoDuplicateColumnIdentifier<SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends SelectItem ? (Extract<ColumnIdentifierUtil.FromSelectItem<SelectsT[index]>, ColumnIdentifierUtil.FromSelectItem<ExtractSelectItemNotAtIndex<SelectsT, index>>> extends never ? never : CompileError<["Duplicate identifiers in SELECT clause not allowed; consider aliasing", ColumnIdentifierUtil.ToErrorMessageFriendlyType<Extract<ColumnIdentifierUtil.FromSelectItem<SelectsT[index]>, ColumnIdentifierUtil.FromSelectItem<ExtractSelectItemNotAtIndex<SelectsT, index>>>>]>) : never);
    }>;
    export type AssertValidColumnIdentifier<SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause> = 
    /**
     * @todo Assert that `IExprSelectItem` do not shadow/hide
     * column identifiers from `FROM` clause?
     *
     * Not a priority at the moment because I'm assuming no one
     * would reasonably have a `tableAlias` with a value of `typeof ALIASED`.
     *
     * If such a thing were to happen, we'd have to also check that
     * `FROM/JOIN`s do not shadow `IExprSelectItem` identifiers in the
     * `SELECT` clause.
     *
     * Or disallow `FROM/JOIN` after a `SELECT` with an `IExprSelectItem`.
     *
     * This would make life a pain.
     */
    AssertDisjointColumnIdentifier<SelectClauseT, SelectsT> & AssertNoDuplicateColumnIdentifier<SelectsT>;
    export function assertValidColumnIdentifier(selectClause: SelectClause | undefined, selects: SelectClause): void;
}
declare module "select-clause/util/predicate/assert-valid-used-ref-aggregate" {
    import { SelectClause } from "select-clause/select-clause";
    import { IFromClause } from "from-clause/index";
    import { ToUnknownIfAllPropertiesNever, ToNeverIfUnknown, AssertNonUnion } from "type-util/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { UsedRefUtil } from "used-ref/index";
    import { AllowedUsedRef } from "select-clause/util/query/index";
    type AssertValidExprSelectItemUsedRef_Aggregate<FromClauseT extends IFromClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends IExprSelectItem ? (SelectsT[index]["isAggregate"] extends true ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT>, SelectsT[index]["usedRef"]>> : never) : never);
    }>;
    export type AssertValidUsedRef_Aggregate<FromClauseT extends IFromClause, SelectsT extends SelectClause> = AssertValidExprSelectItemUsedRef_Aggregate<FromClauseT, SelectsT>;
    export function assertValidUsedRef_Aggregate(fromClause: IFromClause, selects: SelectClause): void;
}
declare module "select-clause/util/predicate/assert-valid-used-ref-non-aggregate" {
    import { SelectClause } from "select-clause/select-clause";
    import { IFromClause } from "from-clause/index";
    import { ColumnRef } from "column-ref/index";
    import { ToUnknownIfAllPropertiesNever, ToNeverIfUnknown, AssertNonUnion } from "type-util/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IColumn } from "column/index";
    import { ColumnMap } from "column-map/index";
    import { AllowedNonAggregateUsedRef } from "select-clause/util/query/index";
    import { GroupByClause } from "group-by-clause/index";
    type AssertValidExprSelectItemUsedRef_NonAggregate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends IExprSelectItem ? (false extends SelectsT[index]["isAggregate"] ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowedCustom<"The following columns cannot be referenced in non-aggregate expressions; they are not in the GROUP BY clause", AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>, SelectsT[index]["usedRef"]>> : never) : never);
    }>;
    type AssertValidColumnUsedRef_NonAggregate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends IColumn ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowedCustom<"The following columns cannot be referenced in non-aggregate expressions; they are not in the GROUP BY clause", AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>, UsedRefUtil.FromColumn<SelectsT[index]>>> : never);
    }>;
    type AssertValidColumnMapUsedRef_NonAggregate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends ColumnMap ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowedCustom<"The following columns cannot be referenced in non-aggregate expressions; they are not in the GROUP BY clause", AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>, UsedRefUtil.FromColumnMap<SelectsT[index]>>> : never);
    }>;
    type AssertValidColumnRefUsedRef_NonAggregate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends ColumnRef ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowedCustom<"The following columns cannot be referenced in non-aggregate expressions; they are not in the GROUP BY clause", AllowedNonAggregateUsedRef<FromClauseT, GroupByClauseT>, UsedRefUtil.FromColumnRef<SelectsT[index]>>> : never);
    }>;
    export type AssertValidUsedRef_NonAggregate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause, SelectsT extends SelectClause> = AssertValidExprSelectItemUsedRef_NonAggregate<FromClauseT, GroupByClauseT, SelectsT> & AssertValidColumnUsedRef_NonAggregate<FromClauseT, GroupByClauseT, SelectsT> & AssertValidColumnMapUsedRef_NonAggregate<FromClauseT, GroupByClauseT, SelectsT> & AssertValidColumnRefUsedRef_NonAggregate<FromClauseT, GroupByClauseT, SelectsT>;
    export function assertValidUsedRef_NonAggregate(fromClause: IFromClause, groupByClause: GroupByClause, selects: SelectClause): void;
}
declare module "select-clause/util/predicate/assert-valid-used-ref" {
    import { SelectClause } from "select-clause/select-clause";
    import { IFromClause } from "from-clause/index";
    import { ColumnRef } from "column-ref/index";
    import { ToUnknownIfAllPropertiesNever, ToNeverIfUnknown, AssertNonUnion } from "type-util/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { UsedRefUtil } from "used-ref/index";
    import { IColumn } from "column/index";
    import { ColumnMap } from "column-map/index";
    import { AllowedUsedRef } from "select-clause/util/query/index";
    type AssertValidExprSelectItemUsedRef<FromClauseT extends IFromClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends IExprSelectItem ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT>, SelectsT[index]["usedRef"]>> : never);
    }>;
    type AssertValidColumnUsedRef<FromClauseT extends IFromClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends IColumn ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT>, UsedRefUtil.FromColumn<SelectsT[index]>>> : never);
    }>;
    type AssertValidColumnMapUsedRef<FromClauseT extends IFromClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends ColumnMap ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT>, UsedRefUtil.FromColumnMap<SelectsT[index]>>> : never);
    }>;
    type AssertValidColumnRefUsedRef<FromClauseT extends IFromClause, SelectsT extends SelectClause> = ToUnknownIfAllPropertiesNever<{
        [index in Extract<keyof SelectsT, string>]: (SelectsT[index] extends ColumnRef ? ToNeverIfUnknown<AssertNonUnion<SelectsT[index]> & UsedRefUtil.AssertAllowed<AllowedUsedRef<FromClauseT>, UsedRefUtil.FromColumnRef<SelectsT[index]>>> : never);
    }>;
    export type AssertValidUsedRef<FromClauseT extends IFromClause, SelectsT extends SelectClause> = AssertValidExprSelectItemUsedRef<FromClauseT, SelectsT> & AssertValidColumnUsedRef<FromClauseT, SelectsT> & AssertValidColumnMapUsedRef<FromClauseT, SelectsT> & AssertValidColumnRefUsedRef<FromClauseT, SelectsT>;
    export function assertValidUsedRef(fromClause: IFromClause, selects: SelectClause): void;
}
declare module "select-clause/util/predicate/index" {
    export * from "select-clause/util/predicate/assert-valid-column-identifier";
    export * from "select-clause/util/predicate/assert-valid-used-ref-aggregate";
    export * from "select-clause/util/predicate/assert-valid-used-ref-non-aggregate";
    export * from "select-clause/util/predicate/assert-valid-used-ref";
}
declare module "select-clause/util/operation/select" {
    import { IFromClause } from "from-clause/index";
    import { SelectDelegate } from "select-clause/select-delegate";
    import { SelectClause } from "select-clause/select-clause";
    import { Concat } from "tuple-util/index";
    import { IExprSelectItem } from "expr-select-item/index";
    import { IUsedRef } from "used-ref/index";
    import { GroupByClause } from "group-by-clause/index";
    /**
     * This reduces the lines of code emitted for the resulting
     * `SELECT` clause.
     *
     * Yes, emit times are a concern.
     */
    type EraseUsedRef<SelectsT extends SelectClause> = {
        [index in keyof SelectsT]: (SelectsT[index] extends IExprSelectItem ? IExprSelectItem<{
            mapper: SelectsT[index]["mapper"];
            tableAlias: SelectsT[index]["tableAlias"];
            alias: SelectsT[index]["alias"];
            usedRef: IUsedRef;
            isAggregate: SelectsT[index]["isAggregate"];
        }> : SelectsT[index]);
    };
    export type Select<SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause> = SelectClauseT extends SelectClause ? Concat<SelectClauseT, EraseUsedRef<SelectsT>> : EraseUsedRef<SelectsT>;
    /**
     * Returns the MySQL equivalent of `...selectClause, ...selectClauseDelegate(fromClause)`
     *
     * @param fromClause
     * @param selectClause
     * @param selectDelegate
     *
     * @todo This should only be allowed **BEFORE** the `COMPOUND QUERY` clause.
     * If we `SELECT` after the `COMPOUND QUERY` clause, it'll change the number of columns, leading to bugs.
     */
    export function select<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause>(fromClause: FromClauseT, groupByClause: GroupByClauseT, selectClause: SelectClauseT, selectDelegate: SelectDelegate<FromClauseT, GroupByClauseT, SelectClauseT, SelectsT>): (Select<SelectClauseT, SelectsT>);
}
declare module "select-clause/util/operation/select-value" {
    import { IFromClause } from "from-clause/index";
    import { SelectClause } from "select-clause/select-clause";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { SelectValueDelegate } from "select-clause/select-value-delegate";
    import { Select } from "select-clause/util/operation/select";
    import { ValueFromBuiltInExpr } from "select-clause/util/constructor/index";
    import { GroupByClause } from "group-by-clause/index";
    export type SelectValue<SelectClauseT extends SelectClause | undefined, BuiltInExprT extends AnyBuiltInExpr> = Select<SelectClauseT, ValueFromBuiltInExpr<BuiltInExprT>>;
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .select(() => [myExpr.as("value")])
     * ```
     *
     * Intended usage,
     * ```ts
     *  myQuery
     *      .selectValue(() => myExpr)
     * ```
     */
    export function selectValue<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined, BuiltInExprT extends AnyBuiltInExpr>(fromClause: FromClauseT, groupByClause: GroupByClauseT, selectClause: SelectClauseT, selectValueDelegate: SelectValueDelegate<FromClauseT, SelectClauseT, BuiltInExprT>): (SelectValue<SelectClauseT, BuiltInExprT>);
}
declare module "select-clause/util/operation/index" {
    export * from "select-clause/util/operation/left-compound";
    export * from "select-clause/util/operation/select-value";
    export * from "select-clause/util/operation/select";
}
declare module "select-clause/util/index" {
    export * from "select-clause/util/constructor/index";
    export * from "select-clause/util/operation/index";
    export * from "select-clause/util/predicate/index";
    export * from "select-clause/util/query/index";
}
declare module "select-clause/select-delegate" {
    import { IFromClause } from "from-clause/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { AssertNonUnion, Identity } from "type-util/index";
    import { SelectClause } from "select-clause/select-clause";
    import * as SelectClauseUtil from "select-clause/util/index";
    import { GroupByClause } from "group-by-clause/index";
    import { IExprSelectItem } from "expr-select-item/index";
    export type SelectDelegateColumns<FromClauseT extends IFromClause> = ColumnRefUtil.TryFlatten<SelectClauseUtil.AllowedColumnRef<FromClauseT>>;
    export type SelectDelegateReturnType<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause> = Identity<SelectsT
    /**
     * Hack to force TS to infer a non-empty tuple type, rather than array type.
     *
     * ```ts
     *  declare function foo<T extends any[]> (t : T) : T;
     *  declare function foo2<T extends any[]> (t : T & { "0":unknown }) : T;
     *  //const x: number[]
     *  const x = foo([1,2,3]);
     *  //const x2: [number, number, number]
     *  const x2 = foo2([1,2,3]);
     * ```
     */
     & {
        "0": unknown;
    } & AssertNonUnion<SelectsT> & SelectClauseUtil.AssertValidColumnIdentifier<SelectClauseT, SelectsT> & (GroupByClauseT extends GroupByClause ? (SelectClauseUtil.AssertValidUsedRef_Aggregate<FromClauseT, SelectsT> & SelectClauseUtil.AssertValidUsedRef_NonAggregate<FromClauseT, GroupByClauseT, SelectsT>) : (true extends Extract<SelectsT[number] | Extract<SelectClauseT, SelectClause>[number], IExprSelectItem>["isAggregate"] ? (SelectClauseUtil.AssertValidUsedRef_Aggregate<FromClauseT, SelectsT> & SelectClauseUtil.AssertValidUsedRef_NonAggregate<FromClauseT, [], SelectsT>) : SelectClauseUtil.AssertValidUsedRef<FromClauseT, SelectsT>))>;
    export type SelectDelegate<FromClauseT extends IFromClause, GroupByClauseT extends GroupByClause | undefined, SelectClauseT extends SelectClause | undefined, SelectsT extends SelectClause> = (columns: SelectDelegateColumns<FromClauseT>) => SelectDelegateReturnType<FromClauseT, GroupByClauseT, SelectClauseT, SelectsT>;
}
declare module "select-clause/index" {
    export * from "select-clause/select-clause";
    export * from "select-clause/select-delegate";
    export * from "select-clause/select-value-delegate";
    import * as SelectClauseUtil from "select-clause/util/index";
    export { SelectClauseUtil, };
}
declare module "column-identifier/util/constructor/from-select-item" {
    import { SelectItem } from "select-item/index";
    import { IColumn } from "column/column";
    import { IExprSelectItem } from "expr-select-item/index";
    import { FromExprSelectItem } from "column-identifier/util/constructor/from-expr-select-item";
    import { FromColumn } from "column-identifier/util/constructor/from-column";
    import { ColumnRef } from "column-ref/index";
    import { FromColumnRef } from "column-identifier/util/constructor/from-column-ref";
    import { ColumnMap } from "column-map/index";
    import { FromColumnMap } from "column-identifier/util/constructor/from-column-map";
    /**
     * + Assumes `SelectItemT` may be union
     */
    export type FromSelectItem<SelectItemT extends SelectItem> = (
    /**
     * Ordered from most likely to least likely
     */
    SelectItemT extends IExprSelectItem ? FromExprSelectItem<SelectItemT> : SelectItemT extends ColumnMap ? FromColumnMap<SelectItemT> : SelectItemT extends ColumnRef ? FromColumnRef<SelectItemT> : SelectItemT extends IColumn ? FromColumn<SelectItemT> : never);
    export function fromSelectItem<SelectItemT extends SelectItem>(selectItem: SelectItemT): (FromSelectItem<SelectItemT>[]);
}
declare module "column-identifier/util/constructor/from-select-clause" {
    import { SelectClause } from "select-clause/index";
    import { FromSelectItem } from "column-identifier/util/constructor/from-select-item";
    /**
     * For output positions
     */
    export type FromSelectClause<SelectClauseT extends SelectClause> = (SelectClauseT extends SelectClause ? FromSelectItem<SelectClauseT[number]> : never);
    /**
     * Does not remove duplicate identifiers
     *
     * @param selectClause
     */
    export function fromSelectClause<SelectClauseT extends SelectClause>(selectClause: SelectClauseT): (FromSelectClause<SelectClauseT>[]);
}
declare module "column-identifier/util/constructor/index" {
    export * from "column-identifier/util/constructor/from-column-identifier-map";
    export * from "column-identifier/util/constructor/from-column-map";
    export * from "column-identifier/util/constructor/from-column-ref";
    export * from "column-identifier/util/constructor/from-column";
    export * from "column-identifier/util/constructor/from-expr-select-item";
    export * from "column-identifier/util/constructor/from-select-clause";
    export * from "column-identifier/util/constructor/from-select-item";
}
declare module "column-identifier/util/operation/to-error-message-friendly-type" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    /**
     * Used to generate nicer looking error messages
     */
    export type ToErrorMessageFriendlyType<ColumnIdentifierT extends ColumnIdentifier> = (ColumnIdentifierT extends ColumnIdentifier ? ([ColumnIdentifierT["tableAlias"], ColumnIdentifierT["columnAlias"]]) : never);
}
declare module "column-identifier/util/operation/index" {
    export * from "column-identifier/util/operation/to-error-message-friendly-type";
}
declare module "column-identifier/util/predicate/is-column-identifier" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export function isColumnIdentifier(raw: unknown): raw is ColumnIdentifier;
}
declare module "column-identifier/util/predicate/is-equal" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type IsEqual<A extends ColumnIdentifier, B extends ColumnIdentifier> = (A extends ColumnIdentifier ? (B extends ColumnIdentifier ? (string extends A["tableAlias"] ? boolean : string extends B["tableAlias"] ? boolean : A["tableAlias"] extends B["tableAlias"] ? (string extends A["columnAlias"] ? boolean : string extends B["columnAlias"] ? boolean : A["columnAlias"] extends B["columnAlias"] ? true : false) : false) : never) : never);
    export function isEqual<A extends ColumnIdentifier, B extends ColumnIdentifier>(a: A, b: B): IsEqual<A, B>;
    export function assertIsEqual(a: ColumnIdentifier, b: ColumnIdentifier): void;
}
declare module "column-identifier/util/predicate/index" {
    export * from "column-identifier/util/predicate/is-column-identifier";
    export * from "column-identifier/util/predicate/is-equal";
}
declare module "column-identifier/util/query/extract-with-column-alias" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type ExtractWithColumnAlias<ColumnIdentifierT extends ColumnIdentifier, ColumnAliasT extends string> = (ColumnIdentifierT extends ColumnIdentifier ? (ColumnIdentifierT["columnAlias"] extends ColumnAliasT ? ColumnIdentifierT : never) : never);
}
declare module "column-identifier/util/query/extract-with-table-alias" {
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type ExtractWithTableAlias<ColumnIdentifierT extends ColumnIdentifier, TableAliasT extends string> = (ColumnIdentifierT extends ColumnIdentifier ? (ColumnIdentifierT["tableAlias"] extends TableAliasT ? ColumnIdentifierT : never) : never);
}
declare module "column-identifier/util/query/index" {
    export * from "column-identifier/util/query/extract-with-column-alias";
    export * from "column-identifier/util/query/extract-with-table-alias";
}
declare module "column-identifier/util/index" {
    export * from "column-identifier/util/constructor/index";
    export * from "column-identifier/util/operation/index";
    export * from "column-identifier/util/predicate/index";
    export * from "column-identifier/util/query/index";
}
declare module "column-identifier/array-util/constructor/from-column-map" {
    import * as ColumnIdentifierUtil from "column-identifier/util/index";
    import { ColumnIdentifierMap } from "column-identifier-map/index";
    export type FromColumnMap<ColumnMapT extends ColumnIdentifierMap> = (ColumnMapT extends ColumnIdentifierMap ? ColumnIdentifierUtil.FromColumnMap<ColumnMapT>[] : never);
    export function fromColumnMap<ColumnMapT extends ColumnIdentifierMap>(columnMap: ColumnMapT): FromColumnMap<ColumnMapT>;
}
declare module "column-identifier/array-util/constructor/from-column-ref" {
    import * as ColumnIdentifierUtil from "column-identifier/util/index";
    import { ColumnIdentifierRef } from "column-identifier-ref/index";
    export type FromColumnRef<ColumnRefT extends ColumnIdentifierRef> = (ColumnIdentifierUtil.FromColumnRef<ColumnRefT>[]);
    export function fromColumnRef<ColumnRefT extends ColumnIdentifierRef>(columnRef: ColumnRefT): FromColumnRef<ColumnRefT>;
}
declare module "column-identifier/array-util/constructor/index" {
    export * from "column-identifier/array-util/constructor/from-column-map";
    export * from "column-identifier/array-util/constructor/from-column-ref";
}
declare module "column-identifier/array-util/predicate/assert-disjoint" {
    import { ColumnIdentifier } from "column-identifier/index";
    export function assertDisjoint(arrA: readonly ColumnIdentifier[], arrB: readonly ColumnIdentifier[]): void;
}
declare module "column-identifier/array-util/predicate/assert-no-duplicate" {
    import { ColumnIdentifier } from "column-identifier/index";
    export function assertNoDuplicate(arr: readonly ColumnIdentifier[]): void;
}
declare module "column-identifier/array-util/predicate/index" {
    export * from "column-identifier/array-util/predicate/assert-disjoint";
    export * from "column-identifier/array-util/predicate/assert-no-duplicate";
}
declare module "column-identifier/array-util/index" {
    export * from "column-identifier/array-util/constructor/index";
    export * from "column-identifier/array-util/predicate/index";
}
declare module "column-identifier/index" {
    export * from "column-identifier/column-identifier";
    import * as ColumnIdentifierArrayUtil from "column-identifier/array-util/index";
    import * as ColumnIdentifierUtil from "column-identifier/util/index";
    export { ColumnIdentifierArrayUtil, ColumnIdentifierUtil, };
}
declare module "column-identifier-map/column-identifier-map" {
    import { ColumnIdentifier } from "column-identifier/index";
    export interface ColumnIdentifierMap {
        readonly [columnAlias: string]: ColumnIdentifier;
    }
    export interface WritableColumnIdentifierMap {
        [columnAlias: string]: ColumnIdentifier;
    }
}
declare module "column-identifier-map/util/constructor/from-column-map" {
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { ColumnMap } from "column-map/index";
    export type FromColumnMap<ColumnMapT extends ColumnMap> = ({
        readonly [columnAlias in Extract<keyof ColumnMapT, string>]: (ColumnIdentifierUtil.FromColumn<ColumnMapT[columnAlias]>);
    });
    export function fromColumnMap<ColumnMapT extends ColumnMap>(columnMap: ColumnMapT): FromColumnMap<ColumnMapT>;
}
declare module "column-identifier-map/util/constructor/from-column-union" {
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type FromColumnUnion<ColumnT extends ColumnIdentifier> = ({
        readonly [columnAlias in ColumnT["columnAlias"]]: (ColumnIdentifierUtil.FromColumn<ColumnIdentifierUtil.ExtractWithColumnAlias<ColumnT, columnAlias>>);
    });
}
declare module "column-identifier-map/util/constructor/from-column" {
    import { ColumnIdentifier, ColumnIdentifierUtil } from "column-identifier/index";
    import { IColumn } from "column/index";
    export type FromColumn<ColumnT extends ColumnIdentifier> = (ColumnT extends IColumn ? {
        readonly [columnAlias in ColumnT["columnAlias"]]: (ColumnIdentifierUtil.FromColumn<ColumnT>);
    } : never);
}
declare module "column-identifier-map/util/constructor/index" {
    export * from "column-identifier-map/util/constructor/from-column-map";
    export * from "column-identifier-map/util/constructor/from-column-union";
    export * from "column-identifier-map/util/constructor/from-column";
}
declare module "column-identifier-map/util/operation/intersect" {
    import { ColumnIdentifierMap } from "column-identifier-map/column-identifier-map";
    export type Intersect<MapA extends ColumnIdentifierMap, MapB extends ColumnIdentifierMap> = (MapA & {
        readonly [columnAlias in Exclude<Extract<keyof MapB, string>, keyof MapA>]: (MapB[columnAlias]);
    });
    export function intersect<MapA extends ColumnIdentifierMap, MapB extends ColumnIdentifierMap>(mapA: MapA, mapB: MapB): (Intersect<MapA, MapB>);
}
declare module "column-identifier-map/util/operation/index" {
    export * from "column-identifier-map/util/operation/intersect";
}
declare module "column-identifier-map/util/predicate/has-column-identifier" {
    import { ColumnIdentifierMap } from "column-identifier-map/column-identifier-map";
    import { ColumnIdentifier, ColumnIdentifierUtil } from "column-identifier/index";
    export type HasColumnIdentifier<ColumnMapT extends ColumnIdentifierMap, ColumnIdentifierT extends ColumnIdentifier> = (keyof ColumnMapT extends never ? false : ColumnMapT extends ColumnIdentifierMap ? (ColumnIdentifierT extends ColumnIdentifier ? (string extends keyof ColumnMapT ? boolean : ColumnIdentifier extends ColumnIdentifierT ? boolean : string extends ColumnIdentifierT["columnAlias"] ? (string extends ColumnIdentifierT["tableAlias"] ? boolean : ColumnIdentifierT["tableAlias"] extends ColumnIdentifierUtil.FromColumnIdentifierMap<ColumnMapT>["tableAlias"] ? boolean : false) : ColumnIdentifierT["columnAlias"] extends keyof ColumnMapT ? (string extends ColumnIdentifierT["tableAlias"] ? boolean : ColumnIdentifierT["tableAlias"] extends ColumnMapT[ColumnIdentifierT["columnAlias"]]["tableAlias"] ? (ColumnIdentifierT["columnAlias"] extends ColumnMapT[ColumnIdentifierT["columnAlias"]]["columnAlias"] ? true : false) : false) : false) : never) : never);
    export function hasColumnIdentifier<MapT extends ColumnIdentifierMap, IdentifierT extends ColumnIdentifier>(map: MapT, identifier: IdentifierT): (HasColumnIdentifier<MapT, IdentifierT>);
    export function assertHasColumnIdentifier(map: ColumnIdentifierMap, identifier: ColumnIdentifier): void;
    export function assertHasColumnIdentifiers(map: ColumnIdentifierMap, identifiers: readonly ColumnIdentifier[]): void;
}
declare module "column-identifier-map/util/predicate/index" {
    export * from "column-identifier-map/util/predicate/has-column-identifier";
}
declare module "column-identifier-map/util/query/column-alias" {
    import { ColumnIdentifierMap } from "column-identifier-map/column-identifier-map";
    export type ColumnAlias<MapT extends ColumnIdentifierMap> = (MapT extends ColumnIdentifierMap ? Extract<keyof MapT, string> : never);
}
declare module "column-identifier-map/util/query/extract-column-identifier" {
    import { ColumnIdentifierMap } from "column-identifier-map/column-identifier-map";
    import { ColumnIdentifier } from "column-identifier/index";
    import { Identity } from "type-util/index";
    /**
     * Does not check `tableAlias`
     */
    export type ExtractColumnIdentifier_ColumnAlias<MapT extends ColumnIdentifierMap, ColumnIdentifierT extends ColumnIdentifier> = {
        [columnAlias in Extract<keyof MapT, string>]: (columnAlias extends ColumnIdentifierT["columnAlias"] ? columnAlias : never);
    }[Extract<keyof MapT, string>];
    /**
     * Does not check `tableAlias`
     */
    export type ExtractColumnIdentifier<MapT extends ColumnIdentifierMap, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        readonly [columnAlias in ExtractColumnIdentifier_ColumnAlias<MapT, ColumnIdentifierT>]: (MapT[columnAlias]);
    }>;
    /**
     * Does not check `tableAlias`
     */
    export function extractColumnIdentifiers<MapT extends ColumnIdentifierMap, ColumnIdentifierT extends ColumnIdentifier>(map: MapT, columnIdentifiers: readonly ColumnIdentifierT[]): (ExtractColumnIdentifier<MapT, ColumnIdentifierT>);
}
declare module "column-identifier-map/util/query/index" {
    export * from "column-identifier-map/util/query/column-alias";
    export * from "column-identifier-map/util/query/extract-column-identifier";
}
declare module "column-identifier-map/util/index" {
    export * from "column-identifier-map/util/constructor/index";
    export * from "column-identifier-map/util/operation/index";
    export * from "column-identifier-map/util/predicate/index";
    export * from "column-identifier-map/util/query/index";
}
declare module "column-identifier-map/index" {
    export * from "column-identifier-map/column-identifier-map";
    import * as ColumnIdentifierMapUtil from "column-identifier-map/util/index";
    export { ColumnIdentifierMapUtil, };
}
declare module "column-identifier-ref/column-identifier-ref" {
    import { ColumnIdentifierMap, WritableColumnIdentifierMap } from "column-identifier-map/index";
    export interface ColumnIdentifierRef {
        readonly [tableAlias: string]: ColumnIdentifierMap;
    }
    export interface WritableColumnIdentifierRef {
        [tableAlias: string]: WritableColumnIdentifierMap;
    }
}
declare module "column-identifier-ref/util/constructor/from-column-map-union" {
    import { ColumnMap, ColumnMapUtil } from "column-map/index";
    /**
     * Combines each `ColumnMap` of the union type into
     * one `ColumnIdentifierRef`.
     *
     * Think of it as,
     * ```ts
     *  columnMapArray.reduce(
     *      (ref, columnMap) => {
     *          combine(ref, columnMap);
     *          return ref;
     *      },
     *      {}
     *  );
     * ```
     */
    export type FromColumnMapUnion<ColumnMapT extends ColumnMap> = ({
        readonly [tableAlias in ColumnMapUtil.TableAlias<ColumnMapT>]: {
            readonly [columnAlias in ColumnMapUtil.FindWithTableAlias<ColumnMapT, tableAlias>["columnAlias"]]: ({
                readonly tableAlias: tableAlias;
                readonly columnAlias: columnAlias;
            });
        };
    });
}
declare module "column-identifier-ref/util/constructor/from-column" {
    import { IColumn } from "column/index";
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    import { WritableColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type FromColumn<ColumnT extends IColumn> = (ColumnT extends IColumn ? {
        readonly [tableAlias in ColumnT["tableAlias"]]: (ColumnIdentifierMapUtil.FromColumn<ColumnT>);
    } : never);
    export function appendColumn(ref: WritableColumnIdentifierRef, column: ColumnIdentifier): WritableColumnIdentifierRef;
}
declare module "column-identifier-ref/util/constructor/from-column-map" {
    import { ColumnMap, ColumnMapUtil } from "column-map/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { WritableColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    export type FromColumnMap<ColumnMapT extends ColumnMap> = (ColumnMapT extends ColumnMap ? {
        readonly [tableAlias in ColumnMapUtil.TableAlias<ColumnMapT>]: ({
            readonly [columnAlias in ColumnMapUtil.FindWithTableAlias<ColumnMapT, tableAlias>["columnAlias"]]: (ColumnIdentifierUtil.FromColumn<ColumnMapT[columnAlias]>);
        });
    } : never);
    export function appendColumnMap(ref: WritableColumnIdentifierRef, columnMap: ColumnMap): WritableColumnIdentifierRef;
    export function fromColumnMap<ColumnMapT extends ColumnMap>(columnMap: ColumnMapT): FromColumnMap<ColumnMapT>;
}
declare module "column-identifier-ref/util/constructor/from-join-array" {
    import { IJoin } from "join/index";
    import { WritableColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { FromColumnMapUnion } from "column-identifier-ref/util/constructor/from-column-map-union";
    export type FromJoinArray<ArrT extends readonly IJoin[]> = (ArrT[number] extends never ? {} : FromColumnMapUnion<ArrT[number]["columns"]>);
    export function appendJoin(ref: WritableColumnIdentifierRef, join: IJoin): WritableColumnIdentifierRef;
    export function appendJoinArray(ref: WritableColumnIdentifierRef, arr: readonly IJoin[]): WritableColumnIdentifierRef;
    export function fromJoinArray<ArrT extends readonly IJoin[]>(arr: ArrT): FromJoinArray<ArrT>;
}
declare module "column-identifier-ref/util/constructor/from-column-union" {
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { ColumnIdentifier } from "column-identifier/column-identifier";
    export type FromColumnUnion<ColumnT extends ColumnIdentifier> = ({
        readonly [tableAlias in ColumnT["tableAlias"]]: (ColumnIdentifierMapUtil.FromColumnUnion<ColumnIdentifierUtil.ExtractWithTableAlias<ColumnT, tableAlias>>);
    });
}
declare module "column-identifier-ref/util/constructor/from-select-clause" {
    import { SelectClause } from "select-clause/index";
    import { ColumnIdentifierUtil } from "column-identifier/index";
    import { FromColumnUnion } from "column-identifier-ref/util/constructor/from-column-union";
    export type FromSelectClause<SelectClauseT extends SelectClause> = FromColumnUnion<ColumnIdentifierUtil.FromSelectClause<SelectClauseT>>;
    export function fromSelectClause<SelectClauseT extends SelectClause>(selectClause: SelectClauseT): (FromSelectClause<SelectClauseT>);
}
declare module "column-identifier-ref/util/constructor/index" {
    export * from "column-identifier-ref/util/constructor/from-column-map-union";
    export * from "column-identifier-ref/util/constructor/from-column-map";
    export * from "column-identifier-ref/util/constructor/from-column";
    export * from "column-identifier-ref/util/constructor/from-join-array";
    export * from "column-identifier-ref/util/constructor/from-select-clause";
}
declare module "column-identifier-ref/util/operation/left-intersect" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    export type LeftIntersect<RefA extends ColumnIdentifierRef, RefB extends ColumnIdentifierRef> = ({
        readonly [tableAlias in Extract<keyof RefA, string>]: (tableAlias extends keyof RefB ? ColumnIdentifierMapUtil.Intersect<RefA[tableAlias], RefB[tableAlias]> : RefA[tableAlias]);
    });
    export function leftIntersect<RefA extends ColumnIdentifierRef, RefB extends ColumnIdentifierRef>(refA: RefA, refB: RefB): (LeftIntersect<RefA, RefB>);
}
declare module "column-identifier-ref/util/operation/intersect" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { LeftIntersect } from "column-identifier-ref/util/operation/left-intersect";
    export type Intersect<RefA extends ColumnIdentifierRef, RefB extends ColumnIdentifierRef> = Extract<LeftIntersect<RefA, RefB> & {
        readonly [tableAlias in Exclude<Extract<keyof RefB, string>, keyof RefA>]: (RefB[tableAlias]);
    }, ColumnIdentifierRef>;
    export function intersect<RefA extends ColumnIdentifierRef, RefB extends ColumnIdentifierRef>(refA: RefA, refB: RefB): Intersect<RefA, RefB>;
}
declare module "column-identifier-ref/util/query/column-alias" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    export type ColumnAlias<RefT extends ColumnIdentifierRef> = (RefT extends ColumnIdentifierRef ? ColumnIdentifierMapUtil.ColumnAlias<RefT[string]> : never);
}
declare module "column-identifier-ref/util/query/extract-column-identifier" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    import { ColumnIdentifier } from "column-identifier/index";
    import { Identity } from "type-util/index";
    export type ExtractColumnIdentifier_TableAlias<RefT extends ColumnIdentifierRef, ColumnIdentifierT extends ColumnIdentifier> = {
        [tableAlias in Extract<keyof RefT, string>]: (tableAlias extends ColumnIdentifierT["tableAlias"] ? tableAlias : never);
    }[Extract<keyof RefT, string>];
    export type ExtractColumnIdentifier<RefT extends ColumnIdentifierRef, ColumnIdentifierT extends ColumnIdentifier> = Identity<{
        readonly [tableAlias in ExtractColumnIdentifier_TableAlias<RefT, ColumnIdentifierT>]: (ColumnIdentifierMapUtil.ExtractColumnIdentifier<RefT[tableAlias], Extract<ColumnIdentifierT, {
            tableAlias: tableAlias;
        }>>);
    }>;
    export function extractColumnIdentifiers<RefT extends ColumnIdentifierRef, ColumnIdentifierT extends ColumnIdentifier>(ref: RefT, columnIdentifiers: readonly ColumnIdentifierT[]): (ExtractColumnIdentifier<RefT, ColumnIdentifierT>);
}
declare module "column-identifier-ref/util/query/index" {
    export * from "column-identifier-ref/util/query/column-alias";
    export * from "column-identifier-ref/util/query/extract-column-identifier";
}
declare module "column-identifier-ref/util/predicate/has-column-identifier" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { ColumnIdentifier } from "column-identifier/index";
    import { ColumnIdentifierMapUtil } from "column-identifier-map/index";
    import { ColumnAlias } from "column-identifier-ref/util/query/index";
    export type HasColumnIdentifier<RefT extends ColumnIdentifierRef, IdentifierT extends ColumnIdentifier> = (keyof RefT extends never ? false : RefT extends ColumnIdentifierRef ? (IdentifierT extends ColumnIdentifier ? (string extends keyof RefT ? boolean : string extends IdentifierT["tableAlias"] ? (string extends IdentifierT["columnAlias"] ? boolean : IdentifierT["columnAlias"] extends ColumnAlias<RefT> ? boolean : false) : IdentifierT["tableAlias"] extends keyof RefT ? (ColumnIdentifierMapUtil.HasColumnIdentifier<RefT[IdentifierT["tableAlias"]], IdentifierT>) : false) : never) : never);
    export function hasColumnIdentifier<RefT extends ColumnIdentifierRef, IdentifierT extends ColumnIdentifier>(ref: RefT, identifier: IdentifierT): (HasColumnIdentifier<RefT, IdentifierT>);
    export function assertHasColumnIdentifier(ref: ColumnIdentifierRef, identifier: ColumnIdentifier): void;
    export function assertHasColumnIdentifiers(ref: ColumnIdentifierRef, identifiers: readonly ColumnIdentifier[]): void;
}
declare module "column-identifier-ref/util/predicate/has-one-table" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    export type HasOneTable<RefT extends ColumnIdentifierRef> = (Extract<keyof RefT, string> extends never ? false : string extends Extract<keyof RefT, string> ? boolean : ({
        [tableAlias in Extract<keyof RefT, string>]: (Exclude<Extract<keyof RefT, string>, tableAlias>);
    }[Extract<keyof RefT, string>]) extends never ? true : false);
}
declare module "column-identifier-ref/util/predicate/index" {
    export * from "column-identifier-ref/util/predicate/has-column-identifier";
    export * from "column-identifier-ref/util/predicate/has-one-table";
}
declare module "column-identifier-ref/util/operation/try-flatten" {
    import { ColumnIdentifierRef } from "column-identifier-ref/column-identifier-ref";
    import { HasOneTable } from "column-identifier-ref/util/predicate/index";
    export type TryFlatten<RefT extends ColumnIdentifierRef> = (RefT extends ColumnIdentifierRef ? (HasOneTable<RefT> extends true ? RefT[Extract<keyof RefT, string>] : RefT) : never);
    export function tryFlatten<RefT extends ColumnIdentifierRef>(ref: RefT): (TryFlatten<RefT>);
}
declare module "column-identifier-ref/util/operation/index" {
    export * from "column-identifier-ref/util/operation/intersect";
    export * from "column-identifier-ref/util/operation/left-intersect";
    export * from "column-identifier-ref/util/operation/try-flatten";
}
declare module "column-identifier-ref/util/index" {
    export * from "column-identifier-ref/util/constructor/index";
    export * from "column-identifier-ref/util/operation/index";
    export * from "column-identifier-ref/util/predicate/index";
    export * from "column-identifier-ref/util/query/index";
}
declare module "column-identifier-ref/index" {
    export * from "column-identifier-ref/column-identifier-ref";
    import * as ColumnIdentifierRefUtil from "column-identifier-ref/util/index";
    export { ColumnIdentifierRefUtil, };
}
declare module "used-ref/used-ref" {
    import { ColumnIdentifierRef } from "column-identifier-ref/index";
    import { TypeRef } from "type-ref/index";
    /**
     * The `never` in the default type argument here is intentional.
     *
     * This will give us,
     * ```ts
     * __contravarianceMarker : (usedRef : never) => void;
     * ```
     *
     * Then, we can assign any other `__contravarianceMarker` to it,
     * ```ts
     * declare const b : (usedRef : { someTable : { someColumn : string } }) => void;
     * __contravarianceMarker = b; //OK!
     * ```
     *
     * `never` is a sub-type of every other type.
     */
    export interface IUsedRef<RefT extends TypeRef = never> {
        /**
         * A no-op function during run-time.
         * Is used for contravariant assignability.
         */
        readonly __contravarianceMarker: (usedRef: RefT) => void;
        /**
         * Contains the actual columns used.
         *
         * Will mirror the type of `TypeRefT` during run-time.
         * It will remain `ColumnIdentifierRef` during compile-time.
         */
        readonly columns: ColumnIdentifierRef;
    }
}
declare module "used-ref/util/constructor/from-column-map" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefUtil } from "type-ref/index";
    import { ColumnMap } from "column-map/index";
    /**
     * Can handle union types
     */
    export type FromColumnMap<MapT extends ColumnMap> = (IUsedRef<TypeRefUtil.FromColumnMap<MapT>>);
    export function fromColumnMap<MapT extends ColumnMap>(map: MapT): (FromColumnMap<MapT>);
}
declare module "used-ref/util/constructor/from-column-ref" {
    import { ColumnRef } from "column-ref/index";
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefUtil } from "type-ref/index";
    export type FromColumnRef<RefT extends ColumnRef> = (IUsedRef<TypeRefUtil.WritableFromColumnRef<RefT>>);
    export function fromColumnRef<RefT extends ColumnRef>(ref: RefT): (FromColumnRef<RefT>);
}
declare module "used-ref/util/constructor/from-column" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefUtil } from "type-ref/index";
    import { IColumn } from "column/index";
    export type FromColumn<ColumnT extends Pick<IColumn, "tableAlias" | "columnAlias" | "mapper">> = (IUsedRef<TypeRefUtil.FromColumn<ColumnT>>);
    export function fromColumn<ColumnT extends Pick<IColumn, "tableAlias" | "columnAlias" | "mapper">>(column: ColumnT): (FromColumn<ColumnT>);
}
declare module "used-ref/util/constructor/from-join" {
    import * as tm from "type-mapping";
    import { IJoin, JoinUtil } from "join/index";
    import { IUsedRef } from "used-ref/used-ref";
    /**
     * Assumes every `IJoin` has a distinct `tableAlias`.
     */
    export type FromJoin<JoinT extends IJoin> = (IUsedRef<{
        [tableAlias in JoinT["tableAlias"]]: ({
            [columnAlias in (Extract<keyof JoinUtil.ExtractWithTableAlias<JoinT, tableAlias>["columns"], string>)]: (tm.OutputOf<JoinUtil.ExtractWithTableAlias<JoinT, tableAlias>["columns"][columnAlias]["mapper"]> | (true extends JoinUtil.ExtractWithTableAlias<JoinT, tableAlias>["nullable"] ? null : never));
        });
    }>);
}
declare module "used-ref/util/constructor/from-join-array" {
    import { IJoin } from "join/index";
    import { FromJoin } from "used-ref/util/constructor/from-join";
    export type FromJoinArray<JoinsT extends readonly IJoin[]> = (FromJoin<JoinsT[number]>);
    export function fromJoinArray<JoinsT extends readonly IJoin[]>(joins: JoinsT): (FromJoinArray<JoinsT>);
}
declare module "used-ref/util/constructor/from-from-clause" {
    import { IFromClause } from "from-clause/index";
    import { IJoin } from "join/index";
    import { FromJoinArray } from "used-ref/util/constructor/from-join-array";
    export type FromFromClause<FromClauseT extends Pick<IFromClause, "outerQueryJoins">> = (FromJoinArray<(FromClauseT["outerQueryJoins"] extends readonly IJoin[] ? FromClauseT["outerQueryJoins"] : never)>);
    export function fromFromClause<FromClauseT extends Pick<IFromClause, "outerQueryJoins">>(fromClause: FromClauseT): (FromFromClause<FromClauseT>);
}
declare module "used-ref/util/constructor/index" {
    export * from "used-ref/util/constructor/from-column-map";
    export * from "used-ref/util/constructor/from-column-ref";
    export * from "used-ref/util/constructor/from-column";
    export * from "used-ref/util/constructor/from-from-clause";
    export * from "used-ref/util/constructor/from-join-array";
    export * from "used-ref/util/constructor/from-join";
}
declare module "used-ref/util/query/extract-column-identifier" {
    import { IUsedRef } from "used-ref/used-ref";
    import { ColumnIdentifier } from "column-identifier/index";
    import { ColumnRefUtil } from "column-ref/index";
    export type ExtractColumnIdentifier<UsedRefT extends IUsedRef, ColumnIdentifierT extends ColumnIdentifier> = UsedRefT extends IUsedRef<infer RefT> ? IUsedRef<ColumnRefUtil.ExtractColumnIdentifier_Mutable<RefT, ColumnIdentifierT>> : never;
    export function extractColumnIdentifiers<UsedRefT extends IUsedRef, ColumnIdentifierT extends ColumnIdentifier>(usedRef: UsedRefT, columnIdentifiers: readonly ColumnIdentifierT[]): (ExtractColumnIdentifier<UsedRefT, ColumnIdentifierT>);
}
declare module "used-ref/util/query/type-ref-of" {
    import { IUsedRef } from "used-ref/used-ref";
    /**
     * Named `TypeRefOf<>` to avoid name collision with type `TypeRef`.
     * @todo name other stuff `XxxOf<>` as well?
     */
    export type TypeRefOf<UsedRefT extends IUsedRef> = (UsedRefT extends IUsedRef<infer RefT> ? RefT : never);
}
declare module "used-ref/util/query/table-alias" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefOf } from "used-ref/util/query/type-ref-of";
    export type TableAlias<UsedRefT extends IUsedRef> = (Extract<keyof TypeRefOf<UsedRefT>, string>);
}
declare module "used-ref/util/query/index" {
    export * from "used-ref/util/query/extract-column-identifier";
    export * from "used-ref/util/query/table-alias";
    export * from "used-ref/util/query/type-ref-of";
}
declare module "used-ref/util/operation/intersect" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefUtil } from "type-ref/index";
    import { TypeRefOf } from "used-ref/util/query/index";
    import { TryReuseExistingType } from "type-util/index";
    /**
     * Assumes `U` is a union
     */
    export type Intersect<U extends IUsedRef> = (IUsedRef<TypeRefUtil.Intersect<TypeRefOf<U>>>);
    export type IntersectTryReuseExistingType<U extends IUsedRef> = (TryReuseExistingType<U, IUsedRef<TypeRefUtil.Intersect<TypeRefOf<U>>>>);
    export function intersect<U extends IUsedRef>(...arr: readonly U[]): (Intersect<U>);
}
declare module "used-ref/util/operation/with-value" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRefUtil } from "type-ref/index";
    export type WithValue<UsedRefT extends IUsedRef, TableAliasT extends string, ColumnAliasT extends string, ValueT extends unknown> = UsedRefT extends IUsedRef<infer RefT> ? IUsedRef<TypeRefUtil.WithValue<RefT, TableAliasT, ColumnAliasT, ValueT>> : never;
}
declare module "used-ref/util/operation/index" {
    export * from "used-ref/util/operation/intersect";
    export * from "used-ref/util/operation/with-value";
}
declare module "used-ref/util/predicate/assert-allowed" {
    import { IUsedRef } from "used-ref/used-ref";
    import { TypeRef, TypeRefUtil } from "type-ref/index";
    import { TypeRefOf } from "used-ref/util/query/index";
    import { CompileError } from "compile-error/index";
    type ExtractedStrictSubTypeToCompileError<T extends [string, string, any, any]> = (T extends [string, string, any, any] ? CompileError<["expected to handle", T[0], T[1], T[3], "actually handles", T[2]]> : never);
    /**
     * Checks if `AllowedT` is assignable to `UsedT`
     */
    export type AssertAllowedImpl<MessageT extends string, AllowedT extends TypeRef, UsedT extends TypeRef> = (TypeRefUtil.ExtractExcessColumnIdentifier<UsedT, AllowedT> extends never ? (TypeRefUtil.ExtractWithStrictSubType<UsedT, AllowedT> extends never ? unknown : ExtractedStrictSubTypeToCompileError<TypeRefUtil.ExtractWithStrictSubType<UsedT, AllowedT>>) : CompileError<[MessageT, TypeRefUtil.ExtractExcessColumnIdentifier<UsedT, AllowedT>]>);
    export type AssertAllowed<AllowedT extends IUsedRef, UsedT extends IUsedRef> = (AssertAllowedImpl<"The following columns cannot be referenced", TypeRefOf<AllowedT>, TypeRefOf<UsedT>>);
    export type AssertAllowedCustom<MessageT extends string, AllowedT extends IUsedRef, UsedT extends IUsedRef> = (AssertAllowedImpl<MessageT, TypeRefOf<AllowedT>, TypeRefOf<UsedT>>);
    /**
     * @todo Better naming
     *
     * @param allowed - Which references are allowed
     * @param used - Which references were actually used
     */
    export function assertAllowed(allowed: Pick<IUsedRef, "columns">, used: Pick<IUsedRef, "columns">): void;
}
declare module "used-ref/util/predicate/assert-empty" {
    import { IUsedRef } from "used-ref/used-ref";
    /**
     * @todo Better naming
     *
     * @param used - Which references were actually used
     */
    export function assertEmpty(used: Pick<IUsedRef, "columns">): void;
}
declare module "used-ref/util/predicate/is-used-ref" {
    import { IUsedRef } from "used-ref/used-ref";
    /**
     * Does not actually check that `x.columns` is a `ColumnIdentifierRef`.
     *
     * @todo Consider adding check for increased type safety.
     */
    export function isUsedRef(x: unknown): x is IUsedRef;
}
declare module "used-ref/util/predicate/index" {
    export * from "used-ref/util/predicate/assert-allowed";
    export * from "used-ref/util/predicate/assert-empty";
    export * from "used-ref/util/predicate/is-used-ref";
}
declare module "used-ref/util/index" {
    export * from "used-ref/util/constructor/index";
    export * from "used-ref/util/operation/index";
    export * from "used-ref/util/predicate/index";
    export * from "used-ref/util/query/index";
}
declare module "used-ref/index" {
    export * from "used-ref/used-ref";
    import * as UsedRefUtil from "used-ref/util/index";
    export { UsedRefUtil, };
}
declare module "expr-library/aggregate-factory/make-aggregate-operator-0" {
    import * as tm from "type-mapping";
    import { Expr } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { IUsedRef } from "used-ref/index";
    import { TypeHint } from "type-hint";
    export type AggregateOperator0<OutputTypeT> = () => (Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: IUsedRef<{}>;
        isAggregate: true;
    }>);
    export function makeAggregateOperator0<OperatorTypeT extends OperatorType, OutputTypeT>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand0<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AggregateOperator0<OutputTypeT>);
}
declare module "expr-library/aggregate-factory/make-aggregate-operator-1" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type AggregateOperator1<InputTypeT, OutputTypeT> = <ArgT extends BuiltInExpr_NonAggregate<InputTypeT>>(arg: ArgT) => (ExprUtil.AggregateIntersect<OutputTypeT, ArgT>);
    export function makeAggregateOperator1<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AggregateOperator1<InputTypeT, OutputTypeT>);
}
declare module "expr-library/aggregate-factory/make-aggregate-operator-2" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { AssertNonNever } from "type-util/index";
    export type AggregateOperator2<LeftTypeT, RightTypeT, OutputTypeT> = <LeftT extends BuiltInExpr_NonAggregate<LeftTypeT>, RightT extends BuiltInExpr_NonAggregate<RightTypeT>>(left: LeftT, right: RightT) => (ExprUtil.AggregateIntersect<OutputTypeT, LeftT | RightT>);
    export function makeAggregateOperator2<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT> & AssertNonNever<[InputTypeT], "InputTypeT required">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AggregateOperator2<InputTypeT, InputTypeT, OutputTypeT>);
    export function makeAggregateOperator2<OperatorTypeT extends OperatorType, LeftTypeT = never, RightTypeT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT> & AssertNonNever<[LeftTypeT], "LeftTypeT required"> & AssertNonNever<[RightTypeT], "RightTypeT required">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AggregateOperator2<LeftTypeT, RightTypeT, OutputTypeT>);
}
declare module "expr-library/aggregate-factory/make-aggregate-operator-3" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonAggregate } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type AggregateOperator3<LeftTypeT, MidTypeT, RightTypeT, OutputTypeT> = <LeftT extends BuiltInExpr_NonAggregate<LeftTypeT>, MidT extends BuiltInExpr_NonAggregate<MidTypeT>, RightT extends BuiltInExpr_NonAggregate<RightTypeT>>(left: LeftT, mid: MidT, right: RightT) => (ExprUtil.AggregateIntersect<OutputTypeT, LeftT | MidT | RightT>);
    export function makeAggregateOperator3<OperatorTypeT extends OperatorType, LeftTypeT = never, MidTypeT = never, RightTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand3<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AggregateOperator3<LeftTypeT, MidTypeT, RightTypeT, OutputTypeT>);
}
declare module "expr-library/aggregate-factory/index" {
    export * from "expr-library/aggregate-factory/make-aggregate-operator-0";
    export * from "expr-library/aggregate-factory/make-aggregate-operator-1";
    export * from "expr-library/aggregate-factory/make-aggregate-operator-2";
    export * from "expr-library/aggregate-factory/make-aggregate-operator-3";
}
declare module "expr-library/aggregate/count-all" {
    import { AggregateOperator0 } from "expr-library/aggregate-factory/index";
    /**
     * Returns a count of the number of rows
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(*)`
     * + PostgreSQL : `COUNT(*)`
     * + SQLite     : `COUNT(*)`
     *
     * @todo Rename to `count`? or `countRow`?
     * @todo Or add a function `count()` with overloads for `countExpr` and `countAll`?
     */
    export const countAll: AggregateOperator0<bigint>;
}
declare module "expr-library/aggregate/count-expr" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns a count of the number of rows with different non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(DISTINCT x)`
     * + PostgreSQL : `COUNT(DISTINCT x)`
     * + SQLite     : `COUNT(DISTINCT x)`
     */
    export const countExprDistinct: AggregateOperator1<unknown, bigint>;
    /**
     * Returns a count of the number of rows with non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(x)`
     * + PostgreSQL : `COUNT(x)`
     * + SQLite     : `COUNT(x)`
     */
    export const countExprAll: AggregateOperator1<unknown, bigint>;
    /**
     * Returns a count of the number of rows with non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(x)`
     * + PostgreSQL : `COUNT(x)`
     * + SQLite     : `COUNT(x)`
     */
    export const countExpr: AggregateOperator1<unknown, bigint>;
}
declare module "expr-library/aggregate/index" {
    export * from "expr-library/aggregate/count-all";
    export * from "expr-library/aggregate/count-expr";
}
declare module "expr-library/assert/throw-if-null" {
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    export type ThrowIfNullExpr<ArgT extends AnyBuiltInExpr> = ExprUtil.Intersect<Exclude<BuiltInExprUtil.TypeOf<ArgT>, null>, ArgT>;
    export function throwIfNull<ArgT extends AnyBuiltInExpr>(arg: ArgT): (ThrowIfNullExpr<ArgT>);
}
declare module "expr-library/assert/index" {
    export * from "expr-library/assert/throw-if-null";
}
declare module "expr-library/cast/bigint-signed-literal" {
    import * as tm from "type-mapping";
    import { Decimal } from "decimal/index";
    import { IUsedRef } from "used-ref/index";
    import { Expr } from "expr/index";
    /**
     * Converts `string|number|bigint|Decimal` to a `BIGINT SIGNED`
     */
    export function bigIntSignedLiteral(rawBigIntSignedLiteral: string | number | bigint | Decimal): (Expr<{
        mapper: tm.SafeMapper<bigint>;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>);
}
declare module "augmentable" {
    /**
     * All augmentable types go here.
     *
     * Libraries/applications should use declaration merging to modify these types,
     * which will affect this library's behaviour.
     *
     * https://github.com/microsoft/TypeScript/issues/18877#issuecomment-476921038
     */
    /**
     * Each type here can be casted to a `DECIMAL` "most of the time".
     * When it cannot be casted to a `DECIMAL`, it should throw and not return `null`.
     */
    export interface CustomDecimalCastableTypeMap {
    }
    /**
     * Each type here has comparison operators implemented for it.
     *
     * Comparison operators include,
     * + less than
     * + less than or equal
     * + greater than
     * + greater than or equal
     * + BETWEEN
     * + etc.
     */
    export interface CustomComparableTypeMap {
    }
}
declare module "expr-library/cast/unsafe-cast-as-decimal" {
    import * as tm from "type-mapping/fluent";
    import { Decimal } from "decimal/index";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { Expr } from "expr/index";
    import { CustomDecimalCastableTypeMap } from "augmentable";
    /**
     * @todo Move this elsewhere?
     */
    export function assertValidDecimalPrecisionAndScale(
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision: number | bigint, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint): ({
        precision: bigint;
        scale: bigint;
    });
    export type CustomDecimalCastableType = CustomDecimalCastableTypeMap[keyof CustomDecimalCastableTypeMap];
    /**
     * These types can be casted to `DECIMAL`, in general.
     *
     * -----
     *
     * ### PostgreSQL
     *
     * + bigint     = OK, or Error (if overflow)
     * + number     = OK, or Error (if overflow)
     * + string     = OK, or Error (if invalid format)
     * + boolean    = Error
     * + Date       = Error
     * + Uint8Array = Error
     * + null       = NULL
     *
     * @todo Convert other cast functions to this
     * @todo Afterwards, determine if all these casting functions should be moved to adapter libraries
     * https://github.com/AnyhowStep/tsql/issues/15
     */
    export type DecimalCastableType = bigint | number | string | null | CustomDecimalCastableType;
    export type NonNullDecimalCastableType = Exclude<DecimalCastableType, null>;
    /**
     * @todo Determine which conversions are not allowed for all `CAST()` functions.
     * For example, casting `bytea` to `DECIMAL` is not allowed in PostgreSQL.
     * It will result in a run-time error.
     *
     * @todo Determine how behaviours differ between DBMS'es
     *
     * For example,
     * + MySQL      : `CAST('a1' AS DECIMAL)` gives `0`
     * + PostgreSQL : `CAST('a1' AS DECIMAL)` throws an error
     * + SQLite     : `CAST('a1' AS DECIMAL)` gives `0`
     *
     * For example,
     * + MySQL      : `CAST('1a1' AS DECIMAL)` gives `1`
     * + PostgreSQL : `CAST('1a1' AS DECIMAL)` throws an error
     * + SQLite     : `CAST('1a1' AS DECIMAL)` gives `1`
     *
     * For example,
     * + MySQL      : `CAST('1e1' AS DECIMAL)` gives `10`
     * + PostgreSQL : `CAST('1e1' AS DECIMAL)` gives `10`
     * + SQLite     : `CAST('1e1' AS DECIMAL)` gives `10`
     *
     * For example,
     * + MySQL      : `CAST(100 AS DECIMAL(2,0))` gives `99`
     * + PostgreSQL : `CAST(100 AS DECIMAL(2,0))` throws an error
     * + SQLite     : `CAST(100 AS DECIMAL(2,0))` gives `100`
     *   + SQLite does not have a `DECIMAL` type.
     *   + So, it's basically just treated like a `NUMERIC` type (and we get an `INTEGER`)
     *
     * @todo Try to unify casting behaviour?
     *
     * -----
     *
     * @todo Is there ever a case where casting a non-null value to `DECIMAL`
     * gives us `NULL`?
     *
     * MySQL seems to return zero, even for data types like `BINARY`.
     *
     * -----
     *
     * ### PostgreSQL
     *
     * + bigint     = OK, or Error (if overflow)
     * + number     = OK, or Error (if overflow)
     * + string     = OK, or Error (if invalid format)
     * + boolean    = Error
     * + Date       = Error
     * + Uint8Array = Error
     * + null       = NULL
     */
    export function unsafeCastAsDecimal<ArgT extends BuiltInExpr<NonNullDecimalCastableType | Decimal>>(arg: ArgT, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision: number | bigint, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint): (Expr<{
        mapper: tm.SafeMapper<Decimal>;
        /**
         * @todo Use `TryReuseExistingType<>` hack to fight off depth limit
         */
        usedRef: BuiltInExprUtil.UsedRef<ArgT>;
        isAggregate: BuiltInExprUtil.IsAggregate<ArgT>;
    }>);
    export function unsafeCastAsDecimal<ArgT extends BuiltInExpr<DecimalCastableType | Decimal>>(arg: ArgT, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision: number | bigint, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint): (Expr<{
        mapper: tm.SafeMapper<Decimal | null>;
        /**
         * @todo Use `TryReuseExistingType<>` hack to fight off depth limit
         */
        usedRef: BuiltInExprUtil.UsedRef<ArgT>;
        isAggregate: BuiltInExprUtil.IsAggregate<ArgT>;
    }>);
}
declare module "expr-library/cast/decimal-literal" {
    import * as tm from "type-mapping";
    import { Decimal } from "decimal/index";
    import { IUsedRef } from "used-ref/index";
    import { Expr } from "expr/index";
    /**
     *
     * @param rawDecimalLiteral
     *
     * @param precision
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     *
     * @param scale
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    export function decimalLiteral(rawDecimalLiteral: string | number | bigint | Decimal, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision: number | bigint, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint): (Expr<{
        mapper: tm.SafeMapper<Decimal>;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>);
}
declare module "expr-library/factory/make-any-operator-1" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type AnyOperator1<OutputTypeT> = <ArgT extends AnyBuiltInExpr>(arg: ArgT) => (ExprUtil.Intersect<OutputTypeT, ArgT>);
    export function makeAnyOperator1<OperatorTypeT extends OperatorType, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (AnyOperator1<OutputTypeT>);
}
declare module "expr-library/decimal/decimal-mapper" {
    import * as tm from "type-mapping/fluent";
    /**
     * We make this precision and scale far larger than what a database
     * can reasonably reach.
     *
     * PostgreSQL has max precision 1,000.
     *
     * Precision 40,000 and scale 20,000 seems like a safe bet, right?
     */
    export const decimalMapper: tm.FluentMapper<tm.Mapper<unknown, tm.mysql.Decimal> & tm.ExpectedInput<tm.mysql.Decimal> & tm.MappableInput<string | number | bigint | tm.mysql.Decimal>>;
}
declare module "expr-library/factory/make-chainable-decimal-operator" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { Decimal } from "decimal/index";
    export type ChainableDecimalOperatorReturn<ArrT extends BuiltInExpr<Decimal>[]> = 
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-521819804
     */
    ExprUtil.Intersect<Decimal, ArrT[number]>;
    export type ChainableDecimalOperator = <ArrT extends BuiltInExpr<Decimal>[]>(...arr: ArrT) => (ChainableDecimalOperatorReturn<ArrT>);
    export function makeChainableDecimalOperator<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1ToN<OperatorTypeT>, rawIdentityElement: string | number | bigint | Decimal, mapper: tm.SafeMapper<Decimal>, 
    /**
     * For now, the typeHint should always be `DECIMAL`
     */
    typeHint: TypeHint.DECIMAL): (ChainableDecimalOperator);
}
declare module "expr-library/factory/make-chainable-operator" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type ChainableOperatorReturn<TypeT, ArrT extends BuiltInExpr<TypeT>[]> = 
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-521819804
     */
    ExprUtil.Intersect<TypeT, ArrT[number]>;
    export type ChainableOperator<TypeT extends null | boolean | number | bigint | string | Uint8Array> = <ArrT extends BuiltInExpr<TypeT>[]>(...arr: ArrT) => (ChainableOperatorReturn<TypeT, ArrT>);
    export function makeChainableOperator<OperatorTypeT extends OperatorType, TypeT extends null | boolean | number | bigint | string | Uint8Array>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1ToN<OperatorTypeT>, identityElement: TypeT, mapper: tm.SafeMapper<TypeT>, typeHint?: TypeHint): (ChainableOperator<TypeT>);
}
declare module "comparable-type/comparable-type" {
    import { BuiltInValueExpr } from "built-in-value-expr/index";
    import { Decimal } from "decimal/index";
    import { CustomComparableTypeMap } from "augmentable";
    export type CustomComparableType = CustomComparableTypeMap[keyof CustomComparableTypeMap];
    /**
     * These types support the following operators,
     * + Greater Than
     * + Greater Than or Equal to
     * + Less Than
     * + Less Than or Equal to
     * + Equal to
     * + Not Equal to
     */
    export type ComparableType = BuiltInValueExpr | Decimal | CustomComparableType;
    export type NonNullComparableType = Exclude<ComparableType, null>;
}
declare module "comparable-type/index" {
    export * from "comparable-type/comparable-type";
}
declare module "expr-library/factory/make-operator-1-to-n" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type Operator1ToNReturn<InputTypeT, OutputTypeT, Arg0T extends BuiltInExpr<InputTypeT>, ArgsT extends readonly BuiltInExpr<InputTypeT>[]> = ExprUtil.Intersect<OutputTypeT, Arg0T | ArgsT[number]>;
    export type Operator1ToN<InputTypeT, OutputTypeT> = <Arg0T extends BuiltInExpr<InputTypeT>, ArgsT extends readonly BuiltInExpr<InputTypeT>[]>(arg0: Arg0T, ...args: ArgsT) => (Operator1ToNReturn<InputTypeT, OutputTypeT, Arg0T, ArgsT>);
    export function makeOperator1ToN<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1ToN<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator1ToN<InputTypeT, OutputTypeT>);
}
declare module "expr-library/factory/make-comparison-1-to-n" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { NonNullComparableType } from "comparable-type/index";
    import { BaseType } from "type-util/index";
    export type Comparison1ToNReturn<Arg0T extends BuiltInExpr<NonNullComparableType>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]> = ExprUtil.Intersect<boolean, Arg0T | ArgsT[number]>;
    export type Comparison1ToN = <Arg0T extends BuiltInExpr<NonNullComparableType>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T, ...args: ArgsT) => (Comparison1ToNReturn<Arg0T, ArgsT>);
    export function makeComparison1ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1ToN<OperatorTypeT>, typeHint?: TypeHint): (Comparison1ToN);
}
declare module "expr-library/factory/make-operator-2-to-n" {
    import * as tm from "type-mapping";
    import { BuiltInExpr, AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { AssertNonNever } from "type-util/index";
    export type Operator2ToNReturn<OutputTypeT, Arg0T extends AnyBuiltInExpr, Arg1T extends AnyBuiltInExpr, ArgsT extends readonly AnyBuiltInExpr[]> = ExprUtil.Intersect<OutputTypeT, Arg0T | Arg1T | ArgsT[number]>;
    export type Operator2ToN<InputType0T, InputType1T, InputTypeRestT, OutputTypeT> = <Arg0T extends BuiltInExpr<InputType0T>, Arg1T extends BuiltInExpr<InputType1T>, ArgsT extends readonly BuiltInExpr<InputTypeRestT>[]>(arg0: Arg0T, arg1: Arg1T, ...args: ArgsT) => (Operator2ToNReturn<OutputTypeT, Arg0T, Arg1T, ArgsT>);
    export function makeOperator2ToN<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2ToN<OperatorTypeT> & AssertNonNever<[InputTypeT], "InputTypeT">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator2ToN<InputTypeT, InputTypeT, InputTypeT, OutputTypeT>);
    export function makeOperator2ToN<OperatorTypeT extends OperatorType, InputType0T = never, InputType1T = never, InputTypeRestT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2ToN<OperatorTypeT> & AssertNonNever<[InputType0T], "InputType0T"> & AssertNonNever<[InputType1T], "InputType1T"> & AssertNonNever<[InputTypeRestT], "InputTypeRestT">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator2ToN<InputType0T, InputType1T, InputTypeRestT, OutputTypeT>);
}
declare module "expr-library/factory/make-comparison-2-to-n" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { NonNullComparableType } from "comparable-type/index";
    import { BaseType } from "type-util/index";
    export type Comparison2ToNReturn<Arg0T extends BuiltInExpr<NonNullComparableType>, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]> = ExprUtil.Intersect<boolean, Arg0T | Arg1T | ArgsT[number]>;
    export type Comparison2ToN = <Arg0T extends BuiltInExpr<NonNullComparableType>, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T, arg1: Arg1T, ...args: ArgsT) => (Comparison2ToNReturn<Arg0T, Arg1T, ArgsT>);
    export function makeComparison2ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2ToN<OperatorTypeT>, typeHint?: TypeHint): (Comparison2ToN);
}
declare module "expr-library/factory/make-comparison-2" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { NonNullComparableType } from "comparable-type/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type Comparison2Return<LeftT extends BuiltInExpr<NonNullComparableType>, RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>> = ExprUtil.Intersect<boolean, LeftT | RightT>;
    export type Comparison2 = <LeftT extends BuiltInExpr<NonNullComparableType>, 
    /**
     * https://github.com/microsoft/TypeScript/issues/33002#issuecomment-523651736
     *
     * @todo Investigate
     */
    RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>>(left: LeftT, right: RightT) => (Comparison2Return<LeftT, RightT>);
    /**
     * Factory for making comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    export function makeComparison2<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT>, typeHint?: TypeHint): Comparison2;
}
declare module "expr-library/factory/make-comparison-3" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { NonNullComparableType } from "comparable-type/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type Comparison3Return<LeftT extends BuiltInExpr<NonNullComparableType>, MidT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>, RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>> = ExprUtil.Intersect<boolean, LeftT | MidT | RightT>;
    export type Comparison3 = <LeftT extends BuiltInExpr<NonNullComparableType>, MidT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>, 
    /**
     * https://github.com/microsoft/TypeScript/issues/33002#issuecomment-523651736
     *
     * @todo Investigate
     */
    RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>>(left: LeftT, mid: MidT, right: RightT) => (Comparison3Return<LeftT, MidT, RightT>);
    /**
     * Factory for making ternary comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    export function makeComparison3<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand3<OperatorTypeT>, typeHint?: TypeHint): Comparison3;
}
declare module "expr-library/factory/make-comparison-projection-2-to-n" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { NonNullComparableType } from "comparable-type/index";
    import { BaseType } from "type-util/index";
    export type ComparisonProjection2ToNReturn<Arg0T extends BuiltInExpr<NonNullComparableType>, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]> = ExprUtil.Intersect<BuiltInExprUtil.TypeOf<Arg0T | Arg1T | ArgsT[number]>, Arg0T | Arg1T | ArgsT[number]>;
    export type ComparisonProjection2ToN = <Arg0T extends BuiltInExpr<NonNullComparableType>, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T, arg1: Arg1T, ...args: ArgsT) => (ComparisonProjection2ToNReturn<Arg0T, Arg1T, ArgsT>);
    /**
     * @todo Better name?
     *
     * Called `Projection` because it picks one of its arguments as the return value.
     * Similar to picking columns in a query.
     */
    export function makeComparisonProjection2ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2ToN<OperatorTypeT>, typeHint?: TypeHint): (ComparisonProjection2ToN);
}
declare module "expr-library/factory/make-equation-1-to-n" {
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type Equation1ToNReturn<Arg0T extends AnyBuiltInExpr, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]> = ExprUtil.Intersect<boolean, Arg0T | ArgsT[number]>;
    export type Equation1ToN = <Arg0T extends AnyBuiltInExpr, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T & BuiltInExprUtil.AssertNonNull<Arg0T>, ...args: ArgsT) => (Equation1ToNReturn<Arg0T, ArgsT>);
    export function makeEquation1ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1ToN<OperatorTypeT>, typeHint?: TypeHint): (Equation1ToN);
}
declare module "expr-library/factory/make-equation-2-to-n" {
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type Equation2ToNReturn<Arg0T extends AnyBuiltInExpr, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]> = ExprUtil.Intersect<boolean, Arg0T | Arg1T | ArgsT[number]>;
    export type Equation2ToN = <Arg0T extends AnyBuiltInExpr, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T & BuiltInExprUtil.AssertNonNull<Arg0T>, arg1: Arg1T, ...args: ArgsT) => (Equation2ToNReturn<Arg0T, Arg1T, ArgsT>);
    export function makeEquation2ToN<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2ToN<OperatorTypeT>, typeHint?: TypeHint): (Equation2ToN);
}
declare module "expr-library/factory/make-equation-2" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr, AnyBuiltInExpr } from "built-in-expr/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type Equation2Return<LeftT extends AnyBuiltInExpr, RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>> = ExprUtil.Intersect<boolean, LeftT | RightT>;
    export type Equation2 = <LeftT extends AnyBuiltInExpr, 
    /**
     * https://github.com/microsoft/TypeScript/issues/33002#issuecomment-523651736
     *
     * @todo Investigate
     */
    RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>>>>(left: LeftT & BuiltInExprUtil.AssertNonNull<LeftT>, right: RightT) => (Equation2Return<LeftT, RightT>);
    /**
     * Factory for making comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    export function makeEquation2<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT>, typeHint?: TypeHint): Equation2;
}
declare module "expr-library/factory/make-null-safe-comparison-1" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { ComparableType } from "comparable-type/index";
    export type NullSafeComparison1 = <BuiltInExprT extends BuiltInExpr<ComparableType>>(builtInExpr: BuiltInExprT) => (ExprUtil.Intersect<boolean, BuiltInExprT>);
    /**
     * Factory for making null-safe unary comparison operators.
     */
    export function makeNullSafeComparison1<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, typeHint?: TypeHint): NullSafeComparison1;
}
declare module "expr-library/factory/make-null-safe-comparison-2" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { ComparableType } from "comparable-type/index";
    export type NullSafeComparison2 = <LeftT extends BuiltInExpr<ComparableType>, RightT extends BuiltInExpr<BuiltInExprUtil.TypeOf<LeftT> | null>>(left: LeftT, right: RightT) => (ExprUtil.Intersect<boolean, LeftT | RightT>);
    /**
     * Factory for making null-safe comparison operators.
     *
     * These allow `null` in comparisons.
     */
    export function makeNullSafeComparison<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT>, typeHint?: TypeHint): NullSafeComparison2;
}
declare module "expr-library/factory/make-null-safe-equation-1" {
    import { ExprUtil } from "expr/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type NullSafeEquation1 = <BuiltInExprT extends AnyBuiltInExpr>(builtInExpr: BuiltInExprT) => (ExprUtil.Intersect<boolean, BuiltInExprT>);
    /**
     * Factory for making null-safe unary equation operators.
     */
    export function makeNullSafeEquation1<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, typeHint?: TypeHint): NullSafeEquation1;
}
declare module "expr-library/factory/make-null-safe-equation-2" {
    import { ExprUtil } from "expr/index";
    import { BuiltInExpr, AnyBuiltInExpr } from "built-in-expr/index";
    import { BuiltInExprUtil } from "built-in-expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { BaseType } from "type-util/index";
    export type NullSafeEquation2 = <LeftT extends AnyBuiltInExpr, RightT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<LeftT>> | null>>(left: LeftT, right: RightT) => (ExprUtil.Intersect<boolean, LeftT | RightT>);
    /**
     * Factory for making null-safe equation operators.
     *
     * These allow `null` in equations.
     */
    export function makeNullSafeEquation2<OperatorTypeT extends OperatorType>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT>, typeHint?: TypeHint): NullSafeEquation2;
}
declare module "expr-library/factory/make-operator-0" {
    import * as tm from "type-mapping";
    import { Expr } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { IUsedRef } from "used-ref/index";
    import { TypeHint } from "type-hint";
    export type Operator0<OutputTypeT> = () => (Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>);
    export function makeOperator0<OperatorTypeT extends OperatorType, OutputTypeT>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand0<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator0<OutputTypeT>);
}
declare module "expr-library/factory/make-operator-1" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type Operator1<InputTypeT, OutputTypeT> = <ArgT extends BuiltInExpr<InputTypeT>>(arg: ArgT) => (ExprUtil.Intersect<OutputTypeT, ArgT>);
    export function makeOperator1<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator1<InputTypeT, OutputTypeT>);
}
declare module "expr-library/factory/make-operator-1-double-elimination" {
    import * as tm from "type-mapping";
    import { OperatorNodeUtil } from "ast/index";
    import { Operator1 } from "expr-library/factory/make-operator-1";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    /**
     * Makes a double elimination unary operator.
     *
     * A double elimination function `f` has the following property,
     * `f(f(x)) == x`
     */
    export function makeOperator1DoubleElimination<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator1<InputTypeT, OutputTypeT>);
}
declare module "expr-library/factory/make-operator-1-idempotent" {
    import * as tm from "type-mapping";
    import { OperatorNodeUtil } from "ast/index";
    import { Operator1 } from "expr-library/factory/make-operator-1";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    /**
     * Makes an idempotent unary operator.
     *
     * An idempotent function `f` has the following property,
     * `f(f(x)) == f(x)`
     */
    export function makeOperator1Idempotent<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand1<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator1<InputTypeT, OutputTypeT>);
}
declare module "expr-library/factory/make-operator-2" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    import { AssertNonNever } from "type-util/index";
    export type Operator2<LeftTypeT, RightTypeT, OutputTypeT> = <LeftT extends BuiltInExpr<LeftTypeT>, RightT extends BuiltInExpr<RightTypeT>>(left: LeftT, right: RightT) => (ExprUtil.Intersect<OutputTypeT, LeftT | RightT>);
    export function makeOperator2<OperatorTypeT extends OperatorType, InputTypeT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT> & AssertNonNever<[InputTypeT], "InputTypeT required">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator2<InputTypeT, InputTypeT, OutputTypeT>);
    export function makeOperator2<OperatorTypeT extends OperatorType, LeftTypeT = never, RightTypeT = never, OutputTypeT = never>(operatorType: (OperatorTypeT & OperatorNodeUtil.AssertHasOperand2<OperatorTypeT> & AssertNonNever<[LeftTypeT], "LeftTypeT required"> & AssertNonNever<[RightTypeT], "RightTypeT required">), mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator2<LeftTypeT, RightTypeT, OutputTypeT>);
}
declare module "expr-library/factory/make-operator-3" {
    import * as tm from "type-mapping";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { OperatorNodeUtil } from "ast/index";
    import { OperatorType } from "operator-type";
    import { TypeHint } from "type-hint";
    export type Operator3<LeftTypeT, MidTypeT, RightTypeT, OutputTypeT> = <LeftT extends BuiltInExpr<LeftTypeT>, MidT extends BuiltInExpr<MidTypeT>, RightT extends BuiltInExpr<RightTypeT>>(left: LeftT, mid: MidT, right: RightT) => (ExprUtil.Intersect<OutputTypeT, LeftT | MidT | RightT>);
    export function makeOperator3<OperatorTypeT extends OperatorType, LeftTypeT = never, MidTypeT = never, RightTypeT = never, OutputTypeT = never>(operatorType: OperatorTypeT & OperatorNodeUtil.AssertHasOperand3<OperatorTypeT>, mapper: tm.SafeMapper<OutputTypeT>, typeHint?: TypeHint): (Operator3<LeftTypeT, MidTypeT, RightTypeT, OutputTypeT>);
}
declare module "expr-library/factory/index" {
    export * from "expr-library/factory/make-any-operator-1";
    export * from "expr-library/factory/make-chainable-decimal-operator";
    export * from "expr-library/factory/make-chainable-operator";
    export * from "expr-library/factory/make-comparison-1-to-n";
    export * from "expr-library/factory/make-comparison-2-to-n";
    export * from "expr-library/factory/make-comparison-2";
    export * from "expr-library/factory/make-comparison-3";
    export * from "expr-library/factory/make-comparison-projection-2-to-n";
    export * from "expr-library/factory/make-equation-1-to-n";
    export * from "expr-library/factory/make-equation-2-to-n";
    export * from "expr-library/factory/make-equation-2";
    export * from "expr-library/factory/make-null-safe-comparison-1";
    export * from "expr-library/factory/make-null-safe-comparison-2";
    export * from "expr-library/factory/make-null-safe-equation-1";
    export * from "expr-library/factory/make-null-safe-equation-2";
    export * from "expr-library/factory/make-operator-0";
    export * from "expr-library/factory/make-operator-1-double-elimination";
    export * from "expr-library/factory/make-operator-1-idempotent";
    export * from "expr-library/factory/make-operator-1-to-n";
    export * from "expr-library/factory/make-operator-1";
    export * from "expr-library/factory/make-operator-2-to-n";
    export * from "expr-library/factory/make-operator-2";
    export * from "expr-library/factory/make-operator-3";
}
declare module "expr-library/cast/unsafe-cast-as-bigint-signed" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Attempts to cast to `BIGINT SIGNED`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS SIGNED INTEGER)`
     *   + Actually gives a signed `bigint`
     *   + Trying to cast `'123e2'` gives `123`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + Trying to cast `'123e2'` throws an error
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + Trying to cast `'123e2'` gives `123`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     * + https://github.com/AnyhowStep/tsql/issues/244
     * + https://github.com/AnyhowStep/tsql/issues/245
     */
    export const unsafeCastAsBigIntSigned: Operator1<unknown, bigint | null>;
}
declare module "expr-library/cast/unsafe-cast-as-binary" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Attempts to cast to `BINARY/bytea/BLOB`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS BINARY)`
     *   + `CAST(1234567890 AS BINARY)` returns `[49,50,51,52,53,54,55,56,57,48]`
     *     + Converts to ASCII string first, then to BINARY
     * + PostgreSQL     : `CAST(x AS bytea)`
     *   + `CAST(1234567890 AS bytea)` throws
     * + SQLite         : `CAST(x AS BLOB)`
     *   + `CAST(1234567890 AS BLOB)` returns `[49,50,51,52,53,54,55,56,57,48]`
     *     + Converts to ASCII string first, then to BLOB
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    export const unsafeCastAsBinary: Operator1<unknown, Uint8Array | null>;
}
declare module "expr-library/cast/unsafe-cast-as-double" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Attempts to cast to `DOUBLE`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL 5.7      : `x + 0e0`
     *   + `('qwerty' + 0e0)` returns `0e0`
     *   + `(TRUE + 0e0)` returns `1e0`
     *   + `(9223372036854775807 + 0e0)` returns `9223372036854776000e0`
     * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
     *   + `CAST('qwerty' AS DOUBLE PRECISION)` throws
     *   + `CAST(TRUE AS DOUBLE PRECISION)` throws
     *   + `CAST(9223372036854775807 AS DOUBLE PRECISION)` returns `9223372036854780000e0`
     * + SQLite         : `CAST(x AS DOUBLE)`
     *   + `CAST('qwerty' AS DOUBLE)` returns `0e0`
     *   + `CAST(TRUE AS DOUBLE)` returns `1e0`
     *   + `CAST(9223372036854775807 AS DOUBLE)` returns `9223372036854776000e0`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    export const unsafeCastAsDouble: Operator1<unknown, number | null>;
}
declare module "expr-library/cast/unsafe-cast-as-json" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Attempts to cast to `JSON`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS JSON)`
     *   + `CAST(1 AS JSON)` returns `'1'`
     *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x": "y"}'`
     * + PostgreSQL     : `CAST(x AS JSON)`
     *   + `CAST(1 AS JSON)` throws
     *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x":"y"}'`
     * + SQLite         : `CAST(x AS TEXT)`
     *   + Or implement with user-defined function.
     *   + Or the `JSON()` function?
     *   + https://www.sqlite.org/json1.html#jmini
     *   + SQLite does not have a `JSON` data type; `TEXT` is used for `JSON` values.
     *   + `JSON(1)` returns `'1'`
     *   + `CAST(1 AS TEXT)` returns `'1'`
     *   + `JSON('{  "x"  :  "y"  }')` returns `'{"x":"y"}'`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    export const unsafeCastAsJson: Operator1<unknown, string | null>;
}
declare module "expr-library/cast/unsafe-cast-as-var-char" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Attempts to cast to `VARCHAR`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS CHAR)`
     *   + `CAST(TRUE AS CHAR)` returns `'1'`
     *   + `CAST(123e0 AS CHAR)` returns `'123'`
     * + PostgreSQL     : `CAST(x AS VARCHAR)`
     *   + `CAST(TRUE AS VARCHAR)` returns `'true'`
     *   + `CAST(CAST(123e0 AS DOUBLE PRECISION) AS VARCHAR)` returns `'123'`
     * + SQLite         : `CAST(x AS VARCHAR)`
     *   + `CAST(TRUE AS VARCHAR)` returns `'1'`
     *   + `CAST(123e0 AS VARCHAR)` returns `'123.0'`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    export const unsafeCastAsVarChar: Operator1<unknown, string | null>;
}
declare module "expr-library/cast/index" {
    export * from "expr-library/cast/bigint-signed-literal";
    export * from "expr-library/cast/unsafe-cast-as-decimal";
    export * from "expr-library/cast/decimal-literal";
    export * from "expr-library/cast/unsafe-cast-as-bigint-signed";
    export * from "expr-library/cast/unsafe-cast-as-binary";
    export * from "expr-library/cast/unsafe-cast-as-double";
    export * from "expr-library/cast/unsafe-cast-as-json";
    export * from "expr-library/cast/unsafe-cast-as-var-char";
}
declare module "expr-library/comparison/between" {
    import { Comparison3 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
     *
     * This version of the `BETWEEN ... AND` operator prevents `NULL`.
     *
     * For null-safe checks, @see {@link nullSafeBetween}
     *
     */
    export const between: Comparison3;
}
declare module "expr-library/comparison/greatest" {
    import { ComparisonProjection2ToN } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
     *
     * This version of the `GREATEST(x, y, ...)` operator prevents `NULL`.
     *
     * No null-safe version is provided in this unification
     * because the different databases treat `NULL` arguments differently.
     *
     * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
     * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
     *
     * -----
     *
     * This version of the `GREATEST(x, y, ...)` operator requires
     * at least 2 arguments because MySQL's requires at least 2.
     *
     * Also, it does not make much sense to get the `GREATEST` of 1 value.
     */
    export const greatest: ComparisonProjection2ToN;
}
declare module "expr-library/comparison/gt-eq" {
    import { Comparison2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
     *
     * This version of the `>=` operator prevents `NULL`.
     *
     */
    export const gtEq: Comparison2;
}
declare module "expr-library/comparison/gt" {
    import { Comparison2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
     *
     * This version of the `>` operator prevents `NULL`.
     *
     */
    export const gt: Comparison2;
}
declare module "expr-library/comparison/least" {
    import { ComparisonProjection2ToN } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
     *
     * This version of the `LEAST(x, y, ...)` operator prevents `NULL`.
     *
     * No null-safe version is provided in this unification
     * because the different databases treat `NULL` arguments differently.
     *
     * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
     * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
     *
     * -----
     *
     * This version of the `LEAST(x, y, ...)` operator requires
     * at least 2 arguments because MySQL's requires at least 2.
     *
     * Also, it does not make much sense to get the `LEAST` of 1 value.
     */
    export const least: ComparisonProjection2ToN;
}
declare module "expr-library/comparison/lt-eq" {
    import { Comparison2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal
     *
     * This version of the `<=` operator prevents `NULL`.
     *
     */
    export const ltEq: Comparison2;
}
declare module "expr-library/comparison/lt" {
    import { Comparison2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     *
     * This version of the `<` operator prevents `NULL`.
     *
     */
    export const lt: Comparison2;
}
declare module "expr-library/comparison/not-between" {
    import { Comparison3 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
     *
     * This version of the `NOT BETWEEN ... AND` operator prevents `NULL`.
     *
     * For null-safe checks, @see {@link nullSafeNotBetween}
     *
     */
    export const notBetween: Comparison3;
}
declare module "expr-library/comparison/index" {
    export * from "expr-library/comparison/between";
    export * from "expr-library/comparison/greatest";
    export * from "expr-library/comparison/gt-eq";
    export * from "expr-library/comparison/gt";
    export * from "expr-library/comparison/least";
    export * from "expr-library/comparison/lt-eq";
    export * from "expr-library/comparison/lt";
    export * from "expr-library/comparison/not-between";
}
declare module "expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { CaseConditionBuilder, UninitializedCaseConditionBuilder } from "expr-library/control-flow/case-condition/case-condition";
    export class UninitializedCaseConditionBuilderImpl implements UninitializedCaseConditionBuilder {
        constructor();
        when<ConditionT extends BuiltInExpr<boolean>, ThenT extends BuiltInExpr<unknown>>(condition: ConditionT, then: ThenT): (CaseConditionBuilder<BuiltInExprUtil.TypeOf<ThenT>, BuiltInExprUtil.IntersectUsedRef<ConditionT | ThenT>, BuiltInExprUtil.IsAggregate<ConditionT | ThenT>>);
    }
}
declare module "expr-library/control-flow/case-condition/case-condition" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprImpl } from "expr/expr-impl";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { BaseType } from "type-util/index";
    export interface CaseConditionBuilder<ResultT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> {
        readonly isAggregate: IsAggregateT;
        when<ConditionT extends BuiltInExpr<boolean>, ThenT extends BuiltInExpr<BaseType<ResultT> | null>>(condition: ConditionT, then: ThenT): (CaseConditionBuilder<ResultT | BuiltInExprUtil.TypeOf<ThenT>, 
        /**
         * This is needed to chain many `.when()` calls.
         *
         * Without `IntersectTryReuseExistingType<>`,
         * we can only chain 10+ calls.
         *
         * With it, we can chain 100+ calls.
         */
        UsedRefUtil.IntersectTryReuseExistingType<UsedRefT | BuiltInExprUtil.IntersectUsedRef<ConditionT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ConditionT | ThenT>>);
        /**
         * Calling `.end()` without an `ELSE` clause can
         * cause the result to be `null`
         */
        end(): ExprImpl<ResultT | null, UsedRefT, IsAggregateT>;
        else<ElseT extends BuiltInExpr<BaseType<ResultT> | null>>(elseResult: ElseT): ({
            end(): ExprImpl<ResultT | BuiltInExprUtil.TypeOf<ElseT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.UsedRef<ElseT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ElseT>>;
        });
    }
    export interface UninitializedCaseConditionBuilder {
        when<ConditionT extends BuiltInExpr<boolean>, ThenT extends BuiltInExpr<unknown>>(condition: ConditionT, then: ThenT): (CaseConditionBuilder<BuiltInExprUtil.TypeOf<ThenT>, BuiltInExprUtil.IntersectUsedRef<ConditionT | ThenT>, BuiltInExprUtil.IsAggregate<ConditionT | ThenT>>);
    }
    export function caseCondition(): (UninitializedCaseConditionBuilder);
}
declare module "expr-library/control-flow/case-condition/case-condition-builder-impl" {
    import * as tm from "type-mapping";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprImpl } from "expr/expr-impl";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { CaseConditionNode } from "ast/index";
    import { CaseConditionBuilder } from "expr-library/control-flow/case-condition/case-condition";
    import { BaseType } from "type-util/index";
    export class CaseConditionBuilderImpl<ResultT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> implements CaseConditionBuilder<ResultT, UsedRefT, IsAggregateT> {
        private readonly resultMappers;
        private readonly usedRef;
        private readonly ast;
        readonly isAggregate: IsAggregateT;
        constructor(resultMappers: tm.SafeMapper<ResultT>[], usedRef: UsedRefT, ast: CaseConditionNode, isAggregate: IsAggregateT);
        when<ConditionT extends BuiltInExpr<boolean>, ThenT extends BuiltInExpr<BaseType<ResultT> | null>>(condition: ConditionT, then: ThenT): (CaseConditionBuilder<ResultT | BuiltInExprUtil.TypeOf<ThenT>, UsedRefUtil.IntersectTryReuseExistingType<UsedRefT | BuiltInExprUtil.IntersectUsedRef<ConditionT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ConditionT | ThenT>>);
        end(): ExprImpl<ResultT | null, UsedRefT, IsAggregateT>;
        else<ElseT extends BuiltInExpr<BaseType<ResultT> | null>>(elseResult: ElseT): ({
            end(): ExprImpl<ResultT | BuiltInExprUtil.TypeOf<ElseT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.UsedRef<ElseT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ElseT>>;
        });
    }
}
declare module "expr-library/control-flow/case-condition/index" {
    export * from "expr-library/control-flow/case-condition/case-condition-builder-impl";
    export * from "expr-library/control-flow/case-condition/case-condition";
    export * from "expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl";
}
declare module "expr-library/control-flow/case-value/uninitialized-case-value-builder-impl" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { Ast } from "ast/index";
    import { CaseValueBuilder, UninitializedCaseValueBuilder } from "expr-library/control-flow/case-value/case-value";
    export class UninitializedCaseValueBuilderImpl<ValueT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> implements UninitializedCaseValueBuilder<ValueT, UsedRefT, IsAggregateT> {
        private readonly usedRef;
        private readonly valueAst;
        readonly isAggregate: IsAggregateT;
        constructor(usedRef: UsedRefT, valueAst: Ast, isAggregate: IsAggregateT);
        when<CompareValueT extends BuiltInExpr<ValueT>, ThenT extends BuiltInExpr<unknown>>(compareValue: CompareValueT, then: ThenT): (CaseValueBuilder<ValueT, BuiltInExprUtil.TypeOf<ThenT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.IntersectUsedRef<CompareValueT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<CompareValueT | ThenT>>);
    }
}
declare module "expr-library/control-flow/case-value/case-value" {
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprImpl } from "expr/expr-impl";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { BaseType } from "type-util/index";
    export interface CaseValueBuilder<ValueT extends unknown, ResultT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> {
        readonly isAggregate: IsAggregateT;
        when<CompareValueT extends BuiltInExpr<ValueT>, ThenT extends BuiltInExpr<BaseType<ResultT> | null>>(compareValue: CompareValueT, then: ThenT): (CaseValueBuilder<ValueT, ResultT | BuiltInExprUtil.TypeOf<ThenT>, 
        /**
         * This is needed to chain many `.when()` calls.
         *
         * Without `IntersectTryReuseExistingType<>`,
         * we can only chain 10+ calls.
         *
         * With it, we can chain 100+ calls.
         */
        UsedRefUtil.IntersectTryReuseExistingType<UsedRefT | BuiltInExprUtil.IntersectUsedRef<CompareValueT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<CompareValueT | ThenT>>);
        /**
         * Calling `.end()` without an `ELSE` clause can
         * cause the result to be `null`
         */
        end(): ExprImpl<ResultT | null, UsedRefT, IsAggregateT>;
        else<ElseT extends BuiltInExpr<BaseType<ResultT> | null>>(elseResult: ElseT): ({
            end(): ExprImpl<ResultT | BuiltInExprUtil.TypeOf<ElseT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.UsedRef<ElseT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ElseT>>;
        });
    }
    export interface UninitializedCaseValueBuilder<ValueT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> {
        readonly isAggregate: IsAggregateT;
        when<CompareValueT extends BuiltInExpr<ValueT>, ThenT extends BuiltInExpr<unknown>>(compareValue: CompareValueT, then: ThenT): (CaseValueBuilder<ValueT, BuiltInExprUtil.TypeOf<ThenT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.IntersectUsedRef<CompareValueT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<CompareValueT | ThenT>>);
    }
    export function caseValue<ValueExprT extends BuiltInExpr<unknown>>(valueExpr: ValueExprT & BuiltInExprUtil.AssertNonNull<ValueExprT>): (UninitializedCaseValueBuilder<BaseType<BuiltInExprUtil.TypeOf<ValueExprT>>, BuiltInExprUtil.UsedRef<ValueExprT>, BuiltInExprUtil.IsAggregate<ValueExprT>>);
}
declare module "expr-library/control-flow/case-value/case-value-builder-impl" {
    import * as tm from "type-mapping";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { ExprImpl } from "expr/expr-impl";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { CaseValueNode } from "ast/index";
    import { CaseValueBuilder } from "expr-library/control-flow/case-value/case-value";
    import { BaseType } from "type-util/index";
    /**
     * Workaround for,
     * https://github.com/microsoft/TypeScript/issues/33573
     */
    global {
        interface ReadonlyArray<T> {
            concat(this: readonly [T, ...T[]], ...items: (T | ConcatArray<T>)[]): ([T, ...T[]]);
        }
        interface Array<T> {
            concat(this: readonly [T, ...T[]], ...items: (T | ConcatArray<T>)[]): ([T, ...T[]]);
        }
    }
    export class CaseValueBuilderImpl<ValueT extends unknown, ResultT extends unknown, UsedRefT extends IUsedRef, IsAggregateT extends boolean> implements CaseValueBuilder<ValueT, ResultT, UsedRefT, IsAggregateT> {
        private readonly resultMappers;
        private readonly usedRef;
        private readonly ast;
        readonly isAggregate: IsAggregateT;
        constructor(resultMappers: tm.SafeMapper<ResultT>[], usedRef: UsedRefT, ast: CaseValueNode, isAggregate: IsAggregateT);
        when<CompareValueT extends BuiltInExpr<ValueT>, ThenT extends BuiltInExpr<BaseType<ResultT> | null>>(compareValue: CompareValueT, then: ThenT): (CaseValueBuilder<ValueT, ResultT | BuiltInExprUtil.TypeOf<ThenT>, UsedRefUtil.IntersectTryReuseExistingType<UsedRefT | BuiltInExprUtil.IntersectUsedRef<CompareValueT | ThenT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<CompareValueT | ThenT>>);
        end(): ExprImpl<ResultT | null, UsedRefT, IsAggregateT>;
        else<ElseT extends BuiltInExpr<BaseType<ResultT> | null>>(elseResult: ElseT): ({
            end(): ExprImpl<ResultT | BuiltInExprUtil.TypeOf<ElseT>, UsedRefUtil.Intersect<UsedRefT | BuiltInExprUtil.UsedRef<ElseT>>, IsAggregateT | BuiltInExprUtil.IsAggregate<ElseT>>;
        });
    }
}
declare module "expr-library/control-flow/case-value/index" {
    export * from "expr-library/control-flow/case-value/case-value-builder-impl";
    export * from "expr-library/control-flow/case-value/case-value";
    export * from "expr-library/control-flow/case-value/uninitialized-case-value-builder-impl";
}
declare module "expr-library/control-flow/case" {
    import { BuiltInExprUtil, BuiltInExpr } from "built-in-expr/index";
    import { UninitializedCaseValueBuilder } from "expr-library/control-flow/case-value/index";
    import { UninitializedCaseConditionBuilder } from "expr-library/control-flow/case-condition/index";
    import { BaseType } from "type-util/index";
    /**
     * Behaves like a `switch` statement from most programming languages.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * -----
     *
     * This version of the `CASE` expression does not allow `null` values.
     * This reduces the probability of a mistake. Consider,
     * ```sql
     *  SELECT
     *      CASE NULL
     *          WHEN NULL THEN 1
     *          ELSE 2
     *      END
     *  ;
     *  > 2 -- The result is `2` and not `1`
     * ```
     *
     * -----
     *
     * @param valueExpr - The expression to compare against; must not be nullable
     *
     * @see caseValue
     */
    function caseConstructor<ValueExprT extends BuiltInExpr<unknown>>(valueExpr: ValueExprT & BuiltInExprUtil.AssertNonNull<ValueExprT>): (UninitializedCaseValueBuilder<BaseType<BuiltInExprUtil.TypeOf<ValueExprT>>, BuiltInExprUtil.UsedRef<ValueExprT>, BuiltInExprUtil.IsAggregate<ValueExprT>>);
    /**
     * Behaves like an `if` statement from most programming languages.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#operator_case
     * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
     * + https://www.sqlite.org/lang_expr.html#case
     *
     * @see caseCondition
     */
    function caseConstructor(): (UninitializedCaseConditionBuilder);
    export { caseConstructor as case, };
}
declare module "expr-library/control-flow/type-of-coalesce" {
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { PopFront } from "tuple-util/index";
    import { MaxDepth, DecrementMaxDepth } from "tuple-util/trampoline-util";
    /**
     * The state of our `TypeOfCoalesce<>` algorithm.
     */
    interface TypeOfCoalesce_State {
        /**
         * Are we done computing?
         */
        done: boolean;
        /**
         * The tuple to coalesce.
         * Should be an empty tuple if we are `done`.
         */
        arr: readonly AnyBuiltInExpr[];
        /**
         * The result.
         * If we are not `done`, it will only contain a **partial** result.
         */
        result: unknown;
    }
    /**
     * Performs `8` iterations of our `TypeOfCoalesce<>` algorithm.
     * It looks a lot like our naive implementation.
     *
     * The difference is that we only do `8` recursive iterations (to prevent going over the max depth).
     * We also return a `TypeOfCoalesce_State`.
     */
    type TypeOfCoalesce_Bounce<ArrT extends readonly AnyBuiltInExpr[], ResultT extends unknown, MaxDepthT extends number = MaxDepth> = {
        /**
         * Can't perform fancy computation with a regular array
         */
        0: {
            done: true;
            arr: ArrT;
            result: BuiltInExprUtil.TypeOf<ArrT[number]>;
        };
        /**
         * Either the tuple started empty or we have exhausted
         * all elements and not found a non-nullable arg.
         */
        1: {
            done: true;
            arr: ArrT;
            result: ResultT;
        };
        /**
         * We ran out of `MaxDepthT` and haven't completed the computation.
         */
        2: {
            done: false;
            arr: PopFront<ArrT>;
            result: (ResultT | BuiltInExprUtil.TypeOf<ArrT[0]>);
        };
        /**
         * Keep trying to compute the type.
         */
        /**
         * This argument is nullable, keep looking
         */
        3: TypeOfCoalesce_Bounce<PopFront<ArrT>, (ResultT | BuiltInExprUtil.TypeOf<ArrT[0]>), DecrementMaxDepth<MaxDepthT>>;
        /**
         * Keep trying to compute the type.
         */
        /**
         * We have found our non-nullable argument
         */
        4: {
            done: true;
            arr: ArrT;
            result: BuiltInExprUtil.TypeOf<ArrT[0]> | Exclude<ResultT, null>;
        };
    }[number extends ArrT["length"] ? 0 : ArrT["length"] extends 0 ? 1 : MaxDepthT extends 0 ? 2 : null extends BuiltInExprUtil.TypeOf<ArrT[0]> ? 3 : 4];
    /**
     * If we are `done`, we don't need to compute anything else.
     *
     * Performs up to `8` iterations of our `TypeOfCoalesce<>` algorithm.
     */
    type TypeOfCoalesce_Bounce1<StateT extends TypeOfCoalesce_State> = StateT["done"] extends true ? 
    /**
     * Reuse the `StateT` type.
     * Creating fewer unnecessary types is better.
     */
    StateT : 
    /**
     * Iterate.
     */
    TypeOfCoalesce_Bounce<StateT["arr"], StateT["result"]>;
    /**
     * Calls `TypeOfCoalesce_Bounce1<>` 8 times.
     *
     * So, this supports coalescing a tuple less than length `8*8 = 64`
     *
     * There is no real reason why the limit was set to `64`.
     * It could have easily been higher or lower.
     *
     * However, if you are coalescing really large tuples while using this
     * library, you must either be writing **really** large SQL queries
     * or are doing something wrong.
     */
    type TypeOfCoalesce_Trampoline<ArrT extends readonly AnyBuiltInExpr[], ResultT extends unknown> = TypeOfCoalesce_Bounce1<{
        done: false;
        arr: ArrT;
        result: ResultT;
    }> extends infer S0 ? (TypeOfCoalesce_Bounce1<Extract<S0, TypeOfCoalesce_State>> extends infer S1 ? (TypeOfCoalesce_Bounce1<Extract<S1, TypeOfCoalesce_State>> extends infer S2 ? (TypeOfCoalesce_Bounce1<Extract<S2, TypeOfCoalesce_State>> extends infer S3 ? (TypeOfCoalesce_Bounce1<Extract<S3, TypeOfCoalesce_State>> extends infer S4 ? (TypeOfCoalesce_Bounce1<Extract<S4, TypeOfCoalesce_State>> extends infer S5 ? (TypeOfCoalesce_Bounce1<Extract<S5, TypeOfCoalesce_State>> extends infer S6 ? (TypeOfCoalesce_Bounce1<Extract<S6, TypeOfCoalesce_State>> extends infer S7 ? (S7) : never) : never) : never) : never) : never) : never) : never) : never;
    /**
     * `COALESCE()` with zero args is just the `NULL` constant.
     */
    /**
     * Coalesces a tuple.
     *
     * ```ts
     * //type Result = 1|2|3
     * type Result = TypeOfCoalesce<[1|null, 2|null, 3, 4, 5|null, 6]>
     * ```
     *
     * This supports coalescing a tuple less than length `8*8 = 64`
     *
     * There is no real reason why the limit was set to `64`.
     * It could have easily been higher or lower.
     *
     * However, if you are coalescing really large tuples while using this
     * library, you must either be writing **really** large SQL queries
     * or are doing something wrong.
     */
    export type TypeOfCoalesce<ArrT extends readonly AnyBuiltInExpr[], ResultT extends unknown = null> = TypeOfCoalesce_Trampoline<ArrT, ResultT> extends {
        done: infer DoneT;
        result: infer R;
    } ? (DoneT extends true ? R : never) : never;
}
declare module "expr-library/control-flow/coalesce" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { TypeOfCoalesce } from "expr-library/control-flow/type-of-coalesce";
    export type CoalesceExpr<ArgsT extends readonly AnyBuiltInExpr[]> = ExprUtil.Intersect<TypeOfCoalesce<ArgsT>, ArgsT[number]>;
    export function coalesceMapper<ArgsT extends readonly AnyBuiltInExpr[]>(...args: ArgsT): tm.SafeMapper<TypeOfCoalesce<ArgsT>>;
    /**
     * Returns the first non-`NULL` value in the list,
     * or `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
     * + https://www.postgresql.org/docs/9.5/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#coalesce
     *
     * -----
     *
     * + MySQL        : `COALESCE(x, ...)`
     * + PostgreSQL   : `COALESCE(x, ...)`
     * + SQLite       : `COALESCE(x, ...)`
     *
     * -----
     *
     * `COALESCE()` with zero args is just the `NULL` constant.
     */
    export function coalesce<ArgsT extends readonly AnyBuiltInExpr[]>(...args: ArgsT): (CoalesceExpr<ArgsT>);
}
declare module "expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table" {
    import { ITable, TableUtil } from "table/index";
    import { ColumnMapUtil } from "column-map/index";
    import { KeyUtil } from "key/index";
    import { UnionToIntersection, PickMulti } from "type-util/index";
    import { CompileError } from "compile-error/index";
    import { IColumn } from "column/index";
    export type AssertNullSafeComparableToCandidateKeysOfTableImpl<SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "columns" | "candidateKeys">, SrcColumnsT extends readonly IColumn[]> = KeyUtil.ExcludeIfInKeyArray<KeyUtil.FromColumnArray<SrcColumnsT>, TableUtil.ExtractCandidateKeysWithColumnAliasInOneOfColumnArray<DstT, SrcColumnsT>[]> extends never ? Extract<UnionToIntersection<SrcColumnsT extends SrcColumnsT ? [ColumnMapUtil.AssertIsNullSafeComparableIfSameOwnEnumerableKeys_NonUnion<ColumnMapUtil.FromColumnArray<SrcColumnsT>, PickMulti<DstT["columns"], KeyUtil.ExtractIfInKeyArray<KeyUtil.FromColumnArray<SrcColumnsT>, TableUtil.ExtractCandidateKeysWithColumnAliasInOneOfColumnArray<DstT, SrcColumnsT>[]>>>] : never>, [unknown]>[0] : CompileError<[KeyUtil.ToErrorMessageFriendlyType<KeyUtil.ExcludeIfInKeyArray<KeyUtil.FromColumnArray<SrcColumnsT>, TableUtil.ExtractCandidateKeysWithColumnAliasInOneOfColumnArray<DstT, SrcColumnsT>[]>>, "is invalid candidate key; expecting one of", KeyUtil.ToErrorMessageFriendlyType<
    /**
     * We use this type for better error message reporting.
     */
    TableUtil.ExtractCandidateKeysWithColumnAliasInTable_Input<DstT, SrcT>>]>;
    /**
     * + Assumes `SrcT` may be a union
     * + Assumes `DstT` may be a union
     * + Assumes `SrcColumnsT` may be a union
     * + Assumes `SrcColumnsT` is only ever built by using the arguments of `EqCandidateKeyOfTableDelegate`
     */
    export type AssertNullSafeComparableToCandidateKeysOfTable<SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "columns" | "candidateKeys">, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>> = AssertNullSafeComparableToCandidateKeysOfTableImpl<SrcT, DstT, SrcColumnsT>;
    export function assertNullSafeComparableToCandidateKeysOfTable<SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "columns" | "candidateKeys">, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(src: SrcT, dst: DstT, srcColumns: SrcColumnsT): (DstT["candidateKeys"][number]);
}
declare module "expr-library/logical/and" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     *
     * This version of the `AND` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link and3}
     */
    export const and: ChainableOperator<boolean>;
}
declare module "expr-library/logical/is-not-null-and" {
    import * as tm from "type-mapping";
    import { IColumn, ColumnUtil } from "column/index";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { Expr } from "expr/expr-impl";
    import { AssertNonUnion } from "type-util/index";
    import { UsedRefUtil } from "used-ref/index";
    export function isNotNullAnd<ColumnT extends IColumn, BuiltInExprT extends BuiltInExpr<boolean>>(column: ColumnT & AssertNonUnion<ColumnT>, builtInExprDelegate: (narrowedColumns: {
        [columnAlias in ColumnT["columnAlias"]]: ColumnUtil.ToNonNullable<ColumnT>;
    }) => BuiltInExprT): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: (UsedRefUtil.WithValue<BuiltInExprUtil.IntersectUsedRef<ColumnT | BuiltInExprT>, ColumnT["tableAlias"], ColumnT["columnAlias"], tm.OutputOf<ColumnT["mapper"]>>);
        isAggregate: BuiltInExprUtil.IsAggregate<ColumnT | BuiltInExprT>;
    }>);
}
declare module "expr-library/logical/or" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     *
     * This version of the `OR` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link or3}
     */
    export const or: ChainableOperator<boolean>;
}
declare module "expr-library/logical/is-null-or" {
    import * as tm from "type-mapping";
    import { IColumn, ColumnUtil } from "column/index";
    import { BuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { Expr } from "expr/expr-impl";
    import { AssertNonUnion } from "type-util/index";
    import { UsedRefUtil } from "used-ref/index";
    export function isNullOr<ColumnT extends IColumn, BuiltInExprT extends BuiltInExpr<boolean>>(column: ColumnT & AssertNonUnion<ColumnT>, builtInExprDelegate: (narrowedColumns: {
        [columnAlias in ColumnT["columnAlias"]]: ColumnUtil.ToNonNullable<ColumnT>;
    }) => BuiltInExprT): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: (UsedRefUtil.WithValue<BuiltInExprUtil.IntersectUsedRef<ColumnT | BuiltInExprT>, ColumnT["tableAlias"], ColumnT["columnAlias"], tm.OutputOf<ColumnT["mapper"]>>);
        isAggregate: BuiltInExprUtil.IsAggregate<ColumnT | BuiltInExprT>;
    }>);
}
declare module "expr-library/logical/not" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     *
     * This version of the `NOT` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link not3}
     */
    export const not: Operator1<boolean, boolean>;
}
declare module "expr-library/logical/xor" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * This version of the `XOR` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link xor3}
     */
    export const xor: Operator2<boolean, boolean, boolean>;
}
declare module "expr-library/logical/index" {
    export * from "expr-library/logical/and";
    export * from "expr-library/logical/is-not-null-and";
    export * from "expr-library/logical/is-null-or";
    export * from "expr-library/logical/not";
    export * from "expr-library/logical/or";
    export * from "expr-library/logical/xor";
}
declare module "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-keys-of-table-delegate" {
    import { ITable, TableUtil } from "table/index";
    import { AssertNullSafeComparableToCandidateKeysOfTable } from "expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table";
    import { Merge } from "type-util/index";
    export type EqCandidateKeyOfTableDelegate<SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "columns" | "candidateKeys">, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>> = (columns: Merge<Pick<SrcT["columns"], TableUtil.ExtractCandidateKeysWithColumnAliasInTable_Input<DstT, SrcT>[number]>>) => (SrcColumnsT & AssertNullSafeComparableToCandidateKeysOfTable<SrcT, DstT, SrcColumnsT>);
}
declare module "expr-library/null-safe-equation/null-safe-eq" {
    import { NullSafeEquation2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     *
     * This operator allows `NULL`.
     *
     * This operator performs an equality comparison like the `=` operator,
     * but returns
     * + `true` rather than `NULL` if both operands are `NULL`, and
     * + `false` rather than `NULL` if one operand is `NULL`.
     *
     * For regular equality, @see {@link eq}
     */
    export const nullSafeEq: NullSafeEquation2;
}
declare module "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table" {
    import * as tm from "type-mapping";
    import { ITable, TableUtil } from "table/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { EqCandidateKeyOfTableDelegate } from "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-keys-of-table-delegate";
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.and(
     *          tsql.nullSafeEq(src.dstCk0, dst.dstCk0),
     *          tsql.nullSafeEq(src.dstCk1, dst.dstCk1),
     *          tsql.nullSafeEq(src.dstCk2, dst.dstCk2),
     *          //etc.
     *      ));
     * ```
     * -----
     *
     * + The `src` does not need to have keys.
     * + The `dst` must have at least one candidate key.
     * + The `src` must have columns **null-safe** comparable to columns of `dst`'s candidate key.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because `src.dstCkX` and `dst.dstCkX` may have nullable columns.
     *
     * @param src - A table that does not need keys
     * @param dst - The table with at least one candidate key to compare against
     * @param eqCandidateKeyOfTableDelegate - A function that returns columns from `src` matching columns of `dst`
     */
    export type EqCandidateKeyOfTable = <SrcT extends Pick<ITable, "columns">, DstT extends Pick<ITable, "columns" | "candidateKeys">, SrcColumnsT extends TableUtil.ColumnArraysFromCandidateKeys<SrcT, DstT>>(src: SrcT, dst: DstT, eqCandidateKeyOfTableDelegate: EqCandidateKeyOfTableDelegate<SrcT, DstT, SrcColumnsT>) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<SrcT["columns"] | DstT["columns"]>;
        isAggregate: false;
    }>);
    export const eqCandidateKeyOfTable: EqCandidateKeyOfTable;
}
declare module "expr-library/null-safe-equation/eq-candidate-key-of-table/index" {
    export * from "expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table";
    export * from "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table";
    export * from "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-keys-of-table-delegate";
}
declare module "expr-library/null-safe-equation/eq-candidate-key" {
    import * as tm from "type-mapping";
    import { ITable } from "table/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { CandidateKey_Input } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.nullSafeEq(candidateKeyColumn0, value0),
     *      tsql.nullSafeEq(candidateKeyColumn1, value1),
     *      tsql.nullSafeEq(candidateKeyColumn2, value2)
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Excess properties are especially dangerous for this function.
     *
     * If your `candidateKeyInput` is actually a super key of two candidate keys,
     * then the candidate key this function compares against is arbitrary.
     *
     * The extra properties will be discarded.
     *
     * If you want to compare against a super key, use `eqSuperKey()` instead.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because the candidate key of a table
     * may have nullable columns.
     *
     * @param table - The table with a candidate key
     * @param candidateKeyInput - The candidate key values to compare against
     *
     * @todo Maybe call it `nullSafeEqCandidateKey()` instead?
     * It doesn't use `eq()` at all. It uses `nullSafeEq()`.
     *
     * @todo Maybe have it use `eq()` for columns we know are non-nullable
     * and use `nullSafeEq()` for columns that are nullable?
     */
    export type EqCandidateKey = (<TableT extends Pick<ITable, "columns" | "candidateKeys" | "primaryKey">>(table: TableT, candidateKeyInput: StrictUnion<CandidateKey_Input<TableT>>) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<TableT["columns"]>;
        isAggregate: false;
    }>));
    export const eqCandidateKey: EqCandidateKey;
}
declare module "expr-library/null-safe-equation/eq-columns" {
    import * as tm from "type-mapping";
    import { ITable } from "table/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { PartialRow_Input } from "partial-row/index";
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.nullSafeEq(column0, value0),
     *      tsql.nullSafeEq(column1, value1),
     *      tsql.nullSafeEq(column2, value2),
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because a table
     * may have nullable columns.
     *
     * @param table - The table
     * @param columnsInput - The column values to compare against
     *
     * @todo Maybe call it `nullSafeEqColumns()` instead?
     * It doesn't use `eq()` at all. It uses `nullSafeEq()`.
     *
     * @todo Maybe have it use `eq()` for columns we know are non-nullable
     * and use `nullSafeEq()` for columns that are nullable?
     */
    export type EqColumns = (<TableT extends Pick<ITable, "columns">>(table: TableT, columnsInput: PartialRow_Input<TableT>) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<TableT["columns"]>;
        isAggregate: false;
    }>));
    export const eqColumns: EqColumns;
}
declare module "expr-library/null-safe-equation/eq-primary-key-of-table" {
    import * as tm from "type-mapping";
    import { TableWithPrimaryKey, ITable, TableUtil } from "table/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.and(
     *          tsql.nullSafeEq(src.dstPk0, dst.dstPk0),
     *          tsql.nullSafeEq(src.dstPk1, dst.dstPk1),
     *          tsql.nullSafeEq(src.dstPk2, dst.dstPk2),
     *          //etc.
     *      ));
     * ```
     * -----
     *
     * + The `src` does not need to have keys.
     * + The `dst` must have a primary key.
     * + The `src` must have columns **null-safe** comparable to columns of `dst`'s primary key.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because `src.dstPkX` may have nullable columns.
     *
     * @param src - A table that does not need keys
     * @param dst - The table with a primary key to compare against
     */
    export type EqPrimaryKeyOfTable = <SrcT extends Pick<ITable, "columns">, DstT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">>(src: SrcT, dst: (DstT & TableUtil.AssertHasNullSafeComparablePrimaryKey<DstT, SrcT["columns"]>)) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<SrcT["columns"] | DstT["columns"]>;
        isAggregate: false;
    }>);
    export const eqPrimaryKeyOfTable: EqPrimaryKeyOfTable;
}
declare module "expr-library/null-safe-equation/eq-super-key" {
    import * as tm from "type-mapping";
    import { ITable } from "table/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { SuperKey_Input } from "super-key/index";
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.nullSafeEq(candidateKeyColumn0, value0),
     *      tsql.nullSafeEq(candidateKeyColumn1, value1),
     *      tsql.nullSafeEq(candidateKeyColumn2, value2),
     *      tsql.nullSafeEq(nonCandidateKeyColumn0, value3),
     *      tsql.nullSafeEq(nonCandidateKeyColumn1, value4),
     *      tsql.nullSafeEq(nonCandidateKeyColumn2, value5),
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because the super key of a table
     * may have nullable columns.
     *
     * @param table - The table with a candidate key
     * @param superKeyInput - The super key values to compare against
     *
     * @todo Maybe call it `nullSafeEqSuperKey()` instead?
     * It doesn't use `eq()` at all. It uses `nullSafeEq()`.
     *
     * @todo Maybe have it use `eq()` for columns we know are non-nullable
     * and use `nullSafeEq()` for columns that are nullable?
     */
    export type EqSuperKey = <TableT extends Pick<ITable, "columns" | "candidateKeys">>(table: TableT, superKeyInput: SuperKey_Input<TableT>) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<TableT["columns"]>;
        isAggregate: false;
    }>);
    export const eqSuperKey: EqSuperKey;
}
declare module "expr-library/null-safe-equation/is-not-null" {
    import { NullSafeEquation1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     *
     * Tests whether a value is not `NULL`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT NULL), (0 IS NOT NULL), (NULL IS NOT NULL);
     *         -> 1, 1, 0
     * ```
     */
    export const isNotNull: NullSafeEquation1;
}
declare module "expr-library/null-safe-equation/is-null" {
    import { NullSafeEquation1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null
     *
     * Tests whether a value is NULL.
     *
     * ```sql
     * mysql> SELECT (1 IS NULL), (0 IS NULL), (NULL IS NULL);
     *         -> 0, 0, 1
     * ```
     */
    export const isNull: NullSafeEquation1;
}
declare module "expr-library/null-safe-equation/not-null-safe-eq" {
    import { NullSafeEquation2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     *
     * This operator allows `NULL`.
     *
     * This operator performs an equality comparison like the `=` operator,
     * but returns
     * + `false` rather than `NULL` if both operands are `NULL`, and
     * + `true` rather than `NULL` if one operand is `NULL`.
     *
     * For regular equality, @see {@link eq}
     */
    export const notNullSafeEq: NullSafeEquation2;
}
declare module "expr-library/null-safe-equation/index" {
    export * from "expr-library/null-safe-equation/eq-candidate-key-of-table/index";
    export * from "expr-library/null-safe-equation/eq-candidate-key";
    export * from "expr-library/null-safe-equation/eq-columns";
    export * from "expr-library/null-safe-equation/eq-primary-key-of-table";
    export * from "expr-library/null-safe-equation/eq-super-key";
    export * from "expr-library/null-safe-equation/is-not-null";
    export * from "expr-library/null-safe-equation/is-null";
    export * from "expr-library/null-safe-equation/not-null-safe-eq";
    export * from "expr-library/null-safe-equation/null-safe-eq";
}
declare module "expr-library/control-flow/if" {
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { BaseType } from "type-util/index";
    /**
     * Behaves like an `if-else` statement from most programming languages.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
     *
     * -----
     *
     * + MySQL        : `IF(x, y, z)`
     * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
     * + SQLite       : `CASE WHEN x THEN y ELSE z END`
     *
     * -----
     *
     * @param condition - The boolean expression to evaluate
     * @param then - The result if `condition` is `true`
     * @param elseResult - The result if `condition` is `false`
     *
     * @see caseCondition
     */
    function ifConstructor<ConditionT extends BuiltInExpr<boolean>, ThenT extends AnyBuiltInExpr, ElseT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<ThenT>> | null>>(condition: ConditionT, then: ThenT, elseResult: ElseT): (ExprUtil.Intersect<BuiltInExprUtil.TypeOf<ThenT | ElseT>, ConditionT | ThenT | ElseT>);
    export { ifConstructor as if, };
}
declare module "expr-library/control-flow/if-is-null" {
    import * as tm from "type-mapping";
    import { IColumn, ColumnUtil } from "column/index";
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { Expr } from "expr/expr-impl";
    import { AssertNonUnion, BaseType } from "type-util/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * A special compile-time type-narrowing function.
     *
     * Narrows a column from `T|null` to `T` in the else-branch.
     *
     * Translated to SQL, we get,
     * ```sql
     *  IF(
     *      myColumn IS NULL,
     *      thenExpr,
     *      -- The `elseExpr` is free to use `myColumn` as a non-nullable column
     *      -- because we know `myColumn` is NOT NULL in the else-branch.
     *      elseExpr
     *  )
     * ```
     *
     *
     * @param column - The column to narrow from `T|null` to `T`
     * @param then - The result of the expression, if the `column` is `null`
     * @param elseDelegate - The result of the expression, if the `column` is `T`
     */
    export function ifIsNull<ColumnT extends IColumn, ThenT extends AnyBuiltInExpr, ElseT extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<ThenT>> | null>>(column: ColumnT & AssertNonUnion<ColumnT>, then: ThenT, elseDelegate: (narrowedColumns: {
        [columnAlias in ColumnT["columnAlias"]]: ColumnUtil.ToNonNullable<ColumnT>;
    }) => ElseT): (Expr<{
        mapper: tm.SafeMapper<BuiltInExprUtil.TypeOf<ThenT | ElseT>>;
        usedRef: (UsedRefUtil.IntersectTryReuseExistingType<BuiltInExprUtil.UsedRef<ThenT> | UsedRefUtil.WithValue<BuiltInExprUtil.IntersectUsedRef<ColumnT | ElseT>, ColumnT["tableAlias"], ColumnT["columnAlias"], tm.OutputOf<ColumnT["mapper"]>>>);
        isAggregate: BuiltInExprUtil.IsAggregate<ColumnT | ThenT | ElseT>;
    }>);
}
declare module "expr-library/control-flow/if-null" {
    import { AnyBuiltInExpr, BuiltInExprUtil, BuiltInExpr } from "built-in-expr/index";
    import { CoalesceExpr } from "expr-library/control-flow/coalesce";
    import { BaseType } from "type-util/index";
    /**
     * Equivalent to `COALESCE()` with two arguments.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#ifnull
     *
     * -----
     *
     * `COALESCE()` is part of the SQL standard.
     * `IFNULL()` is DB-specific.
     *
     * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
     *
     * -----
     *
     * + MySQL        : `IFNULL(x, y)`
     * + PostgreSQL   : `COALESCE(x, y)`
     * + SQLite       : `IFNULL(x, y)`
     *
     * -----
     *
     * @see coalesce
     */
    export function ifNull<Arg0T extends AnyBuiltInExpr, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>> | null>>(arg0: Arg0T, arg1: Arg1T): (CoalesceExpr<[Arg0T, Arg1T]>);
}
declare module "expr-library/control-flow/null-if" {
    import { BuiltInExprUtil, BuiltInExpr, AnyBuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    import { BaseType } from "type-util/index";
    /**
     * Returns `null` if both arguments are null-safe equal.
     *
     * Otherwise, returns the first argument.
     *
     * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * @see nullIfEqual
     */
    export function nullIf<Arg0T extends AnyBuiltInExpr, Arg1T extends BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>> | null>>(arg0: Arg0T, arg1: Arg1T): (ExprUtil.Intersect<BuiltInExprUtil.TypeOf<Arg0T> | null, Arg0T | Arg1T>);
    /**
     * Synonym for `NULLIF(x, y)`.
     *
     * Returns `null` if both arguments are null-safe equal.
     *
     * Otherwise, returns the first argument.
     *
     * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * @see nullIf
     */
    export const nullIfEqual: typeof nullIf;
}
declare module "expr-library/control-flow/index" {
    export * from "expr-library/control-flow/case-condition/index";
    export * from "expr-library/control-flow/case-value/index";
    export * from "expr-library/control-flow/case";
    export * from "expr-library/control-flow/coalesce";
    export * from "expr-library/control-flow/if-is-null";
    export * from "expr-library/control-flow/if-null";
    export * from "expr-library/control-flow/if";
    export * from "expr-library/control-flow/null-if";
    export * from "expr-library/control-flow/type-of-coalesce";
}
declare module "expr-library/date-time/current-date" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns the current date.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_DATE()`
     * + PostgreSQL     : `CURRENT_DATE()`
     * + SQLite         : `strftime('%Y-%m-%d', 'now')`
     *
     * -----
     *
     * Sets hour, minute, second, millisecond to zero.
     */
    export const currentDate: Operator0<Date>;
}
declare module "expr-library/date-time/current-timestamp" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns the current date-time, accurate to 1-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(0)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
     */
    export const currentTimestamp0: Operator0<Date>;
    /**
     * Returns the current date-time, accurate to 0.1-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(1)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
     */
    export const currentTimestamp1: Operator0<Date>;
    /**
     * Returns the current date-time, accurate to 0.01-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(2)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
     */
    export const currentTimestamp2: Operator0<Date>;
    /**
     * Returns the current date-time, accurate to 0.001-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(3)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
     */
    export const currentTimestamp3: Operator0<Date>;
}
declare module "expr-library/date-time/extract" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Extracts the second from a date-time, including fractional seconds; accurate to 0.001 second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * Behaviour is not defined when using 0.0001 second precision (or more precise).
     * SQLite may alternate between truncating and rounding.
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000e0) / 1000e0`
     * ```sql
     *  SELECT
     *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
     *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
     *  > 32.456
     * ```
     * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
     * + SQLite         : `CAST(strftime('%f', datetime) AS DOUBLE)`
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 14:45:32.456789')
     *  > 32.457
     *  -- The result is rounded, not truncated.
     *  -- If it were truncated, we would get 32.456
     * ```
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 23:59:59.999999')
     *  > 59.999
     *  -- The result is truncated, not rounded.
     *  -- If it were rounded, we would get 60
     * ```
     *
     * @todo Make behaviour consistent?
     */
    export const extractFractionalSecond3: Operator1<Date, number>;
    /**
     * Extracts the second from a date-time, truncating fractional seconds.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime)`
     * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
     */
    export const extractIntegerSecond: Operator1<Date, bigint>;
    /**
     * Extracts the minute from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
     */
    export const extractMinute: Operator1<Date, bigint>;
    /**
     * Extracts the hour from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(HOUR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
     */
    export const extractHour: Operator1<Date, bigint>;
    /**
     * Extracts the day (of the month) from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(DAY FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
     */
    export const extractDay: Operator1<Date, bigint>;
    /**
     * Extracts the month from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MONTH FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
     */
    export const extractMonth: Operator1<Date, bigint>;
    /**
     * Extracts the year from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(YEAR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
     */
    export const extractYear: Operator1<Date, bigint>;
}
declare module "expr-library/date-time/last-day" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the date of the last day of the month.
     *
     * Sets hour, minute, second, fractional second to zero.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
     *
     * -----
     *
     * + MySQL          : `LAST_DAY(datetime)`
     * ```sql
     *  SELECT
     *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
     *  > 2010-03-31
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SELECT
     *      (
     *          datetime +
     *          interval '1 month' -
     *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
     *      )::date
     * > 2010-03-31T00:00:00.000Z
     * ```
     * + SQLite         :
     * ```sql
     *  SELECT
     *      strftime(
     *          '%Y-%m-%d',
     *          '2010-03-27 14:45:32.456789',
     *          '+1 month',
     *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
     *      )
     *  > 2010-03-31
     * ```
     */
    export const lastDay: Operator1<Date, Date>;
}
declare module "expr-library/date-time/timestamp-add" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Adds the specified number of milliseconds to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MICROSECOND, x*1000, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      (x/1000e0) || ' second'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of milliseconds to add; following MySQL convention
     * @param right - The date-time to add milliseconds to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddMillisecond: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of seconds to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' second'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of seconds to add; following MySQL convention
     * @param right - The date-time to add seconds to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddSecond: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of minutes to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MINUTE, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' minute'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of minutes to add; following MySQL convention
     * @param right - The date-time to add minutes to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddMinute: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of hours to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(HOUR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' hour'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of hours to add; following MySQL convention
     * @param right - The date-time to add hours to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddHour: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of days to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(DAY, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' day'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of days to add; following MySQL convention
     * @param right - The date-time to add days to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddDay: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of months to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
     * + SQLite         : Complicated implementation.
     *
     * -----
     *
     * @param left - The number of months to add; following MySQL convention
     * @param right - The date-time to add months to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddMonth: Operator2<bigint, Date, Date | null>;
    /**
     * Adds the specified number of years to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' year'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of years to add; following MySQL convention
     * @param right - The date-time to add years to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    export const timestampAddYear: Operator2<bigint, Date, Date | null>;
}
declare module "expr-library/date-time/timestamp-diff" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the number of milliseconds between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in milliseconds
     */
    export const timestampDiffMillisecond: Operator2<Date, Date, bigint>;
    /**
     * Returns the number of seconds between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in seconds
     */
    export const timestampDiffSecond: Operator2<Date, Date, bigint>;
    /**
     * Returns the number of minutes between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in minutes
     */
    export const timestampDiffMinute: Operator2<Date, Date, bigint>;
    /**
     * Returns the number of hours between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in hours
     */
    export const timestampDiffHour: Operator2<Date, Date, bigint>;
    /**
     * Returns the number of days between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
     * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in days
     */
    export const timestampDiffDay: Operator2<Date, Date, bigint>;
}
declare module "expr-library/date-time/unix-timestamp-now" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP()`
     * + PostgreSQL     :
     * ```sql
     *  FLOOR(
     *      EXTRACT(EPOCH FROM (
     *          CURRENT_TIMESTAMP -
     *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
     *      ))
     *  )
     * ```
     * + SQLite         : `strftime('%s', 'now')`
     */
    export const unixTimestampNow: Operator0<bigint>;
}
declare module "expr-library/date-time/utc-string-to-timestamp" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     *
     * -----
     *
     * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
     *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
     *  > 1969-12-31 22:00:00.123
     *  > 10800
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
     *          )
     *      ))
     *  > 1970-01-01T03:00:00.123Z
     *  > 10800
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
     *  > 1970-01-01 03:00:00.123
     *  > 10800
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `UTC` timestamp.
     *
     */
    export const utcStringToTimestamp: Operator1<string, Date | null>;
}
declare module "expr-library/date-time/index" {
    export * from "expr-library/date-time/current-date";
    export * from "expr-library/date-time/current-timestamp";
    export * from "expr-library/date-time/extract";
    export * from "expr-library/date-time/last-day";
    export * from "expr-library/date-time/timestamp-add";
    export * from "expr-library/date-time/timestamp-diff";
    export * from "expr-library/date-time/unix-timestamp-now";
    export * from "expr-library/date-time/utc-string-to-timestamp";
}
declare module "expr-library/equation/eq" {
    import { Equation2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
     *
     * This version of the `=` operator prevents `NULL`.
     *
     * For null-safe equality, @see {@link nullSafeEq}
     */
    export const eq: Equation2;
}
declare module "expr-library/equation/eq-primary-key" {
    import * as tm from "type-mapping";
    import { TableWithPrimaryKey } from "table/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.eq(primaryKeyColumn0, value0),
     *      tsql.eq(primaryKeyColumn1, value1),
     *      tsql.eq(primaryKeyColumn2, value2)
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Uses `eq()` internally because the primary key of a table
     * cannot have nullable columns.
     *
     * @todo Change this to use `nullSafeEq()` jusssst in case people start using
     * nullable columns in PKs for whatever reason?
     *
     * @param table - The table with a primary key
     * @param primaryKeyInput - The primary key values to compare against
     */
    export function eqPrimaryKey<TableT extends Pick<TableWithPrimaryKey, "columns" | "primaryKey">>(table: TableT, primaryKeyInput: PrimaryKey_Input<TableT>): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<TableT["columns"]>;
        isAggregate: false;
    }>);
}
declare module "expr-library/equation/in-array" {
    import { Equation1ToNReturn } from "expr-library/factory/index";
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { BaseType } from "type-util/index";
    /**
     * The `IN` operator has two overloads.
     * + `x IN (y0, y1, y2, y3, ...)`
     * + `x IN (SELECT y FROM ...)`
     *
     * This implementation is for the first overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
     *
     * The array cannot contain `null` because,
     * + `x IN (NULL)` is `NULL`
     * + `1 IN (NULL, 2)` is `NULL`
     * + `1 IN (NULL, 2, 1)` is `true`
     *
     * -----
     *
     * Calling `inArray()` with an empty array will always
     * return `false` because a value is never in an array of zero elements.
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     */
    export function inArray<Arg0T extends AnyBuiltInExpr, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T & BuiltInExprUtil.AssertNonNull<Arg0T>, args: ArgsT): (Equation1ToNReturn<Arg0T, ArgsT>);
}
declare module "expr-library/equation/in-query" {
    import * as tm from "type-mapping";
    import { QueryBaseUtil } from "query-base/index";
    import { Expr } from "expr/index";
    import { BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { BaseType } from "type-util/index";
    /**
     * The `IN` operator has two overloads.
     * + `x IN (y0, y1, y2, y3, ...)`
     * + `x IN (SELECT y FROM ...)`
     *
     * This implementation is for the second overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
     *
     * The query argument cannot `SELECT` `null` because,
     * + `x IN (SELECT NULL)` is `NULL`
     * + `x IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
     *   + At least one row has a `NULL` value
     *   + No rows have the value `x`
     * + `x IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
     *   + No rows have the value `x`
     * + `1 IN (SELECT NULL UNION SELECT 1)` is `true`
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     *
     * -----
     *
     * ### Problems with MySQL
     *
     * The following produced an error,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 IN (SELECT id FROM myTable LIMIT 1);
     * ```
     *
     * The following is a workaround,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
     * ```
     */
    export function inQuery<BuiltInExprT extends AnyBuiltInExpr, QueryT extends QueryBaseUtil.OneSelectItem<BaseType<BuiltInExprUtil.TypeOf<BuiltInExprT>>>>(builtInExpr: BuiltInExprT & BuiltInExprUtil.AssertNonNull<BuiltInExprT>, query: QueryT): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<BuiltInExprT | QueryT>;
        isAggregate: BuiltInExprUtil.IsAggregate<BuiltInExprT>;
    }>);
}
declare module "expr-library/equation/not-eq" {
    import { Equation2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
     *
     * This version of the `<>` operator prevents `NULL`.
     *
     * For null-safe inequality, @see {@link nullSafeNotEq}
     *
     */
    export const notEq: Equation2;
}
declare module "expr-library/equation/not-in-array" {
    /**
     * @todo Refactor `inArray()` and `notInArray()` so they can share code.
     * Something like a `makeInArray()` factory function.
     */
    import { Equation1ToNReturn } from "expr-library/factory/index";
    import { BuiltInExpr, BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { BaseType } from "type-util/index";
    /**
     * The `NOT IN` operator has two overloads.
     * + `x NOT IN (y0, y1, y2, y3, ...)`
     * + `x NOT IN (SELECT y FROM ...)`
     *
     * This implementation is for the first overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
     *
     * The array cannot contain `null` because,
     * + `x NOT IN (NULL)` is `NULL`
     * + `1 NOT IN (NULL, 2)` is `NULL`
     * + `1 NOT IN (NULL, 2, 1)` is `false`
     *
     * -----
     *
     * Calling `notInArray()` with an empty array will always
     * return `true` because a value is always **not** in an array of zero elements.
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     */
    export function notInArray<Arg0T extends AnyBuiltInExpr, ArgsT extends readonly BuiltInExpr<BaseType<BuiltInExprUtil.TypeOf<Arg0T>>>[]>(arg0: Arg0T & BuiltInExprUtil.AssertNonNull<Arg0T>, args: ArgsT): (Equation1ToNReturn<Arg0T, ArgsT>);
}
declare module "expr-library/equation/not-in-query" {
    /**
     * @todo Refactor `inQuery()` and `notInQuery()` so they can share code.
     * Something like a `makeInQuery()` factory function.
     */
    import * as tm from "type-mapping";
    import { QueryBaseUtil } from "query-base/index";
    import { Expr } from "expr/index";
    import { BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { BaseType } from "type-util/index";
    /**
     * The `NOT IN` operator has two overloads.
     * + `x NOT IN (y0, y1, y2, y3, ...)`
     * + `x NOT IN (SELECT y FROM ...)`
     *
     * This implementation is for the second overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
     *
     * The query argument cannot `SELECT` `null` because,
     * + `x NOT IN (SELECT NULL)` is `NULL`
     * + `x NOT IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
     *   + At least one row has a `NULL` value
     *   + No rows have the value `x`
     * + `x NOT IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
     *   + No rows have the value `x`
     * + `1 NOT IN (SELECT NULL UNION SELECT 1)` is `false`
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     *
     * -----
     *
     * ### Problems with MySQL
     *
     * The following produced an error,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 NOT IN (SELECT id FROM myTable LIMIT 1);
     * ```
     *
     * The following is a workaround,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 NOT IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
     * ```
     */
    export function notInQuery<BuiltInExprT extends AnyBuiltInExpr, QueryT extends QueryBaseUtil.OneSelectItem<BaseType<BuiltInExprUtil.TypeOf<BuiltInExprT>>>>(builtInExpr: BuiltInExprT & BuiltInExprUtil.AssertNonNull<BuiltInExprT>, query: QueryT): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<BuiltInExprT | QueryT>;
        isAggregate: BuiltInExprUtil.IsAggregate<BuiltInExprT>;
    }>);
}
declare module "expr-library/equation/index" {
    export * from "expr-library/equation/eq-primary-key";
    export * from "expr-library/equation/eq";
    export * from "expr-library/equation/in-array";
    export * from "expr-library/equation/in-query";
    export * from "expr-library/equation/not-eq";
    export * from "expr-library/equation/not-in-array";
    export * from "expr-library/equation/not-in-query";
}
declare module "expr-library/information/current-schema" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns the default (current) schema name as a string.
     * If there is no default schema, returns `NULL`.
     *
     * -----
     *
     * MySQL does not make a distinction between "database" and "schema".
     * PostgreSQL does.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://www.sqlite.org/lang_attach.html
     *
     * -----
     *
     * + MySQL      : `DATABASE()`
     * + PostgreSQL : `CURRENT_SCHEMA`
     * + SQLite     : `'main'` should always be the current database.
     *   + There's also `'temp'`, I guess
     */
    export const currentSchema: Operator0<string | null>;
}
declare module "expr-library/information/current-user" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * On MySQL,
     * > Returns the user name and host name combination for the MySQL account
     * > that the server used to authenticate the current client.
     * > This account determines your access privileges.
     *
     * -----
     *
     * On PostgreSQL,
     * > the user identifier that is applicable for permission checking.
     * > The SQL standard draws a distinction between current_role and current_user,
     * > but PostgreSQL does not, since it unifies users and roles into a single kind of entity.
     *
     * -----
     *
     * SQLite does not have the concept of users.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
     *
     * -----
     *
     * + MySQL      : `CURRENT_USER`
     *   + MySQL has a `USER()` function that does something different.
     * + PostgreSQL : `CURRENT_USER`
     * + SQLite     : None. It does not make sense to ask what the current user is.
     */
    export const currentUser: Operator0<string | null>;
}
declare module "expr-library/information/index" {
    export * from "expr-library/information/current-schema";
    export * from "expr-library/information/current-user";
}
declare module "expr-library/logical-3/and-3" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     *
     * This version of the `AND` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link and}
     */
    export const and3: ChainableOperator<boolean | null>;
}
declare module "expr-library/logical-3/is-false" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `FALSE`.
     *
     * ```sql
     * mysql> SELECT (1 IS FALSE), (0 IS FALSE), (NULL IS FALSE);
     *         -> 0, 1, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS FALSE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isFalse: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/is-not-false" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `FALSE`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT FALSE), (0 IS NOT FALSE), (NULL IS NOT FALSE);
     *         -> 1, 0, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS NOT FALSE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isNotFalse: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/is-not-true" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `TRUE`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT TRUE), (0 IS NOT TRUE), (NULL IS NOT TRUE);
     *         -> 0, 1, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(1 IS NOT TRUE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isNotTrue: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/is-not-unknown" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `UNKNOWN`.
     * Basically an alias for `IS NOT NULL`
     *
     * ```sql
     * mysql> SELECT (1 IS NOT UNKNOWN), (0 IS NOT UNKNOWN), (NULL IS NOT UNKNOWN);
     *         -> 1, 1, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS NOT UNKNOWN)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isNotUnknown: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/is-true" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `TRUE`.
     *
     * ```sql
     * mysql> SELECT (1 IS TRUE), (0 IS TRUE), (NULL IS TRUE);
     *         -> 1, 0, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(1 IS TRUE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isTrue: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/is-unknown" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `UNKNOWN`.
     * Basically an alias for `IS NULL`
     *
     * ```sql
     * mysql> SELECT (1 IS UNKNOWN), (0 IS UNKNOWN), (NULL IS UNKNOWN);
     *         -> 0, 0, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS UNKNOWN)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    export const isUnknown: Operator1<boolean | null, boolean>;
}
declare module "expr-library/logical-3/not-3" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     *
     * This version of the `NOT` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link not}
     */
    export const not3: Operator1<boolean | null, boolean | null>;
}
declare module "expr-library/logical-3/or-3" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     *
     * This version of the `OR` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link or}
     */
    export const or3: ChainableOperator<boolean | null>;
}
declare module "expr-library/logical-3/xor-3" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * This version of the `XOR` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link xor}
     */
    export const xor3: Operator2<boolean | null, boolean | null, boolean | null>;
}
declare module "expr-library/logical-3/index" {
    export * from "expr-library/logical-3/and-3";
    export * from "expr-library/logical-3/is-false";
    export * from "expr-library/logical-3/is-not-false";
    export * from "expr-library/logical-3/is-not-true";
    export * from "expr-library/logical-3/is-not-unknown";
    export * from "expr-library/logical-3/is-true";
    export * from "expr-library/logical-3/is-unknown";
    export * from "expr-library/logical-3/not-3";
    export * from "expr-library/logical-3/or-3";
    export * from "expr-library/logical-3/xor-3";
}
declare module "expr-library/string/aggregate/group-concat" {
    import { AggregateOperator1, AggregateOperator2 } from "expr-library/aggregate-factory/index";
    /**
     * Returns a string result with the concatenated non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
     * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
     *   + The order of the concatenated elements is arbitrary.
     *   + Uses comma as separator
     *
     * -----
     *
     * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
     * for the DB-unified implementation.
     *
     * Unless we modify the SQLite implementation with a user-defined function?
     *
     * -----
     *
     * @param arg - The expression to aggregate
     *
     * @todo Investigate replacing SQLite `GROUP_CONCAT()` with user-defined function
     */
    export const groupConcatDistinct: AggregateOperator1<string | null, string | null>;
    /**
     * Returns a string result with the concatenated non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(expr, separator)`
     * + SQLite     : `GROUP_CONCAT(expr, separator)`
     *   + The order of the concatenated elements is arbitrary.
     *
     * @param left  - The expression to aggregate
     * @param right - The separator between expressions
     */
    export const groupConcatAll: AggregateOperator2<string | null, string, string | null>;
}
declare module "expr-library/string/aggregate/index" {
    export * from "expr-library/string/aggregate/group-concat";
}
declare module "expr-library/string/ascii" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the numeric value of the leftmost character of the string.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `ASCII(x)`
     * + PostgreSQL     : `ASCII(x)`
     * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  ASCII(CHAR(128 USING latin1))
     *  > 128
     *
     *  ASCII(CHAR(128 USING utf32))
     *  > 0
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/2
     */
    export const ascii: Operator1<string, bigint>;
}
declare module "expr-library/string/bin" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns a binary string representation of a `bigint` value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
     *
     * -----
     *
     * + MySQL          : `BIN(x)`
     * + PostgreSQL     : None. Implement with,
     * ```sql
     *  REGEXP_REPLACE(
     *      (x)::bit(64)::varchar(64),
     *      '^0+(\d+)$',
     *      '\1'
     *  )
     * ```
     * + SQLite         : None. Implement with,
     * ```ts
     * //x >= 0
     * (x).toString(2)
     * //x < 0
     * (2n**64n + BigInt(x)).toString(2)
     * ```
     */
    export const bin: Operator1<bigint, string>;
}
declare module "expr-library/string/bit-length" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the length of the string in bits.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `BIT_LENGTH(x)`
     * + PostgreSQL     : `BIT_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  BIT_LENGTH(CHAR(128 USING latin1))
     *  > 8
     *
     *  BIT_LENGTH(CHAR(128 USING utf32))
     *  > 32
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/3
     */
    export const bitLength: Operator1<string, bigint>;
}
declare module "expr-library/string/char-length" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the length of the string, measured in characters.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#length
     * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
     *
     * -----
     *
     * + MySQL          : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 6
     * + PostgreSQL     : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 8
     * + SQLite         : `LENGTH(x)`
     *   + `LENGTH('cafȩ́')` returns 6
     *
     * -----
     *
     * Surrogate pairs may cause results to differ across databases.
     */
    export const charLength: Operator1<string, bigint>;
}
declare module "expr-library/string/concat-ws" {
    import { Operator2ToN } from "expr-library/factory/index";
    /**
     * Concatenate With Separator.
     * The first argument is the separator for the rest of the arguments.
     * The separator is added between the strings to be concatenated.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + SQLite         : None. Implement with user-defined function.
     */
    export const concatWs: Operator2ToN<string, string | null, string | null, string>;
}
declare module "expr-library/string/concat" {
    import { Operator1ToN } from "expr-library/factory/index";
    /**
     * Returns the string that results from concatenating the arguments.
     * May have one or more arguments.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
     *   + MySQL actually treats `||` as the boolean `OR` operator.
     * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + SQLite uses an operator, not a function, to concatenate strings
     *   + https://www.sqlite.org/lang_expr.html#collateop
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     *
     * -----
     *
     * @see nullSafeConcat
     */
    export const concat: Operator1ToN<string, string>;
}
declare module "expr-library/string/like" {
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    export function assertValidLikeEscapeChar(escapeChar: string): void;
    /**
     * + The escape character must always be specified, with this unified library.
     * + The escape character must be of length `1`.
     *
     * -----
     *
     * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
     *
     * -----
     *
     * This library requires the escape character to always be specified
     * because different databases have different defaults.
     *
     * Forcing an explicit escape character helps keep behaviour more consistent
     * across databases.
     *
     * Default escape characters per database,
     * + MySQL      : backslash (`\`)
     * + PostgreSQL : backslash (`\`)
     * + SQLite     : no-escape-character
     *
     * -----
     *
     * This library requires the escape character to have length `1` because
     * specifying the empty string has different behaviour on different databases,
     * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
     * + PostgreSQL : no-escape-character
     * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
     *
     * @param str - The target of the search
     * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
     * @param escapeChar - The escape character to use on the `pattern`
     */
    export function like<StrT extends BuiltInExpr<string>, PatternT extends BuiltInExpr<string>>(str: StrT, pattern: PatternT, escapeChar: string): (ExprUtil.Intersect<boolean, StrT | PatternT>);
}
declare module "expr-library/string/escape-like-pattern" {
    /**
     * With `LIKE` you can use the following two wildcard characters in the pattern:
     *
     * + `%` matches any number of characters, even zero characters.
     * + `_` matches exactly one character.
     *
     * This function just prepends `escapeChar` to each of the above characters.
     * It also prepends `escapeChar` to itself.
     */
    export function escapeLikePattern(pattern: string, escapeChar: string): string;
}
declare module "expr-library/string/from-base64" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Takes a base-64 encoded string,
     * and returns the decoded result as a `BLOB/bytea`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `FROM_BASE64(x)`
     *   + `FROM_BASE64('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'base64')`
     *   + `DECODE('~', 'base64')` throws an error
     * + SQLite         : None, implement with user-defined function `atob()`
     *   + `atob('~')` throws an error
     *
     * -----
     *
     * If the input is not a valid base-64 string, some databases throw an error.
     * Others return `NULL`.
     */
    export const fromBase64: Operator1<string, Uint8Array | null>;
}
declare module "expr-library/string/hex" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Converts each byte of the input to two hexadecimal digits.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#hex
     *
     * -----
     *
     * + MySQL          : `HEX(x)`
     * + PostgreSQL     : `ENCODE(x, 'hex')`
     * + SQLite         : `HEX(x)`
     */
    export const hex: Operator1<Uint8Array, string>;
}
declare module "expr-library/string/in-str" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the position of the first occurrence of the substring in the target.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
     * + https://www.sqlite.org/lang_corefunc.html#instr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `INSTR(str, substr)`
     * + PostgreSQL     : `STRPOS(str, substr)`
     * + SQLite         : `INSTR(str, substr)`
     *
     * -----
     *
     * @param left - The target of the search
     * @param right - The substring to look for
     *
     * -----
     *
     * If the substring is not found, it returns `0`.
     * Remember that string indices are one-based; not zero-based.
     *
     * @see position
     */
    export const inStr: Operator2<string, string, bigint>;
}
declare module "expr-library/string/l-pad" {
    import { Operator3 } from "expr-library/factory/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    /**
     * Returns a string, left-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     *   + `LPAD('123', 5, '')`   === `NULL`
     *   + `LPAD('123', 2, '')`   === `'12'`
     *   + `LPAD('123', -2, 'a')` === `NULL`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     *   + `LPAD('123', 5, '')`   === `'123'`
     *   + `LPAD('123', 2, '')`   === `'12'`
     *   + `LPAD('123', -2, 'a')` === `''`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the desired length is negative, or padding string is empty,
     * the behaviour cannot be unified.
     *
     * MySQL seems to return `NULL`.
     *
     * -----
     *
     * @param left  - The string to pad
     * @param mid   - The desired length of the output
     * @param right - The padding
     *
     * @see lPad
     */
    export const lPadUnsafe: Operator3<string, bigint, string, string | null>;
    /**
     * Returns a string, left-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * This function does not allow negative `desiredLength`, or empty `padding`.
     *
     * -----
     *
     * @param str           - The string to pad
     * @param desiredLength - The desired length of the output; must not be negative
     * @param padding       - The padding; must not be empty
     *
     * @see lPadUnsafe
     */
    export function lPad<StrT extends BuiltInExpr<string>>(str: StrT, desiredLength: bigint, padding: string): (ExprUtil.Intersect<string, StrT>);
}
declare module "expr-library/string/l-trim" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with leading **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#ltrim
     *
     * -----
     *
     * + MySQL          : `LTRIM(x)`
     * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
     * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
     *
     * -----
     *
     * Does not remove other leading whitespace. Only removes leading spaces.
     */
    export const lTrim: Operator1<string, string>;
}
declare module "expr-library/string/lower" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with all characters changed to lowercase
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#lower
     *
     * -----
     *
     * + MySQL          : `LOWER(x)`
     * + PostgreSQL     : `LOWER(x)`
     * + SQLite         : `LOWER(x)`
     */
    export const lower: Operator1<string, string>;
}
declare module "expr-library/string/not-like" {
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    /**
     * + The escape character must always be specified, with this unified library.
     * + The escape character must be of length `1`.
     *
     * -----
     *
     * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
     *
     * -----
     *
     * This library requires the escape character to always be specified
     * because different databases have different defaults.
     *
     * Forcing an explicit escape character helps keep behaviour more consistent
     * across databases.
     *
     * Default escape characters per database,
     * + MySQL      : backslash (`\`)
     * + PostgreSQL : backslash (`\`)
     * + SQLite     : no-escape-character
     *
     * -----
     *
     * This library requires the escape character to have length `1` because
     * specifying the empty string has different behaviour on different databases,
     * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
     * + PostgreSQL : no-escape-character
     * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
     *
     * @param str - The target of the search
     * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
     * @param escapeChar - The escape character to use on the `pattern`
     */
    export function notLike<StrT extends BuiltInExpr<string>, PatternT extends BuiltInExpr<string>>(str: StrT, pattern: PatternT, escapeChar: string): (ExprUtil.Intersect<boolean, StrT | PatternT>);
}
declare module "expr-library/string/null-safe-concat" {
    import { Operator1ToN } from "expr-library/factory/index";
    /**
     * Returns the string that results from concatenating the arguments.
     * May have one or more arguments.
     * `NULL` values are treated as empty strings.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
     * + PostgreSQL     : `CONCAT(x, ...)`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `COALESCE(x, '') || ... || ...`
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     *
     * -----
     *
     * @see concat
     */
    export const nullSafeConcat: Operator1ToN<string | null, string>;
}
declare module "expr-library/string/octet-length" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the length of the string, measured in bytes.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `OCTET_LENGTH(x)`
     * + PostgreSQL     : `OCTET_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB))`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  OCTET_LENGTH(CHAR(128 USING latin1))
     *  > 1
     *
     *  OCTET_LENGTH(CHAR(128 USING utf32))
     *  > 4
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/4
     */
    export const octetLength: Operator1<string, bigint>;
}
declare module "expr-library/string/position" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the position of the first occurrence of the substring in the target.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `POSITION(substr IN str)`
     * + PostgreSQL     : `POSITION(substr IN str)`
     * + SQLite         : `INSTR(str, substr)`
     *
     * -----
     *
     * @param left  - The substring to look for
     * @param right - The target of the search
     *
     * -----
     *
     * If the substring is not found, it returns `0`.
     * Remember that string indices are one-based; not zero-based.
     *
     * @see inStr
     * @todo Remove `inStr()` and keep `position()`?
     */
    export const position: Operator2<string, string, bigint>;
}
declare module "expr-library/string/r-pad" {
    import { Operator3 } from "expr-library/factory/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    /**
     * Returns a string, right-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     *   + `RPAD('123', 5, '')`   === `NULL`
     *   + `RPAD('123', 2, '')`   === `'12'`
     *   + `RPAD('123', -2, 'a')` === `NULL`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     *   + `RPAD('123', 5, '')`   === `'123'`
     *   + `RPAD('123', 2, '')`   === `'12'`
     *   + `RPAD('123', -2, 'a')` === `''`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the desired length is negative, or padding string is empty,
     * the behaviour cannot be unified.
     *
     * MySQL seems to return `NULL`.
     *
     * -----
     *
     * @param left  - The string to pad
     * @param mid   - The desired length of the output
     * @param right - The padding
     *
     * @see rPad
     */
    export const rPadUnsafe: Operator3<string, bigint, string, string | null>;
    /**
     * Returns a string, right-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * This function does not allow negative `desiredLength`, or empty `padding`.
     *
     * -----
     *
     * @param str           - The string to pad
     * @param desiredLength - The desired length of the output; must not be negative
     * @param padding       - The padding; must not be empty
     *
     * @see rPadUnsafe
     */
    export function rPad<StrT extends BuiltInExpr<string>>(str: StrT, desiredLength: bigint, padding: string): (ExprUtil.Intersect<string, StrT>);
}
declare module "expr-library/string/r-trim" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with trailing **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#rtrim
     *
     * -----
     *
     * + MySQL          : `RTRIM(x)`
     * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
     * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
     *
     * -----
     *
     * Does not remove other trailing whitespace. Only removes trailing spaces.
     */
    export const rTrim: Operator1<string, string>;
}
declare module "expr-library/string/repeat" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Repeats a string the specified amount of times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REPEAT(x, count)`
     * + PostgreSQL     : `REPEAT(x, count)`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the specified amount is zero or less, it returns an empty string.
     *
     * -----
     *
     * @param left  - The string to repeat
     * @param right - The amount of times to repeat the string
     */
    export const repeat: Operator2<string, bigint, string>;
}
declare module "expr-library/string/replace" {
    import { Operator3 } from "expr-library/factory/index";
    /**
     * Returns the string `str`
     * with all occurrences of the string `from`
     * replaced by the string `to`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#replace
     *
     * -----
     *
     * + MySQL          : `REPLACE(str, from, to)`
     * + PostgreSQL     : `REPLACE(str, from, to)`
     * + SQLite         : `REPLACE(str, from, to)`
     *
     * -----
     *
     * @param left  - The string to transform
     * @param mid   - The string to look for
     * @param right - The replacement string
     */
    export const replace: Operator3<string, string, string, string>;
}
declare module "expr-library/string/reverse" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with the order of the characters reversed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REVERSE(x)`
     * + PostgreSQL     : `REVERSE(x)`
     * + SQLite         : None. Implement with user-defined function.
     */
    export const reverse: Operator1<string, string>;
}
declare module "expr-library/string/to-base64" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Converts the argument to base-64 encoded form.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `TO_BASE64(x)`
     * + PostgreSQL     : `ENCODE(x, 'base64')`
     * + SQLite         : None, implement with user-defined function `btoa()`
     */
    export const toBase64: Operator1<Uint8Array, string>;
}
declare module "expr-library/string/trim" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with leading and trailing **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#trim
     *
     * -----
     *
     * + MySQL          : `TRIM(x)`
     * + PostgreSQL     : `TRIM(x)`
     * + SQLite         : `TRIM(x)`
     *
     * -----
     *
     * Does not remove other leading and trailing whitespace.
     * Only removes leading and trailing spaces.
     */
    export const trim: Operator1<string, string>;
}
declare module "expr-library/string/unhex" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Takes a hex encoded string,
     * and returns the decoded result as a `BLOB/bytea`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `UNHEX(x)`
     *   + `UNHEX('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'hex')`
     *   + `DECODE('~', 'hex')` throws an error
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the input is not a valid hex string, some databases throw an error.
     * Others return `NULL`.
     */
    export const unhex: Operator1<string, Uint8Array | null>;
}
declare module "expr-library/string/upper" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the string with all characters changed to uppercase
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#upper
     *
     * -----
     *
     * + MySQL          : `UPPER(x)`
     * + PostgreSQL     : `UPPER(x)`
     * + SQLite         : `UPPER(x)`
     */
    export const upper: Operator1<string, string>;
}
declare module "expr-library/string/index" {
    export * from "expr-library/string/aggregate/index";
    export * from "expr-library/string/ascii";
    export * from "expr-library/string/bin";
    export * from "expr-library/string/bit-length";
    export * from "expr-library/string/char-length";
    export * from "expr-library/string/concat-ws";
    export * from "expr-library/string/concat";
    export * from "expr-library/string/escape-like-pattern";
    export * from "expr-library/string/from-base64";
    export * from "expr-library/string/hex";
    export * from "expr-library/string/in-str";
    export * from "expr-library/string/l-pad";
    export * from "expr-library/string/l-trim";
    export * from "expr-library/string/like";
    export * from "expr-library/string/lower";
    export * from "expr-library/string/not-like";
    export * from "expr-library/string/null-safe-concat";
    export * from "expr-library/string/octet-length";
    export * from "expr-library/string/position";
    export * from "expr-library/string/r-pad";
    export * from "expr-library/string/r-trim";
    export * from "expr-library/string/repeat";
    export * from "expr-library/string/replace";
    export * from "expr-library/string/reverse";
    export * from "expr-library/string/to-base64";
    export * from "expr-library/string/trim";
    export * from "expr-library/string/unhex";
    export * from "expr-library/string/upper";
}
declare module "expr-library/subquery/exists" {
    import * as tm from "type-mapping";
    import { QueryBaseUtil } from "query-base/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    export function exists<QueryT extends QueryBaseUtil.AfterFromClause | QueryBaseUtil.AfterSelectClause>(query: QueryT): (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromFromClause<QueryT["fromClause"]>;
        /**
         * Sub-queries are not aggregate expressions.
         * `EXISTS()` isn't an aggregate function, either.
         */
        isAggregate: false;
    }>);
}
declare module "expr-library/subquery/index" {
    export * from "expr-library/subquery/exists";
}
declare module "expr-library/decimal/aggregate/avg" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    import { Decimal } from "decimal/index";
    export const avgDistinct: AggregateOperator1<Decimal, Decimal | null>;
    export const avgAll: AggregateOperator1<Decimal, Decimal | null>;
    export const avg: AggregateOperator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/aggregate/max" {
    import { Decimal } from "decimal/index";
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    export const max: AggregateOperator1<Decimal | null, Decimal | null>;
}
declare module "expr-library/decimal/aggregate/min" {
    import { Decimal } from "decimal/index";
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    export const min: AggregateOperator1<Decimal | null, Decimal | null>;
}
declare module "expr-library/decimal/aggregate/sum" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    import { Decimal } from "decimal/index";
    export const sumDistinct: AggregateOperator1<Decimal, Decimal | null>;
    export const sumAll: AggregateOperator1<Decimal, Decimal | null>;
    export const sum: AggregateOperator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/aggregate/index" {
    export * from "expr-library/decimal/aggregate/avg";
    export * from "expr-library/decimal/aggregate/max";
    export * from "expr-library/decimal/aggregate/min";
    export * from "expr-library/decimal/aggregate/sum";
}
declare module "expr-library/decimal/abs" {
    import { Operator1 } from "expr-library/factory/index";
    import { Decimal } from "decimal/index";
    /**
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     */
    export const abs: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/add" {
    import { ChainableDecimalOperator } from "expr-library/factory/index";
    export const add: ChainableDecimalOperator;
}
declare module "expr-library/decimal/ceiling" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function is idempotent.
     * `CEILING(CEILING(x)) == CEILING(x)`
     */
    export const ceiling: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/exp" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    export const exp: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/floor" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function is idempotent.
     * `FLOOR(FLOOR(x)) == FLOOR(x)`
     */
    export const floor: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/fractional-div" {
    import { Decimal } from "decimal/index";
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Performs regular fixed-point division
     */
    export const fractionalDiv: Operator2<Decimal, Decimal, Decimal>;
}
declare module "expr-library/decimal/ln" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * + MySQL      : `LN(0)` === `NULL`
     * + PostgreSQL : `LN(0)` throws error
     */
    export const ln: Operator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/log" {
    import { Decimal } from "decimal/index";
    import { Operator2 } from "expr-library/factory/index";
    /**
     * + MySQL      : `LOG(0, 0)` === `NULL`
     * + PostgreSQL : `LOG(0, 0)` throws error
     */
    export const log: Operator2<Decimal, Decimal, Decimal | null>;
}
declare module "expr-library/decimal/log2" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * + MySQL      : `LOG2(0)` === `NULL`
     * + PostgreSQL : `LOG(2, 0)` throws error
     */
    export const log2: Operator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/log10" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * + MySQL      : `LOG10(0)` === `NULL`
     * + PostgreSQL : `LOG(10, 0)` throws error
     */
    export const log10: Operator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/mul" {
    import { ChainableDecimalOperator } from "expr-library/factory/index";
    export const mul: ChainableDecimalOperator;
}
declare module "expr-library/decimal/neg" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     */
    export const neg: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/power" {
    import { Operator2 } from "expr-library/factory/index";
    import { Decimal } from "decimal/index";
    export const power: Operator2<Decimal, Decimal, Decimal>;
}
declare module "expr-library/decimal/random" {
    import { Operator0 } from "expr-library/factory/index";
    import { Decimal } from "decimal/index";
    export const random: Operator0<Decimal>;
}
declare module "expr-library/decimal/sign" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
     */
    export const sign: Operator1<Decimal, Decimal>;
}
declare module "expr-library/decimal/sqrt" {
    import { Decimal } from "decimal/index";
    import { Operator1 } from "expr-library/factory/index";
    /**
     * + MySQL      : `SQRT(-5)` === `null`
     * + PostgreSQL : `SQRT(-5)` throws error
     */
    export const sqrt: Operator1<Decimal, Decimal | null>;
}
declare module "expr-library/decimal/sub" {
    import { Operator2 } from "expr-library/factory/index";
    import { Decimal } from "decimal/index";
    export const sub: Operator2<Decimal, Decimal, Decimal>;
}
declare module "expr-library/decimal/index" {
    export * from "expr-library/decimal/aggregate/index";
    export * from "expr-library/decimal/abs";
    export * from "expr-library/decimal/add";
    export * from "expr-library/decimal/ceiling";
    export * from "expr-library/decimal/exp";
    export * from "expr-library/decimal/floor";
    export * from "expr-library/decimal/fractional-div";
    /**
     * PostgreSQL and SQLite do not support fractional remainder `frem(x, y)`
     */
    export * from "expr-library/decimal/ln";
    export * from "expr-library/decimal/log";
    export * from "expr-library/decimal/log2";
    export * from "expr-library/decimal/log10";
    export * from "expr-library/decimal/mul";
    export * from "expr-library/decimal/neg";
    export * from "expr-library/decimal/power";
    export * from "expr-library/decimal/random";
    export * from "expr-library/decimal/sign";
    export * from "expr-library/decimal/sqrt";
    export * from "expr-library/decimal/sub";
}
declare module "expr-library/double/aggregate/avg" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)`
     * + PostgreSQL : `AVG(DISTINCT x)`
     * + SQLite     : `AVG(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const avgDistinct: AggregateOperator1<number | null, number | null>;
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const avgAll: AggregateOperator1<number | null, number | null>;
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const avg: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/max" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    export const max: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/min" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    export const min: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/stddev-pop" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the population standard deviation of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_POP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `STDDEV_POP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The population standard deviation is,
     * ```sql
     *  SQRT(
     *      -- SUM() and AVG() should ignore rows with `NULL` values
     *      SUM(
     *          POW((x - AVG(x), 2)
     *      ) /
     *      COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
     *  )
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    export const stdDevPop: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/stddev-samp" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the sample standard deviation of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * It returns `NULL` if there is only one non-`NULL` value.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_SAMP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `STDDEV_SAMP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The sample standard deviation is,
     * ```sql
     *  SQRT(
     *      -- SUM() and AVG() should ignore rows with `NULL` values
     *      SUM(
     *          POW((x - AVG(x), 2)
     *      ) /
     *      (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
     *  )
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    export const stdDevSamp: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/sum" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)`
     * + PostgreSQL : `SUM(DISTINCT x)`
     * + SQLite     : `SUM(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const sumDistinct: AggregateOperator1<number | null, number | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(x)`
     * + SQLite     : `SUM(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const sumAll: AggregateOperator1<number | null, number | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(x)`
     * + SQLite     : `SUM(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    export const sum: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/var-pop" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the population variance of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_POP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `VAR_POP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The population variance is,
     * ```sql
     *  -- SUM() and AVG() should ignore rows with `NULL` values
     *  SUM(
     *      POW((x - AVG(x), 2)
     *  ) /
     *  COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    export const varPop: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/var-samp" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the sample variance of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * It returns `NULL` if there is only one non-`NULL` value.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_SAMP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `VAR_SAMP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The sample variance is,
     * ```sql
     *  -- SUM() and AVG() should ignore rows with `NULL` values
     *  SUM(
     *      POW((x - AVG(x), 2)
     *  ) /
     *  (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    export const varSamp: AggregateOperator1<number | null, number | null>;
}
declare module "expr-library/double/aggregate/index" {
    export * from "expr-library/double/aggregate/avg";
    export * from "expr-library/double/aggregate/max";
    export * from "expr-library/double/aggregate/min";
    export * from "expr-library/double/aggregate/stddev-pop";
    export * from "expr-library/double/aggregate/stddev-samp";
    export * from "expr-library/double/aggregate/sum";
    export * from "expr-library/double/aggregate/var-pop";
    export * from "expr-library/double/aggregate/var-samp";
}
declare module "expr-library/double/abs" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the absolute value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_corefunc.html#abs
     *
     * -----
     *
     * + MySQL        : `ABS(x)`
     * + PostgreSQL   : `ABS(x)`
     * + SQLite       : `ABS(x)`
     *   + `ABS(Infinity)  = Infinity`
     *   + `ABS(-Infinity) = Infinity`
     *
     * -----
     *
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     */
    export const abs: Operator1<number, number>;
}
declare module "expr-library/double/acos" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the arc cosine.
     *
     * If the argument is not in [-1, 1], may throw, or return `null`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ACOS(x)`
     * + PostgreSQL     : `ACOS(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * + MySQL      : `ACOS(1.5)` === `NULL`
     * + PostgreSQL : `ACOS(1.5)` throws error
     */
    export const acos: Operator1<number, number | null>;
}
declare module "expr-library/double/add" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * Returns the addition of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
     *
     * -----
     *
     * + MySQL        : `+`
     *   + `1e308+1e308` throws
     *   + `(-1e308)+(-1e308)` throws
     * + PostgreSQL   : `+`
     *   + `CAST(1e308 AS double precision)+CAST(1e308 AS double precision)` throws
     *   + `CAST(-1e308 AS double precision)+CAST(-1e308 AS double precision)` throws
     * + SQLite       : `+`
     *   + `1e308+1e308 = Infinity`
     *   + `(-1e308)+(-1e308) = -Infinity`
     *
     * -----
     *
     * In SQLite, addition with doubles may return `null`,
     * ```sql
     *  SELECT 1e999 + -1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    export const add: ChainableOperator<number>;
}
declare module "expr-library/double/asin" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the arc sine.
     *
     * If the argument is not in [-1, 1], may throw, or return `null`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ASIN(x)`
     * + PostgreSQL     : `ASIN(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * + MySQL      : `ASIN(1.5)` === `NULL`
     * + PostgreSQL : `ASIN(1.5)` throws error
     */
    export const asin: Operator1<number, number | null>;
}
declare module "expr-library/double/atan" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the arc tangent.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN(x)`
     * + PostgreSQL     : `ATAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    export const atan: Operator1<number, number>;
}
declare module "expr-library/double/atan2" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Similar to calculating the arc tangent of `Y / X`,
     * except that the signs of both arguments are used
     * to determine the quadrant of the result.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN2(y, x)`
     * + PostgreSQL     : `ATAN2(y, x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * @param left  - The Y of the vector
     * @param right - The X of the vector
     */
    export const atan2: Operator2<number, number, number>;
}
declare module "expr-library/double/cbrt" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the cube root
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_pow
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `IF(x >= 0, POWER(x, 1.0/3.0), -POWER(-(x), 1.0/3.0))`
     *   + The `.0` parts are important!
     *   + MySQL's `POWER()` function throws on negative numbers
     * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
     * + SQLite       : Requres creating a `CBRT(x)` user-defined function
     *
     * -----
     *
     * MySQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 3
     * ```
     *
     * PostgreSQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 2.99999999999999999997
     *
     * SELECT CBRT(27)
     * > 3
     * ```
     */
    export const cbrt: Operator1<number, number>;
}
declare module "expr-library/double/ceiling" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the ceiling of the number
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceiling
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `CEIL(x)/CEILING(x)`
     * + PostgreSQL   : `CEIL(x)/CEILING(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * ```sql
     *  SELECT CEILING(1.1)
     *  > 2
     *
     *  SELECT CEILING(-1.1)
     *  > -1
     * ```
     *
     * -----
     *
     * This function is idempotent.
     * `CEILING(CEILING(x)) == CEILING(x)`
     */
    export const ceiling: Operator1<number, number>;
}
declare module "expr-library/double/cos" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the cosine
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COS(x)`
     * + PostgreSQL     : `COS(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COS(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The cosine
     */
    export const cos: Operator1<number, number | null>;
}
declare module "expr-library/double/cot" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the cotangent
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COT(x)`
     * + PostgreSQL     : `COT(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COT(1e999)`
     *
     * -----
     *
     * + MySQL      : `COT(0)` throws error
     * + PostgreSQL : `COT(0)` === `NULL`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The cotangent
     */
    export const cot: Operator1<number, number | null>;
}
declare module "expr-library/double/degrees" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Converts from radians to degrees.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `DEGREES(x)`
     * + PostgreSQL     : `DEGREES(x)`
     * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
     *
     * -----
     *
     * @param arg - radians
     * @returns degrees
     */
    export const degrees: Operator1<number, number>;
}
declare module "expr-library/double/exp" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * The natural exponential function
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://en.wikipedia.org/wiki/Exponential_function
     *
     * -----
     *
     * + MySQL          : `EXP(x)`
     * + PostgreSQL     : `EXP(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * @param arg - The power value
     * @returns e^arg
     */
    export const exp: Operator1<number, number>;
}
declare module "expr-library/double/floor" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the floor of the number
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `FLOOR(x)`
     * + PostgreSQL   : `FLOOR(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * ```sql
     *  SELECT FLOOR(1.1)
     *  > 1
     *
     *  SELECT FLOOR(-1.1)
     *  > -2
     * ```
     *
     * -----
     *
     * This function is idempotent.
     * `FLOOR(FLOOR(x)) == FLOOR(x)`
     */
    export const floor: Operator1<number, number>;
}
declare module "expr-library/double/fractional-div" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Performs regular floating-point division
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `/`
     * + PostgreSQL   : `/`
     * + SQLite       : `/`
     *
     * -----
     *
     * `1e0/0e0`,
     *
     * + MySQL      : `NULL`
     * + PostgreSQL : throws
     * + SQLite     : `NULL`
     *
     * -----
     *
     * `1e308/0.1e0`,
     *
     * + MySQL      : throws
     * + PostgreSQL : throws
     * + SQLite     : `Infinity`
     *
     * -----
     *
     * `1e308/-0.1e0`,
     *
     * + MySQL      : throws
     * + PostgreSQL : throws
     * + SQLite     : `-Infinity`
     *
     * -----
     *
     * MySQL,
     * ```sql
     *  SELECT
     *      3.141592653539793e0 /
     *      6.233523257997525e0;
     *  > 0.5039834654517689
     * ```
     * PostgreSQL,
     * ```sql
     *  SELECT
     *      CAST(3.141592653539793e0 AS DOUBLE PRECISION) /
     *      CAST(6.233523257997525e0 AS DOUBLE PRECISION);
     *  > 0.503983465451769
     * ```
     *
     * SQLite,
     * ```sql
     *  SELECT
     *      3.141592653539793e0 /
     *      6.233523257997525e0;
     *  > 0.5039834654517689
     * ```
     */
    export const fractionalDiv: Operator2<number, number, number | null>;
}
declare module "expr-library/double/fractional-remainder" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the remainder after fractional division.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_mod
     * + https://stackoverflow.com/questions/53486669/modulo-operation-on-floating-point-numbers-on-postgresql
     *
     * -----
     *
     * + MySQL      : `dividend % divisor`
     * + PostgreSQL : See algorithm below
     * + SQLite     : See algorithm below
     *
     * ```sql
     *  IF(
     *      dividend >= 0,
     *      dividend - FLOOR(dividend / divisor) * divisor,
     *      -((-dividend) - FLOOR((-dividend) / divisor) * divisor)
     *  )
     * ```
     */
    export const fractionalRemainder: Operator2<number, number, number | null>;
}
declare module "expr-library/double/ln" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the natural logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LN(x)`
     * + PostgreSQL     : `LN(x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LN(0)` === `NULL`
     * + PostgreSQL : `LN(0)` throws error
     *
     * -----
     *
     * + MySQL      : `LN(-1)` === `NULL`
     * + PostgreSQL : `LN(-1)` throws error
     */
    export const ln: Operator1<number, number | null>;
}
declare module "expr-library/double/log" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the logarithm to the specified `base`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LOG(base, x)`
     * + PostgreSQL     : `LOG(base, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG(0, 0)` === `NULL`
     * + PostgreSQL : `LOG(0, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG(1, 5)` === `NULL`
     * + PostgreSQL : `LOG(1, 5)` throws error
     *
     * -----
     *
     * @param left  - The base
     * @param right - The anti-logarithm
     * @returns log_{base}(anti-logarithm) = logarithm
     */
    export const log: Operator2<number, number, number | null>;
}
declare module "expr-library/double/log2" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the base-2 logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
     *
     * -----
     *
     * + MySQL          : `LOG2(x)`
     * + PostgreSQL     : `LOG(2.0, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG2(0)` === `NULL`
     * + PostgreSQL : `LOG(2, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG2(-1)` === `NULL`
     * + PostgreSQL : `LOG(2, -1)` throws error
     */
    export const log2: Operator1<number, number | null>;
}
declare module "expr-library/double/log10" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the base-10 logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
     *
     * -----
     *
     * + MySQL          : `LOG10(x)`
     * + PostgreSQL     : `LOG(10.0, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG10(0)` === `NULL`
     * + PostgreSQL : `LOG(10, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG10(-1)` === `NULL`
     * + PostgreSQL : `LOG(10, -1)` throws error
     */
    export const log10: Operator1<number, number | null>;
}
declare module "expr-library/double/mul" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * Returns the multiplication of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
     *
     * -----
     *
     * + MySQL        : `*`
     *   + `1e308*1e308` throws
     *   + `1e308*-1e308` throws
     * + PostgreSQL   : `*`
     *   + `CAST(1e308 AS double precision)*CAST(1e308 AS double precision)` throws
     *   + `CAST(1e308 AS double precision)*CAST(-1e308 AS double precision)` throws
     * + SQLite       : `*`
     *   + `1e308*1e308 = Infinity`
     *   + `1e308*-1e308 = -Infinity`
     *
     * -----
     *
     * In SQLite, multiplication with doubles may return `null`,
     * ```sql
     *  SELECT 0e0 * 1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    export const mul: ChainableOperator<number>;
}
declare module "expr-library/double/neg" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the unary minus of the double value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     *
     * -----
     *
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     */
    export const neg: Operator1<number, number>;
}
declare module "expr-library/double/pi" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns the value of pi
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://en.wikipedia.org/wiki/Pi
     *
     * -----
     *
     * + MySQL          : `PI()`; MySQL's understanding of pi is... terrible
     *   + https://github.com/AnyhowStep/tsql/issues/252
     *   + The MySQL adapter library **should not** use `PI()`, it should use `3.141592653589793` instead
     * + PostgreSQL     : `PI()` Returns `3.14159265358979`
     * + SQLite         : None, implement using `3.141592653589793`
     *
     * -----
     *
     * In JS, `Math.PI` is `3.141592653589793`
     */
    export const pi: Operator0<number>;
}
declare module "expr-library/double/power" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns `base^exponent`
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `POWER(base, exponent)`
     * + PostgreSQL   : `^` or `POWER(base, exponent)` (Let's not use the ugly `^` operator)
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `POWER(-1, 0.5)`
     *
     * -----
     *
     * If base is negative, and exponent is fractional,
     * + MySQL throws
     * + PostgreSQL throws
     * + SQLite reutrns `null` (`extension-functions.c`)
     *
     * -----
     *
     * If base is zero, and exponent is negative,
     * + MySQL throws
     * + PostgreSQL throws
     * + SQLite reutrns `Infinity` (`extension-functions.c`)
     *
     * -----
     *
     * @param left  - The base
     * @param right - The exponent
     * @returns base^exponent
     *
     * @todo Decide if we should make SQLite throw instead of return `null`
     */
    export const power: Operator2<number, number, number | null>;
}
declare module "expr-library/double/radians" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Converts from degrees to radians.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `RADIANS(x)`
     * + PostgreSQL     : `RADIANS(x)`
     * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
     *
     * -----
     *
     * @param arg - degrees
     * @returns radians
     */
    export const radians: Operator1<number, number>;
}
declare module "expr-library/double/random" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns a random floating point number in the range, `[0.0, 1.0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#random
     *
     * -----
     *
     * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
     * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
     * + SQLite         : Incompatible.
     *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
     *   See algorithm below to emulate.
     *   Or just use a user-defined function...
     *
     * -----
     *
     * SQLite emulation,
     * ```sql
     *  COALESCE(
     *      NULLIF(
     *          ABS(RANDOM()+0e0) / 9223372036854775809e0,
     *          1
     *      ),
     *      0.999999999999999
     *  )
     * ```
     */
    export const random: Operator0<number>;
}
declare module "expr-library/double/sign" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * + If the argument is negative, returns -1
     * + If the argument is positive, returns  1
     * + If the argument is zero, returns 0
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `SIGN(x)`
     * + PostgreSQL     : `SIGN(x)`
     * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
     *
     * -----
     *
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
    */
    export const sign: Operator1<number, number>;
}
declare module "expr-library/double/sin" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the sine
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `SIN(x)`
     * + PostgreSQL     : `SIN(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `SIN(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The sine
     */
    export const sin: Operator1<number, number | null>;
}
declare module "expr-library/double/sqrt" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the square root
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `SQRT(x)`
     * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
     * + SQLite       : Requres creating a `SQRT(x)` user-defined function
     *
     * -----
     *
     * + MySQL      : `SQRT(-5)` === `null`
     * + PostgreSQL : `SQRT(-5)` throws error
     */
    export const sqrt: Operator1<number, number | null>;
}
declare module "expr-library/double/sub" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Returns the subtraction of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
     *
     * -----
     *
     * + MySQL        : `-`
     *   + `-1e308 - 1e308` throws
     *   + `1e308 - -1e308` throws
     * + PostgreSQL   : `-`
     *   + `CAST(-1e308 AS DOUBLE PRECISION) - CAST(1e308 AS DOUBLE PRECISION)` throws
     *   + `CAST(1e308 AS DOUBLE PRECISION) - CAST(-1e308 AS DOUBLE PRECISION)` throws
     * + SQLite       : `-`
     *   + `-1e308 - 1e308 = -Infinity`
     *   + `1e308 - -1e308 = Infinity`
     *
     * -----
     *
     * In SQLite, subtraction with doubles may return `null`,
     * ```sql
     *  SELECT 1e999 - 1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    export const sub: Operator2<number, number, number>;
}
declare module "expr-library/double/tan" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * Returns the tangent
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `TAN(x)`
     * + PostgreSQL     : `TAN(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `TAN(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The tangent
     */
    export const tan: Operator1<number, number | null>;
}
declare module "expr-library/double/index" {
    export * from "expr-library/double/aggregate/index";
    export * from "expr-library/double/abs";
    export * from "expr-library/double/acos";
    export * from "expr-library/double/add";
    export * from "expr-library/double/asin";
    export * from "expr-library/double/atan";
    export * from "expr-library/double/atan2";
    export * from "expr-library/double/cbrt";
    export * from "expr-library/double/ceiling";
    export * from "expr-library/double/cos";
    export * from "expr-library/double/cot";
    export * from "expr-library/double/degrees";
    export * from "expr-library/double/exp";
    export * from "expr-library/double/floor";
    export * from "expr-library/double/fractional-div";
    export * from "expr-library/double/fractional-remainder";
    /**
     * MySQL's `DIV` is just too... Unintuitive.
     * One would think it converts operands to int before performing int-div.
     * Instead, it performs fractional-div, then converts result to int.
     *
     * If you really want integer-div, just cast and divide yourself.
     */
    /**
     * For the same reason that integer-div is removed.
     */
    export * from "expr-library/double/ln";
    export * from "expr-library/double/log";
    export * from "expr-library/double/log2";
    export * from "expr-library/double/log10";
    export * from "expr-library/double/mul";
    export * from "expr-library/double/neg";
    export * from "expr-library/double/pi";
    export * from "expr-library/double/power";
    export * from "expr-library/double/radians";
    export * from "expr-library/double/random";
    export * from "expr-library/double/sign";
    export * from "expr-library/double/sin";
    export * from "expr-library/double/sqrt";
    export * from "expr-library/double/sub";
    export * from "expr-library/double/tan";
}
declare module "expr-library/integer/aggregate/avg" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    import { Decimal } from "decimal/index";
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)`
     * + PostgreSQL : `AVG(DISTINCT x)`
     * + SQLite     : `AVG(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const avgDistinct: AggregateOperator1<bigint | null, Decimal | null>;
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const avgAll: AggregateOperator1<bigint | null, Decimal | null>;
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const avg: AggregateOperator1<bigint | null, Decimal | null>;
}
declare module "expr-library/integer/aggregate/max" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    export const max: AggregateOperator1<bigint | null, bigint | null>;
}
declare module "expr-library/integer/aggregate/min" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    export const min: AggregateOperator1<bigint | null, bigint | null>;
}
declare module "expr-library/integer/aggregate/sum-as-bigint" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(DISTINCT x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(DISTINCT x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(DISTINCT x)`
     *   + Throws on integer overflow
     *
     */
    export const sumAsBigIntSignedDistinct: AggregateOperator1<bigint | null, bigint | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(x)`
     *   + Throws on integer overflow
     *
     */
    export const sumAsBigIntSignedAll: AggregateOperator1<bigint | null, bigint | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(x)`
     *   + Throws on integer overflow
     *
     */
    export const sumAsBigIntSigned: AggregateOperator1<bigint | null, bigint | null>;
}
declare module "expr-library/integer/aggregate/sum-as-decimal" {
    import { AggregateOperator1 } from "expr-library/aggregate-factory/index";
    import { Decimal } from "decimal/index";
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)`
     * + PostgreSQL : `SUM(DISTINCT CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(DISTINCT CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const sumAsDecimalDistinct: AggregateOperator1<bigint | null, Decimal | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const sumAsDecimalAll: AggregateOperator1<bigint | null, Decimal | null>;
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    export const sumAsDecimal: AggregateOperator1<bigint | null, Decimal | null>;
}
declare module "expr-library/integer/aggregate/index" {
    export * from "expr-library/integer/aggregate/avg";
    export * from "expr-library/integer/aggregate/max";
    export * from "expr-library/integer/aggregate/min";
    export * from "expr-library/integer/aggregate/sum-as-bigint";
    export * from "expr-library/integer/aggregate/sum-as-decimal";
}
declare module "expr-library/integer/bitwise/bitwise-and" {
    import { ChainableOperator } from "expr-library/factory/index";
    export const bitwiseAnd: ChainableOperator<bigint>;
}
declare module "expr-library/integer/bitwise/bitwise-left-shift" {
    import { Operator2 } from "expr-library/factory/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    /**
     * Performs a **signed** bitwise left-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     *
     * -----
     *
     * If the RHS is negative, the behaviour is cannot be unified.
     *
     * + MySQL      : `2 << -1` is `0`
     * + PostgreSQL : `2 << -1` is `0`
     * + SQLite     : `2 << -1` is `1`
     * + JavaScript : `2 << -1` is `0`
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; undefined behaviour if negative
     *
     * @see bitwiseLeftShift
     */
    export const bitwiseLeftShiftUnsafe: Operator2<bigint, bigint, bigint>;
    /**
     * Performs a **signed** bitwise left-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     *
     * -----
     *
     * If the RHS is negative, this throws.
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; throws if negative
     *
     * @see bitwiseLeftShiftUnsafe
     */
    export function bitwiseLeftShift<LeftT extends BuiltInExpr<bigint>>(left: LeftT, right: bigint): (ExprUtil.Intersect<bigint, LeftT>);
}
declare module "expr-library/integer/bitwise/bitwise-not" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function has the double elimination property.
     * `~(~(x)) == x`
     */
    export const bitwiseNot: Operator1<bigint, bigint>;
}
declare module "expr-library/integer/bitwise/bitwise-or" {
    import { ChainableOperator } from "expr-library/factory/index";
    export const bitwiseOr: ChainableOperator<bigint>;
}
declare module "expr-library/integer/bitwise/bitwise-right-shift" {
    import { Operator2 } from "expr-library/factory/index";
    import { BuiltInExpr } from "built-in-expr/index";
    import { ExprUtil } from "expr/index";
    /**
     * Performs a **signed** bitwise right-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     *
     * -----
     *
     * If the RHS is negative, the behaviour is cannot be unified.
     *
     * + MySQL      : `2 >> -1` is `0`
     * + PostgreSQL : `2 >> -1` is `0`
     * + SQLite     : `2 >> -1` is `4`
     * + JavaScript : `2 >> -1` is `0`
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; undefined behaviour if negative
     *
     * @see bitwiseRightShift
     */
    export const bitwiseRightShiftUnsafe: Operator2<bigint, bigint, bigint>;
    /**
     * Performs a **signed** bitwise right-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     *
     * -----
     *
     * If the RHS is negative, this throws.
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; throws if negative
     *
     * @see bitwiseRightShiftUnsafe
     */
    export function bitwiseRightShift<LeftT extends BuiltInExpr<bigint>>(left: LeftT, right: bigint): (ExprUtil.Intersect<bigint, LeftT>);
}
declare module "expr-library/integer/bitwise/bitwise-xor" {
    import { Operator2 } from "expr-library/factory/index";
    export const bitwiseXor: Operator2<bigint, bigint, bigint>;
}
declare module "expr-library/integer/bitwise/index" {
    export * from "expr-library/integer/bitwise/bitwise-and";
    export * from "expr-library/integer/bitwise/bitwise-left-shift";
    export * from "expr-library/integer/bitwise/bitwise-not";
    export * from "expr-library/integer/bitwise/bitwise-or";
    export * from "expr-library/integer/bitwise/bitwise-right-shift";
    export * from "expr-library/integer/bitwise/bitwise-xor";
}
declare module "expr-library/integer/abs" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     *
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT ABS(-9223372036854775808)
     * ```
     * The above throws an error on MySQL, PostgreSQL and SQLite.
     */
    export const abs: Operator1<bigint, bigint>;
}
declare module "expr-library/integer/add" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807+9223372036854775807;
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT -9223372036854775808+-9223372036854775808
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615+18446744073709551615
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is adding two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is adding two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 + -9223372036854775808 + -9223372036854775808
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL` and the result is correctly `-1`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE` and the result is **incorrectly** `0`.
     *
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintAdd()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    export const add: ChainableOperator<bigint>;
}
declare module "expr-library/integer/integer-div" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * Treats both arguments as integers and performs integer division
     *
     * -----
     *
     * ### Divide by zero
     *
     * ```sql
     *  SELECT 9223372036854775807 DIV 0; -- MySQL
     *  SELECT 9223372036854775807 / 0; -- PostgreSQL, SQLite
     * ```
     * The above gives `NULL` for MySQL and SQLite.
     * The above throws an error for PostgreSQL.
     */
    export const integerDiv: Operator2<bigint, bigint, bigint | null>;
}
declare module "expr-library/integer/integer-remainder" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * The remainder after performing integer division.
     *
     * Integer division is defined as,
     * `dividend / divisor`
     *
     * ```ts
     * result = sign(dividend) * abs(remainder)
     * ```
     *
     * If the dividend is positive, the result is positive.
     * If the dividend is negative, the result is negative.
     *
     * ```ts
     * integerRemainder( 5,  3); //2
     * integerRemainder( 5, -3); //2
     * integerRemainder(-5,  3); //-2
     * integerRemainder(-5, -3); //-2
     * ```
     *
     * -----
     *
     * ### Divide by zero
     *
     * ```sql
     *  SELECT 9223372036854775807 % 0
     * ```
     * The above gives `NULL` for MySQL and SQLite.
     * The above throws an error for PostgreSQL.
     */
    export const integerRemainder: Operator2<bigint, bigint, bigint | null>;
}
declare module "expr-library/integer/mul" {
    import { ChainableOperator } from "expr-library/factory/index";
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807*9223372036854775807;
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT 9223372036854775807*-9223372036854775808
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615*18446744073709551615
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is multiplying two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is multiplying two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 * -9223372036854775808
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
     *
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintMul()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    export const mul: ChainableOperator<bigint>;
}
declare module "expr-library/integer/neg" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     *
     * -----
     *
     * ### `BIGINT SIGNED` too large (from database)
     *
     * Be careful, however,
     * ```sql
     *  CREATE TABLE a (id BIGINT);
     *  INSERT INTO a (id) VALUES (-9223372036854775808);
     *
     *  SELECT
     *      -- 9223372036854775808 is too big
     *      -- to fit in signed bigint
     *      -id
     *  FROM
     *      a
     * ```
     *
     * The above will throw an error on both MySQL and PostgreSQL
     * because `9223372036854775808` is not a valid signed bigint value.
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * ### Double Unary Minus Elimination on Negative `BIGINT SIGNED` Literal
     *
     * The following will not throw an error but will silently
     * cast the result,
     * ```sql
     *  SELECT -(-9223372036854775808);
     * ```
     * Both **do not** error in MySQL and PostgreSQL.
     * PostgreSQL seems to perform double unary minus elimination and treats the result as a `DECIMAL` literal.
     * MySQL seems to perform double unary minus elimination and treats the result as an `BIGINT UNSIGNED` literal.
     *
     * SQLite casts to `DOUBLE`
     *
     * -----
     *
     * ```sql
     *  SELECT -(
     *      CAST(-9223372036854775808 AS BIGINT)
     *  ); -- PostgreSQL
     *
     *  SELECT -(-9223372036854775808 + 0); -- PostgreSQL
     *
     *  SELECT -(
     *      CAST(-9223372036854775808 AS BIGINT SIGNED)
     *  ); -- MySQL
     * ```
     * The above throws an error on PostgreSQL.
     * The above silently casts to an `BIGINT UNSIGNED` on MySQL.
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * ```sql
     *  SELECT
     *      CAST(-(-9223372036854775808) AS BIGINT); -- PostgreSQL
     *
     *  SELECT
     *      CAST(-(-9223372036854775808) AS BIGINT SIGNED); -- MySQL
     * ```
     * The above throws an error on PostgreSQL.
     * The above silently casts to an `BIGINT UNSIGNED`
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * MySQL seems to treat `BIGINT SIGNED` values from **columns** and **literals** differently!
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small.
     *
     * MySQL-specific,
     * ```sql
     *  CREATE TABLE a (id  BIGINT UNSIGNED);
     *  INSERT INTO a (id) VALUES (9223372036854775809);
     *  SELECT -id FROM a;
     * ```
     *
     * `-9223372036854775809` is too small to fit in `BIGINT SIGNED`. This will throw an error.
     *
     * -----
     *
     * ```sql
     *  SELECT -CAST(9223372036854775809 AS UNSIGNED);
     * ```
     * The above gives you a `DECIMAL` type with value `-9223372036854775809` in MySQL.
     * PostgreSQL and SQLite do not have `BIGINT UNSIGNED`.
     *
     * -----
     *
     * MySQL and PostgreSQL query builders should perform the unary minus on the library
     * level as much as possible. However, it is not always feasible...
     *
     * PostgreSQL should perform bigint unary minus with `-CAST(x AS BIGINT)` to avoid implicit conversions.
     *
     * MySQL should just use `CAST(-x AS SIGNED)`.
     *
     * However, on MySQL,
     * `CAST(-18446744073709551615 AS SIGNED)` === `-9223372036854775808` (signed bigint minimum value)
     *
     * It would be nice if it threw an error instead.
     * It throws an error on PostgreSQL.
     *
     * SQLite should have a special `bigintNeg()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    export const neg: Operator1<bigint, bigint>;
}
declare module "expr-library/integer/random-bigint-signed" {
    import { Operator0 } from "expr-library/factory/index";
    /**
     * Returns a random `BIGINT SIGNED` in the range,
     * [-9223372036854775808, 9223372036854775807]
     *
     * -----
     *
     * MySQL,
     * ```sql
     *  CAST(
     *      CAST(RAND() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
     *      AS SIGNED
     *  )
     * ```
     *
     * PostgreSQL,
     * ```sql
     *  CAST(
     *      CAST(RANDOM() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
     *      AS BIGINT
     *  )
     * ```
     *
     * SQLite,
     * ```sql
     *  RANDOM()
     * ```
     */
    export const randomBigIntSigned: Operator0<bigint>;
}
declare module "expr-library/integer/sign" {
    import { Operator1 } from "expr-library/factory/index";
    /**
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
     *
     * Will return -1, 0, 1
     */
    export const sign: Operator1<bigint, bigint>;
}
declare module "expr-library/integer/sub" {
    import { Operator2 } from "expr-library/factory/index";
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807- (-9223372036854775808);
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT -9223372036854775808 - 9223372036854775807
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615 - (-9223372036854775808)
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is subtracting two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is subtracting two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 - 9223372036854775807 - 9223372036854775807 - 9223372036854775807
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintSub()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    export const sub: Operator2<bigint, bigint, bigint>;
}
declare module "expr-library/integer/index" {
    export * from "expr-library/integer/aggregate/index";
    export * from "expr-library/integer/bitwise/index";
    export * from "expr-library/integer/abs";
    export * from "expr-library/integer/add";
    export * from "expr-library/integer/integer-div";
    export * from "expr-library/integer/integer-remainder";
    export * from "expr-library/integer/mul";
    export * from "expr-library/integer/neg";
    export * from "expr-library/integer/random-bigint-signed";
    export * from "expr-library/integer/sign";
    export * from "expr-library/integer/sub";
}
declare module "expr-library/index" {
    export * from "expr-library/aggregate/index";
    export * from "expr-library/aggregate-factory/index";
    export * from "expr-library/assert/index";
    export * from "expr-library/cast/index";
    export * from "expr-library/comparison/index";
    export * from "expr-library/control-flow/index";
    export * from "expr-library/date-time/index";
    export * from "expr-library/equation/index";
    export * from "expr-library/factory/index";
    export * from "expr-library/information/index";
    export * from "expr-library/logical/index";
    export * from "expr-library/logical-3/index";
    export * from "expr-library/null-safe-equation/index";
    export * from "expr-library/string/index";
    export * from "expr-library/subquery/index";
    import * as decimal from "expr-library/decimal/index";
    import * as double from "expr-library/double/index";
    import * as integer from "expr-library/integer/index";
    export { decimal, double, integer, };
}
declare module "ast/literal-value-node/util/constructor/decimal-literal-node" {
    import { Decimal } from "decimal/index";
    import { DecimalLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function decimalLiteralNode(rawDecimalLiteral: string | number | bigint | Decimal, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision: number | bigint, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale: number | bigint): DecimalLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/double-literal-node" {
    import { DoubleLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function doubleLiteralNode(literalValue: number): DoubleLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/null-literal-node" {
    import { NullLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function nullLiteralNode(literalValue: null): NullLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/string-literal-node" {
    import { StringLiteralNode } from "ast/literal-value-node/literal-value-node";
    export function stringLiteralNode(literalValue: string): StringLiteralNode;
}
declare module "ast/literal-value-node/util/constructor/index" {
    export * from "ast/literal-value-node/util/constructor/bigint-literal-node";
    export * from "ast/literal-value-node/util/constructor/boolean-literal-node";
    export * from "ast/literal-value-node/util/constructor/buffer-literal-node";
    export * from "ast/literal-value-node/util/constructor/date-time-literal-node";
    export * from "ast/literal-value-node/util/constructor/decimal-literal-node";
    export * from "ast/literal-value-node/util/constructor/double-literal-node";
    export * from "ast/literal-value-node/util/constructor/null-literal-node";
    export * from "ast/literal-value-node/util/constructor/string-literal-node";
}
declare module "ast/literal-value-node/util/predicate/is-literal-value-node" {
    import { LiteralValueNode } from "ast/literal-value-node/literal-value-node";
    /**
     * Does not check for `precision` and `scale` for `DecimalLiteralNode`.
     * Just assumes it exists.
     */
    export function isLiteralValueNode(mixed: unknown): mixed is LiteralValueNode;
}
declare module "ast/literal-value-node/util/predicate/index" {
    export * from "ast/literal-value-node/util/predicate/is-literal-value-node";
}
declare module "ast/literal-value-node/util/index" {
    export * from "ast/literal-value-node/util/constructor/index";
    export * from "ast/literal-value-node/util/predicate/index";
}
declare module "ast/literal-value-node/index" {
    export * from "ast/literal-value-node/literal-value-node";
    import * as LiteralValueNodeUtil from "ast/literal-value-node/util/index";
    export { LiteralValueNodeUtil, };
}
declare module "ast/sqlfier/operator-sqlfier" {
    import { OperatorNode } from "ast/operator-node/index";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    import { Ast, AstArray } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { OperatorType } from "operator-type";
    import { LiteralValueNode } from "ast/literal-value-node/index";
    export type OperatorSqlfier = {
        readonly [operatorType in OperatorType]: (op: OperatorNode<operatorType>, toSql: (ast: Ast) => string, sqlfier: Sqlfier) => string | AstArray | Parentheses | FunctionCall | LiteralValueNode;
    };
}
declare module "ast/identifier-node" {
    export interface IdentifierNode {
        readonly type: "Identifier";
        /**
         * Must have at least one identifier.
         *
         * MySQL will add backticks to each identifier, and separate each identifier with a dot.
         * PostgreSQL will add double quotes to each identifier, and separate each identifier with a dot.
         */
        readonly identifiers: readonly [string, ...string[]];
    }
    export function identifierNode(...identifiers: IdentifierNode["identifiers"]): IdentifierNode;
    /**
     * Does not check that each element of the `identifiers` property is a `string`
     *
     * @param mixed
     */
    export function isIdentifierNode(mixed: unknown): mixed is IdentifierNode;
}
declare module "ast/sqlfier/identifier-sqlfier" {
    import { IdentifierNode } from "ast/identifier-node";
    export interface IdentifierSqlfier {
        (identifierNode: IdentifierNode): string;
    }
}
declare module "ast/sqlfier/query-base-sqlfier" {
    import { IQueryBase } from "query-base/index";
    import { Ast } from "ast/ast";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    export interface QueryBaseSqlfier {
        (query: IQueryBase, toSql: (ast: Ast) => string, sqlfier: Sqlfier): string;
    }
}
declare module "ast/sqlfier/literal-value-sqlfier" {
    import { LiteralValueNode, LiteralValueType } from "ast/literal-value-node/index";
    import { AstArray, Ast } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    export type LiteralValueToSql<TypeT extends LiteralValueType> = (node: Extract<LiteralValueNode, {
        literalValueType: TypeT;
    }>, toSql: (ast: Ast) => string, sqlfier: Sqlfier) => string | AstArray | Parentheses | FunctionCall;
    export type LiteralValueSqlfier = {
        [literalValueType in LiteralValueType]: LiteralValueToSql<literalValueType>;
    };
}
declare module "ast/sqlfier/case-condition-sqlfier" {
    import { AstArray, Ast } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    import { CaseConditionNode } from "ast/case-condition-node/index";
    export interface CaseConditionSqlfier {
        (node: CaseConditionNode, toSql: (ast: Ast) => string, sqlfier: Sqlfier): string | AstArray | Parentheses | FunctionCall;
    }
}
declare module "ast/sqlfier/parentheses-sqlfier" {
    import { AstArray, Ast } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    import { LiteralValueNode } from "ast/literal-value-node/index";
    export interface ParenthesesSqlfier {
        (parentheses: Parentheses, toSql: (ast: Ast) => string, sqlfier: Sqlfier): string | AstArray | Parentheses | FunctionCall | LiteralValueNode;
    }
}
declare module "ast/sqlfier/sqlfier" {
    import { OperatorSqlfier } from "ast/sqlfier/operator-sqlfier";
    import { IdentifierSqlfier } from "ast/sqlfier/identifier-sqlfier";
    import { QueryBaseSqlfier } from "ast/sqlfier/query-base-sqlfier";
    import { LiteralValueSqlfier } from "ast/sqlfier/literal-value-sqlfier";
    import { CaseValueSqlfier } from "ast/sqlfier/case-sqlfier";
    import { CaseConditionSqlfier } from "ast/sqlfier/case-condition-sqlfier";
    import { ParenthesesSqlfier } from "ast/sqlfier/parentheses-sqlfier";
    export interface Sqlfier {
        readonly identifierSqlfier: IdentifierSqlfier;
        readonly literalValueSqlfier: LiteralValueSqlfier;
        readonly operatorSqlfier: OperatorSqlfier;
        readonly queryBaseSqlfier: QueryBaseSqlfier;
        readonly caseValueSqlfier: CaseValueSqlfier;
        readonly caseConditionSqlfier: CaseConditionSqlfier;
        /**
         * Added specially for MySQL.
         *
         * This is invalid,
         * ```ts
         *  SELECT (
         *      (SELECT 1)
         *      UNION
         *      (SELECT 1)
         *  )
         * ```
         *
         * This is valid,
         * ```ts
         *  SELECT (
         *      SELECT 1
         *      UNION
         *      (SELECT 1)
         *  )
         * ```
         */
        readonly parenthesesSqlfier?: ParenthesesSqlfier;
    }
}
declare module "ast/case-value-node/case-value-node" {
    import { Ast } from "ast/ast";
    /**
     * The first `Ast` is the `compare_value`.
     * The second `Ast` is the `result`.
     */
    export type Case = readonly [Ast, Ast];
    /**
     * Similar to switch-statements in other languages.
     */
    export interface CaseValueNode {
        readonly type: "CaseValue";
        /**
         * The `value` to test against.
         */
        readonly value: Ast;
        /**
         * A `CASE` expression must have at least one case.
         */
        readonly cases: readonly [Case, ...Case[]];
        /**
         * A `CASE` expression may have an `ELSE` clause.
         */
        readonly else: Ast | undefined;
    }
}
declare module "ast/case-value-node/util/predicate/is-case-value-node" {
    import { CaseValueNode } from "ast/case-value-node/case-value-node";
    export function isCaseValueNode(mixed: unknown): mixed is CaseValueNode;
}
declare module "ast/case-value-node/util/predicate/index" {
    export * from "ast/case-value-node/util/predicate/is-case-value-node";
}
declare module "ast/case-value-node/util/index" {
    export * from "ast/case-value-node/util/predicate/index";
}
declare module "ast/case-value-node/index" {
    export * from "ast/case-value-node/case-value-node";
    import * as CaseValueNodeUtil from "ast/case-value-node/util/index";
    export { CaseValueNodeUtil, };
}
declare module "ast/sqlfier/case-sqlfier" {
    import { AstArray, Ast } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    import { CaseValueNode } from "ast/case-value-node/index";
    export interface CaseValueSqlfier {
        (node: CaseValueNode, toSql: (ast: Ast) => string, sqlfier: Sqlfier): string | AstArray | Parentheses | FunctionCall;
    }
}
declare module "ast/sqlfier/not-implemented-sqlfier" {
    import { Sqlfier } from "ast/sqlfier/sqlfier";
    export const notImplementedSqlfier: Sqlfier;
}
declare module "ast/sqlfier/index" {
    export * from "ast/sqlfier/case-sqlfier";
    export * from "ast/sqlfier/case-condition-sqlfier";
    export * from "ast/sqlfier/identifier-sqlfier";
    export * from "ast/sqlfier/not-implemented-sqlfier";
    export * from "ast/sqlfier/literal-value-sqlfier";
    export * from "ast/sqlfier/operator-sqlfier";
    export * from "ast/sqlfier/parentheses-sqlfier";
    export * from "ast/sqlfier/query-base-sqlfier";
    export * from "ast/sqlfier/sqlfier";
}
declare module "ast/function-call" {
    import { Ast } from "ast/ast";
    import { Sqlfier } from "ast/sqlfier/index";
    export class FunctionArg {
        readonly type = "FunctionArg";
        readonly ast: Ast;
        constructor(ast: Ast);
        toSql: (sqlfier: Sqlfier) => string;
        static IsFunctionArg(x: any): x is FunctionArg;
    }
    export class FunctionCall {
        readonly type = "FunctionCall";
        readonly functionName: string;
        readonly args: readonly FunctionArg[];
        constructor(functionName: string, args: readonly FunctionArg[]);
        toSql: (sqlfier: Sqlfier) => string;
        static IsFunctionCall(x: any): x is FunctionCall;
    }
    export function functionArg(ast: Ast): FunctionArg;
    export function functionCall(functionName: string, args: readonly Ast[]): FunctionCall;
}
declare module "ast/util/is-ast" {
    import { Ast } from "ast/ast";
    /**
     * A type guard for the `Ast` type
     *
     * @param raw
     */
    export function isAst(raw: unknown): raw is Ast;
}
declare module "formatter/TokenType" {
    export enum TokenType {
        WHITESPACE = "whitespace",
        WORD = "word",
        STRING = "string",
        RESERVED = "reserved",
        RESERVED_TOPLEVEL = "reserved-toplevel",
        RESERVED_NEWLINE = "reserved-newline",
        RESERVED_PRE_NEWLINE = "reserved-pre-newline",
        OPERATOR = "operator",
        OPEN_PAREN = "open-paren",
        CLOSE_PAREN = "close-paren",
        LINE_COMMENT = "line-comment",
        BLOCK_COMMENT = "block-comment",
        NUMBER = "number",
        PLACEHOLDER = "placeholder"
    }
}
declare module "formatter/Indentation" {
    /**
     * Manages indentation levels.
     *
     * There are two types of indentation levels:
     *
     * - BLOCK_LEVEL : increased by open-parenthesis
     * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
     */
    export class Indentation {
        private readonly indent;
        private readonly indentTypes;
        /**
         * @param {String} indent Indent value, default is "  " (2 spaces)
         */
        constructor(indent: string | undefined);
        /**
         * Returns current indentation string.
         * @return {String}
         */
        getIndent(): string;
        /**
         * Increases indentation by one top-level indent.
         */
        increaseToplevel(): void;
        /**
         * Increases indentation by one block-level indent.
         */
        increaseBlockLevel(): void;
        /**
         * Decreases indentation by one top-level indent.
         * Does nothing when the previous indent is not top-level.
         */
        decreaseTopLevel(): void;
        /**
         * Decreases indentation by one block-level indent.
         * If there are top-level indents within the block-level indent,
         * throws away these as well.
         */
        decreaseBlockLevel(): void;
    }
}
declare module "formatter/Token" {
    import { TokenType } from "formatter/TokenType";
    export interface Token {
        type: TokenType;
        value: string;
        key?: string;
    }
}
declare module "formatter/InlineBlock" {
    import { Token } from "formatter/Token";
    /**
     * Bookkeeper for inline blocks.
     *
     * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.
     * These blocks are formatted on a single line, unlike longer parenthized
     * expressions where open-parenthesis causes newline and increase of indentation.
     */
    export class InlineBlock {
        private level;
        constructor();
        /**
         * Begins inline block when lookahead through upcoming tokens determines
         * that the block would be smaller than INLINE_MAX_LENGTH.
         * @param  {Object[]} tokens Array of all tokens
         * @param  {Number} index Current token position
         */
        beginIfPossible(tokens: Token[], index: number): void;
        /**
         * Finishes current inline block.
         * There might be several nested ones.
         */
        end(): void;
        /**
         * True when inside an inline block
         * @return {Boolean}
         */
        isActive(): boolean;
        isInlineBlock(tokens: Token[], index: number): boolean;
        isForbiddenToken({ type, value }: Token): boolean;
    }
}
declare module "formatter/Params" {
    import { Token } from "formatter/Token";
    /**
     * Handles placeholder replacement with given params.
     */
    export class Params {
        private readonly params;
        private index;
        /**
         * @param {Object} params
         */
        constructor(params: string[] | {
            [key: string]: string;
        } | undefined);
        /**
         * Returns param value that matches given placeholder with param key.
         * @param {Object} token
         * @param {String} token.key Placeholder key
         * @param {String} token.value Placeholder value
         * @return {String} param or token.value when params are missing
         */
        get({ key, value }: Token): string;
    }
}
declare module "formatter/Tokenizer" {
    import { TokenType } from "formatter/TokenType";
    import { Token } from "formatter/Token";
    export interface TokenizerConfig {
        reservedWords: string[];
        reservedToplevelWords: string[];
        reservedNewlineWords: string[];
        reservedPreNewlineWords: string[];
        stringTypes: ("``" | "[]" | "\"\"" | "''" | "N''" | "X''" | "pascal-single" | "pascal-double")[];
        openParens: string[];
        closeParens: string[];
        indexedPlaceholderTypes: string[];
        namedPlaceholderTypes: string[];
        lineCommentTypes: string[];
        specialWordChars: string[] | undefined;
    }
    export class Tokenizer {
        private readonly WHITESPACE_REGEX;
        private readonly NUMBER_REGEX;
        private readonly OPERATOR_REGEX;
        private readonly BLOCK_COMMENT_REGEX;
        private readonly LINE_COMMENT_REGEX;
        private readonly RESERVED_TOPLEVEL_REGEX;
        private readonly RESERVED_NEWLINE_REGEX;
        private readonly RESERVED_PRE_NEWLINE_REGEX;
        private readonly RESERVED_PLAIN_REGEX;
        private readonly WORD_REGEX;
        private readonly STRING_REGEX;
        private readonly OPEN_PAREN_REGEX;
        private readonly CLOSE_PAREN_REGEX;
        private readonly INDEXED_PLACEHOLDER_REGEX;
        private readonly IDENT_NAMED_PLACEHOLDER_REGEX;
        private readonly STRING_NAMED_PLACEHOLDER_REGEX;
        /**
         * @param {Object} cfg
         *  @param {String[]} cfg.reservedWords Reserved words in SQL
         *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately
         *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline
         *  @param {String[]} cfg.stringTypes String types to enable: "", '', ``, [], N''
         *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [
         *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]
         *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?
         *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :
         *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --
         *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #
         */
        constructor(cfg: TokenizerConfig);
        createLineCommentRegex(lineCommentTypes: string[]): RegExp;
        createReservedWordRegex(reservedWords: string[]): RegExp;
        createWordRegex(specialChars?: string[]): RegExp;
        createStringRegex(stringTypes: TokenizerConfig["stringTypes"]): RegExp;
        createStringPattern(stringTypes: TokenizerConfig["stringTypes"]): string;
        createParenRegex(parens: string[]): RegExp;
        escapeParen(paren: string): string;
        createPlaceholderRegex(types: string[], pattern: string): RegExp | undefined;
        /**
         * Takes a SQL string and breaks it into tokens.
         * Each token is an object with type and value.
         *
         * @param {String} input The SQL string
         * @return {Object[]} tokens An array of tokens.
         *  @return {String} token.type
         *  @return {String} token.value
         */
        tokenize(input: string): Token[];
        getNextToken(input: string, previousToken: Token | undefined): Token | undefined;
        getWhitespaceToken(input: string): Token | undefined;
        getCommentToken(input: string): Token | undefined;
        getLineCommentToken(input: string): Token | undefined;
        getBlockCommentToken(input: string): Token | undefined;
        getStringToken(input: string): Token | undefined;
        getOpenParenToken(input: string): Token | undefined;
        getCloseParenToken(input: string): Token | undefined;
        getPlaceholderToken(input: string): Token | undefined;
        getIdentNamedPlaceholderToken(input: string): Token | undefined;
        getStringNamedPlaceholderToken(input: string): Token | undefined;
        getIndexedPlaceholderToken(input: string): Token | undefined;
        getPlaceholderTokenWithKey({ input, regex, parseKey }: {
            input: string;
            regex: RegExp | undefined;
            parseKey: (v: string) => string;
        }): Token | undefined;
        getEscapedPlaceholderKey({ key, quoteChar }: {
            key: string;
            quoteChar: string;
        }): string;
        getNumberToken(input: string): Token | undefined;
        getOperatorToken(input: string): Token | undefined;
        getReservedWordToken(input: string, previousToken: Token | undefined): Token | undefined;
        getToplevelReservedToken(input: string): Token | undefined;
        getNewlineReservedToken(input: string): Token | undefined;
        getPreNewlineReservedToken(input: string): Token | undefined;
        getPlainReservedToken(input: string): Token | undefined;
        getWordToken(input: string): Token | undefined;
        getTokenOnFirstMatch({ input, type, regex }: {
            input: string;
            type: TokenType;
            regex: RegExp | undefined;
        }): Token | undefined;
    }
}
declare module "formatter/Formatter" {
    import { Tokenizer } from "formatter/Tokenizer";
    import { Token } from "formatter/Token";
    export interface FormatterConfig {
        indent?: string;
        params?: string[] | {
            [key: string]: string;
        } | undefined;
    }
    export class Formatter {
        private readonly cfg;
        private readonly indentation;
        private readonly inlineBlock;
        private readonly params;
        private readonly tokenizer;
        private previousReservedWord;
        private tokens;
        private index;
        /**
         * @param {Object} cfg
         *   @param {Object} cfg.indent
         *   @param {Object} cfg.params
         * @param {Tokenizer} tokenizer
         */
        constructor(cfg: FormatterConfig | undefined, tokenizer: Tokenizer);
        /**
         * Formats whitespaces in a SQL string to make it easier to read.
         *
         * @param {String} query The SQL query string
         * @return {String} formatted query
         */
        format(query: string): string;
        getFormattedQueryFromTokens(): string;
        formatLineComment(token: Token, query: string): string;
        formatBlockComment(token: Token, query: string): string;
        indentComment(comment: string): string;
        formatToplevelReservedWord(token: Token, query: string): string;
        formatNewlineReservedWord(token: Token, query: string): string;
        formatPreNewlineReservedWord(token: Token, query: string): string;
        equalizeWhitespace(string: string): string;
        formatOpeningParentheses(token: Token, query: string): string;
        formatClosingParentheses(token: Token, query: string): string;
        formatPlaceholder(token: Token, query: string): string;
        formatComma(token: Token, query: string): string;
        formatWithSpaceAfter(token: Token, query: string): string;
        formatWithoutSpaces(token: Token, query: string): string;
        formatWithSpaces(token: Token, query: string): string;
        addNewline(query: string): string;
        trimTrailingWhitespace(query: string): string;
        hasPreviousNonWhitespaceToken(): boolean;
        previousNonWhitespaceToken(): Token;
        hasPreviousToken(offset?: number): boolean;
        previousToken(offset?: number): Token;
    }
}
declare module "formatter/SqlFormatter" {
    import { FormatterConfig } from "formatter/Formatter";
    import { TokenizerConfig } from "formatter/Tokenizer";
    export const defaultTokenizerConfig: TokenizerConfig;
    export class SqlFormatter {
        private readonly cfg;
        private readonly tokenizerConfig;
        private tokenizer;
        /**
         * @param {Object} cfg Different set of configurations
         */
        constructor(cfg?: FormatterConfig | undefined, tokenizerConfig?: Partial<TokenizerConfig> | undefined);
        /**
         * Format the whitespace in a Standard SQL string to make it easier to read
         *
         * @param {String} query The Standard SQL string
         * @return {String} formatted string
         */
        format(query: string): string;
    }
}
declare module "formatter/index" {
    export * from "formatter/Formatter";
    export * from "formatter/Indentation";
    export * from "formatter/InlineBlock";
    export * from "formatter/Params";
    export * from "formatter/SqlFormatter";
    export * from "formatter/Token";
    export * from "formatter/Tokenizer";
    export * from "formatter/TokenType";
}
declare module "ast/util/to-sql" {
    import { Ast, AstArray } from "ast/ast";
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { Sqlfier } from "ast/sqlfier/index";
    import { LiteralValueNode } from "ast/literal-value-node/index";
    export function toSqlAst(ast: Ast, sqlfier: Sqlfier): string | AstArray | Parentheses | FunctionCall | LiteralValueNode;
    /**
     * Converts an AST to a SQL string.
     *
     * **DOES NOT** prettify the output.
     *
     * @see {@link toSqlPretty} for prettified output.
     *
     * @param ast
     */
    export function toSql(ast: Ast, sqlfier: Sqlfier): string;
}
declare module "ast/util/to-sql-pretty" {
    import { TokenizerConfig } from "formatter/index";
    import { Ast } from "ast/ast";
    import { Sqlfier } from "ast/sqlfier/index";
    /**
     * Converts an AST to a SQL string.
     *
     * Prettifies the output.
     *
     * -----
     *
     * Perfomance is generally "okay" but when queries become
     * hundreds of thousands of characters long,
     * it can take a long time.
     *
     * Use this with caution.
     *
     * @param ast
     */
    export function toSqlPretty(ast: Ast, sqlfier: Sqlfier, tokenizerConfig: (
    /**
     * `stringTypes` must be set because it's too dangerous
     * to leave it at the default settings.
     *
     * MySQL uses `'\\'` to represent a single backslash character.
     * PostgreSQL and SQLite use `'\'` to represent a single backslash character.
     */
    Partial<TokenizerConfig> & {
        stringTypes: TokenizerConfig["stringTypes"];
    })): string;
}
declare module "ast/util/try-extract-ast" {
    import { Ast } from "ast/ast";
    type TryExtractAstResult<ReturnT extends boolean | Ast | undefined> = (ReturnT extends boolean ? Ast : never) | Extract<ReturnT, Ast | undefined>;
    /**
     * + If the AST satisfies the predicate, it is returned.
     * + If the AST is a `Parentheses` that contains an AST satisfying the predicate,
     * the `Parentheses` is returned.
     * + Else, `undefined` is returned.
     */
    export function tryExtractAst<ReturnT extends boolean | Ast | undefined>(operand: Ast, extractDelegate: (operand: Ast) => ReturnT): TryExtractAstResult<ReturnT>;
    export function tryExtractAstOr(operand: Ast, extractDelegate: (operand: Ast) => boolean | Ast | undefined, noMatchDelegate: (operand: Ast) => Ast): Ast;
}
declare module "ast/util/try-unwrap-parentheses" {
    import { Ast } from "ast/ast";
    export function tryUnwrapParentheses(ast: Ast): Ast;
}
declare module "ast/util/index" {
    export * from "ast/util/insert-between";
    export * from "ast/util/is-ast";
    export * from "ast/util/to-sql-pretty";
    export * from "ast/util/to-sql";
    export * from "ast/util/try-extract-ast";
    export * from "ast/util/try-unwrap-parentheses";
}
declare module "ast/parentheses" {
    import { Ast } from "ast/ast";
    import { Sqlfier } from "ast/sqlfier/index";
    export class Parentheses {
        readonly type = "Parentheses";
        readonly ast: Ast;
        /**
         * This,
         * ```sql
         * SELECT
         *  IF(
         *      RAND() > 0.5,
         *      --The parentheses here may be unwrapped safely
         *      (RAND() + 1),
         *      --The parentheses here MAY NOT be unwrapped safely
         *      (SELECT x FROM myTable ORDER BY RAND() LIMIT 1)
         *  )
         * ```
         *
         * Is the same as this,
         * ```sql
         * SELECT
         *  IF(
         *      RAND() > 0.5,
         *      --The parentheses here may be unwrapped safely
         *      RAND() + 1,
         *      --The parentheses here MAY NOT be unwrapped safely
         *      (SELECT x FROM myTable ORDER BY RAND() LIMIT 1)
         *  )
         * ```
         *
         * You cannot unwrap sub-queries or you will get a syntax error.
         */
        readonly canUnwrap: boolean;
        constructor(ast: Ast, canUnwrap: boolean);
        toSql: (sqlfier: Sqlfier) => string;
        static IsParentheses(x: any): x is Parentheses;
        static Create(ast: Ast, canUnwrap?: boolean): Ast;
    }
    export function parentheses(ast: Ast, canUnwrap?: boolean): Ast;
}
declare module "ast/ast" {
    import { Parentheses } from "ast/parentheses";
    import { FunctionCall } from "ast/function-call";
    import { OperatorNode } from "ast/operator-node/index";
    import { IdentifierNode } from "ast/identifier-node";
    import { IQueryBase } from "query-base/index";
    import { LiteralValueNode } from "ast/literal-value-node/index";
    import { CaseValueNode } from "ast/case-value-node/index";
    import { CaseConditionNode } from "ast/case-condition-node/index";
    export interface AstArray extends ReadonlyArray<Ast> {
    }
    export type Ast = 
    /**
     * A string literal that will not be escaped
     */
    string
    /**
     * An array of AST
     */
     | AstArray
    /**
     * Adds parentheses around an AST
     */
     | Parentheses
    /**
     * @todo Description
     */
     | FunctionCall
    /**
     * @todo Description
     */
     | OperatorNode
    /**
     * @todo Description
     */
     | IdentifierNode
    /**
     * A literal value, it **MUST** have its value **ESCAPED** before being passed to the DBMS!
     */
     | LiteralValueNode
    /**
     * A query
     */
     | IQueryBase
    /**
     * Similar to switch-statements in other languages.
     */
     | CaseValueNode
    /**
     * Similar to if-statements in other languages.
     */
     | CaseConditionNode;
}
declare module "ast/case-condition-node/case-condition-node" {
    import { Ast } from "ast/ast";
    /**
     * The first `Ast` is the `condition`.
     * The second `Ast` is the `result`.
     */
    export type Branch = readonly [Ast, Ast];
    /**
     * Similar to if-statements in other languages.
     */
    export interface CaseConditionNode {
        readonly type: "CaseCondition";
        /**
         * A `CASE WHEN` expression must have at least one branch.
         */
        readonly branches: readonly [Branch, ...Branch[]];
        /**
         * A `CASE WHEN` expression may have an `ELSE` clause.
         */
        readonly else: Ast | undefined;
    }
}
declare module "ast/case-condition-node/util/predicate/is-case-condition-node" {
    import { CaseConditionNode } from "ast/case-condition-node/case-condition-node";
    export function isCaseConditionNode(mixed: unknown): mixed is CaseConditionNode;
}
declare module "ast/case-condition-node/util/predicate/index" {
    export * from "ast/case-condition-node/util/predicate/is-case-condition-node";
}
declare module "ast/case-condition-node/util/index" {
    export * from "ast/case-condition-node/util/predicate/index";
}
declare module "ast/case-condition-node/index" {
    export * from "ast/case-condition-node/case-condition-node";
    import * as CaseConditionNodeUtil from "ast/case-condition-node/util/index";
    export { CaseConditionNodeUtil, };
}
declare module "ast/index" {
    export * from "ast/case-condition-node/index";
    export * from "ast/case-value-node/index";
    export * from "ast/literal-value-node/index";
    export * from "ast/operator-node/index";
    export * from "ast/sqlfier/index";
    export * from "ast/ast";
    export * from "ast/function-call";
    export * from "ast/identifier-node";
    export * from "ast/parentheses";
    import * as AstUtil from "ast/util/index";
    export { AstUtil, };
}
declare module "expr/expr" {
    import * as tm from "type-mapping";
    import { Ast } from "ast/index";
    import { IUsedRef } from "used-ref/index";
    export interface ExprData {
        readonly mapper: tm.AnySafeMapper;
        readonly usedRef: IUsedRef;
        readonly isAggregate: boolean;
    }
    export interface IExpr<DataT extends ExprData = ExprData> {
        /**
         * The mapper that validates/converts raw values for use
         */
        readonly mapper: DataT["mapper"];
        /**
         * The columns used by this expression.
         * ```sql
         * SELECT
         *  --The `usedRef` of this expression are the two columns involved
         *  (myTable.myColumn + otherTable.otherColumn)
         * FROM
         *  myTable
         * JOIN
         *  otherTable
         * ON
         *  myTable.id = otherTable.id
         * ```
         */
        readonly usedRef: DataT["usedRef"];
        readonly isAggregate: DataT["isAggregate"];
        /**
         * The AST of the expression
         */
        readonly ast: Ast;
    }
    /**
     * @todo Find All References and check that usages are valid.
     */
    export type IAnonymousExpr<TypeT, IsAggregateT extends boolean> = (IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: IUsedRef;
        isAggregate: IsAggregateT;
    }>);
}
declare module "expr/util/constructor/from-built-in-expr" {
    import * as tm from "type-mapping";
    import { Expr } from "expr/expr-impl";
    import { BuiltInExprUtil, AnyBuiltInExpr } from "built-in-expr/index";
    import { CustomExpr_NonCorrelated, CustomExpr_NonCorrelated_NonAggregate, CustomExprUtil } from "custom-expr/index";
    import { IAnonymousColumn } from "column/index";
    import { IUsedRef } from "used-ref/index";
    export type FromBuiltInExpr<BuiltInExprT extends AnyBuiltInExpr> = (Expr<{
        mapper: BuiltInExprUtil.Mapper<BuiltInExprT>;
        usedRef: BuiltInExprUtil.UsedRef<BuiltInExprT>;
        isAggregate: BuiltInExprUtil.IsAggregate<BuiltInExprT>;
    }>);
    export function fromBuiltInExpr<BuiltInExprT extends AnyBuiltInExpr>(builtInExpr: BuiltInExprT): (FromBuiltInExpr<BuiltInExprT>);
    export function fromRawExprNoUsedRefInput<TypeT>(mapper: tm.SafeMapper<TypeT> | IAnonymousColumn<TypeT>, value: CustomExpr_NonCorrelated_NonAggregate<TypeT>): (Expr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>);
    export function fromRawExprNoUsedRefInput<CustomExprT extends CustomExpr_NonCorrelated<unknown>>(mapper: tm.SafeMapper<CustomExprUtil.TypeOf<CustomExprT>> | IAnonymousColumn<CustomExprUtil.TypeOf<CustomExprT>>, value: CustomExprT): (Expr<{
        mapper: tm.SafeMapper<CustomExprUtil.TypeOf<CustomExprT>>;
        usedRef: IUsedRef<{}>;
        isAggregate: CustomExprUtil.IsAggregate<CustomExprT>;
    }>);
}
declare module "expr/util/constructor/index" {
    export * from "expr/util/constructor/from-built-in-expr";
}
declare module "expr/util/operation/aggregate-intersect" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr_NonAggregate, BuiltInExprUtil } from "built-in-expr/index";
    import { Expr } from "expr/expr-impl";
    import { TryReuseExistingType } from "type-util/index";
    import { Ast } from "ast/index";
    /**
     * Given `foo(arg0, arg1, ...)`,
     *
     * | `foo` is aggregate | some `arg` is aggregate | expression is aggregate |
     * |--------------------|-------------------------|-------------------------|
     * | Y                  | Y                       | -Compile Error-
     * | Y                  | N                       | Y
     * | N                  | Y                       | Y
     * | N                  | N                       | N
     *
     * This `AggregateIntersect<>` type assumes `foo` is aggregate.
     * @see Intersect<>
     */
    export type AggregateIntersect<OutputTypeT, ArgsT extends AnyBuiltInExpr_NonAggregate> = TryReuseExistingType<ArgsT, Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<ArgsT>;
        isAggregate: true;
    }>>;
    /**
     * Called wasteful because it does not attempt to reuse existing types,
     * wasting our depth limit.
     */
    export type __WastefulAggregateIntersect<OutputTypeT, ArgsT extends AnyBuiltInExpr_NonAggregate> = Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<ArgsT>;
        isAggregate: true;
    }>;
    export function aggregateIntersect<OutputTypeT, ArgsT extends AnyBuiltInExpr_NonAggregate>(mapper: tm.SafeMapper<OutputTypeT>, args: readonly ArgsT[], ast: Ast): AggregateIntersect<OutputTypeT, ArgsT>;
}
declare module "expr/util/operation/as" {
    import { IExpr } from "expr/expr";
    import { ALIASED } from "constants";
    import { AliasedExpr } from "aliased-expr/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export type AsImpl<AliasT extends string, MapperT extends IExpr["mapper"], UsedRefT extends IExpr["usedRef"], IsAggregateT extends IExpr["isAggregate"]> = (AliasedExpr<{
        mapper: MapperT;
        tableAlias: typeof ALIASED;
        alias: AliasT;
        usedRef: UsedRefT;
        isAggregate: IsAggregateT;
    }>);
    export type As<ExprT extends IExpr, AliasT extends string> = (AsImpl<AliasT, ExprT["mapper"], ExprT["usedRef"], ExprT["isAggregate"]>);
    export function as<ExprT extends IExpr, AliasT extends string>(expr: ExprT, alias: AliasT): As<ExprT, AliasT>;
}
declare module "expr/util/operation/intersect" {
    import * as tm from "type-mapping";
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { Expr } from "expr/expr-impl";
    import { TryReuseExistingType } from "type-util/index";
    import { Ast } from "ast/index";
    type Intersect_IsAggregate<ArgsT extends AnyBuiltInExpr> = true extends BuiltInExprUtil.HasNonUnitIsAggregate<ArgsT> ? boolean : true extends BuiltInExprUtil.IsAggregate<ArgsT> ? true : false;
    /**
     * Given `foo(arg0, arg1, ...)`,
     *
     * | `foo` is aggregate | some `arg` is aggregate | expression is aggregate |
     * |--------------------|-------------------------|-------------------------|
     * | Y                  | Y                       | -Compile Error-
     * | Y                  | N                       | Y
     * | N                  | Y                       | Y
     * | N                  | N                       | N
     *
     * This `Intersect<>` type assumes `foo` is non-aggregate.
     * @see AggregateIntersect<>
     */
    export type Intersect<OutputTypeT, ArgsT extends AnyBuiltInExpr> = TryReuseExistingType<ArgsT, Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<ArgsT>;
        isAggregate: Intersect_IsAggregate<ArgsT>;
    }>>;
    /**
     * Called wasteful because it does not attempt to reuse existing types,
     * wasting our depth limit.
     */
    export type __WastefulIntersect<OutputTypeT, ArgsT extends AnyBuiltInExpr> = Expr<{
        mapper: tm.SafeMapper<OutputTypeT>;
        usedRef: BuiltInExprUtil.IntersectUsedRef<ArgsT>;
        isAggregate: Intersect_IsAggregate<ArgsT>;
    }>;
    export function intersect<OutputTypeT, ArgsT extends AnyBuiltInExpr>(mapper: tm.SafeMapper<OutputTypeT>, args: readonly ArgsT[], ast: Ast): Intersect<OutputTypeT, ArgsT>;
}
declare module "expr/util/operation/sort" {
    import { IExpr } from "expr/expr";
    import { SortDirection } from "sort-direction/index";
    export type Asc<ExprT extends IExpr> = ([ExprT, SortDirection.ASC]);
    export function asc<ExprT extends IExpr>(expr: ExprT): Asc<ExprT>;
    export type Desc<ExprT extends IExpr> = ([ExprT, typeof SortDirection.DESC]);
    export function desc<ExprT extends IExpr>(expr: ExprT): Desc<ExprT>;
    export type Sort<ExprT extends IExpr> = ([ExprT, SortDirection]);
    export function sort<ExprT extends IExpr>(expr: ExprT, sortDirection: SortDirection): Sort<ExprT>;
}
declare module "expr/util/operation/index" {
    export * from "expr/util/operation/aggregate-intersect";
    export * from "expr/util/operation/as";
    export * from "expr/util/operation/intersect";
    export * from "expr/util/operation/sort";
}
declare module "expr/util/predicate/is-expr" {
    import { IAnonymousExpr } from "expr/expr";
    /**
     * Does not actually check,
     * + `x.usedRef` is `IUsedRef`
     * + `x.ast` is `Ast`
     *
     * @todo Consider adding checks for increased type safety.
     */
    export function isExpr(x: unknown): x is IAnonymousExpr<unknown, boolean>;
}
declare module "expr/util/predicate/index" {
    export * from "expr/util/predicate/is-expr";
}
declare module "expr/util/index" {
    export * from "expr/util/constructor/index";
    export * from "expr/util/operation/index";
    export * from "expr/util/predicate/index";
}
declare module "expr/expr-impl" {
    import * as tm from "type-mapping";
    import { ExprData, IExpr } from "expr/expr";
    import { Ast } from "ast/index";
    import { ColumnMap } from "column-map/index";
    import { SortDirection } from "sort-direction/index";
    import * as ExprUtil from "expr/util/index";
    import { IUsedRef } from "used-ref/index";
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    export class ExprImpl<TypeT, UsedRefT extends ExprData["usedRef"], IsAggregateT extends boolean> implements IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefT;
        isAggregate: IsAggregateT;
    }> {
        readonly mapper: tm.SafeMapper<TypeT>;
        readonly usedRef: UsedRefT;
        readonly isAggregate: IsAggregateT;
        readonly ast: Ast;
        constructor(data: {
            mapper: tm.SafeMapper<TypeT>;
            usedRef: UsedRefT;
            isAggregate: IsAggregateT;
        }, ast: Ast);
        /**
         * If you are running into "max instantiation depth" errors,
         * consider adding explicit `TableExpr<>` type annotations.
         *
         * If that doesn't help,
         * consider using `ExprUtil.as()` instead.
         *
         * Also, consider reading this to understand my frustration,
         * https://github.com/microsoft/TypeScript/issues/29511
         *
         * @param alias
         */
        as<AliasT extends string>(alias: AliasT): ExprUtil.As<this, AliasT>;
        /**
         * ```sql
         * ORDER BY
         *  RAND() ASC
         * ```
         */
        asc(): ExprUtil.Asc<this>;
        /**
         * ```sql
         * ORDER BY
         *  RAND() DESC
         * ```
         */
        desc(): ExprUtil.Desc<this>;
        /**
         * ```sql
         * ORDER BY
         *  (myTable.myColumn IS NOT NULL) ASC,
         *  RAND() DESC
         * ```
         */
        sort(sortDirection: SortDirection): ExprUtil.Sort<this>;
    }
    export type Expr<DataT extends ExprData> = ExprImpl<ReturnType<DataT["mapper"]>, DataT["usedRef"], DataT["isAggregate"]>;
    export function expr<DataT extends ExprData>(data: DataT, ast: Ast): (Expr<DataT>);
    /**
     * This is useful for avoiding "max instantiation depth" problems.
     * It also speeds up type checking.
     *
     * As much as possible, **DO NOT** let `tsc/tsserver` infer
     * the type of `expr`.
     *
     * Just bite the bullet and add these explicit type annotations.
     *
     * Example:
     *
     * ```ts
     *  const expr : tsql.TableExpr<typeof myTable, bigint> = (
     *      tsql.requireParentJoins(myTable)
     *          .from(otherTable)
     *          .where(c => tsql.eq(c.myTable.myColumn, c.otherTable.otherColumn))
     *          .select(c => [otherTable.amount])
     *          .limit(1)
     *          .coalesce(null)
     *  );
     * ```
     *
     * Or,
     * ```ts
     *  function amount () : tsql.TableExpr<typeof myTable, bigint> {
     *      return tsql.requireParentJoins(myTable)
     *          .from(otherTable)
     *          .where(c => tsql.eq(c.myTable.myColumn, c.otherTable.otherColumn))
     *          .select(c => [otherTable.amount])
     *          .limit(1)
     *          .coalesce(null)
     *  }
     * ```
     */
    export type TableExpr<TableT extends {
        tableAlias: string;
        columns: ColumnMap;
    }, TypeT, IsAggregateT extends boolean> = (Expr<{
        mapper: tm.SafeMapper<TypeT>;
        /**
         * @todo Change this to `UsedRefUtil.FromTable<>` ?
         */
        usedRef: IUsedRef<{
            [alias in TableT["tableAlias"]]: TableT["columns"];
        }>;
        isAggregate: IsAggregateT;
    }>);
}
declare module "expr/index" {
    export * from "expr/expr-impl";
    export * from "expr/expr";
    import * as ExprUtil from "expr/util/index";
    export { ExprUtil, };
}
declare module "built-in-expr/built-in-expr" {
    /**
     * Types of expressions,
     * + `BuiltInValueExpr`
     *   + Called a "value" expr because it's just values like `-3.141, new Date(), 34n, "hello", Buffer.from("hi"), etc.`
     *   + Called a "built-in" expr because they use **JavaScript's** built-in types to represent **SQL's** built-in types,
     *     `bigint|number|string|boolean|Date|Uint8Array|null`
     *   + `Uint8Array` is not a "primitive" type; it is a "built-in" type.
     *
     * + `IExpr`
     *   + An arbitrary expression that may contain operators, function calls, subqueries, values, etc.
     *
     * + `IColumn`
     *   + A column belonging to a table/view/derived table
     *
     * + `OneSelectItem & ZeroOrOneRow`
     *   + A scalar subquery returning zero or one rows
     *
     * + `OneSelectItem & OneRow`
     *   + A scalar subquery returning one row
     *
     * + `IExprSelectItem`
     *   + A **named** `IExpr`
     *
     * + `CustomValueExpr` (Basically `Exclude<unknown, AllOfTheAboveTypes>`, or `not AllOfTheAboveTypes`)
     *   + Called a "value" expr because it's just values like `{ x:4, y:5.6 }, [1,2,3], etc.`
     *   + Called a "custom" expr because they use custom data types to represent.
     *     + Some of **SQL's** built-in types require **custom JavaScript** types to represent.
     *       + `DECIMAL(precision, scale)`
     *       + `BIGINT UNSIGNED` (MySQL)
     *       + Spatial types (MySQL, PostgreSQL)
     *   + Mostly used by `UPDATE` and `INSERT` statements for tables becase they require an `IDataType`
     *     to work properly. An `IDataType` is usually only found in table columns.
     *
     * -----
     *
     * Categorizations of expressions,
     * + `AnyValueExpr`
     *   + Either a `BuiltInValueExpr` or `CustomValueExpr`
     *
     * + `AnyBuiltInExpr` (Originally `AnyRawExpr`)
     *   + Any kind of expression, except `CustomValueExpr`
     *   + Used for stuff like `.fetchValue()`
     *     + We wouldn't know how to handle `.fetchValue(() => { return { x:1, y:2 }; })`
     *
     * + `BuiltInExpr<TypeT>` (Orignally `RawExpr<TypeT>`)
     *   + A raw expression that was originally not meant to have `CustomValueExpr`.
     *   + Mainly used for composing expressions
     *   + Used for stuff like `tsql.decimal.sum()`
     *     + We wouldn't know how to handle `tsql.decimal.sum(myDecimalType)`
     *     + `myDecimalType` might be a `string`
     *   + We might be able to get rid of some usages of this type
     *     if we force `IExpr` factories to take an `IDataType` for each argument
     *   + Cannot get rid of usages like `if(condition, then, else)` because the `then` and `else`
     *     arguments may be completely arbitrary.
     *
     * + `AnySubqueryExpr`
     *   + Helper type for `AnyNonCustomValueRawExpr`/`AnyRawExpr`
     *
     * + `AnyNonValueExpr` (Originally `AnyNonPrimitiveRawExpr`)
     *   + `IExpr|IColumn|IExprSelectItem|AnySubqueryExpr`
     *
     * + `NonValueExpr_NonCorrelated<TypeT>` (Originally `NonPrimitiveRawExprNoUsedRef<TypeT>`)
     *   + Used for `INSERT` statements
     *
     * + `AnyBuiltInExpr_NonCorrelated` (Originally `AnyRawExprNoUsedRef`)
     *   + Not used at the moment, delete?
     *
     * + `BuiltInExpr_NonCorrelated<TypeT>` (Originally `RawExprNoUsedRef_Output<TypeT>`)
     *   + Used for `INSERT` statements; at output positions
     *   + Does not allow `CustomValueExpr`
     *
     * + `CustomExpr_NonCorrelated<TypeT>` (Originally `RawExprNoUsedRef_Input<TypeT>`)
     *   + Used for `INSERT` statements; at input positions
     *   + Allows `CustomValueExpr`, requires `IDataType` to handle correctly
     *
     * + `BuiltInExpr_MapCorrelated<TypeT, ColumnMapT>` (Originally `RawExprUsingColumnMap_Output<ColumnMapT, TypeT>`)
     *   + Used for `UPDATE` statements; at output positions
     *   + Does not allow `CustomValueExpr`
     *
     * + `CustomExpr_MapCorrelated<TypeT, ColumnMapT>` (Originally `RawExprUsingColumnMap_Input<ColumnMapT, TypeT>`)
     *   + Used for `UPDATE` statements; at input positions
     *   + Allows `CustomValueExpr`, requires `IDataType` to handle correctly
     */
    import * as tm from "type-mapping";
    import { BuiltInValueExpr } from "built-in-value-expr/index";
    import { IAnonymousExpr, IExpr } from "expr/index";
    import { IAnonymousColumn, IColumn, ColumnUtil } from "column/index";
    import { IAnonymousExprSelectItem, IExprSelectItem } from "expr-select-item/index";
    import { QueryBaseUtil } from "query-base/index";
    import { IUsedRef, UsedRefUtil } from "used-ref/index";
    import { ColumnMap } from "column-map/index";
    /**
     * @note `IsAggregateT` here is impossible to infer in the following situation,
     * ```ts
     *  declare function foo<TypeT, IsAggregateT extends boolean> (e : BuiltInExpr<TypeT, IsAggregateT>) : IsAggregateT;
     *  foo(1); //What is the return type?
     * ```
     *
     * It is inferred as `boolean`, when it should be `false`.
     */
    export type BuiltInExpr<TypeT> = (unknown extends TypeT ? BuiltInValueExpr : never) | (TypeT extends BuiltInValueExpr ? TypeT : never) | IAnonymousExpr<TypeT, boolean> | IAnonymousColumn<TypeT> | (null extends TypeT ? (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.ZeroOrOneRow) : (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.OneRow)) | IAnonymousExprSelectItem<TypeT, boolean>;
    export type AnySubqueryExpr = (QueryBaseUtil.OneSelectItem<any> & QueryBaseUtil.ZeroOrOneRow);
    export type AnyBuiltInExpr = BuiltInValueExpr | IExpr | IColumn | AnySubqueryExpr | IExprSelectItem;
    export type AnyBuiltInExpr_NonAggregate = BuiltInValueExpr | IExpr<{
        mapper: tm.AnySafeMapper;
        usedRef: IUsedRef;
        isAggregate: false;
    }> | IColumn | AnySubqueryExpr | IExprSelectItem<{
        mapper: tm.AnySafeMapper;
        tableAlias: string;
        alias: string;
        usedRef: IUsedRef;
        isAggregate: false;
    }>;
    export type AnyNonValueExpr = IExpr | IColumn | AnySubqueryExpr | IExprSelectItem;
    export type NonValueExpr_NonCorrelated<TypeT> = IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: IUsedRef<{}>;
        isAggregate: boolean;
    }>
    /**
     * A `column` is itself a used ref, and is not allowed
     */
     | (null extends TypeT ? (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.ZeroOrOneRow & QueryBaseUtil.NonCorrelated) : (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.OneRow & QueryBaseUtil.NonCorrelated)) | IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        tableAlias: string;
        alias: string;
        usedRef: IUsedRef<{}>;
        isAggregate: boolean;
    }>;
    export type AnyBuiltInExpr_NonCorrelated = BuiltInValueExpr | NonValueExpr_NonCorrelated<any>;
    export type BuiltInExpr_NonCorrelated<TypeT> = (unknown extends TypeT ? BuiltInValueExpr : never) | (TypeT extends BuiltInValueExpr ? TypeT : never) | NonValueExpr_NonCorrelated<TypeT>;
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     */
    export type BuiltInExpr_NonCorrelatedOrUndefined<TypeT> = BuiltInExpr_NonCorrelated<TypeT> | undefined;
    /**
     * We don't support subqueries because it's too complicated
     * to check their `IUsedRef`
     */
    export type BuiltInExpr_MapCorrelated<ColumnMapT extends ColumnMap, TypeT> = Extract<TypeT, BuiltInValueExpr> | IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        isAggregate: boolean;
    }> | ColumnUtil.FromColumnMap<ColumnMapT> | IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: UsedRefUtil.FromColumnMap<ColumnMapT>;
        tableAlias: string;
        alias: string;
        isAggregate: boolean;
    }>;
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     *
     * We don't support subqueries because it's too complicated
     * to check their `IUsedRef`
     */
    export type BuiltInExpr_MapCorrelatedOrUndefined<ColumnMapT extends ColumnMap, TypeT> = BuiltInExpr_MapCorrelated<ColumnMapT, TypeT> | undefined;
    export type BuiltInExpr_NonAggregate<TypeT> = ((unknown extends TypeT ? BuiltInValueExpr : never) | (TypeT extends BuiltInValueExpr ? TypeT : never) | IAnonymousExpr<TypeT, false> | IAnonymousColumn<TypeT> | (null extends TypeT ? (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.ZeroOrOneRow) : (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.OneRow)) | IAnonymousExprSelectItem<TypeT, false>);
    export type NonValueExpr_NonCorrelated_NonAggregate<TypeT> = IExpr<{
        mapper: tm.SafeMapper<TypeT>;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>
    /**
     * A `column` is itself a used ref, and is not allowed
     */
     | (null extends TypeT ? (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.ZeroOrOneRow & QueryBaseUtil.NonCorrelated) : (QueryBaseUtil.OneSelectItem<TypeT> & QueryBaseUtil.OneRow & QueryBaseUtil.NonCorrelated)) | IExprSelectItem<{
        mapper: tm.SafeMapper<TypeT>;
        tableAlias: string;
        alias: string;
        usedRef: IUsedRef<{}>;
        isAggregate: false;
    }>;
    export type AnyBuiltInExpr_NonCorrelated_NonAggregate = BuiltInValueExpr | NonValueExpr_NonCorrelated_NonAggregate<any>;
    export type BuiltInExpr_NonCorrelated_NonAggregate<TypeT> = (unknown extends TypeT ? BuiltInValueExpr : never) | (TypeT extends BuiltInValueExpr ? TypeT : never) | NonValueExpr_NonCorrelated_NonAggregate<TypeT>;
    /**
     * Workaround,
     * https://github.com/microsoft/TypeScript/issues/35616#issuecomment-564894944
     */
    export type BuiltInExpr_NonCorrelated_NonAggregateOrUndefined<TypeT> = BuiltInExpr_NonCorrelated_NonAggregate<TypeT> | undefined;
}
declare module "built-in-expr/index" {
    export * from "built-in-expr/built-in-expr";
    import * as BuiltInExprUtil from "built-in-expr/util/index";
    export { BuiltInExprUtil, };
}
declare module "data-type/data-type" {
    import * as tm from "type-mapping";
    import { BuiltInExpr_NonCorrelated_NonAggregate } from "built-in-expr/index";
    /**
     * When just using `TypeT` with a `BuiltInValueExpr`,
     * this `DataType<>` interface may seem useless.
     *
     * However, its real usefulness is more apparent
     * when used with custom data types, **and** helper
     * methods that perform reads and writes as atomic
     * operations.
     */
    export interface IDataType<TypeT> extends tm.SafeMapper<TypeT> {
        /**
         * Used when a helper needs to automatically
         * fetch data from the database,
         * and immediately send that value back to the database
         * without any help from the programmer.
         *
         * Examples:
         * + `Log.track()`
         *
         *   Needs to fetch the previous row, and may use previous values
         *   when inserting a new row.
         *
         * + `TablePerType.insertOne()`
         *
         *   After inserting a row to a parent table,
         *   it fetches the row, and may use those values
         *   when inserting rows to derived tables.
         *
         * @param value - The value to convert to a `BuiltInExpr_NonCorrelated`
         */
        toBuiltInExpr_NonCorrelated(value: TypeT): BuiltInExpr_NonCorrelated_NonAggregate<TypeT>;
        /**
         * At the moment, this is specifically used by `Log.track()`
         * to determine if data for a column has changed.
         *
         * Null-safe equality means if both arguments are `null`,
         * it returns `true`.
         *
         * If one argument is `null` and the other is not,
         * it returns `false`.
         */
        isNullSafeEqual(a: TypeT, b: TypeT): boolean;
    }
}
declare module "data-type/data-type-impl" {
    import { IDataType } from "data-type/data-type";
    export interface DataType<TypeT> extends IDataType<TypeT> {
        /**
         * Convenience method to get a `DataType<>` that allows `NULL`.
         */
        orNull(): IDataType<TypeT | null>;
    }
}
declare module "type-util/pop-union" {
    import { UnionToIntersection } from "type-util/union-to-intersection";
    type UnionToFunctionOverloads<U> = (UnionToIntersection<U extends any ? (f: U) => void : never>);
    export type PopUnion<U> = (UnionToFunctionOverloads<U> extends ((a: infer A) => void) ? A : never);
}
declare module "schema-validation/schema-validation-error" {
    export enum SchemaValidationErrorType {
        TABLE_ON_APPLICATION_ONLY = "TABLE_ON_APPLICATION_ONLY",
        TABLE_ALIAS_MISMATCH = "TABLE_ALIAS_MISMATCH",
        PRIMARY_KEY_ON_APPLICATION_ONLY = "PRIMARY_KEY_ON_APPLICATION_ONLY",
        PRIMARY_KEY_MISMATCH = "PRIMARY_KEY_MISMATCH",
        CANDIDATE_KEY_ON_APPLICATION_ONLY = "CANDIDATE_KEY_ON_APPLICATION_ONLY",
        DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY = "DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY",
        COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL = "COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL",
        COLUMN_ON_APPLICATION_ONLY = "COLUMN_ON_APPLICATION_ONLY",
        COLUMN_ALIAS_MISMATCH = "COLUMN_ALIAS_MISMATCH",
        AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL",
        AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL = "AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL",
        COLUMN_NULLABLE_ON_DATABASE_ONLY = "COLUMN_NULLABLE_ON_DATABASE_ONLY",
        COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL",
        COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL",
        COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL",
        COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL = "COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL",
        COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION = "COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION",
        COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL",
        COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"
    }
    export interface TableOnApplicationOnlyError {
        type: SchemaValidationErrorType.TABLE_ON_APPLICATION_ONLY;
        description: string;
        applicationTableAlias: string;
        databaseSchemaAlias: string;
    }
    export interface TableAliasMismatchError {
        type: SchemaValidationErrorType.TABLE_ALIAS_MISMATCH;
        description: string;
        applicationTableAlias: string;
        databaseTableAlias: string;
    }
    export interface PrimaryKeyOnApplicationOnlyError {
        type: SchemaValidationErrorType.PRIMARY_KEY_ON_APPLICATION_ONLY;
        description: string;
        tableAlias: string;
        primaryKey: readonly string[];
    }
    export interface PrimaryKeyMismatchError {
        type: SchemaValidationErrorType.PRIMARY_KEY_MISMATCH;
        description: string;
        tableAlias: string;
        applicationPrimaryKey: readonly string[];
        databasePrimaryKey: readonly string[];
    }
    export interface CandidateKeyOnApplicationOnlyError {
        type: SchemaValidationErrorType.CANDIDATE_KEY_ON_APPLICATION_ONLY;
        description: string;
        tableAlias: string;
        applicationCandidateKey: readonly string[];
    }
    export interface DatabaseTableHasNoPrimaryOrCandidateKeysError {
        type: SchemaValidationErrorType.DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY;
        description: string;
        tableAlias: string;
    }
    export interface ColumnOnDatabaseOnlyInsertWillFailError {
        type: SchemaValidationErrorType.COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        databaseColumnAlias: string;
        isNullable: false;
        isAutoIncrement: false;
        generationExpression: undefined;
        explicitDefaultValue: undefined;
        insertEnabled: true;
    }
    export interface ColumnOnApplicationOnlyError {
        type: SchemaValidationErrorType.COLUMN_ON_APPLICATION_ONLY;
        description: string;
        tableAlias: string;
        applicationColumnAlias: string;
    }
    export interface AutoIncrementOnApplicationOnlyInsertWillFailError {
        type: SchemaValidationErrorType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface AutoIncrementMismatchInsertWillFailError {
        type: SchemaValidationErrorType.AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        applicationColumnAlias: string;
        databaseColumnAlias: string;
    }
    export interface ColumnAliasMismatchError {
        type: SchemaValidationErrorType.COLUMN_ALIAS_MISMATCH;
        description: string;
        tableAlias: string;
        applicationColumnAlias: string;
        databaseColumnAlias: string;
    }
    export interface ColumnNullableOnDatabaseOnlyError {
        type: SchemaValidationErrorType.COLUMN_NULLABLE_ON_DATABASE_ONLY;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnNullableOnApplicationOnlyInsertWillFailError {
        type: SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnNullableOnApplicationOnlyUpdateWillFailError {
        type: SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedOnDatabaseOnlyInsertWillFailError {
        type: SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedOnDatabaseOnlyUpdateWillFailError {
        type: SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedAndAutoIncrementOnApplicationError {
        type: SchemaValidationErrorType.COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION;
        description: string;
        tableAlias: string;
        applicationColumnAlias: string;
    }
    export interface ColumnGeneratedOnApplicationOnlyInsertWillFailError {
        type: SchemaValidationErrorType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnExplicitDefaultValueOnApplicationOnlyInsertWillFailError {
        type: SchemaValidationErrorType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export type SchemaValidationError = TableOnApplicationOnlyError | TableAliasMismatchError | PrimaryKeyOnApplicationOnlyError | PrimaryKeyMismatchError | CandidateKeyOnApplicationOnlyError | DatabaseTableHasNoPrimaryOrCandidateKeysError | ColumnOnDatabaseOnlyInsertWillFailError | ColumnOnApplicationOnlyError | AutoIncrementOnApplicationOnlyInsertWillFailError | AutoIncrementMismatchInsertWillFailError | ColumnAliasMismatchError | ColumnNullableOnDatabaseOnlyError | ColumnNullableOnApplicationOnlyInsertWillFailError | ColumnNullableOnApplicationOnlyUpdateWillFailError | ColumnGeneratedOnDatabaseOnlyInsertWillFailError | ColumnGeneratedOnDatabaseOnlyUpdateWillFailError | ColumnGeneratedAndAutoIncrementOnApplicationError | ColumnGeneratedOnApplicationOnlyInsertWillFailError | ColumnExplicitDefaultValueOnApplicationOnlyInsertWillFailError;
}
declare module "schema-validation/schema-validation-warning" {
    export enum SchemaValidationWarningType {
        TABLE_ON_DATABASE_ONLY = "TABLE_ON_DATABASE_ONLY",
        TABLE_HAS_NO_PRIMARY_KEY = "TABLE_HAS_NO_PRIMARY_KEY",
        PRIMARY_KEY_ON_DATABASE_ONLY = "PRIMARY_KEY_ON_DATABASE_ONLY",
        CANDIDATE_KEY_ON_DATABASE_ONLY = "CANDIDATE_KEY_ON_DATABASE_ONLY",
        COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE = "COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE",
        COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED = "COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED",
        AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED",
        AUTO_INCREMENT_ON_DATABASE_ONLY = "AUTO_INCREMENT_ON_DATABASE_ONLY",
        AUTO_INCREMENT_MISMATCH_INSERT_DISABLED = "AUTO_INCREMENT_MISMATCH_INSERT_DISABLED",
        COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED",
        COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED",
        COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE = "COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE",
        COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED",
        COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY",
        COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE",
        COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED"
    }
    export interface TableOnDatabaseOnlyWarning {
        type: SchemaValidationWarningType.TABLE_ON_DATABASE_ONLY;
        description: string;
        databaseTableAlias: string;
    }
    export interface TableHasNoPrimaryKeyWarning {
        type: SchemaValidationWarningType.TABLE_HAS_NO_PRIMARY_KEY;
        description: string;
        tableAlias: string;
    }
    export interface PrimaryKeyOnDatabaseOnlyWarning {
        type: SchemaValidationWarningType.PRIMARY_KEY_ON_DATABASE_ONLY;
        description: string;
        tableAlias: string;
        primaryKey: readonly string[];
    }
    export interface CandidateKeyOnDatabaseOnlyWarning {
        type: SchemaValidationWarningType.CANDIDATE_KEY_ON_DATABASE_ONLY;
        description: string;
        tableAlias: string;
        databaseCandidateKey: readonly string[];
    }
    export interface ColumnOnDatabaseOnlyWithDefaultOrGeneratedValueWarning {
        type: SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE;
        description: string;
        tableAlias: string;
        databaseColumnAlias: string;
        isNullable: boolean;
        isAutoIncrement: boolean;
        generationExpression: string | undefined;
        explicitDefaultValue: string | undefined;
        insertEnabled: true;
    }
    export interface ColumnOnDatabaseOnlyInsertDisabledWarning {
        type: SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED;
        description: string;
        tableAlias: string;
        databaseColumnAlias: string;
        isNullable: boolean;
        isAutoIncrement: boolean;
        generationExpression: string | undefined;
        explicitDefaultValue: string | undefined;
        insertEnabled: false;
    }
    export interface AutoIncrementOnApplicationOnlyInsertDisabledWarning {
        type: SchemaValidationWarningType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface AutoIncrementOnDatabaseOnlyWarning {
        type: SchemaValidationWarningType.AUTO_INCREMENT_ON_DATABASE_ONLY;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface AutoIncrementMismatchInsertDisabledWarning {
        type: SchemaValidationWarningType.AUTO_INCREMENT_MISMATCH_INSERT_DISABLED;
        description: string;
        tableAlias: string;
        applicationColumnAlias: string;
        databaseColumnAlias: string;
    }
    export interface ColumnNullableOnApplicationOnlyInsertAndUpdateDisabledWarning {
        type: SchemaValidationWarningType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedOnDatabaseOnlyInsertAndUpdateDisabledWarning {
        type: SchemaValidationWarningType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedOnApplicationOnlyUsingDatabaseDefaultValueWarning {
        type: SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnGeneratedOnApplicationOnlyInsertDisabledWarning {
        type: SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export interface ColumnExplicitDefaultValueOnDatabaseOnlyWarning {
        type: SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY;
        description: string;
        tableAlias: string;
        columnAlias: string;
        explicitDefaultValue: string;
    }
    export interface ColumnExplicitDefaultValueOnApplicationOnlyUsingDatabaseGeneratedOrNullValueWarning {
        type: SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE;
        description: string;
        tableAlias: string;
        columnAlias: string;
        isNullable: boolean;
        isAutoIncrement: boolean;
        generationExpression: string | undefined;
        explicitDefaultValue: undefined;
    }
    export interface ColumnExplicitDefaultValueOnApplicationOnlyInsertDisabledWarning {
        type: SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED;
        description: string;
        tableAlias: string;
        columnAlias: string;
    }
    export type SchemaValidationWarning = TableOnDatabaseOnlyWarning | TableHasNoPrimaryKeyWarning | PrimaryKeyOnDatabaseOnlyWarning | CandidateKeyOnDatabaseOnlyWarning | ColumnOnDatabaseOnlyWithDefaultOrGeneratedValueWarning | ColumnOnDatabaseOnlyInsertDisabledWarning | AutoIncrementOnApplicationOnlyInsertDisabledWarning | AutoIncrementOnDatabaseOnlyWarning | AutoIncrementMismatchInsertDisabledWarning | ColumnNullableOnApplicationOnlyInsertAndUpdateDisabledWarning | ColumnGeneratedOnDatabaseOnlyInsertAndUpdateDisabledWarning | ColumnGeneratedOnApplicationOnlyUsingDatabaseDefaultValueWarning | ColumnGeneratedOnApplicationOnlyInsertDisabledWarning | ColumnExplicitDefaultValueOnDatabaseOnlyWarning | ColumnExplicitDefaultValueOnApplicationOnlyUsingDatabaseGeneratedOrNullValueWarning | ColumnExplicitDefaultValueOnApplicationOnlyInsertDisabledWarning;
}
declare module "schema-validation/schema-validation-result" {
    import { SchemaValidationError } from "schema-validation/schema-validation-error";
    import { SchemaValidationWarning } from "schema-validation/schema-validation-warning";
    export interface WritableSchemaValidationResult {
        warnings: SchemaValidationWarning[];
        errors: SchemaValidationError[];
    }
    export interface SchemaValidationResult {
        warnings: readonly SchemaValidationWarning[];
        errors: readonly SchemaValidationError[];
    }
}
declare module "sqlstring/index" {
    /**
     * Escapes a MySQL identifier.
     *
     * For example,
     * + Database name
     * + Table name
     * + Column name
     * + Alias
     *
     * -----
     *
     * ```ts
     * escapeIdentifier("x") == "`x`"
     * escapeIdentifier("x.y") == "`x.y`"
     * escapeIdentifier("x`x.y") == "`x``x.y`"
     * ```
     *
     * @param rawIdentifier - The identifier to escape
     *
     * @todo Refactor this.
     * + MySQL uses backticks.
     * + PostgreSQL uses double quotes. (Following the same rules as MySQL)
     * + MySQL can be made to use double quotes by enabling `ANSI_QUOTES` but this is disabled by default
     *
     * Each database adapter will need to create their own `escaoeIdentifier` function
     * and pass it around.
     *
     * A pain in the butt. Necessary, however.
     *
     * -----
     *
     * Another option would be forcing the MySQL adapter to always run a SQL query
     * to enable `ANSI_QUOTES`...
     *
     * Definitely less of a hassle there.
     *
     * @deprecated Use the `Identifier` AST Node instead
     */
    export function escapeIdentifierWithBackticks(rawIdentifier: string): string;
    export function escapeIdentifierWithDoubleQuotes(rawIdentifier: string): string;
    export function tryUnescapeIdentifierWithDoubleQuotes(rawIdentifier: string): string;
    /**
     * Escapes a MySQL value.
     *
     * Does not handle `Date` as timezones are a pain.
     *
     * @param rawValue - The value to escape
     */
    export function escapeValue(rawValue: null | boolean | number | bigint | Uint8Array): string;
    /**
     * Only MySQL supports C-style escapes (using the backslash character).
     */
    export function cStyleEscapeString(rawString: string): string;
    /**
     * PostgreSQL and SQLite use Pascal-style escapes
     */
    export function pascalStyleEscapeString(rawString: string): string;
}
declare module "schema-validation/util/operation/validate-column" {
    import { ITable } from "table/index";
    import { IColumn } from "column/index";
    import { ColumnMeta } from "schema-introspection/index";
    import { SchemaValidationResult } from "schema-validation/schema-validation-result";
    export function validateColumn(applicationTable: Pick<ITable, ("nullableColumns" | "mutableColumns" | "generatedColumns" | "explicitDefaultValueColumns" | "alias" | "autoIncrement" | "insertEnabled")>, applicationColumn: Pick<IColumn, "columnAlias">, columnMeta: ColumnMeta): SchemaValidationResult;
}
declare module "schema-validation/util/operation/validate-table" {
    /**
     * You will find a bunch of if-statements that have empty bodies,
     * with only comments in them.
     *
     * This is intentional.
     * We want to explicitly decide to handle or ignore an if-statement branch.
     */
    import { ITable } from "table/index";
    import { TableMeta } from "schema-introspection/index";
    import { SchemaValidationResult } from "schema-validation/schema-validation-result";
    export function validateTable(applicationTable: ITable, tableMeta: TableMeta): SchemaValidationResult;
}
declare module "schema-validation/util/operation/validate-schema" {
    import { ITable } from "table/index";
    import { SchemaMeta } from "schema-introspection/index";
    import { SchemaValidationResult } from "schema-validation/schema-validation-result";
    export function validateSchema(applicationTables: readonly ITable[], schemaMeta: SchemaMeta): SchemaValidationResult;
}
declare module "schema-validation/util/operation/index" {
    export * from "schema-validation/util/operation/validate-column";
    export * from "schema-validation/util/operation/validate-schema";
    export * from "schema-validation/util/operation/validate-table";
}
declare module "schema-validation/util/index" {
    export * from "schema-validation/util/operation/index";
}
declare module "schema-validation/index" {
    export * from "schema-validation/schema-validation-error";
    export * from "schema-validation/schema-validation-result";
    export * from "schema-validation/schema-validation-warning";
    import * as SchemaValidationUtil from "schema-validation/util/index";
    export { SchemaValidationUtil, };
}
declare module "design-pattern-log/log" {
    import { TableWithPrimaryKey, InsertableTable } from "table/index";
    import { IColumn } from "column/index";
    import { SortDirection } from "sort-direction/index";
    import { IsolableSelectConnection } from "execution/index";
    /**
     * Properties ordered this way to look nicest when type is emitted/displayed.
     */
    export interface LogData {
        readonly tracked: readonly string[];
        readonly doNotCopy: readonly string[];
        readonly copy: readonly string[];
        readonly trackedWithDefaultValue: readonly string[];
        /**
         * (`ownerTable`'s PK, `IColumn`) must form a
         * candidate key of `logTable`
         */
        readonly latestOrder: readonly [IColumn, SortDirection];
        readonly logTable: InsertableTable;
        readonly ownerTable: TableWithPrimaryKey;
    }
    export interface ILog<DataT extends LogData = LogData> {
        readonly tracked: DataT["tracked"];
        readonly doNotCopy: DataT["doNotCopy"];
        readonly copy: DataT["copy"];
        readonly trackedWithDefaultValue: DataT["trackedWithDefaultValue"];
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        /**
         * (`ownerTable`'s PK, `IColumn`) must form a
         * candidate key of `logTable`
         */
        readonly latestOrder: DataT["latestOrder"];
        /**
         * May have `ownerTable` as `IUsedRef`
         */
        readonly copyDefaultsDelegate: (args: {
            ownerPrimaryKey: unknown;
            connection: IsolableSelectConnection;
        }) => Promise<unknown>;
        /**
         * May have `ownerTable` as `IUsedRef`
         */
        readonly trackedDefaults: {
            [columnAlias: string]: unknown;
        };
    }
}
declare module "design-pattern-log/util/constructor/06-set-tracked-defaults" {
    import { ILog, LogData } from "design-pattern-log/log";
    import { Log } from "design-pattern-log/log-impl";
    import { TableUtil } from "table/index";
    import { CustomExpr_NonCorrelated } from "custom-expr/index";
    import { Identity } from "type-util/index";
    export type LogMustSetTrackedDefaultsData = Pick<LogData, "logTable" | "ownerTable" | "tracked" | "doNotCopy" | "copy" | "latestOrder"> & Pick<ILog, "copyDefaultsDelegate">;
    export type TrackedDefaults<DataT extends LogMustSetTrackedDefaultsData> = Identity<{
        readonly [columnAlias in (DataT["tracked"][number])]: (undefined | CustomExpr_NonCorrelated<TableUtil.ColumnType<DataT["logTable"], columnAlias>>);
    }>;
    export type SetTrackedDefaults<DataT extends LogMustSetTrackedDefaultsData, TrackedDefaultsT extends TrackedDefaults<DataT>> = Log<{
        tracked: DataT["tracked"];
        doNotCopy: DataT["doNotCopy"];
        copy: DataT["copy"];
        trackedWithDefaultValue: readonly Extract<{
            [columnAlias in keyof TrackedDefaultsT]: (undefined extends TrackedDefaultsT[columnAlias] ? never : columnAlias);
        }[keyof TrackedDefaultsT], DataT["tracked"][number]>[];
        logTable: DataT["logTable"];
        ownerTable: DataT["ownerTable"];
        latestOrder: DataT["latestOrder"];
    }>;
    export function setTrackedDefaults<DataT extends LogMustSetTrackedDefaultsData, TrackedDefaultsT extends TrackedDefaults<DataT>>(log: DataT, rawTrackedDefaults: TrackedDefaults<DataT>): (SetTrackedDefaults<DataT, TrackedDefaultsT>);
    export class LogMustSetTrackedDefaults<DataT extends LogMustSetTrackedDefaultsData> {
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        readonly latestOrder: DataT["latestOrder"];
        readonly tracked: DataT["tracked"];
        readonly doNotCopy: DataT["doNotCopy"];
        readonly copy: DataT["copy"];
        readonly copyDefaultsDelegate: DataT["copyDefaultsDelegate"];
        constructor(data: DataT);
        setTrackedDefaults<TrackedDefaultsT extends TrackedDefaults<DataT>>(rawTrackedDefaults: TrackedDefaultsT): (SetTrackedDefaults<DataT, TrackedDefaultsT>);
    }
}
declare module "design-pattern-log/util/constructor/05-set-copy-defaults-delegate" {
    import { ILog, LogData } from "design-pattern-log/log";
    import { TableUtil } from "table/index";
    import { Identity } from "type-util/index";
    import { IsolableSelectConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { CustomExpr_NonCorrelated } from "custom-expr/index";
    import { LogMustSetTrackedDefaults } from "design-pattern-log/util/constructor/06-set-tracked-defaults";
    export type LogMustSetCopyDefaultsDelegateData = Pick<LogData, "logTable" | "ownerTable" | "tracked" | "doNotCopy" | "copy"> & Pick<ILog, "latestOrder">;
    export type CopyDefaults<DataT extends LogMustSetCopyDefaultsDelegateData> = Identity<{
        readonly [columnAlias in Extract<TableUtil.RequiredColumnAlias<DataT["logTable"]>, DataT["copy"][number]>]: (CustomExpr_NonCorrelated<TableUtil.ColumnType<DataT["logTable"], columnAlias>>);
    } & {
        readonly [columnAlias in Extract<TableUtil.OptionalColumnAlias<DataT["logTable"]>, DataT["copy"][number]>]: (
        /**
         * Makes things more explicit by forcing `undefined`
         */
        undefined | CustomExpr_NonCorrelated<TableUtil.ColumnType<DataT["logTable"], columnAlias>>);
    }>;
    export type CopyDefaultsDelegate<DataT extends LogMustSetCopyDefaultsDelegateData> = (args: {
        ownerPrimaryKey: PrimaryKey_Input<DataT["ownerTable"]>;
        connection: IsolableSelectConnection;
    }) => Promise<CopyDefaults<DataT>>;
    export type SetCopyDefaultsDelegate<DataT extends LogMustSetCopyDefaultsDelegateData> = LogMustSetTrackedDefaults<{
        logTable: DataT["logTable"];
        ownerTable: DataT["ownerTable"];
        latestOrder: DataT["latestOrder"];
        tracked: DataT["tracked"];
        doNotCopy: DataT["doNotCopy"];
        copy: DataT["copy"];
        copyDefaultsDelegate: ILog["copyDefaultsDelegate"];
    }>;
    export function setCopyDefaultsDelegate<DataT extends LogMustSetCopyDefaultsDelegateData>(log: DataT, rawCopyDefaultsDelegate: CopyDefaultsDelegate<DataT>): (SetCopyDefaultsDelegate<DataT>);
    export class LogMustSetCopyDefaultsDelegate<DataT extends LogMustSetCopyDefaultsDelegateData> {
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        readonly latestOrder: DataT["latestOrder"];
        readonly tracked: DataT["tracked"];
        readonly doNotCopy: DataT["doNotCopy"];
        readonly copy: DataT["copy"];
        constructor(data: DataT);
        setCopyDefaults(rawCopyDefaultsDelegate: CopyDefaultsDelegate<DataT>): (SetCopyDefaultsDelegate<DataT>);
    }
}
declare module "design-pattern-log/util/constructor/04-set-do-not-copy" {
    import { ILog, LogData } from "design-pattern-log/log";
    import { ColumnUtil } from "column/index";
    import { LogMustSetTrackedDefaults } from "design-pattern-log/util/constructor/06-set-tracked-defaults";
    import { LogMustSetCopyDefaultsDelegate } from "design-pattern-log/util/constructor/05-set-copy-defaults-delegate";
    export type LogMustSetDoNotCopyData = Pick<LogData, "logTable" | "ownerTable" | "tracked" | "copy"> & Pick<ILog, "latestOrder">;
    export type DoNotCopy<DataT extends LogMustSetDoNotCopyData> = readonly ColumnUtil.FromColumnMap<Pick<DataT["logTable"]["columns"], DataT["copy"][number]>>[];
    export type SetDoNotCopyDelegate<DataT extends LogMustSetDoNotCopyData, DoNotCopyT extends DoNotCopy<DataT>> = (columns: Pick<DataT["logTable"]["columns"], DataT["copy"][number]>) => DoNotCopyT;
    export type CopyDefaultsDelegateAfterSetDoNotCopy<DataT extends LogMustSetDoNotCopyData, DoNotCopyT extends DoNotCopy<DataT>> = Exclude<DataT["copy"][number], DoNotCopyT[number]["columnAlias"]> extends never ? ILog["copyDefaultsDelegate"] : undefined;
    export type SetDoNotCopy<DataT extends LogMustSetDoNotCopyData, DoNotCopyT extends DoNotCopy<DataT>> = (CopyDefaultsDelegateAfterSetDoNotCopy<DataT, DoNotCopyT> extends ILog["copyDefaultsDelegate"] ? LogMustSetTrackedDefaults<{
        logTable: DataT["logTable"];
        ownerTable: DataT["ownerTable"];
        latestOrder: DataT["latestOrder"];
        tracked: DataT["tracked"];
        doNotCopy: readonly (DoNotCopyT[number]["columnAlias"])[];
        copy: readonly Exclude<DataT["copy"][number], DoNotCopyT[number]["columnAlias"]>[];
        copyDefaultsDelegate: ILog["copyDefaultsDelegate"];
    }> : LogMustSetCopyDefaultsDelegate<{
        logTable: DataT["logTable"];
        ownerTable: DataT["ownerTable"];
        latestOrder: DataT["latestOrder"];
        tracked: DataT["tracked"];
        doNotCopy: readonly (DoNotCopyT[number]["columnAlias"])[];
        copy: readonly Exclude<DataT["copy"][number], DoNotCopyT[number]["columnAlias"]>[];
    }>);
    export function setDoNotCopy<DataT extends LogMustSetDoNotCopyData, DoNotCopyT extends DoNotCopy<DataT>>(log: DataT, delegate: SetDoNotCopyDelegate<DataT, DoNotCopyT>): (SetDoNotCopy<DataT, DoNotCopyT>);
    export class LogMustSetDoNotCopy<DataT extends LogMustSetDoNotCopyData> {
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        readonly latestOrder: DataT["latestOrder"];
        readonly tracked: DataT["tracked"];
        readonly copy: DataT["copy"];
        constructor(data: DataT);
        setDoNotCopy<DoNotCopyT extends DoNotCopy<DataT>>(delegate: SetDoNotCopyDelegate<DataT, DoNotCopyT>): (SetDoNotCopy<DataT, DoNotCopyT>);
    }
}
declare module "design-pattern-log/util/constructor/03-set-tracked" {
    import { Identity } from "type-util/index";
    import { ColumnUtil } from "column/index";
    import { LogData, ILog } from "design-pattern-log/log";
    import { LogMustSetDoNotCopy } from "design-pattern-log/util/constructor/04-set-do-not-copy";
    export type LogMustSetTrackedData = Pick<LogData, "logTable" | "ownerTable"> & Pick<ILog, "latestOrder">;
    export type TrackedColumnMap<DataT extends LogMustSetTrackedData> = Identity<{
        [columnAlias in Exclude<Extract<keyof DataT["logTable"]["columns"], string>, DataT["ownerTable"]["primaryKey"][number] | DataT["logTable"]["generatedColumns"][number] | DataT["logTable"]["autoIncrement"] | DataT["latestOrder"][0]["columnAlias"]>]: (DataT["logTable"]["columns"][columnAlias]);
    }>;
    export type Tracked<DataT extends LogMustSetTrackedData> = readonly [ColumnUtil.FromColumnMap<TrackedColumnMap<DataT>>, ...ColumnUtil.FromColumnMap<TrackedColumnMap<DataT>>[]];
    export type TrackedDelegate<DataT extends LogMustSetTrackedData, TrackedT extends Tracked<DataT>> = (columns: TrackedColumnMap<DataT>) => TrackedT;
    export class LogMustSetTracked<DataT extends LogMustSetTrackedData> {
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        readonly latestOrder: DataT["latestOrder"];
        constructor(data: DataT);
        setTracked<TrackedT extends Tracked<DataT>>(trackedDelegate: TrackedDelegate<DataT, TrackedT>): (LogMustSetDoNotCopy<{
            logTable: DataT["logTable"];
            ownerTable: DataT["ownerTable"];
            latestOrder: DataT["latestOrder"];
            tracked: readonly (TrackedT[number]["columnAlias"])[];
            copy: readonly (Exclude<Extract<keyof DataT["logTable"]["columns"], string>, DataT["ownerTable"]["primaryKey"][number] | DataT["logTable"]["generatedColumns"][number] | DataT["logTable"]["autoIncrement"] | DataT["latestOrder"][0]["columnAlias"] | TrackedT[number]["columnAlias"]>)[];
        }>);
    }
}
declare module "design-pattern-log/util/constructor/02-set-latest-order" {
    import { KeyArrayUtil } from "key/index";
    import { Identity } from "type-util/index";
    import { ColumnUtil } from "column/index";
    import { SortDirection } from "sort-direction/index";
    import { LogData } from "design-pattern-log/log";
    import { LogMustSetTracked } from "design-pattern-log/util/constructor/03-set-tracked";
    export type LogMustSetLatestOrderData = Pick<LogData, "logTable" | "ownerTable">;
    export type LatestOrderColumnAlias<DataT extends LogMustSetLatestOrderData> = {
        [columnAlias in (DataT["logTable"]["explicitDefaultValueColumns"][number] | DataT["logTable"]["generatedColumns"][number])]: (KeyArrayUtil.HasKey<DataT["logTable"]["candidateKeys"], readonly (DataT["ownerTable"]["primaryKey"][number] | columnAlias)[]> extends true ? columnAlias : never);
    }[DataT["logTable"]["explicitDefaultValueColumns"][number] | DataT["logTable"]["generatedColumns"][number]];
    export function latestOrderColumnAlias<DataT extends LogMustSetLatestOrderData>(data: DataT): (LatestOrderColumnAlias<DataT>[]);
    export type LatestOrderColumnMap<DataT extends LogMustSetLatestOrderData> = Identity<{
        [columnAlias in LatestOrderColumnAlias<DataT>]: (DataT["logTable"]["columns"][columnAlias]);
    }>;
    export type LatestOrder<DataT extends LogMustSetLatestOrderData> = readonly [ColumnUtil.FromColumnMap<LatestOrderColumnMap<DataT>>, SortDirection];
    export type LatestOrderDelegate<DataT extends LogMustSetLatestOrderData, LatestOrderT extends LatestOrder<DataT>> = (columns: LatestOrderColumnMap<DataT>) => LatestOrderT;
    export class LogMustSetLatestOrder<DataT extends LogMustSetLatestOrderData> {
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        constructor(data: DataT);
        setLatestOrder<LatestOrderT extends LatestOrder<DataT>>(latestOrderDelegate: LatestOrderDelegate<DataT, LatestOrderT>): (LogMustSetTracked<{
            logTable: DataT["logTable"];
            ownerTable: DataT["ownerTable"];
            latestOrder: LatestOrderT;
        }>);
    }
}
declare module "design-pattern-log/util/constructor/01-set-owner" {
    import { TableWithPrimaryKey } from "table/index";
    import { LogMustSetLatestOrder } from "design-pattern-log/util/constructor/02-set-latest-order";
    import { LogData } from "design-pattern-log/log";
    export type LogMustSetOwnerData = Pick<LogData, "logTable">;
    export class LogMustSetOwner<DataT extends LogMustSetOwnerData> {
        readonly logTable: DataT["logTable"];
        constructor(data: DataT);
        setOwner<OwnerTableT extends TableWithPrimaryKey>(ownerTable: OwnerTableT): (LogMustSetLatestOrder<{
            logTable: DataT["logTable"];
            ownerTable: OwnerTableT;
        }>);
    }
}
declare module "design-pattern-log/util/constructor/00-log" {
    import { InsertableTable } from "table/index";
    import { LogMustSetOwner } from "design-pattern-log/util/constructor/01-set-owner";
    export function log<LogTableT extends InsertableTable>(logTable: LogTableT): (LogMustSetOwner<{
        logTable: LogTableT;
    }>);
}
declare module "design-pattern-log/util/constructor/index" {
    export * from "design-pattern-log/util/constructor/00-log";
    export * from "design-pattern-log/util/constructor/01-set-owner";
    export * from "design-pattern-log/util/constructor/02-set-latest-order";
    export * from "design-pattern-log/util/constructor/03-set-tracked";
    export * from "design-pattern-log/util/constructor/04-set-do-not-copy";
    export * from "design-pattern-log/util/constructor/05-set-copy-defaults-delegate";
    export * from "design-pattern-log/util/constructor/06-set-tracked-defaults";
}
declare module "design-pattern-log/util/execution/exists" {
    import { ILog } from "design-pattern-log/log";
    import { PrimaryKey_Input } from "primary-key/index";
    import { SelectConnection } from "execution/index";
    export function exists<LogT extends ILog>(log: LogT, connection: SelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>): (Promise<boolean>);
}
declare module "design-pattern-log/util/execution/fetch-default" {
    import { ILog } from "design-pattern-log/log";
    import { IsolableSelectConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { CompileError } from "compile-error/index";
    import { TableUtil } from "table/index";
    import { Identity } from "type-util/index";
    export type AssertAllTrackedHasDefaultValue<LogT extends ILog> = Exclude<LogT["tracked"][number], LogT["trackedWithDefaultValue"][number]> extends never ? unknown : CompileError<[Exclude<LogT["tracked"][number], LogT["trackedWithDefaultValue"][number]>, "do not have default values"]>;
    export function assertAllTrackedHasDefaultValue(log: ILog): void;
    export type DefaultRow<LogT extends ILog> = Identity<{
        readonly [columnAlias in (LogT["ownerTable"]["primaryKey"][number] | LogT["trackedWithDefaultValue"][number] | Extract<LogT["copy"][number], TableUtil.RequiredColumnAlias<LogT["logTable"]>>)]: (TableUtil.ColumnType<LogT["logTable"], columnAlias>);
    } & {
        readonly [columnAlias in (Extract<LogT["copy"][number], TableUtil.OptionalColumnAlias<LogT["logTable"]>>)]?: (TableUtil.ColumnType<LogT["logTable"], columnAlias>);
    }>;
    export function fetchDefault<LogT extends ILog>(log: LogT, // & AssertAllTrackedHasDefaultValue<LogT>,
    connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>): Promise<DefaultRow<LogT>>;
}
declare module "design-pattern-log/util/execution/latest-by-primary-key" {
    import { ILog } from "design-pattern-log/log";
    import { QueryUtil } from "unified-query/index";
    import { PrimaryKey_Input } from "primary-key/index";
    export type LatestByPrimaryKey<LogT extends ILog> = (QueryUtil.LimitBigInt<QueryUtil.OrderBy<QueryUtil.WhereEqColumns<QueryUtil.From<QueryUtil.NewInstance, LogT["logTable"]>>>, 1n>);
    export function latestByPrimaryKey<LogT extends ILog>(log: LogT, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>): (LatestByPrimaryKey<LogT>);
}
declare module "design-pattern-log/util/execution/fetch-latest" {
    import { ILog } from "design-pattern-log/log";
    import { PrimaryKey_Input } from "primary-key/index";
    import { ExecutionUtil, SelectConnection } from "execution/index";
    import { Row } from "row/index";
    export type FetchLatest<LogT extends ILog> = ExecutionUtil.FetchOnePromise<Row<LogT["logTable"]>>;
    export function fetchLatest<LogT extends ILog>(log: LogT, connection: SelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>): (FetchLatest<LogT>);
}
declare module "design-pattern-log/util/execution/fetch-latest-or-default" {
    import { ILog } from "design-pattern-log/log";
    import { DefaultRow } from "design-pattern-log/util/execution/fetch-default";
    import { Row } from "row/index";
    import { IsolableSelectConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    export type LatestOrDefault<LatestRowT, DefaultRowT> = {
        isDefault: false;
        row: LatestRowT;
    } | {
        isDefault: true;
        row: DefaultRowT;
    };
    export type FetchLatestOrDefault<LogT extends ILog> = LatestOrDefault<Row<LogT["logTable"]>, DefaultRow<LogT>>;
    export function fetchLatestOrDefault<LogT extends ILog>(log: LogT, connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>): Promise<FetchLatestOrDefault<LogT>>;
}
declare module "design-pattern-log/util/execution/fetch-latest-value" {
    import { ILog } from "design-pattern-log/log";
    import { PrimaryKey_Input } from "primary-key/index";
    import { ExecutionUtil, SelectConnection } from "execution/index";
    import { FromClauseUtil } from "from-clause/index";
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { SelectValueDelegate } from "select-clause/index";
    export type FetchLatestValue<BuiltInExprT extends AnyBuiltInExpr> = ExecutionUtil.FetchValuePromise<BuiltInExprUtil.TypeOf<BuiltInExprT>>;
    export type FetchLatestValueSelectValueDelegate<LogT extends ILog, BuiltInExprT extends AnyBuiltInExpr> = SelectValueDelegate<FromClauseUtil.From<FromClauseUtil.NewInstance, LogT["logTable"]>, undefined, BuiltInExprT>;
    export function fetchLatestValue<LogT extends ILog, BuiltInExprT extends AnyBuiltInExpr>(log: LogT, connection: SelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>, selectValueDelegate: FetchLatestValueSelectValueDelegate<LogT, BuiltInExprT>): (FetchLatestValue<AnyBuiltInExpr>);
}
declare module "design-pattern-log/util/execution/fetch-latest-value-or-default" {
    import { ILog } from "design-pattern-log/log";
    import { PrimaryKey_Input } from "primary-key/index";
    import { IsolableSelectConnection } from "execution/index";
    import { ColumnUtil } from "column/index";
    import { Identity } from "type-util/index";
    export type FetchLatestValueOrDefaultColumnMap<LogT extends ILog> = Identity<{
        [columnAlias in LogT["trackedWithDefaultValue"][number]]: (LogT["logTable"]["columns"][columnAlias]);
    }>;
    export type FetchLatestValueOrDefaultColumn<LogT extends ILog> = ColumnUtil.FromColumnMap<FetchLatestValueOrDefaultColumnMap<LogT>>;
    export type FetchLatestValueOrDefaultSelectValueDelegate<LogT extends ILog, ColumnT extends FetchLatestValueOrDefaultColumn<LogT>> = (columns: FetchLatestValueOrDefaultColumnMap<LogT>) => ColumnT;
    export function fetchLatestValueOrDefault<LogT extends ILog, ColumnT extends FetchLatestValueOrDefaultColumn<LogT>>(log: LogT, connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>, selectValueDelegate: FetchLatestValueOrDefaultSelectValueDelegate<LogT, ColumnT>): (Promise<ReturnType<ColumnT["mapper"]>>);
}
declare module "design-pattern-log/util/execution/track-result" {
    import { LatestOrDefault } from "design-pattern-log/util/execution/fetch-latest-or-default";
    export type TrackResult<LatestRowT, DefaultRowT> = {
        changed: true;
        previous: LatestOrDefault<LatestRowT, DefaultRowT>;
        current: LatestRowT;
    } | {
        changed: false;
        previous: LatestOrDefault<LatestRowT, DefaultRowT>;
    };
}
declare module "design-pattern-log/util/execution/unsafe-track" {
    import { ILog } from "design-pattern-log/log";
    import { IsolableInsertOneConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { TableUtil } from "table/index";
    import { CustomExpr_NonCorrelated, CustomExpr_NonCorrelatedOrUndefined } from "custom-expr/index";
    import { DefaultRow } from "design-pattern-log/util/execution/fetch-default";
    import { Row } from "row/index";
    import { TrackResult } from "design-pattern-log/util/execution/track-result";
    export type TrackRow<LogT extends ILog> = 
    /**
     * All `trackedWithDefaultValue` columns may have values set or unset.
     * If unset, previous values are used, if any.
     * Otherwise, default values are used.
     *
     * If set, the set value is used.
     */
    {
        readonly [columnAlias in LogT["trackedWithDefaultValue"][number]]?: (CustomExpr_NonCorrelatedOrUndefined<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All `tracked` columns without default values **should** always have values set.
     * However, with `unsafeTrack()`, we explicitly allow an avoidable run-time error
     * to happen.
     *
     * If set to `undefined`, there's a chance the function will throw.
     *
     * At the moment, these properties are **NOT** optional.
     * You **MUST** explicitly say you want the property to be `undefined`,
     * and explicitly acknowledge the possibility of a run-time error.
     *
     * @todo Maybe consider making the property optional?
     */
     & {
        readonly [columnAlias in Exclude<LogT["tracked"][number], LogT["trackedWithDefaultValue"][number]>]: (undefined | CustomExpr_NonCorrelated<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All required `doNotCopy` columns must have values set.
     */
     & {
        readonly [columnAlias in Extract<LogT["doNotCopy"][number], TableUtil.RequiredColumnAlias<LogT["logTable"]>>]: (CustomExpr_NonCorrelated<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All optional `doNotCopy` columns may have values set or unset.
     * If unset, the default value is used.
     * If set, the set value is used.
     */
     & {
        readonly [columnAlias in Extract<LogT["doNotCopy"][number], TableUtil.OptionalColumnAlias<LogT["logTable"]>>]?: (CustomExpr_NonCorrelatedOrUndefined<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    };
    export type Track<LogT extends ILog> = TrackResult<Row<LogT["logTable"]>, DefaultRow<LogT>>;
    /**
     * Allows `tracked` columns without default values to be unset.
     * However, this comes with the risk of run-time errors, if no previous row is found.
     */
    export function unsafeTrack<LogT extends ILog>(log: LogT, connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>, unsafeTrackRow: TrackRow<LogT>): (Promise<Track<LogT>>);
}
declare module "design-pattern-log/util/execution/track-or-insert" {
    import { ILog } from "design-pattern-log/log";
    import { IsolableInsertOneConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { TableUtil } from "table/index";
    import { CustomExpr_NonCorrelated, CustomExpr_NonCorrelatedOrUndefined } from "custom-expr/index";
    import { Track } from "design-pattern-log/util/execution/unsafe-track";
    export type TrackOrInsertRow<LogT extends ILog> = 
    /**
     * All `trackedWithDefaultValue` columns may have values set or unset.
     * If unset, previous values are used, if any.
     * Otherwise, default values are used.
     *
     * If set, the set value is used.
     */
    {
        readonly [columnAlias in LogT["trackedWithDefaultValue"][number]]?: (CustomExpr_NonCorrelatedOrUndefined<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All `tracked` columns without default values must always have values set.
     */
     & {
        readonly [columnAlias in Exclude<LogT["tracked"][number], LogT["trackedWithDefaultValue"][number]>]: (CustomExpr_NonCorrelated<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All required `doNotCopy` columns must have values set.
     */
     & {
        readonly [columnAlias in Extract<LogT["doNotCopy"][number], TableUtil.RequiredColumnAlias<LogT["logTable"]>>]: (CustomExpr_NonCorrelated<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    }
    /**
     * All optional `doNotCopy` columns may have values set or unset.
     * If unset, the default value is used.
     * If set, the set value is used.
     */
     & {
        readonly [columnAlias in Extract<LogT["doNotCopy"][number], TableUtil.OptionalColumnAlias<LogT["logTable"]>>]?: (CustomExpr_NonCorrelatedOrUndefined<TableUtil.ColumnType<LogT["logTable"], columnAlias>>);
    };
    export function trackOrInsert<LogT extends ILog>(log: LogT, connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>, trackOrInsertRow: TrackOrInsertRow<LogT>): (Promise<Track<LogT>>);
}
declare module "design-pattern-log/util/execution/track" {
    import { ILog } from "design-pattern-log/log";
    import { IsolableInsertOneConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { AssertAllTrackedHasDefaultValue } from "design-pattern-log/util/execution/fetch-default";
    import { TrackRow, Track } from "design-pattern-log/util/execution/unsafe-track";
    export function track<LogT extends ILog>(log: LogT & AssertAllTrackedHasDefaultValue<LogT>, connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<LogT["ownerTable"]>, trackRow: TrackRow<LogT>): (Promise<Track<LogT>>);
}
declare module "design-pattern-log/util/execution/index" {
    export * from "design-pattern-log/util/execution/exists";
    export * from "design-pattern-log/util/execution/fetch-default";
    export * from "design-pattern-log/util/execution/fetch-latest-or-default";
    export * from "design-pattern-log/util/execution/fetch-latest-value-or-default";
    export * from "design-pattern-log/util/execution/fetch-latest-value";
    export * from "design-pattern-log/util/execution/fetch-latest";
    export * from "design-pattern-log/util/execution/latest-by-primary-key";
    export * from "design-pattern-log/util/execution/track-or-insert";
    export * from "design-pattern-log/util/execution/track-result";
    export * from "design-pattern-log/util/execution/track";
    export * from "design-pattern-log/util/execution/unsafe-track";
}
declare module "design-pattern-log/util/correlated-subquery/exists" {
    import * as tm from "type-mapping";
    import { ILog } from "design-pattern-log/log";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    export type Exists<LogT extends ILog> = Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<LogT["ownerTable"]["columns"]>;
        isAggregate: false;
    }>;
    export function exists<LogT extends ILog>(log: LogT): (Exists<LogT>);
}
declare module "design-pattern-log/util/correlated-subquery/latest" {
    import { ILog } from "design-pattern-log/log";
    import { QueryUtil } from "unified-query/index";
    export type Latest<LogT extends ILog> = (QueryUtil.LimitBigInt<QueryUtil.OrderBy<QueryUtil.Where<QueryUtil.From<QueryUtil.NewInstanceWithOuterQueryJoins<[LogT["ownerTable"]]>, LogT["logTable"]>>>, 1n>);
    export function latest<LogT extends ILog>(log: LogT): (Latest<LogT>);
}
declare module "design-pattern-log/util/correlated-subquery/latest-value-or-default" {
    import * as tm from "type-mapping";
    import { ILog } from "design-pattern-log/log";
    import { ColumnUtil } from "column/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { Identity } from "type-util/index";
    export type LatestValueOrDefaultColumnMap<LogT extends ILog> = Identity<{
        [columnAlias in LogT["trackedWithDefaultValue"][number]]: (LogT["logTable"]["columns"][columnAlias]);
    }>;
    export type LatestValueOrDefaultColumn<LogT extends ILog> = ColumnUtil.FromColumnMap<LatestValueOrDefaultColumnMap<LogT>>;
    export type LatestValueOrDefaultSelectValueDelegate<LogT extends ILog, ColumnT extends LatestValueOrDefaultColumn<LogT>> = (columns: LatestValueOrDefaultColumnMap<LogT>) => ColumnT;
    export type LatestValueOrDefault<LogT extends ILog, ColumnT extends LatestValueOrDefaultColumn<LogT>> = (Expr<{
        mapper: tm.SafeMapper<ReturnType<ColumnT["mapper"]>>;
        usedRef: UsedRefUtil.FromColumnMap<LogT["ownerTable"]["columns"]>;
        isAggregate: false;
    }>);
    export function latestValueOrDefault<LogT extends ILog, ColumnT extends LatestValueOrDefaultColumn<LogT>>(log: LogT, selectValueDelegate: LatestValueOrDefaultSelectValueDelegate<LogT, ColumnT>): (LatestValueOrDefault<LogT, ColumnT>);
}
declare module "design-pattern-log/util/correlated-subquery/latest-value" {
    import * as tm from "type-mapping";
    import { ILog } from "design-pattern-log/log";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    import { AnyBuiltInExpr, BuiltInExprUtil } from "built-in-expr/index";
    import { FromClauseUtil } from "from-clause/index";
    import { SelectValueDelegate } from "select-clause/index";
    export type LatestValue<LogT extends ILog, BuiltInExprT extends AnyBuiltInExpr> = (Expr<{
        mapper: tm.SafeMapper<null | BuiltInExprUtil.TypeOf<BuiltInExprT>>;
        usedRef: UsedRefUtil.FromColumnMap<LogT["ownerTable"]["columns"]>;
        isAggregate: false;
    }>);
    export interface LatestValueSelectValueDelegate<LogT extends ILog, BuiltInExprT extends AnyBuiltInExpr> extends SelectValueDelegate<FromClauseUtil.From<FromClauseUtil.NewInstanceWithOuterQueryJoins<false, [LogT["ownerTable"]]>, LogT["logTable"]>, undefined, BuiltInExprT> {
    }
    export function latestValue<LogT extends ILog, BuiltInExprT extends AnyBuiltInExpr>(log: LogT, selectValueDelegate: LatestValueSelectValueDelegate<LogT, BuiltInExprT>): (LatestValue<LogT, AnyBuiltInExpr>);
}
declare module "design-pattern-log/util/correlated-subquery/index" {
    export * from "design-pattern-log/util/correlated-subquery/exists";
    export * from "design-pattern-log/util/correlated-subquery/latest-value-or-default";
    export * from "design-pattern-log/util/correlated-subquery/latest-value";
    export * from "design-pattern-log/util/correlated-subquery/latest";
}
declare module "design-pattern-log/util/index" {
    export * from "design-pattern-log/util/constructor/index";
    export * from "design-pattern-log/util/execution/index";
    import * as CorrelatedSubquery from "design-pattern-log/util/correlated-subquery/index";
    export { CorrelatedSubquery, };
}
declare module "design-pattern-log/log-impl" {
    import { LogData, ILog } from "design-pattern-log/log";
    import { SelectConnection, IsolableSelectConnection, IsolableInsertOneConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import * as LogUtil from "design-pattern-log/util/index";
    import { AnyBuiltInExpr } from "built-in-expr/index";
    export class Log<DataT extends LogData> implements ILog<DataT> {
        readonly tracked: DataT["tracked"];
        readonly doNotCopy: DataT["doNotCopy"];
        readonly copy: DataT["copy"];
        readonly trackedWithDefaultValue: DataT["trackedWithDefaultValue"];
        readonly logTable: DataT["logTable"];
        readonly ownerTable: DataT["ownerTable"];
        readonly latestOrder: DataT["latestOrder"];
        readonly copyDefaultsDelegate: ILog["copyDefaultsDelegate"];
        readonly trackedDefaults: ILog["trackedDefaults"];
        constructor(data: DataT, extraData: Pick<ILog, "copyDefaultsDelegate" | "trackedDefaults">);
        fetchDefault(connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>): (Promise<LogUtil.DefaultRow<this>>);
        fetchLatest(connection: SelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>): (LogUtil.FetchLatest<this>);
        fetchLatestValue<BuiltInExprT extends AnyBuiltInExpr>(connection: SelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>, selectValueDelegate: LogUtil.FetchLatestValueSelectValueDelegate<this, BuiltInExprT>): (LogUtil.FetchLatestValue<BuiltInExprT>);
        /**
         * @todo Make this part of fluent API of `fetchLatest()`?
         */
        fetchLatestOrDefault(connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>): (Promise<LogUtil.FetchLatestOrDefault<this>>);
        fetchLatestValueOrDefault<ColumnT extends LogUtil.FetchLatestValueOrDefaultColumn<this>>(connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>, selectValueDelegate: LogUtil.FetchLatestValueOrDefaultSelectValueDelegate<this, ColumnT>): (Promise<ReturnType<ColumnT["mapper"]>>);
        exists(connection: IsolableSelectConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>): (Promise<boolean>);
        trackOrInsert(connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>, trackOrInsertRow: LogUtil.TrackOrInsertRow<this>): (Promise<LogUtil.Track<this>>);
        unsafeTrack(connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>, unsafeTrackRow: LogUtil.TrackRow<this>): (Promise<LogUtil.Track<this>>);
        track(this: this & LogUtil.AssertAllTrackedHasDefaultValue<this>, connection: IsolableInsertOneConnection, primaryKey: PrimaryKey_Input<this["ownerTable"]>, trackRow: LogUtil.TrackRow<this>): (Promise<LogUtil.Track<this>>);
        /**
         * A collection of correlated subqueries/expressions,
         * these require the `ownerTable` to be in the `FROM` clause.
         */
        readonly correlatedSubquery: {
            exists: () => LogUtil.CorrelatedSubquery.Exists<ILog<DataT>>;
            latest: () => LogUtil.CorrelatedSubquery.Latest<ILog<DataT>>;
            latestValue: <BuiltInExprT extends AnyBuiltInExpr>(selectValueDelegate: LogUtil.CorrelatedSubquery.LatestValueSelectValueDelegate<ILog<DataT>, BuiltInExprT>) => LogUtil.CorrelatedSubquery.LatestValue<ILog<DataT>, BuiltInExprT>;
            latestValueOrDefault: <ColumnT extends LogUtil.CorrelatedSubquery.LatestValueOrDefaultColumn<ILog<DataT>>>(selectValueDelegate: LogUtil.CorrelatedSubquery.LatestValueOrDefaultSelectValueDelegate<ILog<DataT>, ColumnT>) => LogUtil.CorrelatedSubquery.LatestValueOrDefault<ILog<DataT>, ColumnT>;
        };
    }
}
declare module "design-pattern-log/index" {
    export * from "design-pattern-log/log-impl";
    export * from "design-pattern-log/log";
    import * as LogUtil from "design-pattern-log/util/index";
    export { LogUtil, };
    import { log } from "design-pattern-log/util/index";
    export { log, };
}
declare module "design-pattern-table-per-type/table-per-type" {
    import { TableWithPrimaryKey } from "table/index";
    import { Key } from "key/index";
    export interface TablePerTypeData {
        readonly childTable: TableWithPrimaryKey;
        readonly parentTables: readonly TableWithPrimaryKey[];
        readonly autoIncrement: readonly string[];
        readonly explicitAutoIncrementValueEnabled: readonly string[];
        /**
         * Some `parentTables` may not have an `autoIncrement` column.
         *
         * When such a `parentTable` is encountered and
         * we call `TablePerTypeUtil.insertAndFetch()`,
         * we need to provide explicit values for the primary key
         * of the `parentTable`.
         *
         * A value of `readonly never[]` indicates
         * we do not need to specify any primary key.
         */
        readonly insertAndFetchPrimaryKey: Key;
    }
    export interface ITablePerType<DataT extends TablePerTypeData = TablePerTypeData> {
        /**
         * The "child" table we are currently concerned with.
         *
         * `table extends parentTables`
         */
        readonly childTable: DataT["childTable"];
        /**
         * All other tables higher up the inheritance hierarchy.
         */
        readonly parentTables: DataT["parentTables"];
        /**
         * Multiple columns may be `autoIncrement` in a table-per-type hierarchy.
         */
        readonly autoIncrement: DataT["autoIncrement"];
        readonly explicitAutoIncrementValueEnabled: DataT["explicitAutoIncrementValueEnabled"];
        readonly insertAndFetchPrimaryKey: DataT["insertAndFetchPrimaryKey"];
        /**
         * An array of 2-tuples containing table aliases.
         *
         * It will tell us how to construct `INNER JOIN`s to
         * efficiently query all columns for the `childTable`.
         *
         * We have to be mindful of the following possible
         * inheritance subgraphs,
         *
         * + Linear inheritance
         *   + D extends C extends B extends A
         *
         * + Diamond inheritance
         *   + D extends B extends A
         *   + D extends C extends A
         *
         * + Tree inheritance
         *   + D extends B extends A
         *   + D extends C
         */
        readonly joins: readonly (readonly [string, string])[];
    }
    type InsertableTablePerTypeImpl = Omit<ITablePerType, "parentTables"> & {
        childTable: {
            insertEnabled: true;
        };
        parentTables: readonly (TableWithPrimaryKey & {
            insertEnabled: true;
        })[];
    };
    /**
     * + https://github.com/microsoft/TypeScript/issues/34777#issuecomment-551993933
     * + https://github.com/microsoft/TypeScript/issues/35654
     */
    export interface InsertableTablePerType extends InsertableTablePerTypeImpl {
    }
    type DeletableTablePerTypeImpl = Omit<ITablePerType, "parentTables"> & {
        childTable: {
            deleteEnabled: true;
        };
        parentTables: readonly (TableWithPrimaryKey & {
            deleteEnabled: true;
        })[];
    };
    /**
     * + https://github.com/microsoft/TypeScript/issues/34777#issuecomment-551993933
     * + https://github.com/microsoft/TypeScript/issues/35654
     */
    export interface DeletableTablePerType extends DeletableTablePerTypeImpl {
    }
}
declare module "design-pattern-table-per-type/util/query/column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    export type ColumnAlias<TptT extends ITablePerType> = TableUtil.ColumnAlias<TptT["childTable"] | TptT["parentTables"][number]>;
    export function columnAliases<TptT extends ITablePerType>(tpt: TptT): ColumnAlias<TptT>[];
    export function isColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is ColumnAlias<TptT>;
}
declare module "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    export type ExtractAllTablesWithColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string> = TableUtil.ExtractWithColumnAlias<(TptT["childTable"] | TptT["parentTables"][number]), ColumnAliasT>;
    export function extractAllTablesWithColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string>(tpt: TptT, columnAlias: ColumnAliasT): ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>[];
}
declare module "design-pattern-table-per-type/util/query/extract-table-with-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractTableWithAlias<T extends ITablePerType, AliasT extends string> = Extract<(T["childTable"] | T["parentTables"][number]), {
        alias: AliasT;
    }>;
}
declare module "design-pattern-table-per-type/util/query/column-type" {
    import * as tm from "type-mapping";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    import { ExtractAllTablesWithColumnAlias } from "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias";
    import { ExtractTableWithAlias } from "design-pattern-table-per-type/util/query/extract-table-with-alias";
    /**
     * If `TableAliasT` is the only table with `ColumnAliasT`,
     * then this will return `never`.
     *
     * + `never extends true`.
     * + `true extends true`.
     *
     * So, just check if `HasSmallestColumnType<> extends true`.
     */
    export type HasSmallestColumnType<TptT extends ITablePerType, TableAliasT extends string, ColumnAliasT extends string> = {
        [otherTableAlias in Exclude<ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>["alias"], TableAliasT>]: (TableUtil.ColumnType<ExtractTableWithAlias<TptT, TableAliasT>, ColumnAliasT> extends TableUtil.ColumnType<ExtractTableWithAlias<TptT, otherTableAlias>, ColumnAliasT> ? true : false);
    }[Exclude<ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>["alias"], TableAliasT>];
    export type ColumnType<TptT extends ITablePerType, ColumnAliasT extends string> = {
        [tableAlias in ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>["alias"]]: (HasSmallestColumnType<TptT, tableAlias, ColumnAliasT> extends true ? TableUtil.ColumnType<ExtractTableWithAlias<TptT, tableAlias>, ColumnAliasT> : never);
    }[ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>["alias"]];
    export function columnMapper<TptT extends ITablePerType, ColumnAliasT extends string>(tpt: TptT, columnAlias: ColumnAliasT): tm.SafeMapper<ColumnType<TptT, ColumnAliasT>>;
}
declare module "design-pattern-table-per-type/util/query/parent-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    export type ParentColumnAlias<TptT extends ITablePerType> = TableUtil.ColumnAlias<TptT["parentTables"][number]>;
    export function parentColumnAliases<TptT extends ITablePerType>(tpt: TptT): ParentColumnAlias<TptT>[];
    export function isParentColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is ParentColumnAlias<TptT>;
}
declare module "design-pattern-table-per-type/util/query/extract-all-parent-tables-with-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    export type ExtractAllParentTablesWithColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string> = TableUtil.ExtractWithColumnAlias<TptT["parentTables"][number], ColumnAliasT>;
}
declare module "design-pattern-table-per-type/util/query/explicit-default-value-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { ParentColumnAlias } from "design-pattern-table-per-type/util/query/parent-column-alias";
    import { ExtractAllParentTablesWithColumnAlias } from "design-pattern-table-per-type/util/query/extract-all-parent-tables-with-column-alias";
    export type ExplicitDefaultValueColumnAlias<TptT extends ITablePerType> = {
        [columnAlias in ColumnAlias<TptT>]: (columnAlias extends ParentColumnAlias<TptT> ? (TableUtil.HasExplicitDefaultValue<ExtractAllParentTablesWithColumnAlias<TptT, columnAlias>, columnAlias> extends true ? columnAlias : never) : (TableUtil.HasExplicitDefaultValue<TptT["childTable"], columnAlias> extends true ? columnAlias : never));
    }[ColumnAlias<TptT>];
    export function isExplicitDefaultValueColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is ExplicitDefaultValueColumnAlias<TptT>;
    export function explicitDefaultValueColumnAliases<TptT extends ITablePerType>(tpt: TptT): ExplicitDefaultValueColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/predicate/is-table-per-type" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    /**
     * Actually only checks if it has all the properties of `ITablePerType`.
     *
     * So, if it has all the properties but they're of the wrong data type...
     */
    export function isTablePerType(mixed: unknown): mixed is ITablePerType;
}
declare module "design-pattern-table-per-type/util/predicate/index" {
    export * from "design-pattern-table-per-type/util/predicate/is-table-per-type";
}
declare module "design-pattern-table-per-type/util/query/extract-all-tables" {
    import { ITable } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractAllTables<T extends ITable | ITablePerType> = T extends ITablePerType ? (T["parentTables"][number] | T["childTable"]) : T extends ITable ? T : never;
    export function extractAllTables<T extends ITable | ITablePerType>(t: T): ExtractAllTables<T>[];
}
declare module "design-pattern-table-per-type/util/query/extract-auto-increment" {
    import { ITable } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractAutoIncrement<T extends ITable | ITablePerType> = T extends ITablePerType ? T["autoIncrement"][number] : T extends ITable ? Extract<T["autoIncrement"], string> : never;
    export function extractAutoIncrement<T extends ITable | ITablePerType>(t: T): ExtractAutoIncrement<T>[];
}
declare module "design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled" {
    import { ITable } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractExplicitAutoIncrementValueEnabled<T extends ITable | ITablePerType> = T extends ITablePerType ? T["explicitAutoIncrementValueEnabled"][number] : T extends ITable ? (T["explicitAutoIncrementValueEnabled"] extends true ? Extract<T["autoIncrement"], string> : never) : never;
    export function extractExplicitAutoIncrementValueEnabled<T extends ITable | ITablePerType>(t: T): ExtractExplicitAutoIncrementValueEnabled<T>[];
}
declare module "design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key" {
    import { TableWithPrimaryKey, TableWithAutoIncrement } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractInsertAndFetchPrimaryKey<T extends TableWithPrimaryKey | ITablePerType> = T extends ITablePerType ? T["insertAndFetchPrimaryKey"][number] : T extends TableWithAutoIncrement ? never : T extends TableWithPrimaryKey ? Exclude<T["primaryKey"][number], T["generatedColumns"][number] | T["autoIncrement"]> : never;
    export function extractInsertAndFetchPrimaryKey<T extends TableWithPrimaryKey | ITablePerType>(t: T): ExtractInsertAndFetchPrimaryKey<T>[];
}
declare module "design-pattern-table-per-type/util/query/extract-child-table" {
    import { ITable } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractChildTable<T extends ITable | ITablePerType> = T extends ITablePerType ? T["childTable"] : T;
    export function extractChildTable<T extends ITable | ITablePerType>(t: T): ExtractChildTable<T>;
}
declare module "design-pattern-table-per-type/util/query/extract-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ITable, TableUtil } from "table/index";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    export type ExtractColumnAlias<T extends ITable | ITablePerType> = T extends ITablePerType ? ColumnAlias<T> : T extends ITable ? TableUtil.ColumnAlias<T> : never;
    export function extractColumnAliases<T extends ITable | ITablePerType>(t: T): ExtractColumnAlias<T>[];
}
declare module "design-pattern-table-per-type/util/query/extract-parent-tables" {
    import { ITable } from "table/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ExtractParentTables<T extends ITable | ITablePerType> = T extends ITablePerType ? T["parentTables"][number] : never;
    export function extractParentTables<T extends ITable | ITablePerType>(t: T): ExtractParentTables<T>[];
}
declare module "design-pattern-table-per-type/util/query/find-last-join-to-table" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export function findLastJoinToTable(tpt: ITablePerType, toTableAlias: string): readonly [string, string];
}
declare module "design-pattern-table-per-type/util/query/find-table-with-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ExtractAllTablesWithColumnAlias } from "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias";
    /**
     * Goes up the inheritance hierarchy, starting from `childTable`,
     * to look for a table with `columnAlias` as a column
     */
    export function findTableWithColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string>(tpt: TptT, columnAlias: ColumnAliasT): ExtractAllTablesWithColumnAlias<TptT, ColumnAliasT>;
}
declare module "design-pattern-table-per-type/util/query/find-table-with-generated-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    export type ExtractAllTablesWithGeneratedColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string> = TableUtil.ExtractWithGeneratedColumnAlias<(TptT["childTable"] | TptT["parentTables"][number]), ColumnAliasT>;
    /**
     * Goes up the inheritance hierarchy, starting from `childTable`,
     * to look for a table with `columnAlias` as a generated column
     */
    export function findTableWithGeneratedColumnAlias<TptT extends ITablePerType, ColumnAliasT extends string>(tpt: TptT, columnAlias: ColumnAliasT): ExtractAllTablesWithGeneratedColumnAlias<TptT, ColumnAliasT>;
}
declare module "design-pattern-table-per-type/util/query/generated-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type GeneratedColumnAlias<TptT extends ITablePerType> = (TptT["childTable"] | TptT["parentTables"][number])["generatedColumns"][number];
    export function isGeneratedColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is GeneratedColumnAlias<TptT>;
    export function generatedColumnAliases<TptT extends ITablePerType>(tpt: TptT): GeneratedColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/implicit-auto-increment" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type ImplicitAutoIncrement<TptT extends ITablePerType> = Exclude<TptT["autoIncrement"][number], TptT["explicitAutoIncrementValueEnabled"][number]>;
    export function implicitAutoIncrement<TptT extends ITablePerType>(tpt: TptT): ImplicitAutoIncrement<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/insertable-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { GeneratedColumnAlias } from "design-pattern-table-per-type/util/query/generated-column-alias";
    import { ImplicitAutoIncrement } from "design-pattern-table-per-type/util/query/implicit-auto-increment";
    export type InsertableColumnAlias<TptT extends ITablePerType> = Exclude<ColumnAlias<TptT>, (GeneratedColumnAlias<TptT> | ImplicitAutoIncrement<TptT>)>;
}
declare module "design-pattern-table-per-type/util/query/mutable-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { ExtractAllTablesWithColumnAlias } from "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias";
    export type MutableColumnAlias<TptT extends ITablePerType> = {
        [columnAlias in ColumnAlias<TptT>]: (TableUtil.IsMutable<ExtractAllTablesWithColumnAlias<TptT, columnAlias>, columnAlias> extends true ? columnAlias : never);
    }[ColumnAlias<TptT>];
    export function isMutableColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is MutableColumnAlias<TptT>;
    export function mutableColumnAliases<TptT extends ITablePerType>(tpt: TptT): MutableColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/non-generated-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { GeneratedColumnAlias } from "design-pattern-table-per-type/util/query/generated-column-alias";
    export type NonGeneratedColumnAlias<TptT extends ITablePerType> = Exclude<ColumnAlias<TptT>, GeneratedColumnAlias<TptT>>;
    export function nonGeneratedColumnAliases<TptT extends ITablePerType>(tpt: TptT): NonGeneratedColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/nullable-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { TableUtil } from "table/index";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { ExtractAllTablesWithColumnAlias } from "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias";
    export type NullableColumnAlias<TptT extends ITablePerType> = {
        [columnAlias in ColumnAlias<TptT>]: (TableUtil.IsNullable<ExtractAllTablesWithColumnAlias<TptT, columnAlias>, columnAlias> extends true ? columnAlias : never);
    }[ColumnAlias<TptT>];
    export function isNullableColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is NullableColumnAlias<TptT>;
    export function nullableColumnAliases<TptT extends ITablePerType>(tpt: TptT): NullableColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/optional-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ExplicitDefaultValueColumnAlias } from "design-pattern-table-per-type/util/query/explicit-default-value-column-alias";
    import { NullableColumnAlias } from "design-pattern-table-per-type/util/query/nullable-column-alias";
    import { GeneratedColumnAlias } from "design-pattern-table-per-type/util/query/generated-column-alias";
    import { Identity } from "type-util/index";
    export type OptionalColumnAlias<TptT extends ITablePerType> = Identity<TptT["explicitAutoIncrementValueEnabled"][number] | Exclude<(NullableColumnAlias<TptT> | ExplicitDefaultValueColumnAlias<TptT>), GeneratedColumnAlias<TptT>>>;
    export function isOptionalColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is OptionalColumnAlias<TptT>;
    export function optionalColumnAliases<TptT extends ITablePerType>(tpt: TptT): OptionalColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/primary-key-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    export type PrimaryKeyColumnAlias<TptT extends ITablePerType> = TptT["childTable"]["primaryKey"][number] | TptT["parentTables"][number]["primaryKey"][number];
    export function isPrimaryColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is PrimaryKeyColumnAlias<TptT>;
    export function primaryKeyColumnAliases<TptT extends ITablePerType>(tpt: TptT): PrimaryKeyColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/required-column-alias" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ExplicitDefaultValueColumnAlias } from "design-pattern-table-per-type/util/query/explicit-default-value-column-alias";
    import { NullableColumnAlias } from "design-pattern-table-per-type/util/query/nullable-column-alias";
    import { GeneratedColumnAlias } from "design-pattern-table-per-type/util/query/generated-column-alias";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    export type RequiredColumnAlias<TptT extends ITablePerType> = Exclude<ColumnAlias<TptT>, (GeneratedColumnAlias<TptT> | NullableColumnAlias<TptT> | ExplicitDefaultValueColumnAlias<TptT> | TptT["autoIncrement"][number])>;
    export function isRequiredColumnAlias<TptT extends ITablePerType>(tpt: TptT, columnAlias: string): columnAlias is RequiredColumnAlias<TptT>;
    export function requiredColumnAliases<TptT extends ITablePerType>(tpt: TptT): RequiredColumnAlias<TptT>[];
}
declare module "design-pattern-table-per-type/util/query/row" {
    import * as tm from "type-mapping";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { ColumnType } from "design-pattern-table-per-type/util/query/column-type";
    import { Identity } from "type-util/index";
    export type Row<TptT extends ITablePerType> = Identity<{
        [columnAlias in ColumnAlias<TptT>]: (ColumnType<TptT, columnAlias>);
    }>;
    export function rowMapper<TptT extends ITablePerType>(tpt: TptT): tm.SafeMapper<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/query/super-key-mapper" {
    import * as tm from "type-mapping";
    import { Key } from "key/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CandidateKey_NonUnionImpl } from "candidate-key/index";
    import { ColumnAlias } from "design-pattern-table-per-type/util/query/column-alias";
    import { ColumnType } from "design-pattern-table-per-type/util/query/column-type";
    export type SuperKey_FromCandidateKeyImpl<TptT extends ITablePerType, CandidateKeyT extends Key> = CandidateKeyT extends Key ? (CandidateKey_NonUnionImpl<TptT["childTable"]["columns"], CandidateKeyT> & {
        [columnName in Exclude<ColumnAlias<TptT>, CandidateKeyT[number]>]?: (ColumnType<TptT, columnName>);
    }) : never;
    export type SuperKey<TptT extends ITablePerType> = SuperKey_FromCandidateKeyImpl<TptT, TptT["childTable"]["candidateKeys"][number]>;
    export function superKeyMapper<TptT extends ITablePerType>(tpt: TptT): tm.SafeMapper<SuperKey<TptT>>;
}
declare module "design-pattern-table-per-type/util/query/index" {
    export * from "design-pattern-table-per-type/util/query/column-alias";
    export * from "design-pattern-table-per-type/util/query/column-type";
    export * from "design-pattern-table-per-type/util/query/explicit-default-value-column-alias";
    export * from "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias";
    export * from "design-pattern-table-per-type/util/query/extract-all-tables";
    export * from "design-pattern-table-per-type/util/query/extract-auto-increment";
    export * from "design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled";
    export * from "design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key";
    export * from "design-pattern-table-per-type/util/query/extract-child-table";
    export * from "design-pattern-table-per-type/util/query/extract-column-alias";
    export * from "design-pattern-table-per-type/util/query/extract-parent-tables";
    export * from "design-pattern-table-per-type/util/query/extract-table-with-alias";
    export * from "design-pattern-table-per-type/util/query/find-last-join-to-table";
    export * from "design-pattern-table-per-type/util/query/find-table-with-column-alias";
    export * from "design-pattern-table-per-type/util/query/find-table-with-generated-column-alias";
    export * from "design-pattern-table-per-type/util/query/generated-column-alias";
    export * from "design-pattern-table-per-type/util/query/implicit-auto-increment";
    export * from "design-pattern-table-per-type/util/query/insertable-column-alias";
    export * from "design-pattern-table-per-type/util/query/mutable-column-alias";
    export * from "design-pattern-table-per-type/util/query/non-generated-column-alias";
    export * from "design-pattern-table-per-type/util/query/nullable-column-alias";
    export * from "design-pattern-table-per-type/util/query/optional-column-alias";
    export * from "design-pattern-table-per-type/util/query/parent-column-alias";
    export * from "design-pattern-table-per-type/util/query/primary-key-column-alias";
    export * from "design-pattern-table-per-type/util/query/required-column-alias";
    export * from "design-pattern-table-per-type/util/query/row";
    export * from "design-pattern-table-per-type/util/query/super-key-mapper";
}
declare module "design-pattern-table-per-type/util/constructor/table-per-type" {
    import { TableWithPrimaryKey } from "table/index";
    import { TablePerType } from "design-pattern-table-per-type/table-per-type-impl";
    import { ExtractAutoIncrement, ExtractExplicitAutoIncrementValueEnabled, ExtractInsertAndFetchPrimaryKey } from "design-pattern-table-per-type/util/query/index";
    export function tablePerType<ChildTableT extends TableWithPrimaryKey>(childTable: ChildTableT): TablePerType<{
        childTable: ChildTableT;
        parentTables: readonly [];
        autoIncrement: readonly ExtractAutoIncrement<ChildTableT>[];
        explicitAutoIncrementValueEnabled: readonly ExtractExplicitAutoIncrementValueEnabled<ChildTableT>[];
        insertAndFetchPrimaryKey: readonly ExtractInsertAndFetchPrimaryKey<ChildTableT>[];
    }>;
}
declare module "design-pattern-table-per-type/util/constructor/index" {
    export * from "design-pattern-table-per-type/util/constructor/table-per-type";
}
declare module "design-pattern-table-per-type/util/execution/assignment-map" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { Identity } from "type-util/index";
    import { MutableColumnAlias, ColumnType, ColumnAlias } from "design-pattern-table-per-type/util/query/index";
    import { CustomExpr_MapCorrelated_NonAggregateOrUndefined } from "custom-expr/index";
    import { ColumnRefUtil } from "column-ref/index";
    import { ColumnUtil } from "column/index";
    export type CustomAssignmentMap<TptT extends ITablePerType> = Identity<{
        readonly [columnAlias in MutableColumnAlias<TptT>]?: (
        /**
         * The following `UPDATE` statement is invalid,
         * aggregate expressions are not allowed.
         * ```sql
         *  UPDATE myTable SET myColumn = SUM(myColumn);
         * ```
         */
        CustomExpr_MapCorrelated_NonAggregateOrUndefined<(TptT["childTable"]["columns"] | TptT["parentTables"][number]["columns"]), ColumnType<TptT, columnAlias>>);
    } & {
        readonly [columnAlias in Exclude<ColumnAlias<TptT>, MutableColumnAlias<TptT>>]?: undefined;
    }>;
    export type AssignmentMapDelegate<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>> = (columns: ColumnRefUtil.FromColumnArray<ColumnUtil.FromColumnMap<TptT["childTable"]["columns"] | TptT["parentTables"][number]["columns"]>[]>) => AssignmentMapT;
}
declare module "design-pattern-table-per-type/util/execution-impl/absorb-row" {
    import { ITable } from "table/index";
    /**
     * @todo Better name
     *
     * Adds properties from `row` to `result`.
     *
     * If a property from `row` already exists on `result`,
     * we use `table` to check if the values on both objects are equal.
     *
     * If they are not equal, an `Error` is thrown.
     */
    export function absorbRow(result: Record<string, unknown>, table: ITable, row: Record<string, unknown>): void;
}
declare module "design-pattern-table-per-type/util/execution-impl/from" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { Query } from "unified-query/index";
    import { IFromClause } from "from-clause/index";
    import { JoinUtil } from "join/index";
    export type From<TptT extends ITablePerType> = Query<{
        fromClause: IFromClause<{
            outerQueryJoins: undefined;
            currentJoins: readonly JoinUtil.FromAliasedTable<(TptT["childTable"] | TptT["parentTables"][number]), false>[];
        }>;
        selectClause: undefined;
        limitClause: undefined;
        compoundQueryClause: undefined;
        compoundQueryLimitClause: undefined;
        mapDelegate: undefined;
        groupByClause: undefined;
    }>;
    /**
     * This is used to implement a more efficient `fetchOne` operation.
     *
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    export function from<TptT extends ITablePerType>(tpt: TptT): From<TptT>;
}
declare module "design-pattern-table-per-type/util/execution-impl/assert-exists-impl" {
    import { SelectConnection } from "execution/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { From } from "design-pattern-table-per-type/util/execution-impl/from";
    import { WhereDelegate } from "where-clause/index";
    export function assertExistsImpl<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): (Promise<void>);
}
declare module "design-pattern-table-per-type/util/execution-impl/delete-one-impl" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ExecutionUtil, IsolableDeleteConnection } from "execution/index";
    import { TableWithPrimaryKey } from "table/index";
    import { From } from "design-pattern-table-per-type/util/execution-impl/from";
    import { WhereDelegate } from "where-clause/index";
    export interface DeleteOneResult {
        deleteOneResults: (ExecutionUtil.DeleteOneResult & {
            table: TableWithPrimaryKey;
        })[];
        deletedRowCount: bigint;
        /**
         * @todo MySQL sometimes gives a `warningCount` value `> 0` for
         * `DELETE` statements. Recall why.
         */
        warningCount: bigint;
    }
    export function deleteOneImpl<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): Promise<DeleteOneResult>;
}
declare module "design-pattern-table-per-type/util/execution-impl/exists-impl" {
    import { SelectConnection } from "execution/index";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { From } from "design-pattern-table-per-type/util/execution-impl/from";
    import { WhereDelegate } from "where-clause/index";
    export function existsImpl<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): (Promise<{
        sql: string;
        exists: boolean;
    }>);
}
declare module "design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableDeleteConnection } from "execution/index";
    import { From } from "design-pattern-table-per-type/util/execution-impl/from";
    import { WhereDelegate } from "where-clause/index";
    import { DeleteOneResult } from "design-pattern-table-per-type/util/execution-impl/delete-one-impl";
    export interface DeleteZeroResult {
        /**
         * Used as a discriminant.
         */
        deleteOneResults: undefined;
        query: {
            sql: string;
        };
        deletedRowCount: 0n;
        /**
         * @todo MySQL sometimes gives a `warningCount` value `> 0` for
         * `DELETE` statements. Recall why.
         */
        warningCount: bigint;
        /**
         * An arbitrary message.
         * May be an empty string.
         */
        message: string;
    }
    export type DeleteZeroOrOneResult = DeleteZeroResult | DeleteOneResult;
    export function deleteZeroOrOneImpl<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): Promise<DeleteZeroOrOneResult>;
}
declare module "design-pattern-table-per-type/util/execution-impl/fetch-one-impl" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import * as ExecutionImpl from "execution/util/operation/impl/index";
    import { SelectConnection } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { Row } from "design-pattern-table-per-type/util/query/index";
    import { From } from "design-pattern-table-per-type/util/execution-impl/from";
    /**
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    export function fetchOneImpl<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): ExecutionImpl.FetchOneImplPromise<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/index";
    import { IsolableSelectConnection } from "execution/index";
    import { From } from "design-pattern-table-per-type/util/execution-impl/index";
    import { WhereDelegate } from "where-clause/index";
    /**
     * Not meant to be called externally.
     *
     * @todo Better name
     */
    export function invokeAssignmentDelegate<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableSelectConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>, assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<Record<string, unknown>>;
}
declare module "design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableUpdateConnection, ExecutionUtil } from "execution/index";
    import { TableWithPrimaryKey } from "table/index";
    import { UpdateOneResult } from "execution/util/index";
    export interface UpdateAndFetchOneResult<RowT> {
        updateOneResults: (UpdateOneResult & {
            table: TableWithPrimaryKey;
        })[];
        foundRowCount: bigint;
        /**
         * You cannot trust this number for SQLite.
         * SQLite thinks that all found rows are updated, even if you set `x = x`.
         *
         * @todo Consider renaming this to `unreliableUpdatedRowCount`?
         */
        updatedRowCount: bigint;
        /**
         * May be the duplicate row count, or some other value.
         */
        warningCount: bigint;
        row: RowT;
    }
    /**
     * Not meant to be called externally.
     *
     * **DOES NOT** use savepoints, internally.
     * You **SHOULD** use savepoints before calling this function.
     */
    export function updateAndFetchOneImpl<TptT extends ITablePerType>(tpt: TptT, connection: IsolableUpdateConnection, cleanedAssignmentMap: Record<string, unknown>, updateAndFetchChildResult: ExecutionUtil.UpdateAndFetchOneResult<any, any>): Promise<UpdateAndFetchOneResult<Record<string, unknown>>>;
}
declare module "design-pattern-table-per-type/util/execution-impl/index" {
    export * from "design-pattern-table-per-type/util/execution-impl/absorb-row";
    export * from "design-pattern-table-per-type/util/execution-impl/assert-exists-impl";
    export * from "design-pattern-table-per-type/util/execution-impl/delete-one-impl";
    export * from "design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl";
    export * from "design-pattern-table-per-type/util/execution-impl/exists-impl";
    export * from "design-pattern-table-per-type/util/execution-impl/fetch-one-impl";
    export * from "design-pattern-table-per-type/util/execution-impl/from";
    export * from "design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate";
    export * from "design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl";
}
declare module "design-pattern-table-per-type/util/execution/delete-one-by-candidate-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    export function deleteOneByCandidateKey<TptT extends DeletableTablePerType, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TptT["childTable"]>>>(tpt: TptT, connection: IsolableDeleteConnection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey: CandidateKeyT): Promise<DeleteOneResult>;
}
declare module "design-pattern-table-per-type/util/execution/delete-one-by-primary-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { PrimaryKey_Input } from "primary-key/index";
    export function deleteOneByPrimaryKey<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, primaryKey: PrimaryKey_Input<TptT["childTable"]>): Promise<DeleteOneResult>;
}
declare module "design-pattern-table-per-type/util/operation/remove-duplicate-parents" {
    import { ITable } from "table/index";
    export function removeDuplicateParents<ParentTableT extends ITable>(arr: readonly ParentTableT[]): (ParentTableT)[];
}
declare module "design-pattern-table-per-type/util/operation/add-parent" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ITable, TableWithPrimaryKey } from "table/index";
    import { ExtractAutoIncrement, ExtractColumnAlias, ExtractExplicitAutoIncrementValueEnabled, ExtractInsertAndFetchPrimaryKey, ExtractAllTables } from "design-pattern-table-per-type/util/query/index";
    import { TablePerType } from "design-pattern-table-per-type/table-per-type-impl";
    import { Identity } from "type-util/index";
    /**
     * + `ParentT["parentTables"]`
     * + `ParentT["childTable"]`
     * + `Tpt["parentTables"]`
     * + `Tpt["childTable"]`
     *
     * Before:
     * ```
     * C1 -> P1
     * ```
     *
     * After:
     * ```
     * C1 -> P1 -> C2 -> P2
     * ```
     */
    type AddParent_AutoIncrement<TptT extends ITablePerType, ParentT extends ITable | ITablePerType> = Identity<ExtractAutoIncrement<ParentT> | Exclude<TptT["autoIncrement"][number], ExtractColumnAlias<ParentT>>>;
    type AddParent_ExplicitAutoIncrementValueEnabled<TptT extends ITablePerType, ParentT extends ITable | ITablePerType> = Identity<Extract<ExtractExplicitAutoIncrementValueEnabled<ParentT>, TptT["explicitAutoIncrementValueEnabled"][number]> | Exclude<ExtractExplicitAutoIncrementValueEnabled<ParentT>, TptT["autoIncrement"][number]> | Exclude<TptT["explicitAutoIncrementValueEnabled"][number], ExtractColumnAlias<ParentT>>>;
    type AddParent_InsertAndFetchPrimaryKey<TptT extends ITablePerType, ParentT extends TableWithPrimaryKey | ITablePerType> = Identity<ExtractInsertAndFetchPrimaryKey<ParentT> | Exclude<TptT["insertAndFetchPrimaryKey"][number], ExtractColumnAlias<ParentT>>>;
    export type AddParent<TptT extends ITablePerType, ParentT extends TableWithPrimaryKey | ITablePerType> = TablePerType<{
        childTable: TptT["childTable"];
        parentTables: readonly (ExtractAllTables<ParentT> | TptT["parentTables"][number])[];
        autoIncrement: readonly AddParent_AutoIncrement<TptT, ParentT>[];
        explicitAutoIncrementValueEnabled: readonly AddParent_ExplicitAutoIncrementValueEnabled<TptT, ParentT>[];
        insertAndFetchPrimaryKey: readonly AddParent_InsertAndFetchPrimaryKey<TptT, ParentT>[];
    }>;
    /**
     * @todo Check that a column is not both auto-increment and generated at the same time
     *
     * @todo Check that `tpt.childTable` can join to `parent.childTable` using `parent.childTable`'s primary key
     *
     * @todo Check that columns have compatible types; must be assigble from child to parent
     *       Example: child.type = "red"|"blue", parent.type = "red"|"blue"|"green"
     *
     * @todo Check that inheritance is not circular
     *       Example: `Animal` cannot be a child of `Animal`.
     *       Example: This is invalid: `Dog extends Animal extends Mammal extends Dog`
     */
    export function addParent<TptT extends ITablePerType, ParentT extends TableWithPrimaryKey | ITablePerType>(tpt: TptT, parent: ParentT): (AddParent<TptT, ParentT>);
}
declare module "design-pattern-table-per-type/util/operation/eq-super-key" {
    import * as tm from "type-mapping";
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { SuperKey } from "design-pattern-table-per-type/util/query/index";
    import { Expr } from "expr/index";
    import { UsedRefUtil } from "used-ref/index";
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.nullSafeEq(candidateKeyColumn0, value0),
     *      tsql.nullSafeEq(candidateKeyColumn1, value1),
     *      tsql.nullSafeEq(candidateKeyColumn2, value2),
     *      tsql.nullSafeEq(nonCandidateKeyColumn0, value3),
     *      tsql.nullSafeEq(nonCandidateKeyColumn1, value4),
     *      tsql.nullSafeEq(nonCandidateKeyColumn2, value5),
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Uses `nullSafeEq()` internally because the super key of a table
     * may have nullable columns.
     *
     * @param tpt - The `ITablePerType` with a candidate key
     * @param superKeyInput - The super key values to compare against
     *
     * @todo Maybe call it `nullSafeEqSuperKey()` instead?
     * It doesn't use `eq()` at all. It uses `nullSafeEq()`.
     *
     * @todo Maybe have it use `eq()` for columns we know are non-nullable
     * and use `nullSafeEq()` for columns that are nullable?
     */
    export type EqSuperKey = <TptT extends ITablePerType>(tpt: TptT, superKeyInput: SuperKey<TptT>) => (Expr<{
        mapper: tm.SafeMapper<boolean>;
        usedRef: UsedRefUtil.FromColumnMap<TptT["childTable"]["columns"] | TptT["parentTables"][number]["columns"]>;
        isAggregate: false;
    }>);
    export const eqSuperKey: EqSuperKey;
}
declare module "design-pattern-table-per-type/util/operation/index" {
    export * from "design-pattern-table-per-type/util/operation/add-parent";
    export * from "design-pattern-table-per-type/util/operation/eq-super-key";
    export * from "design-pattern-table-per-type/util/operation/remove-duplicate-parents";
}
declare module "design-pattern-table-per-type/util/execution/delete-one-by-super-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { SuperKey } from "design-pattern-table-per-type/util/query/index";
    export function deleteOneBySuperKey<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, superKey: SuperKey<TptT>): Promise<DeleteOneResult>;
}
declare module "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteZeroOrOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    export function deleteZeroOrOneByCandidateKey<TptT extends DeletableTablePerType, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TptT["childTable"]>>>(tpt: TptT, connection: IsolableDeleteConnection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey: CandidateKeyT): Promise<DeleteZeroOrOneResult>;
}
declare module "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteZeroOrOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { PrimaryKey_Input } from "primary-key/index";
    export function deleteZeroOrOneByPrimaryKey<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, primaryKey: PrimaryKey_Input<TptT["childTable"]>): Promise<DeleteZeroOrOneResult>;
}
declare module "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key" {
    import { DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableDeleteConnection } from "execution/index";
    import { DeleteZeroOrOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { SuperKey } from "design-pattern-table-per-type/util/query/index";
    export function deleteZeroOrOneBySuperKey<TptT extends DeletableTablePerType>(tpt: TptT, connection: IsolableDeleteConnection, superKey: SuperKey<TptT>): Promise<DeleteZeroOrOneResult>;
}
declare module "design-pattern-table-per-type/util/execution/fetch-one" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { SelectConnection } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { Row } from "design-pattern-table-per-type/util/query/index";
    import { FetchOnePromise } from "execution/util/index";
    import { From } from "design-pattern-table-per-type/util/execution-impl/index";
    /**
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    export function fetchOne<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, whereDelegate: WhereDelegate<From<TptT>["fromClause"]>): FetchOnePromise<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { SelectConnection } from "execution/index";
    import { FetchOnePromise } from "execution/util/index";
    import { Row } from "design-pattern-table-per-type/util/query/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion } from "type-util/index";
    export function fetchOneByCandidateKey<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, candidateKey: StrictUnion<CandidateKey_NonUnion<TptT["childTable"]>>): FetchOnePromise<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/execution/fetch-one-by-primary-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { SelectConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { FetchOnePromise } from "execution/util/index";
    import { Row } from "design-pattern-table-per-type/util/query/index";
    export function fetchOneByPrimaryKey<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, primaryKey: PrimaryKey_Input<TptT["childTable"]>): FetchOnePromise<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/execution/fetch-one-by-super-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { SelectConnection } from "execution/index";
    import { FetchOnePromise } from "execution/util/index";
    import { Row, SuperKey } from "design-pattern-table-per-type/util/query/index";
    export function fetchOneBySuperKey<TptT extends ITablePerType>(tpt: TptT, connection: SelectConnection, superKey: SuperKey<TptT>): FetchOnePromise<Row<TptT>>;
}
declare module "design-pattern-table-per-type/util/execution/insert-row" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { ColumnType, RequiredColumnAlias, OptionalColumnAlias, InsertableColumnAlias } from "design-pattern-table-per-type/util/query/index";
    import { Identity } from "type-util/index";
    import { CustomExpr_NonCorrelated_NonAggregate, CustomExpr_NonCorrelated_NonAggregateOrUndefined } from "custom-expr/index";
    import { BuiltInExpr_NonCorrelated_NonAggregate, BuiltInExpr_NonCorrelated_NonAggregateOrUndefined } from "built-in-expr/index";
    import { Key, KeyUtil } from "key/index";
    export type ValueInsertRow<TptT extends ITablePerType> = Identity<{
        readonly [columnAlias in RequiredColumnAlias<TptT>]: (ColumnType<TptT, columnAlias>);
    } & {
        readonly [columnAlias in OptionalColumnAlias<TptT>]?: (ColumnType<TptT, columnAlias>);
    }>;
    export type CustomInsertRow<TptT extends ITablePerType> = Identity<{
        readonly [columnAlias in RequiredColumnAlias<TptT>]: (
        /**
         * The following `INSERT` statement is invalid,
         * ```sql
         *  INSERT INTO myTable (myColumn) VALUES (SUM(1));
         * ```
         */
        CustomExpr_NonCorrelated_NonAggregate<ColumnType<TptT, columnAlias>>);
    } & {
        readonly [columnAlias in OptionalColumnAlias<TptT>]?: (CustomExpr_NonCorrelated_NonAggregateOrUndefined<ColumnType<TptT, columnAlias>>);
    }>;
    export type BuiltInInsertRow<TptT extends ITablePerType> = Identity<{
        readonly [columnAlias in RequiredColumnAlias<TptT>]: (BuiltInExpr_NonCorrelated_NonAggregate<ColumnType<TptT, columnAlias>>);
    } & {
        readonly [columnAlias in OptionalColumnAlias<TptT>]?: (BuiltInExpr_NonCorrelated_NonAggregateOrUndefined<ColumnType<TptT, columnAlias>>);
    }>;
    export type CustomInsertRowWithPrimaryKey_NonUnion<TptT extends ITablePerType, PrimaryKeyT extends Key> = Identity<{
        readonly [columnAlias in Exclude<RequiredColumnAlias<TptT>, PrimaryKeyT[number]>]: (CustomExpr_NonCorrelated_NonAggregate<ColumnType<TptT, columnAlias>>);
    } & {
        readonly [columnAlias in Exclude<OptionalColumnAlias<TptT>, PrimaryKeyT[number]>]?: (CustomExpr_NonCorrelated_NonAggregateOrUndefined<ColumnType<TptT, columnAlias>>);
    }
    /**
     * This primary key is required.
     */
     & {
        readonly [candidateKeyColumnAlias in PrimaryKeyT[number]]: (CustomExpr_NonCorrelated_NonAggregate<ColumnType<TptT, candidateKeyColumnAlias>>);
    }>;
    export type CustomInsertRowWithPrimaryKeyImpl<TptT extends ITablePerType, PrimaryKeyT extends Key> = PrimaryKeyT extends Key ? (KeyUtil.IsSubKey<PrimaryKeyT, InsertableColumnAlias<TptT>[]> extends true ? CustomInsertRowWithPrimaryKey_NonUnion<TptT, PrimaryKeyT> : never) : never;
    export type CustomInsertRowWithPrimaryKey<TptT extends ITablePerType> = CustomInsertRowWithPrimaryKeyImpl<TptT, TptT["insertAndFetchPrimaryKey"]>;
}
declare module "design-pattern-table-per-type/util/execution/insert-and-fetch" {
    import { InsertableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CustomInsertRowWithPrimaryKey } from "design-pattern-table-per-type/util/execution/insert-row";
    import { IsolableInsertOneConnection } from "execution/index";
    import { Identity, OnlyKnownProperties } from "type-util/index";
    import { ColumnAlias, ColumnType } from "design-pattern-table-per-type/util/query/index";
    import { CustomExprUtil } from "custom-expr/index";
    export type InsertAndFetchRow<TptT extends InsertableTablePerType> = CustomInsertRowWithPrimaryKey<TptT>;
    export type InsertedAndFetchedRow<TptT extends InsertableTablePerType, RowT extends InsertAndFetchRow<TptT>> = Identity<{
        readonly [columnAlias in ColumnAlias<TptT>]: (columnAlias extends keyof RowT ? (undefined extends RowT[columnAlias] ? ColumnType<TptT, columnAlias> : CustomExprUtil.TypeOf<RowT[columnAlias]>) : ColumnType<TptT, columnAlias>);
    }>;
    /**
     * Assumes there are no duplicate `parentTables`.
     *
     * `.addParent()` should remove duplicates.
     */
    export function insertAndFetch<TptT extends InsertableTablePerType, RowT extends InsertAndFetchRow<TptT>>(tpt: TptT, connection: IsolableInsertOneConnection, insertRow: OnlyKnownProperties<RowT, InsertAndFetchRow<TptT>>): (Promise<InsertedAndFetchedRow<TptT, RowT>>);
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion, Identity } from "type-util/index";
    import { IsolableUpdateConnection } from "execution/index";
    import { ColumnType, ColumnAlias } from "design-pattern-table-per-type/util/query/index";
    import { CustomExprUtil } from "custom-expr/index";
    import { UpdateAndFetchOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export type UpdatedAndFetchedRow<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>> = Identity<{
        readonly [columnAlias in ColumnAlias<TptT>]: (columnAlias extends keyof AssignmentMapT ? (undefined extends AssignmentMapT[columnAlias] ? ColumnType<TptT, columnAlias> : CustomExprUtil.TypeOf<AssignmentMapT[columnAlias]>) : ColumnType<TptT, columnAlias>);
    }>;
    export type UpdateAndFetchOneReturnType<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>> = Identity<UpdateAndFetchOneResult<UpdatedAndFetchedRow<TptT, AssignmentMapT>>>;
    export function updateAndFetchOneByCandidateKey<TptT extends ITablePerType, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TptT["childTable"]>>, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableUpdateConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { UpdateAndFetchOneReturnType } from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export function updateAndFetchOneByPrimaryKey<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<TptT["childTable"]>, assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableUpdateConnection } from "execution/index";
    import { UpdateAndFetchOneReturnType } from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key";
    import { SuperKey } from "design-pattern-table-per-type/util/query/index";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export function updateAndFetchOneBySuperKey<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, superKey: SuperKey<TptT>, assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { StrictUnion, Identity } from "type-util/index";
    import { IsolableUpdateConnection } from "execution/index";
    import { UpdatedAndFetchedRow } from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key";
    import { NotFoundUpdateAndFetchResult } from "execution/util/index";
    import { UpdateAndFetchOneResult } from "design-pattern-table-per-type/util/execution-impl/index";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export type UpdateAndFetchZeroOrOneReturnType<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>> = Identity<UpdateAndFetchOneResult<UpdatedAndFetchedRow<TptT, AssignmentMapT>> | NotFoundUpdateAndFetchResult>;
    export function updateAndFetchZeroOrOneByCandidateKey<TptT extends ITablePerType, CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<TptT["childTable"]>>, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableUpdateConnection } from "execution/index";
    import { PrimaryKey_Input } from "primary-key/index";
    import { UpdateAndFetchZeroOrOneReturnType } from "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export function updateAndFetchZeroOrOneByPrimaryKey<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<TptT["childTable"]>, assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key" {
    import { ITablePerType } from "design-pattern-table-per-type/table-per-type";
    import { IsolableUpdateConnection } from "execution/index";
    import { UpdateAndFetchZeroOrOneReturnType } from "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key";
    import { SuperKey } from "design-pattern-table-per-type/util/query/index";
    import { CustomAssignmentMap, AssignmentMapDelegate } from "design-pattern-table-per-type/util/execution/assignment-map";
    export function updateAndFetchZeroOrOneBySuperKey<TptT extends ITablePerType, AssignmentMapT extends CustomAssignmentMap<TptT>>(tpt: TptT, connection: IsolableUpdateConnection, superKey: SuperKey<TptT>, assignmentMapDelegate: AssignmentMapDelegate<TptT, AssignmentMapT>): Promise<UpdateAndFetchZeroOrOneReturnType<TptT, AssignmentMapT>>;
}
declare module "design-pattern-table-per-type/util/execution/index" {
    export * from "design-pattern-table-per-type/util/execution/assignment-map";
    export * from "design-pattern-table-per-type/util/execution/delete-one-by-candidate-key";
    export * from "design-pattern-table-per-type/util/execution/delete-one-by-primary-key";
    export * from "design-pattern-table-per-type/util/execution/delete-one-by-super-key";
    export * from "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key";
    export * from "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key";
    export * from "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key";
    export * from "design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key";
    export * from "design-pattern-table-per-type/util/execution/fetch-one-by-primary-key";
    export * from "design-pattern-table-per-type/util/execution/fetch-one-by-super-key";
    export * from "design-pattern-table-per-type/util/execution/fetch-one";
    export * from "design-pattern-table-per-type/util/execution/insert-and-fetch";
    export * from "design-pattern-table-per-type/util/execution/insert-row";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key";
    export * from "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key";
}
declare module "design-pattern-table-per-type/util/index" {
    export * from "design-pattern-table-per-type/util/constructor/index";
    export * from "design-pattern-table-per-type/util/execution/index";
    export * from "design-pattern-table-per-type/util/execution-impl/index";
    export * from "design-pattern-table-per-type/util/operation/index";
    export * from "design-pattern-table-per-type/util/query/index";
}
declare module "design-pattern-table-per-type/table-per-type-impl" {
    import { ITablePerType, TablePerTypeData, InsertableTablePerType, DeletableTablePerType } from "design-pattern-table-per-type/table-per-type";
    import * as TablePerTypeUtil from "design-pattern-table-per-type/util/index";
    import { TableWithPrimaryKey } from "table/index";
    import { SelectConnection, ExecutionUtil, IsolableInsertOneConnection, IsolableUpdateConnection, IsolableDeleteConnection } from "execution/index";
    import { WhereDelegate } from "where-clause/index";
    import { OnlyKnownProperties, StrictUnion } from "type-util/index";
    import { CandidateKey_NonUnion } from "candidate-key/index";
    import { PrimaryKey_Input } from "primary-key/index";
    export class TablePerType<DataT extends TablePerTypeData> implements ITablePerType<DataT> {
        readonly childTable: DataT["childTable"];
        readonly parentTables: DataT["parentTables"];
        readonly autoIncrement: DataT["autoIncrement"];
        readonly explicitAutoIncrementValueEnabled: DataT["explicitAutoIncrementValueEnabled"];
        readonly insertAndFetchPrimaryKey: DataT["insertAndFetchPrimaryKey"];
        readonly joins: ITablePerType["joins"];
        constructor(data: DataT, joins: ITablePerType["joins"]);
        addParent<ParentTableT extends TableWithPrimaryKey | ITablePerType>(parentTable: ParentTableT): (TablePerTypeUtil.AddParent<this, ParentTableT>);
        fetchOne(connection: SelectConnection, whereDelegate: WhereDelegate<TablePerTypeUtil.From<this>["fromClause"]>): ExecutionUtil.FetchOnePromise<TablePerTypeUtil.Row<this>>;
        fetchOneByCandidateKey(connection: SelectConnection, candidateKey: StrictUnion<CandidateKey_NonUnion<this["childTable"]>>): ExecutionUtil.FetchOnePromise<TablePerTypeUtil.Row<this>>;
        fetchOneByPrimaryKey(connection: SelectConnection, primaryKey: PrimaryKey_Input<this["childTable"]>): ExecutionUtil.FetchOnePromise<TablePerTypeUtil.Row<this>>;
        fetchOneBySuperKey(connection: SelectConnection, superKey: TablePerTypeUtil.SuperKey<this>): ExecutionUtil.FetchOnePromise<TablePerTypeUtil.Row<this>>;
        insertAndFetch<RowT extends TablePerTypeUtil.InsertAndFetchRow<Extract<this, InsertableTablePerType>>>(this: Extract<this, InsertableTablePerType>, connection: IsolableInsertOneConnection, row: OnlyKnownProperties<RowT, TablePerTypeUtil.InsertAndFetchRow<Extract<this, InsertableTablePerType>>>): (Promise<TablePerTypeUtil.InsertedAndFetchedRow<Extract<this, InsertableTablePerType>, RowT>>);
        updateAndFetchOneByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>, AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
        assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchOneReturnType<this, AssignmentMapT>>;
        updateAndFetchOneByPrimaryKey<AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<this["childTable"]>, assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchOneReturnType<this, AssignmentMapT>>;
        updateAndFetchOneBySuperKey<AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, superKey: TablePerTypeUtil.SuperKey<this>, assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchOneReturnType<this, AssignmentMapT>>;
        updateAndFetchZeroOrOneByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>, AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT, // & AssertNonUnion<CandidateKeyT>,
        assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchZeroOrOneReturnType<this, AssignmentMapT>>;
        updateAndFetchZeroOrOneByPrimaryKey<AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, primaryKey: PrimaryKey_Input<this["childTable"]>, assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchZeroOrOneReturnType<this, AssignmentMapT>>;
        updateAndFetchZeroOrOneBySuperKey<AssignmentMapT extends TablePerTypeUtil.CustomAssignmentMap<this>>(connection: IsolableUpdateConnection, superKey: TablePerTypeUtil.SuperKey<this>, assignmentMapDelegate: TablePerTypeUtil.AssignmentMapDelegate<this, AssignmentMapT>): Promise<TablePerTypeUtil.UpdateAndFetchZeroOrOneReturnType<this, AssignmentMapT>>;
        deleteOneByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>>(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT): Promise<TablePerTypeUtil.DeleteOneResult>;
        deleteOneByPrimaryKey(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, primaryKey: PrimaryKey_Input<Extract<this, DeletableTablePerType>["childTable"]>): Promise<TablePerTypeUtil.DeleteOneResult>;
        deleteOneBySuperKey(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, superKey: TablePerTypeUtil.SuperKey<Extract<this, DeletableTablePerType>>): Promise<TablePerTypeUtil.DeleteOneResult>;
        deleteZeroOrOneByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>>(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT): Promise<TablePerTypeUtil.DeleteZeroOrOneResult>;
        deleteZeroOrOneByPrimaryKey(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, primaryKey: PrimaryKey_Input<Extract<this, DeletableTablePerType>["childTable"]>): Promise<TablePerTypeUtil.DeleteZeroOrOneResult>;
        deleteZeroOrOneBySuperKey(this: Extract<this, DeletableTablePerType>, connection: IsolableDeleteConnection, superKey: TablePerTypeUtil.SuperKey<Extract<this, DeletableTablePerType>>): Promise<TablePerTypeUtil.DeleteZeroOrOneResult>;
        existsByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>>(connection: SelectConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT): Promise<boolean>;
        existsByPrimaryKey(connection: SelectConnection, primaryKey: PrimaryKey_Input<this["childTable"]>): Promise<boolean>;
        existsBySuperKey(connection: SelectConnection, superKey: TablePerTypeUtil.SuperKey<this>): Promise<boolean>;
        assertExistsByCandidateKey<CandidateKeyT extends StrictUnion<CandidateKey_NonUnion<this["childTable"]>>>(connection: SelectConnection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey: CandidateKeyT): Promise<void>;
        assertExistsByPrimaryKey(connection: SelectConnection, primaryKey: PrimaryKey_Input<this["childTable"]>): Promise<void>;
        assertExistsBySuperKey(connection: SelectConnection, superKey: TablePerTypeUtil.SuperKey<this>): Promise<void>;
    }
}
declare module "design-pattern-table-per-type/index" {
    export * from "design-pattern-table-per-type/table-per-type-impl";
    export * from "design-pattern-table-per-type/table-per-type";
    import * as TablePerTypeUtil from "design-pattern-table-per-type/util/index";
    export { TablePerTypeUtil, };
    export const tablePerType: typeof TablePerTypeUtil.tablePerType;
}
declare module "promise-util/invoke-async-callback-safely" {
    export function invokeAsyncCallbackSafely<T, U>(asyncCallback: () => PromiseLike<T>, thenCallback: (t: T) => U | PromiseLike<U>, catchCallback: (err: any) => U | PromiseLike<U>): Promise<U>;
}
declare module "promise-util/index" {
    export * from "promise-util/invoke-async-callback-safely";
}
declare module "async-queue" {
    export class AsyncQueueStoppingError extends Error {
        constructor(message: string);
    }
    export type AllocateDelegate<ItemT> = () => {
        item: ItemT;
        deallocate: () => Promise<void>;
    };
    /**
     * Only one `ItemT` can be allocated at a time.
     * Only one enqueued callback can be running at a time.
     *
     * This can be used to implement `IConnection.lock()`
     */
    export class AsyncQueue<ItemT> {
        private readonly allocateDelegate;
        constructor(allocateDelegate: AllocateDelegate<ItemT>);
        private shouldStop;
        private lastPromise;
        private deallocateErr;
        /**
         * Enqueues a callback that will be run asynchronously.
         *
         * Only one callback will be running at any given time.
         */
        enqueue: <ResultT>(callback: (item: ItemT) => Promise<ResultT>) => Promise<ResultT>;
        /**
         * This makes all future calls to `.enqueue()` throw a run-time error.
         *
         * Returns a promise that resolves when the last enqueued
         * callback resolves.
         */
        stop: () => Promise<void>;
        getShouldStop(): boolean;
        /**
         * Enqueues a callback that will be run asynchronously.
         * This callback will be given another `AsyncQueue` instance.
         *
         * This `AsyncQueue` will wait for the other instance to
         * complete before continuing.
         *
         * Only one callback will be running at any given time.
         */
        lock: <ResultT>(callback: (nestedAsyncQueue: AsyncQueue<ItemT>) => Promise<ResultT>) => Promise<ResultT>;
    }
}
declare module "string-util/zero-pad" {
    export function zeroPad(num: number, length: number): string;
    export function trailingZeroPad(num: number | string, length: number): string;
}
declare module "string-util/index" {
    export * from "string-util/zero-pad";
}
declare module "date-time-util/util" {
    export function toSqlUtc(d: Date, fractionalSecondPrecision: 0 | 1 | 2 | 3): string;
    export function fromSqlUtc(sql: string, fractionalSecondPrecision: 0 | 1 | 2 | 3): Date;
}
declare module "date-time-util/index" {
    export * from "date-time-util/util";
}
declare module "index" {
    export * from "aliased-expr/index";
    export * from "aliased-table/index";
    export * from "ast/index";
    export * from "built-in-expr/index";
    export * from "built-in-value-expr/index";
    export * from "candidate-key/index";
    export * from "column/index";
    export * from "column-identifier/index";
    export * from "column-identifier-map/index";
    export * from "column-identifier-ref/index";
    export * from "column-map/index";
    export * from "column-ref/index";
    export * from "comparable-type/index";
    export * from "compile-error/index";
    export * from "compound-query/index";
    export * from "compound-query-clause/index";
    export * from "compound-query-order-by-clause/index";
    export * from "custom-expr/index";
    export * from "data-type/index";
    export * from "decimal/index";
    export * from "derived-table/index";
    export * from "derived-table-select-item/index";
    export * from "design-pattern-log/index";
    export * from "design-pattern-table-per-type/index";
    export * from "event/index";
    export * from "execution/index";
    export * from "expr/index";
    export * from "expr-column/index";
    export * from "expr-library/index";
    export * from "expr-select-item/index";
    export * from "from-clause/index";
    export * from "group-by-clause/index";
    export * from "having-clause/index";
    export * from "insert/index";
    export * from "insert-select/index";
    export * from "join/index";
    export * from "join-map/index";
    export * from "key/index";
    export * from "limit-clause/index";
    export * from "map-delegate/index";
    export * from "mapper-map/index";
    export * from "on-clause/index";
    export * from "order/index";
    export * from "order-by-clause/index";
    export * from "partial-row/index";
    export * from "primary-key/index";
    export * from "query-base/index";
    export * from "row/index";
    export * from "schema-introspection/index";
    export * from "schema-validation/index";
    export * from "select-clause/index";
    export * from "select-item/index";
    export * from "sort-direction/index";
    export * from "super-key/index";
    export * from "sqlstring/index";
    export * from "table/index";
    export * from "table-where/index";
    export * from "type-map/index";
    export * from "type-ref/index";
    export * from "unified-query/index";
    export * from "update/index";
    export * from "used-ref/index";
    export * from "value-expr/index";
    export * from "where-clause/index";
    export * from "async-queue";
    export * from "constants";
    export * from "error/index";
    export * from "isolation-level";
    export * from "operator-type";
    export * from "transaction-access-mode";
    export * from "type-hint";
    import * as DateTimeUtil from "date-time-util/index";
    import * as FormatUtil from "formatter/index";
    import * as PromiseUtil from "promise-util/index";
    import * as TupleUtil from "tuple-util/index";
    import * as TypeUtil from "type-util/index";
    export { DateTimeUtil, FormatUtil, PromiseUtil, TupleUtil, TypeUtil, };
    /**
     * Augmentable types **MUST** be exported in this specific way.
     *
     * https://github.com/microsoft/TypeScript/issues/18877#issuecomment-476921038
     */
    export { CustomDecimalCastableTypeMap, CustomComparableTypeMap, } from "augmentable";
}
//# sourceMappingURL=index.d.ts.map