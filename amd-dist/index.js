"use strict";
define("built-in-value-expr/built-in-value-expr", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("date-util/is-date", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDate(x) {
        return Object.prototype.toString.call(x) === "[object Date]";
    }
    exports.isDate = isDate;
});
define("date-util/index", ["require", "exports", "date-util/is-date"], function (require, exports, is_date_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_date_1);
});
define("built-in-value-expr/util/predicate/is-built-in-value-expr", ["require", "exports", "type-mapping", "date-util/index"], function (require, exports, tm, date_util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBuiltInValueExpr(raw) {
        if (tm.TypeUtil.isBigInt(raw)) {
            return true;
        }
        switch (typeof raw) {
            case "number":
            case "string":
            case "boolean": {
                return true;
            }
        }
        if (date_util_1.isDate(raw)) {
            return true;
        }
        if (raw instanceof Uint8Array) {
            return true;
        }
        if (raw === null) {
            return true;
        }
        return false;
    }
    exports.isBuiltInValueExpr = isBuiltInValueExpr;
});
define("built-in-value-expr/util/predicate/is-non-null-built-in-value-expr", ["require", "exports", "built-in-value-expr/util/predicate/is-built-in-value-expr"], function (require, exports, is_built_in_value_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNonNullBuiltInValueExpr(raw) {
        if (raw === null) {
            return false;
        }
        return is_built_in_value_expr_1.isBuiltInValueExpr(raw);
    }
    exports.isNonNullBuiltInValueExpr = isNonNullBuiltInValueExpr;
});
define("built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array", ["require", "exports", "built-in-value-expr/util/predicate/is-non-null-built-in-value-expr"], function (require, exports, is_non_null_built_in_value_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNonNullBuiltInValueExprArray(raw) {
        if (!Array.isArray(raw)) {
            return false;
        }
        for (const item of raw) {
            if (!is_non_null_built_in_value_expr_1.isNonNullBuiltInValueExpr(item)) {
                return false;
            }
        }
        return true;
    }
    exports.isNonNullBuiltInValueExprArray = isNonNullBuiltInValueExprArray;
});
define("built-in-value-expr/array-util/predicate/is-built-in-value-expr-array", ["require", "exports", "built-in-value-expr/util/predicate/is-built-in-value-expr"], function (require, exports, is_built_in_value_expr_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBuiltInValueExprArray(raw) {
        if (!Array.isArray(raw)) {
            return false;
        }
        for (const item of raw) {
            if (!is_built_in_value_expr_2.isBuiltInValueExpr(item)) {
                return false;
            }
        }
        return true;
    }
    exports.isBuiltInValueExprArray = isBuiltInValueExprArray;
});
define("built-in-value-expr/array-util/predicate/index", ["require", "exports", "built-in-value-expr/array-util/predicate/is-non-null-built-in-value-expr-array", "built-in-value-expr/array-util/predicate/is-built-in-value-expr-array"], function (require, exports, is_non_null_built_in_value_expr_array_1, is_built_in_value_expr_array_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_non_null_built_in_value_expr_array_1);
    __export(is_built_in_value_expr_array_1);
});
define("built-in-value-expr/array-util/index", ["require", "exports", "built-in-value-expr/array-util/predicate/index"], function (require, exports, predicate_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_1);
});
define("compile-error/compile-error", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("compile-error/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/assert-non-never", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/assert-same-own-enumerable-keys", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertSameOwnEnumerableKeys(a, b) {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        const extraKeys = aKeys.filter(k => !bKeys.includes(k));
        const missingKeys = bKeys.filter(k => !aKeys.includes(k));
        if (extraKeys.length > 0) {
            if (missingKeys.length > 0) {
                throw new Error(`Extra keys found: ${extraKeys.join(",")}; Missing keys found: ${missingKeys.join(",")}`);
            }
            else {
                throw new Error(`Extra keys found: ${extraKeys.join(",")}`);
            }
        }
        else {
            if (missingKeys.length > 0) {
                throw new Error(`Missing keys found: ${missingKeys.join(",")}`);
            }
            else {
                //Do nothing
            }
        }
    }
    exports.assertSameOwnEnumerableKeys = assertSameOwnEnumerableKeys;
});
define("type-util/assert-subset-own-enumerable-keys", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/base-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/better-return-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/identity", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/is-strict-same-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/is-null-safe-comparable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/is-comparable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/is-object-with-own-enumerable-keys", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObjectWithOwnEnumerableKeys() {
        return (raw, keys) => {
            if (raw == undefined) {
                return false;
            }
            if (!(raw instanceof Object)) {
                return false;
            }
            for (const k of keys) {
                if (!Object.prototype.hasOwnProperty.call(raw, k)) {
                    return false;
                }
                if (!Object.prototype.propertyIsEnumerable.call(raw, k)) {
                    return false;
                }
            }
            return true;
        };
    }
    exports.isObjectWithOwnEnumerableKeys = isObjectWithOwnEnumerableKeys;
});
define("type-util/union-to-intersection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/is-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/merge", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/no-infer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/non-optional-partial", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/omit-own-enumerable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function omitOwnEnumerable(obj, keys) {
        const result = {};
        for (const k of Object.keys(obj)) {
            if (Object.prototype.propertyIsEnumerable.call(obj, k) &&
                keys.indexOf(k) < 0) {
                result[k] = obj[k];
            }
        }
        return result;
    }
    exports.omitOwnEnumerable = omitOwnEnumerable;
});
define("type-util/only-known-properties", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/outersect", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/pick-multi", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/pick-own-enumerable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function pickOwnEnumerable(obj, keys) {
        const result = {};
        for (const k of keys) {
            if (Object.prototype.hasOwnProperty.call(obj, k) &&
                Object.prototype.propertyIsEnumerable.call(obj, k)) {
                result[k] = obj[k];
            }
        }
        return result;
    }
    exports.pickOwnEnumerable = pickOwnEnumerable;
});
define("type-util/replace-property", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/replace", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/strict-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/to-promise", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/to-unknown-if-all-properties-never", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/type-of-await", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/writable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/index", ["require", "exports", "type-util/assert-same-own-enumerable-keys", "type-util/is-object-with-own-enumerable-keys", "type-util/omit-own-enumerable", "type-util/pick-own-enumerable"], function (require, exports, assert_same_own_enumerable_keys_1, is_object_with_own_enumerable_keys_1, omit_own_enumerable_1, pick_own_enumerable_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_same_own_enumerable_keys_1);
    __export(is_object_with_own_enumerable_keys_1);
    __export(omit_own_enumerable_1);
    __export(pick_own_enumerable_1);
});
define("built-in-value-expr/util/operation/case-insensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-value-expr/util/operation/case-sensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-value-expr/util/operation/null-safe-case-insensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-value-expr/util/operation/null-safe-case-sensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-value-expr/util/operation/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-value-expr/util/predicate/is-equal", ["require", "exports", "type-mapping", "date-util/index"], function (require, exports, tm, date_util_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (date_util_2.isDate(a)) {
            if (date_util_2.isDate(b)) {
                if (isNaN(a.getTime()) && isNaN(b.getTime())) {
                    return true;
                }
                return a.getTime() === b.getTime();
            }
            else {
                return false;
            }
        }
        if (a instanceof Uint8Array) {
            if (b instanceof Uint8Array) {
                return tm.ArrayBufferUtil.equals(a, b);
            }
            else {
                return false;
            }
        }
        /**
         * Use `strictEqual()` algorithm that handles `bigint` polyfill
         */
        return tm.TypeUtil.strictEqual(a, b);
    }
    exports.isEqual = isEqual;
});
define("built-in-value-expr/util/predicate/index", ["require", "exports", "built-in-value-expr/util/predicate/is-equal", "built-in-value-expr/util/predicate/is-non-null-built-in-value-expr", "built-in-value-expr/util/predicate/is-built-in-value-expr"], function (require, exports, is_equal_1, is_non_null_built_in_value_expr_2, is_built_in_value_expr_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_equal_1);
    __export(is_non_null_built_in_value_expr_2);
    __export(is_built_in_value_expr_3);
});
define("built-in-value-expr/util/index", ["require", "exports", "built-in-value-expr/util/predicate/index"], function (require, exports, predicate_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_2);
});
define("built-in-value-expr/index", ["require", "exports", "built-in-value-expr/array-util/index", "built-in-value-expr/util/index"], function (require, exports, BuiltInValueExprArrayUtil, BuiltInValueExprUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BuiltInValueExprArrayUtil = BuiltInValueExprArrayUtil;
    exports.BuiltInValueExprUtil = BuiltInValueExprUtil;
});
define("ast/util/insert-between", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function insertBetween(operands, insertElement) {
        const result = [];
        for (const operand of operands) {
            if (result.length > 0) {
                result.push(insertElement);
            }
            result.push(operand);
        }
        return result;
    }
    exports.insertBetween = insertBetween;
});
define("ast/operator-node/operand", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("operator-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * It's called `OperatorType` but also contains function names.
     * A function is just an operator with different syntax.
     *
     * -----
     *
     * **EVERY** new `OperatorType` added is a **BREAKING CHANGE**.
     * Make sure to bump the **MAJOR** version number.
     */
    var OperatorType;
    (function (OperatorType) {
        /*
            Comparison Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `BETWEEN ... AND ...`
         * + PostgreSQL   : `BETWEEN ... AND ...`
         * + SQLite       : `BETWEEN ... AND ...`
         */
        OperatorType["BETWEEN_AND"] = "BETWEEN_AND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
         * + https://www.postgresql.org/docs/9.5/functions-conditional.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `COALESCE(x, ...)`
         * + PostgreSQL   : `COALESCE(x, ...)`
         * + SQLite       : `COALESCE(x, ...)`
         */
        OperatorType["COALESCE"] = "COALESCE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `=`
         * + PostgreSQL   : `=`
         * + SQLite       : `=`
         */
        OperatorType["EQUAL"] = "EQUAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<=>`
         * + PostgreSQL   : `IS NOT DISTINCT FROM`
         * + SQLite       : `IS`
         */
        OperatorType["NULL_SAFE_EQUAL"] = "NULL_SAFE_EQUAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `>`
         * + PostgreSQL   : `>`
         * + SQLite       : `>`
         */
        OperatorType["GREATER_THAN"] = "GREATER_THAN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `>=`
         * + PostgreSQL   : `>=`
         * + SQLite       : `>=`
         */
        OperatorType["GREATER_THAN_OR_EQUAL"] = "GREATER_THAN_OR_EQUAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
         * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
         *
         * -----
         *
         * + MySQL        : `GREATEST(x, y, ...)` //Requires 2 args
         *   + `NULL` values cause return value of `NULL`
         * + PostgreSQL   : `GREATEST(x, ...)`    //Requires 1 arg
         *   + Ignores `NULL` values
         * + SQLite       : `MAX(x, ...)`         //Requires 1 arg
         *   + `NULL` values cause return value of `NULL`
         */
        OperatorType["GREATEST"] = "GREATEST";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `IN`
         * + PostgreSQL   : `IN`
         * + SQLite       : `IN`
         */
        OperatorType["IN_ARRAY"] = "IN_ARRAY";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16806
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `IN`
         * + PostgreSQL   : `IN`
         * + SQLite       : `IN`
         */
        OperatorType["IN_QUERY"] = "IN_QUERY";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_interval
         */
        //INTERVAL = "INTERVAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS TRUE`
         * + PostgreSQL   : `IS TRUE`
         * + SQLite       : `<NULL_SAFE_EQUAL> TRUE`
         */
        OperatorType["IS_TRUE"] = "IS_TRUE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS FALSE`
         * + PostgreSQL   : `IS FALSE`
         * + SQLite       : `<NULL_SAFE_EQUAL> FALSE`
         */
        OperatorType["IS_FALSE"] = "IS_FALSE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * This does not refer to the TypeScript `unknown`.
         * It refers to the three-valued logic `unknown`.
         *
         * It generally has a value equivalent to `NULL`.
         *
         * -----
         *
         * + MySQL        : `IS UNKNOWN`
         * + PostgreSQL   : `IS UNKNOWN`
         * + SQLite       : `<NULL_SAFE_EQUAL> UNKNOWN`
         */
        OperatorType["IS_UNKNOWN"] = "IS_UNKNOWN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT TRUE`
         * + PostgreSQL   : `IS NOT TRUE`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> TRUE`
         */
        OperatorType["IS_NOT_TRUE"] = "IS_NOT_TRUE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT FALSE`
         * + PostgreSQL   : `IS NOT FALSE`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> FALSE`
         */
        OperatorType["IS_NOT_FALSE"] = "IS_NOT_FALSE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * This does not refer to the TypeScript `unknown`.
         * It refers to the three-valued logic `unknown`.
         *
         * It generally has a value equivalent to `NULL`.
         *
         * -----
         *
         * + MySQL        : `IS NOT UNKNOWN`
         * + PostgreSQL   : `IS NOT UNKNOWN`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> UNKNOWN`
         */
        OperatorType["IS_NOT_UNKNOWN"] = "IS_NOT_UNKNOWN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NOT NULL`
         * + PostgreSQL   : `IS NOT NULL`
         * + SQLite       : `<NOT_NULL_SAFE_EQUAL> NULL`
         */
        OperatorType["IS_NOT_NULL"] = "IS_NOT_NULL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
         * + https://www.postgresql.org/docs/9.0/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `IS NULL`
         * + PostgreSQL   : `IS NULL`
         * + SQLite       : `<NULL_SAFE_EQUAL> NULL`
         */
        OperatorType["IS_NULL"] = "IS_NULL";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_isnull
         */
        //ISNULL = "ISNULL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15322
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL        : `LEAST(x, y, ...)` //Requires 2 args
         * + PostgreSQL   : `LEAST(x, ...)`    //Requires 1 arg
         * + SQLite       : `MIN(x, ...)`         //Requires 1 arg
         */
        OperatorType["LEAST"] = "LEAST";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<`
         * + PostgreSQL   : `<`
         * + SQLite       : `<`
         */
        OperatorType["LESS_THAN"] = "LESS_THAN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<=`
         * + PostgreSQL   : `<=`
         * + SQLite       : `<=`
         */
        OperatorType["LESS_THAN_OR_EQUAL"] = "LESS_THAN_OR_EQUAL";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `LIKE`
         * + PostgreSQL   : `LIKE`
         * + SQLite       : `LIKE`
         */
        /*
         * The `LIKE` operator has different default escape behaviours across databases.
         * By default, SQLite does not have an escape character.
         * By default, MySQL's is the backslash.
         */
        //LIKE = "LIKE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `LIKE ... ESCAPE ...`
         * + PostgreSQL   : `LIKE ... ESCAPE ...`
         * + SQLite       : `LIKE ... ESCAPE ...`
         */
        OperatorType["LIKE_ESCAPE"] = "LIKE_ESCAPE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#between
         *
         * -----
         *
         * + MySQL        : `NOT BETWEEN ... AND ...`
         * + PostgreSQL   : `NOT BETWEEN ... AND ...`
         * + SQLite       : `NOT BETWEEN ... AND ...`
         */
        OperatorType["NOT_BETWEEN_AND"] = "NOT_BETWEEN_AND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `<>`
         * + PostgreSQL   : `<>`
         * + SQLite       : `<>`
         */
        OperatorType["NOT_EQUAL"] = "NOT_EQUAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
         * + https://www.postgresql.org/docs/9.1/functions-comparison.html
         * + https://www.sqlite.org/lang_expr.html#isisnot
         *
         * -----
         *
         * + MySQL        : `<NOT> (x <NULL_SAFE_EQUAL>)`
         * + PostgreSQL   : `IS DISTINCT FROM`
         * + SQLite       : `IS NOT`
         */
        OperatorType["NOT_NULL_SAFE_EQUAL"] = "NOT_NULL_SAFE_EQUAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `NOT IN`
         * + PostgreSQL   : `NOT IN`
         * + SQLite       : `NOT IN`
         */
        OperatorType["NOT_IN_ARRAY"] = "NOT_IN_ARRAY";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-in
         * + https://www.postgresql.org/docs/9.0/functions-subquery.html#AEN16831
         * + https://www.sqlite.org/lang_expr.html#in_op
         *
         * -----
         *
         * + MySQL        : `NOT IN`
         * + PostgreSQL   : `NOT IN`
         * + SQLite       : `NOT IN`
         */
        OperatorType["NOT_IN_QUERY"] = "NOT_IN_QUERY";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `NOT LIKE`
         * + PostgreSQL   : `NOT LIKE`
         * + SQLite       : `NOT LIKE`
         */
        /*
         * The `LIKE` operator has different default escape behaviours across databases.
         * By default, SQLite does not have an escape character.
         * By default, MySQL's is the backslash.
         */
        //NOT_LIKE = "NOT_LIKE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_not-like
         * + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-LIKE
         * + https://www.sqlite.org/lang_expr.html#like
         *
         * -----
         *
         * + MySQL        : `NOT LIKE ... ESCAPE ...`
         * + PostgreSQL   : `NOT LIKE ... ESCAPE ...`
         * + SQLite       : `NOT LIKE ... ESCAPE ...`
         */
        OperatorType["NOT_LIKE_ESCAPE"] = "NOT_LIKE_ESCAPE";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#function_strcmp
         */
        //STRCMP = "STRCMP",
        /*
            Logical Operators
            https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `AND`
         * + PostgreSQL   : `AND`
         * + SQLite       : `AND`
         */
        OperatorType["AND"] = "AND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `NOT`
         * + PostgreSQL   : `NOT`
         * + SQLite       : `NOT`
         */
        OperatorType["NOT"] = "NOT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
         * + https://www.postgresql.org/docs/9.1/functions-logical.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `OR`
         * + PostgreSQL   : `OR`
         * + SQLite       : `OR`
         */
        OperatorType["OR"] = "OR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
         *
         * -----
         *
         * + MySQL        : `XOR`
         * + PostgreSQL   : `<NOT_EQUAL>`
         * + SQLite       : `<NOT_EQUAL>`
         */
        OperatorType["XOR"] = "XOR";
        /*
            Control Flow Functions
            https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
         * + https://www.sqlite.org/lang_expr.html#case
         *
         * -----
         *
         * + MySQL        : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         * + PostgreSQL   : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         * + SQLite       : `CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] ELSE result END`
         */
        /**
         * This is handled using `CaseValueNode`
         */
        //CASE = "CASE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#operator_case
         * + https://www.postgresql.org/docs/8.4/functions-conditional.html#AEN15225
         * + https://www.sqlite.org/lang_expr.html#case
         *
         * -----
         *
         * + MySQL        : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         * + PostgreSQL   : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         * + SQLite       : `CASE WHEN condition THEN result [WHEN condition THEN result ...] ELSE result END`
         */
        /**
         * This is handled using `CaseConditionNode`
         */
        //CASE_WHEN = "CASE_WHEN",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
         *
         * -----
         *
         * + MySQL        : `IF(x, y, z)`
         * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
         * + SQLite       : `CASE WHEN x THEN y ELSE z END`
         */
        OperatorType["IF"] = "IF";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
         * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
         * + https://www.sqlite.org/lang_corefunc.html#ifnull
         *
         * `COALESCE()` is part of the SQL standard.
         * `IFNULL()` is DB-specific.
         *
         * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
         *
         * -----
         *
         * + MySQL        : `IFNULL(x, y)`
         * + PostgreSQL   : `COALESCE(x, y)`
         * + SQLite       : `IFNULL(x, y)`
         */
        OperatorType["IF_NULL"] = "IF_NULL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
         * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
         * + https://www.sqlite.org/lang_corefunc.html#nullif
         *
         * -----
         *
         * + MySQL        : `NULLIF(x, y)`
         * + PostgreSQL   : `NULLIF(x, y)`
         * + SQLite       : `NULLIF(x, y)`
         *
         * -----
         *
         * This is the same as `CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END`
         */
        OperatorType["NULL_IF_EQUAL"] = "NULL_IF_EQUAL";
        /*
            String Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `ASCII(x)`
         * + PostgreSQL     : `ASCII(x)`
         * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
         */
        OperatorType["ASCII"] = "ASCII";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
         *
         * -----
         *
         * + MySQL          : `BIN(x)`
         * + PostgreSQL     : None. Implement with,
         * ```sql
         *  REGEXP_REPLACE(
         *      (x)::bit(64)::varchar(64),
         *      '^0+(\d+)$',
         *      '\1'
         *  )
         * ```
         * + SQLite         : None. Implement with,
         * ```ts
         * //x >= 0
         * (x).toString(2)
         * //x < 0
         * (2n**64n + BigInt(x)).toString(2)
         * ```
         */
        OperatorType["BIN"] = "BIN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `BIT_LENGTH(x)`
         * + PostgreSQL     : `BIT_LENGTH(x)`
         * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
         */
        OperatorType["BIT_LENGTH"] = "BIT_LENGTH";
        /*
         * Appears to be MySQL and SQLite-specific,
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char
         * + https://www.sqlite.org/lang_corefunc.html#char
         *
         * They have different implementations, however.
         */
        //CHAR = "CHAR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#length
         * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
         *
         * -----
         *
         * + MySQL          : `CHAR_LENGTH(x)`
         *   + `CHAR_LENGTH('cafȩ́')` returns 6
         * + PostgreSQL     : `CHAR_LENGTH(x)`
         *   + `CHAR_LENGTH('cafȩ́')` returns 8
         * + SQLite         : `LENGTH(x)`
         *   + `LENGTH('cafȩ́')` returns 6
         */
        OperatorType["CHAR_LENGTH"] = "CHAR_LENGTH";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
         *   + MySQL actually treats `||` as the boolean `OR` operator.
         * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
         *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
         *     + This is different from MySQL's `CONCAT()`
         * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
         *   + SQLite uses an operator, not a function, to concatenate strings
         *   + https://www.sqlite.org/lang_expr.html#collateop
         *
         * -----
         *
         * The SQL standard says,
         * > `<concatenation operator>` is an operator, `||`,
         * > that returns the character string made by joining its character string operands in the order given.
         *
         * MySQL actually treats `||` as the boolean `OR` operator.
         */
        OperatorType["CONCAT"] = "CONCAT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
         * + PostgreSQL     : `CONCAT(x, ...)`
         *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
         *     + This is different from MySQL's `CONCAT()`
         * + SQLite         : `COALESCE(x, '') || ... || ...`
         *
         * -----
         *
         * The SQL standard says,
         * > `<concatenation operator>` is an operator, `||`,
         * > that returns the character string made by joining its character string operands in the order given.
         *
         * MySQL actually treats `||` as the boolean `OR` operator.
         */
        OperatorType["NULL_SAFE_CONCAT"] = "NULL_SAFE_CONCAT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `CONCAT_WS(separator, x, ...)`
         *   + If the separator is `NULL`, the result is `NULL`
         *   + Ignores `NULL` arguments after the separator
         * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
         *   + If the separator is `NULL`, the result is `NULL`
         *   + Ignores `NULL` arguments after the separator
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["CONCAT_WS"] = "CONCAT_WS";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_elt
         */
        //ELT = "ELT",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_export-set
         */
        //EXPORT_SET = "EXPORT_SET",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_field
         */
        //FIELD = "FIELD",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_find-in-set
         *
         * ```sql
         * FIND_IN_SET(str, strlist)
         * ```
         *
         * There is a way to emulate it with PostgreSQL,
         * https://stackoverflow.com/questions/35169412/mysql-find-in-set-equivalent-to-postgresql
         *
         * ```sql
         *  array_position(
         *      string_to_array(strlist, ','),
         *      str
         *  )
         * ```
         *
         * @todo Decide if we should add this
         */
        //FIND_IN_SET = "FIND_IN_SET",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `FROM_BASE64(x)`
         *   + `FROM_BASE64('~')` === `NULL`
         * + PostgreSQL     : `DECODE(x, 'base64')`
         *   + `DECODE('~', 'base64')` throws an error
         * + SQLite         : None, implement with user-defined function `atob()`
         *   + `atob('~')` throws an error
         */
        OperatorType["FROM_BASE64"] = "FROM_BASE64";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#hex
         *
         * -----
         *
         * + MySQL          : `HEX(x)`
         * + PostgreSQL     : `ENCODE(x, 'hex')`
         * + SQLite         : `HEX(x)`
         */
        OperatorType["HEX"] = "HEX";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_insert
         */
        //INSERT = "INSERT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
         * + https://www.sqlite.org/lang_corefunc.html#instr
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `INSTR(str, substr)`
         * + PostgreSQL     : `STRPOS(str, substr)`
         * + SQLite         : `INSTR(str, substr)`
         */
        OperatorType["IN_STR"] = "IN_STR";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_left
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
         */
        //LEFT = "LEFT",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#length
         *
         * -----
         *
         * + MySQL          : `LENGTH(x)`
         * + PostgreSQL     : `LENGTH(x)`
         * + SQLite         : None. The `LENGTH(x)` implementation is incompatible.
         *
         * -----
         *
         * ```sql
         *  SELECT
         *      -- '\u00c7'
         *      LENGTH('Ç') AS one_length,
         *      CHAR_LENGTH('Ç') AS one_char_length,
         *      -- '\u0043\u0327'
         *      LENGTH('Ç') AS two_length,
         *      CHAR_LENGTH('Ç') AS two_char_length
         * ```
         *
         * MySQL        : `2,1,3,2`
         * PostgreSQL   : `2,2,3,3`
         * SQLite       : `1,X,2,X` (`X` because SQLite does not have `CHAR_LENGTH()`)
         *
         * |                            | MySQL `LENGTH()` | MySQL `CHAR_LENGTH()` | PostgreSQL `LENGTH()` | PostgreSQL `CHAR_LENGTH()` | SQLite `LENGTH()` |
         * |----------------------------|------------------|-----------------------|-----------------------|----------------------------|-------------------|
         * | MySQL      `LENGTH()`      | X                |                       | X                     | X                          |                   |
         * | MySQL      `CHAR_LENGTH()` |                  | X                     |                       |                            | X                 |
         * | PostgreSQL `LENGTH()`      | X                |                       | X                     | X                          |                   |
         * | PostgreSQL `CHAR_LENGTH()` | X                |                       | X                     | X                          |                   |
         * | SQLite     `LENGTH()`      |                  | X                     |                       |                            | X                 |
         *
         * https://news.ycombinator.com/item?id=17311196
         *
         * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/3
         * + https://www.db-fiddle.com/f/aaKrWx7aAuzzC2HWPcrsBn/4
         *
         * -----
         *
         * TL;DR,
         * We cannot provide `LENGTH` as a DB-unified operator because of the inconsistencies
         *
         * -----
         *
         * See, `OCTET_LENGTH` instead.
         * All three databases can be made to agree on the behaviour of `OCTET_LENGTH`
         */
        //LENGTH = "LENGTH",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file
         */
        //LOAD_FILE = "LOAD_FILE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_locate
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `LOCATE(substr, str)/LOCATE(substr, str, pos)`
         * + PostgreSQL     : `STRPOS(str, substr)`, the 3-arg version is more complicated.
         *
         *   Tentatively, `STRPOS(SUBSTR(str, pos), substr) + pos` or something like that.
         *
         * + SQLite         : None. Implement with user-defined function.
         * @todo
         */
        //LOCATE = "LOCATE",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#lower
         *
         * -----
         *
         * + MySQL          : `LOWER(x)`
         * + PostgreSQL     : `LOWER(x)`
         * + SQLite         : `LOWER(x)`
         */
        OperatorType["LOWER"] = "LOWER";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `LPAD(str, len, padstr)`
         *   + `LPAD('123', 4, '98')` === `'9123'`
         *   + `LPAD('123', 2, '98')` === `'12'`
         * + PostgreSQL     : `LPAD(str, len, padstr)`
         *   + `LPAD('123', 4, '98')` === `'9123'`
         *   + `LPAD('123', 2, '98')` === `'12'`
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["LPAD"] = "LPAD";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#ltrim
         *
         * -----
         *
         * + MySQL          : `LTRIM(x)`
         * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
         * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
         */
        OperatorType["LTRIM"] = "LTRIM";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_make-set
         */
        //MAKE_SET = "MAKE_SET",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_oct
         */
        //OCT = "OCT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `OCTET_LENGTH(x)`
         * + PostgreSQL     : `OCTET_LENGTH(x)`
         * + SQLite         : `LENGTH(CAST(x AS BLOB))`
         */
        OperatorType["OCTET_LENGTH"] = "OCTET_LENGTH";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ord
         */
        //ORD = "ORD",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         *
         * -----
         *
         * + MySQL          : `POSITION(substr IN str)`
         * + PostgreSQL     : `POSITION(substr IN str)`
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["POSITION"] = "POSITION";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_quote
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#quote
         *
         * -----
         *
         * + MySQL          : `QUOTE(x)`
         * + PostgreSQL     : `QUOTE_NULLABLE(x)`
         * + SQLite         : `QUOTE(x)`
         *
         * SQLite seems to not return just strings...
         * SQLite can return string|Uint8Array|number|bigint|...
         * So, we can't unify this.
         */
        //QUOTE = "QUOTE",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
         *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp
         *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#function_regexp-like
         *   + https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax
         *   + http://userguide.icu-project.org/strings/regexp
         * + `~`/`~*`/`!~`/`!~*`
         *   + https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-POSIX-REGEXP
         * + TODO: Find out difference between POSIX regex and ICU regex
         */
        //REGEXP = "REGEXP",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `REPEAT(x, count)`
         * + PostgreSQL     : `REPEAT(x, count)`
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["REPEAT"] = "REPEAT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#replace
         *
         * -----
         *
         * + MySQL          : `REPLACE(str, from, to)`
         * + PostgreSQL     : `REPLACE(str, from, to)`
         * + SQLite         : `REPLACE(str, from, to)`
         */
        OperatorType["REPLACE"] = "REPLACE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `REVERSE(x)`
         * + PostgreSQL     : `REVERSE(x)`
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["REVERSE"] = "REVERSE";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_right
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * The MySQL and PostgreSQL implementations are incompatible for negative numbers.
         */
        //RIGHT = "RIGHT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `RPAD(str, len, padstr)`
         * + PostgreSQL     : `RPAD(str, len, padstr)`
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["RPAD"] = "RPAD";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#rtrim
         *
         * -----
         *
         * + MySQL          : `RTRIM(x)`
         * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
         * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
         */
        OperatorType["RTRIM"] = "RTRIM";
        /*
         * Appears to be PostgreSQL-specific,
         * https://www.postgresql.org/docs/9.0/functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP
         */
        //SIMILAR_TO = "SIMILAR_TO",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_soundex
         * + https://www.sqlite.org/lang_corefunc.html#soundex
         * + https://www.postgresql.org/docs/9.1/fuzzystrmatch.html
         *
         * -----
         *
         * + MySQL          : `SOUNDEX(x)`
         * + PostgreSQL     : `SOUNDEX(x)`
         * + SQLite         : `SOUNDEX(x)`
         */
        //SOUNDEX = "SOUNDEX",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#operator_sounds-like
         */
        //SOUNDS_LIKE = "SOUNDS_LIKE",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_space
         *
         * -----
         *
         * `SPACE(n)` is the same as `REPEAT(' ', n)`
         */
        //SPACE = "SPACE",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substr
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#substr
         *
         * -----
         *
         * + MySQL          : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
         *   + `SUBSTR('hello', -1)` === `'o'`
         *   + `SUBSTR('hello', -1, -2)` === `''`
         *   + `SUBSTR('hello', -2, 2)` === `'lo'`
         * + PostgreSQL     : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
         *   + `SUBSTR('hello', -1)` === `'hello'`
         *   + `SUBSTR('hello', -1, -2)` throws an error
         *   + `SUBSTR('hello', -2, 2)` === `''`
         * + SQLite         : `SUBSTR(str, pos)/SUBSTR(str, pos, len)`
         *   + `SUBSTR('hello', -1)` === `'o'`
         *   + `SUBSTR('hello', -1, -2)` === `'ll'`
         *   + `SUBSTR('hello', -2, 2)` === `'lo'`
         *
         * -----
         *
         * Behaviour varies too much.
         */
        //SUBSTR = "SUBSTR",
        /*
         * Appears to be MySQl-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substring-index
         */
        //SUBSTRING_INDEX = "SUBSTRING_INDEX",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `TO_BASE64(x)`
         * + PostgreSQL     : `ENCODE(x, 'base64')`
         * + SQLite         : None, implement with user-defined function `btoa()`
         */
        OperatorType["TO_BASE64"] = "TO_BASE64";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
         * + https://www.sqlite.org/lang_corefunc.html#trim
         *
         * -----
         *
         * + MySQL          : `TRIM(x)`
         * + PostgreSQL     : `TRIM(x)`
         * + SQLite         : `TRIM(x)`
         */
        OperatorType["TRIM"] = "TRIM";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
         * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
         *
         * -----
         *
         * + MySQL          : `UNHEX(x)`
         *   + `UNHEX('~')` === `NULL`
         * + PostgreSQL     : `DECODE(x, 'hex')`
         *   + `DECODE('~', 'hex')` throws an error
         * + SQLite         : None. Implement with user-defined function.
         */
        OperatorType["UNHEX"] = "UNHEX";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
         * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
         * + https://www.sqlite.org/lang_corefunc.html#upper
         *
         * -----
         *
         * + MySQL          : `UPPER(x)`
         * + PostgreSQL     : `UPPER(x)`
         * + SQLite         : `UPPER(x)`
         */
        OperatorType["UPPER"] = "UPPER";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_weight-string
         */
        //WEIGHT_STIRNG = "WEIGHT_STIRNG",
        /*
            Arithmetic Operators
            https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_div
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS
         *
         * -----
         *
         * Interestingly enough,
         * MySQL uses `SIGNED` and `UNSIGNED` for integer type names when casting.
         * PostgreSQL uses `INTEGER`
         *
         * -----
         *
         * + MySQL        : `DIV`
         * + PostgreSQL   : `CAST(TRUNC(CAST(x AS NUMERIC) / CAST(y AS NUMERIC), 0) AS BIGINT)`
         * + SQLite       : `CAST(x/y AS BIGINT)`
         *   + SQLite does not have `DECIMAL` data type support...
         *
         */
        OperatorType["INTEGER_DIVISION"] = "INTEGER_DIVISION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `/`
         * + PostgreSQL   : `/`
         * + SQLite       : `/`
         */
        OperatorType["FRACTIONAL_DIVISION"] = "FRACTIONAL_DIVISION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
         *
         * -----
         *
         * + MySQL        : `-`
         * + PostgreSQL   : `-`
         * + SQLite       : `-`
         */
        OperatorType["SUBTRACTION"] = "SUBTRACTION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * @todo Find out if they behave the same
         *
         * + MySQL        : `%`
         *   + `1%0` === `NULL`
         * + PostgreSQL   : `mod(x, y)` (The `%` operator does not handle negative values)
         *   + `mod(1, 0)` throws error
         * + SQLite       : `%`
         *   + `1%0` === `NULL`
         */
        OperatorType["INTEGER_REMAINDER"] = "INTEGER_REMAINDER";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * + MySQL        : `%`
         * + PostgreSQL   : Not supported
         * + SQLite       : Not supported
         */
        OperatorType["FRACTIONAL_REMAINDER"] = "FRACTIONAL_REMAINDER";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
         *
         * -----
         *
         * + MySQL        : `+`
         * + PostgreSQL   : `+`
         * + SQLite       : `+`
         */
        OperatorType["ADDITION"] = "ADDITION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
         *
         * -----
         *
         * + MySQL        : `*`
         * + PostgreSQL   : `*`
         * + SQLite       : `*`
         */
        OperatorType["MULTIPLICATION"] = "MULTIPLICATION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
         *
         * -----
         *
         * + MySQL        : `-`
         * + PostgreSQL   : `-`
         * + SQLite       : `-`
         */
        OperatorType["UNARY_MINUS"] = "UNARY_MINUS";
        /*
            Mathematical Functions
            https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_corefunc.html#abs
         *
         * -----
         *
         * + MySQL        : `ABS(x)`
         * + PostgreSQL   : `@` or `ABS(x)` (Let's not use the ugly `@` operator)
         * + SQLite       : `ABS(x)`
         */
        OperatorType["ABSOLUTE_VALUE"] = "ABSOLUTE_VALUE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ACOS(x)`
         * + PostgreSQL     : `ACOS(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["ARC_COSINE"] = "ARC_COSINE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ASIN(x)`
         * + PostgreSQL     : `ASIN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["ARC_SINE"] = "ARC_SINE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ATAN(x)`
         * + PostgreSQL     : `ATAN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["ARC_TANGENT"] = "ARC_TANGENT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `ATAN2(y, x)`
         * + PostgreSQL     : `ATAN2(y, x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["ARC_TANGENT_2"] = "ARC_TANGENT_2";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceil
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL        : `CEIL(x)/CEILING(x)`
         * + PostgreSQL   : `CEIL(x)/CEILING(x)`
         * + SQLite       : None, use the following instead,
         *   + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
         * ```sql
         *  (
         *      CASE
         *          WHEN x = CAST(x AS INT) THEN
         *              CAST(x AS INT)
         *          ELSE
         *              1 + CAST(x AS INT)
         *      END
         *  )
         * ```
         *
         */
        OperatorType["CEILING"] = "CEILING";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_conv
         */
        //CONV = "CONV"
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `COS(x)`
         * + PostgreSQL     : `COS(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["COSINE"] = "COSINE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `COT(x)`
         * + PostgreSQL     : `COT(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["COTANGENT"] = "COTANGENT";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_crc32
         */
        //CRC32 = "CRC32",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `DEGREES(x)`
         * + PostgreSQL     : `DEGREES(x)`
         * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
         */
        OperatorType["DEGREES"] = "DEGREES";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `EXP(x)`
         * + PostgreSQL     : `EXP(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["NATURAL_EXPONENTIATION"] = "NATURAL_EXPONENTIATION";
        /*
         * Appears to be PostgreSQL-specific,
         * + Factorial; `x !` / `!! x`
         * + https://www.postgresql.org/docs/8.2/functions-math.html
         */
        //FACTORIAL = "FACTORIAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL        : `FLOOR(x)`
         * + PostgreSQL   : `FLOOR(x)`
         * + SQLite       : None, use the following instead,
         *   + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
         * ```sql
         *  (
         *      CASE
         *          WHEN x >= 0 THEN
         *              CAST(x AS INT)
         *          WHEN x = CAST(x AS INT) THEN
         *              CAST(x AS INT)
         *          ELSE
         *              CAST(x - 1.0 AS INT)
         *      END
         *  )
         * ```
         */
        OperatorType["FLOOR"] = "FLOOR";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_format
         */
        //FORMAT = "FORMAT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `LN(x)`
         * + PostgreSQL     : `LN(x)`
         * + SQLite         : None, implment with user-defined function
         */
        OperatorType["LN"] = "LN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `LOG(base, x)`
         * + PostgreSQL     : `LOG(base, x)`
         * + SQLite         : None, implment with user-defined function
         */
        OperatorType["LOG"] = "LOG";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
         *
         * -----
         *
         * + MySQL          : `LOG2(x)`
         * + PostgreSQL     : `LOG(2.0, x)`
         * + SQLite         : None, implment with user-defined function
         */
        OperatorType["LOG2"] = "LOG2";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
         *
         * -----
         *
         * + MySQL          : `LOG10(x)`
         * + PostgreSQL     : `LOG(10.0, x)`
         * + SQLite         : None, implment with user-defined function
         */
        OperatorType["LOG10"] = "LOG10";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `PI()` Returns `3.141592653589793`
         * + PostgreSQL     : `PI()` Returns `3.14159265358979`
         * + SQLite         : None, implement using `3.141592653589793`
         *
         * -----
         *
         * In JS, `Math.PI` is `3.141592653589793`
         */
        OperatorType["PI"] = "PI";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * + MySQL        : `POWER(x, y)`
         * + PostgreSQL   : `^` or `POWER(x, y)` (Let's not use the ugly `^` operator)
         * + SQLite       : Requres creating a `POWER(x, y)` user-defined function
         */
        OperatorType["POWER"] = "POWER";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `RADIANS(x)`
         * + PostgreSQL     : `RADIANS(x)`
         * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
         */
        OperatorType["RADIANS"] = "RADIANS";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#random
         *
         * -----
         *
         * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
         * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
         * + SQLite         : Incompatible.
         *
         *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
         *
         *   Therefore, one should use, `ABS(RANDOM()) / 9223372036854775808`
         */
        OperatorType["RANDOM"] = "RANDOM";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_round
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#round
         *
         * -----
         *
         * + MySQL          : `ROUND(x)` or `ROUND(x, y)`
         * + PostgreSQL     : `ROUND(x)` or `ROUND(x, y)`
         * + SQLite         : `ROUND(x)` or `ROUND(x, y)`
         */
        //ROUND = "ROUND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
         *
         * -----
         *
         * + MySQL          : `SIGN(x)`
         * + PostgreSQL     : `SIGN(x)`
         * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
         */
        OperatorType["SIGN"] = "SIGN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `SIN(x)`
         * + PostgreSQL     : `SIN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["SINE"] = "SINE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * -----
         *
         * + MySQL        : `SQRT(x)`
         * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
         * + SQLite       : Requres creating a `SQRT(x)` user-defined function
         */
        OperatorType["SQUARE_ROOT"] = "SQUARE_ROOT";
        /**
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
         *
         * -----
         *
         * + MySQL        : `POWER(x, 1.0/3.0)` The `.0` parts are important!
         * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
         * + SQLite       : Requres creating a `CBRT(x)` user-defined function
         *
         * -----
         *
         * MySQL
         * ```sql
         * SELECT POWER(27, 1.0/3.0)
         * > 3
         * ```
         *
         * PostgreSQL
         * ```sql
         * SELECT POWER(27, 1.0/3.0)
         * > 2.99999999999999999997
         * ```
         */
        OperatorType["CUBE_ROOT"] = "CUBE_ROOT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
         * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
         *
         * -----
         *
         * + MySQL          : `TAN(x)`
         * + PostgreSQL     : `TAN(x)`
         * + SQLite         : None, implement with user-defined function
         */
        OperatorType["TANGENT"] = "TANGENT";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_truncate
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         *
         * -----
         *
         * + MySQL          : `TRUNCATE(x, d)`
         * + PostgreSQL     : `TRUNC(x, d)`
         * + SQLite         : None, implement with `Math.trunc(x * Math.pow(10, d)) / Math.pow(10, d)`
         */
        //TRUNCATE = "TRUNCATE",
        /*
            Date and Time Functions
            https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
        */
        /**
         * @todo
         */
        /*
         * + MySQL          :
         * ```sql
         *  SELECT
         *      adddate(date('2010-01-01'), interval 1 hour),
         *      adddate(date('2010-01-01'), interval 1 day);
         *  > 2010-01-01 01:00:00
         *  > 2010-01-02
         * ```
         * + PostgreSQL     :
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      date '2010-01-01' + interval '1 hour',
         *      date '2010-01-01' + interval '1 day',
         *      time '10:23:45.123' + interval '1 hour',
         *      time '10:23:45.123' + interval '1 day'
         *  > 2010-01-01T01:00:00.000Z
         *  > 2010-01-02T00:00:00.000Z
         *  > 11:23:45.123
         *  > 10:23:45.123
         * ```
         */
        //ADDDATE = "ADDDATE",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_addtime
         *
         * It has... Weird behaviour.
         */
        //ADDTIME = "ADDTIME",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_DATE()`
         * + PostgreSQL     : `CURRENT_DATE()`
         * + SQLite         : `strftime('%Y-%m-%d', 'now')`
         */
        OperatorType["CURRENT_DATE"] = "CURRENT_DATE";
        /* *
         * Cannot use JS `Date` to represent SQL `TIME`.
         *
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIME(0)`
         * + PostgreSQL     : `CURRENT_TIME(0)`
         * + SQLite         : `strftime('%H:%M:%S', 'now')`
         */
        //CURRENT_TIME_0 = "CURRENT_TIME_0",
        /* *
         * Cannot use JS `Date` to represent SQL `TIME`.
         *
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIME(1)`
         * + PostgreSQL     : `CURRENT_TIME(1)`
         * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 10)`
         */
        //CURRENT_TIME_1 = "CURRENT_TIME_1",
        /* *
         * Cannot use JS `Date` to represent SQL `TIME`.
         *
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIME(2)`
         * + PostgreSQL     : `CURRENT_TIME(2)`
         * + SQLite         : `substr(strftime('%H:%M:%f', 'now'), 1, 11)`
         */
        //CURRENT_TIME_2 = "CURRENT_TIME_2",
        /* *
         * Cannot use JS `Date` to represent SQL `TIME`.
         *
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-time
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIME(3)`
         * + PostgreSQL     : `CURRENT_TIME(3)`
         * + SQLite         : `strftime('%H:%M:%f', 'now')`
         */
        //CURRENT_TIME_3 = "CURRENT_TIME_3",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(0)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(0),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(0))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(0),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(0)
         *      ))
         *  > 2019-09-07T23:58:20.000Z
         *  > 1567900700
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%S', 'now'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%S', 'now'));
         *  > 2019-09-07 23:59:35
         *  > 1567900775
         * ```
         */
        OperatorType["CURRENT_TIMESTAMP_0"] = "CURRENT_TIMESTAMP_0";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(1)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(1),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(1))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.8
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(1),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(1)
         *      ))
         *  > 2019-09-07T23:58:20.400Z
         *  > 1567900700
         * ```
         * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
         * ```sql
         *  SELECT
         *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21),
         *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21));
         *  > 2019-09-07 23:59:35.3
         *  > 1567900775
         * ```
         */
        OperatorType["CURRENT_TIMESTAMP_1"] = "CURRENT_TIMESTAMP_1";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(2)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(2),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(2))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.83
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(2),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(2)
         *      ))
         *  > 2019-09-07T23:58:20.470Z
         *  > 1567900700
         * ```
         * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
         * ```sql
         *  SELECT
         *      substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22),
         *      strftime('%s', substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22));
         *  > 2019-09-07 23:59:35.32
         *  > 1567900775
         * ```
         */
        OperatorType["CURRENT_TIMESTAMP_2"] = "CURRENT_TIMESTAMP_2";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `CURRENT_TIMESTAMP(3)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(3),
         *      FLOOR(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))),
         *      UNIX_TIMESTAMP()
         *  > 2019-09-07 19:55:03.836
         *  > 1567900503
         *  > 1567900503
         * ```
         * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
         *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
         *
         *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
         *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      CURRENT_TIMESTAMP(3),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM CURRENT_TIMESTAMP(3)
         *      ))
         *  > 2019-09-07T23:58:20.477Z
         *  > 1567900700
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%f', 'now'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', 'now'));
         *  > 2019-09-07 23:59:35.327
         *  > 1567900775
         * ```
         */
        OperatorType["CURRENT_TIMESTAMP_3"] = "CURRENT_TIMESTAMP_3";
        /**
         *
         * -----
         *
         * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
         *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
         *  > 1969-12-31 22:00:00.123
         *  > 10800
         * ```
         * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
         *      FLOOR(EXTRACT(
         *          EPOCH FROM (
         *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
         *          )
         *      ))
         *  > 1970-01-01T03:00:00.123Z
         *  > 10800
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
         *  > 1970-01-01 03:00:00.123
         *  > 10800
         * ```
         *
         * -----
         *
         * Treat `x` as representing a `UTC` timestamp.
         *
         */
        OperatorType["UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR"] = "UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR";
        /*
         *
         * -----
         *
         * + MySQL          : `TIMESTAMP(x)`
         * ```sql
         *  SET @@session.time_zone = 'EST';
         *  SELECT
         *      TIMESTAMP('1970-01-01 00:00:00.123'),
         *      FLOOR(UNIX_TIMESTAMP(TIMESTAMP('1970-01-01 00:00:00.123')));
         *  > 1970-01-01 00:00:00.123
         *  > 18000
         * ```
         * + PostgreSQL     : `(x)::timestamp AT TIME ZONE current_setting('TIMEZONE')`
         * ```sql
         *  SET TIME ZONE 'EST';
         *  SELECT
         *      '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE'),
         *      FLOOR(EXTRACT(
         *          EPOCH FROM (
         *              '1970-01-01 00:00:00.123'::timestamp AT TIME ZONE current_setting('TIMEZONE')
         *          )
         *      ))
         *  > 1970-01-01T05:00:00.123Z
         *  > 18000
         * ```
         * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x, 'utc')`
         * ```sql
         *  SELECT
         *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'),
         *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 00:00:00.123', 'utc'));
         *  > 1970-01-01 05:00:00.123
         *  > 18000
         * ```
         *
         * -----
         *
         * Treat `x` as representing a `local` timestamp.
         *
         */
        //LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR = "LOCAL_STRING_TO_TIMESTAMP_CONSTRUCTOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000.0) / 1000.0`
         * ```sql
         *  SELECT
         *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
         *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
         *  > 32.4560
         * ```
         * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
         * + SQLite         : `strftime('%f', datetime)`
         * ```sql
         *  SELECT
         *      strftime('%f', '2010-03-27 14:45:32.456789')
         *  > 32.457
         *  -- The result is rounded, not truncated.
         *  -- If it were truncated, we would get 32.456
         * ```
         * ```sql
         *  SELECT
         *      strftime('%f', '2010-03-27 23:59:59.999999')
         *  > 59.999
         *  -- The result is truncated, not rounded.
         *  -- If it were rounded, we would get 60
         * ```
         *
         * @todo Make behaviour consistent?
         */
        OperatorType["EXTRACT_FRACTIONAL_SECOND_3"] = "EXTRACT_FRACTIONAL_SECOND_3";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(SECOND FROM datetime)`
         * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_INTEGER_SECOND"] = "EXTRACT_INTEGER_SECOND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_MINUTE"] = "EXTRACT_MINUTE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(HOUR FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_HOUR"] = "EXTRACT_HOUR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(DAY FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_DAY"] = "EXTRACT_DAY";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(MONTH FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_MONTH"] = "EXTRACT_MONTH";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `EXTRACT(YEAR FROM datetime)`
         * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
         * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
         */
        OperatorType["EXTRACT_YEAR"] = "EXTRACT_YEAR";
        /**
         * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
         *
         * -----
         *
         * + MySQL          : `LAST_DAY(datetime)`
         * ```sql
         *  SELECT
         *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
         *  > 2010-03-31
         * ```
         * + PostgreSQL     :
         * ```sql
         *  SELECT
         *      (
         *          datetime +
         *          interval '1 month' -
         *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
         *      )::date
         * > 2010-03-31T00:00:00.000Z
         * ```
         * + SQLite         :
         * ```sql
         *  SELECT
         *      strftime(
         *          '%Y-%m-%d',
         *          '2010-03-27 14:45:32.456789',
         *          '+1 month',
         *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
         *      )
         *  > 2010-03-31
         * ```
         */
        OperatorType["LAST_DAY"] = "LAST_DAY";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(MICROSECOND, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x/1000.0, ' millisecond')::interval`
         *
         *   1 millisecond is 1000 microseconds
         *
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      -- 1 second is 1,000,000 microseconds
         *      (x/1000000.0) || ' second'
         *  );
         * ```
         *
         * However, SQLite only displays up to millisecond precision (3 decimal places for seconds).
         * JS' `Date` also only has up to millisecond precision.
         */
        //TIMESTAMPADD_MICROSECOND = "TIMESTAMPADD_MICROSECOND",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x/1000.0, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      (x/1000e0) || ' second'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_MILLISECOND"] = "TIMESTAMPADD_MILLISECOND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' second'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_SECOND"] = "TIMESTAMPADD_SECOND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0, datetime)`
         *   + `TIMESTAMPADD(MINUTE, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' minute'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_MINUTE"] = "TIMESTAMPADD_MINUTE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*60.0*60.0, datetime)`
         *   + `TIMESTAMPADD(HOUR, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' hour'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_HOUR"] = "TIMESTAMPADD_HOUR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(SECOND, x*24.0*60.0*60.0, datetime)`
         *   + `TIMESTAMPADD(DAY, x, datetime)` ignores the fractional part of `x`.
         *   + We convert `x` to seconds as a workaround.
         * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' day'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_DAY"] = "TIMESTAMPADD_DAY";
        /**
         * Seems to be a MySQL and PostgreSQL thing.
         * SQLite does not have `week` intervals.
         *
         * Could probably be emulated with `7 day` being `1 week`
         */
        //TIMESTAMPADD_WEEK = "TIMESTAMPADD_WEEK",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' month'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_MONTH"] = "TIMESTAMPADD_MONTH";
        /**
         * Seems to be a MySQL thing.
         * PostgreSQL and SQLite do not have `quarter` intervals.
         *
         * Could probably be emulated with `3 month` being `1 quarter`
         */
        //TIMESTAMPADD_QUARTER = "TIMESTAMPADD_QUARTER",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
         * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
         * + SQLite         :
         * ```sql
         *  strftime(
         *      '%Y-%m-%d %H:%M:%f',
         *      datetime,
         *      x || ' year'
         *  );
         * ```
         */
        OperatorType["TIMESTAMPADD_YEAR"] = "TIMESTAMPADD_YEAR";
        /*
         * SQLite does not have microsecond precision.
         */
        //TIMESTAMPDIFF_MICROSECOND = "TIMESTAMPDIFF_MICROSECOND",
        /**
         * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
         *   + The `TRUNC()` at the end is necessary
         *   + Extracting `SECOND` gives a number with decimal places for milliseconds
         *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        OperatorType["TIMESTAMPDIFF_MILLISECOND"] = "TIMESTAMPDIFF_MILLISECOND";
        /**
         * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
         *   + The `TRUNC()` at the end is necessary
         *   + Extracting `SECOND` gives a number with decimal places for milliseconds
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        OperatorType["TIMESTAMPDIFF_SECOND"] = "TIMESTAMPDIFF_SECOND";
        /**
         * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        OperatorType["TIMESTAMPDIFF_MINUTE"] = "TIMESTAMPDIFF_MINUTE";
        /**
         * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
         * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        OperatorType["TIMESTAMPDIFF_HOUR"] = "TIMESTAMPDIFF_HOUR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
         *
         * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
         * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
         * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
         *   + We cast to `BIGINT` to be consistent with MySQL
         */
        OperatorType["TIMESTAMPDIFF_DAY"] = "TIMESTAMPDIFF_DAY";
        /*
         * Seems to be MySQL-specific
         */
        //TIMESTAMPDIFF_WEEK = "TIMESTAMPDIFF_WEEK",
        /*
         * + MySQL          : `TIMESTAMPDIFF(MONTH, from, to)`
         * + PostgreSQL     :
         * ```sql
         * EXTRACT(YEAR FROM AGE(to, from))*12 +
         * EXTRACT(MONTH FROM AGE(to, from))
         * ```
         * + SQLite         : @todo? Doesn't seem possible to compute properly
         */
        //TIMESTAMPDIFF_MONTH = "TIMESTAMPDIFF_MONTH",
        /*
         * Seems to be MySQL-specific
         */
        //TIMESTAMPDIFF_QUARTER = "TIMESTAMPDIFF_QUARTER",
        /*
         * + MySQL          : `TIMESTAMPDIFF(YEAR, from, to)`
         * + PostgreSQL     :
         * ```sql
         * EXTRACT(YEAR FROM AGE(to, from))
         * ```
         * + SQLite         : @todo? Doesn't seem possible to compute properly
         */
        //TIMESTAMPDIFF_YEAR = "TIMESTAMPDIFF_YEAR",
        /*
         * The different databases implement this differently,
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-format
         * + https://www.postgresql.org/docs/9.4/functions-formatting.html
         * + https://www.sqlite.org/lang_datefunc.html
         */
        //TIME_FORMAT = "TIME_FORMAT",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_time-to-sec
         */
        //TIME_TO_SEC = "TIME_TO_SEC",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days
         */
        //TO_DAYS = "TO_DAYS",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-seconds
         */
        //TO_SECONDS = "TO_SECONDS",
        /*
         * @todo
         *
         * I don't think this can easily be made portable across different database systems
         * **AND** made to behave consistently across different session time zone settings.
         *
         * -----
         *
         * + MySQL          : `UNIX_TIMESTAMP(datetime)`
         *   + The return value is an integer if no argument is given or the argument does not include a fractional seconds part,
         *   + or `DECIMAL` if an argument is given that includes a fractional seconds part.
         *   + returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
         *   + The server interprets date as a value in the session time zone and converts it to an internal Unix timestamp value in UTC.
         * +
         */
        //UNIX_TIMESTAMP_AT_DATETIME = "UNIX_TIMESTAMP_AT_DATETIME",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `UNIX_TIMESTAMP()`
         * + PostgreSQL     :
         * ```sql
         *  FLOOR(
         *      EXTRACT(EPOCH FROM (
         *          CURRENT_TIMESTAMP -
         *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
         *      ))
         *  )
         * ```
         * + SQLite         : `strftime('%s', 'now')`
         */
        OperatorType["UNIX_TIMESTAMP_NOW"] = "UNIX_TIMESTAMP_NOW";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-date
         */
        //UTC_DATE = "UTC_DATE",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_utc-time
         */
        //UTC_TIME = "UTC_TIME",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
         *
         * Also, it does not play well with the other MySQL date-time functions.
         * Do not implement in base package unless a **VERY** good reason exists.
         */
        //UTC_TIMESTAMP = "UTC_TIMESTAMP",
        /*
         * Wtf is this, even?
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_week
         */
        //WEEK = "WEEK",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekday
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `WEEKDAY(date)`           ; `0=Monday, 1=Tuesday, ..., 6=Sunday`
         * + PostgreSQL     : `EXTRACT(DOW FROM date)`  ; `0=Sunday, 1=Monday , ..., 6=Saturday`
         * + SQLite         : `strftime('%w', date)`    ; `0=Sunday, 1=Monday , ..., 6=Saturday`
         *
         * -----
         *
         * Implementations are incompatible.
         * Can possibly use a different name and unify their implementations, however.
         */
        //WEEKDAY = "WEEKDAY",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_weekofyear
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `WEEKOFYEAR(date)`        ; `1-53`
         * + PostgreSQL     : `EXTRACT(WEEK FROM date)` ; `@todo`
         * + SQLite         : `strftime('%W', date)`    ; `0-53`
         *
         * -----
         *
         * Implementations are incompatible.
         * Can possibly use a different name and unify their implementations, however.
         */
        //WEEKOFYEAR = "WEEKOFYEAR",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_year
         * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
         * + https://www.sqlite.org/lang_datefunc.html
         *
         * -----
         *
         * + MySQL          : `YEAR(date)`
         * + PostgreSQL     : `EXTRACT(YEAR FROM date)`
         * + SQLite         : `strftime('%Y', date)`
         *
         * @todo How is this different from `EXTRACT(YEAR FROM date)`?
         */
        //YEAR = "YEAR",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_yearweek
         */
        //YEARWEEK = "YEARWEEK",
        /*
            Cast Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html
        */
        /**
         * @todo
         */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS BINARY)`
         * + PostgreSQL     : `CAST(x AS bytea)`
         * + SQLite         : `CAST(x AS BLOB)`
         */
        OperatorType["CAST_AS_BINARY"] = "CAST_AS_BINARY";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS CHAR) [charset_info]`
         * + PostgreSQL     : `CAST(x AS VARCHAR) [charset_info]`
         * + SQLite         : `CAST(x AS VARCHAR) [charset_info]`
         */
        OperatorType["CAST_AS_VARCHAR"] = "CAST_AS_VARCHAR";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS DATE)`
         * + PostgreSQL     : `CAST(x AS DATE)`
         * + SQLite         :
         *   **DO NOT** use `CAST(x AS DATE)`!
         * ```sql
         * SELECT CAST('2010-10-27 12:00:00' AS DATE)
         * > 2019
         * ```
         *
         * The above happens because `DATE` has `NUMERIC` affinity.
         * And so, the cast is the same as saying `CAST(x AS DECIMAL)`
         *
         * -----
         *
         * Actually, don't even use `CAST_AS_DATE`.
         * Just use one of the two `TIMESTAMP` constructors.
         */
        //CAST_AS_DATE = "CAST_AS_DATE",
        /*
         * Actually, don't even use `CAST_AS_DATETIME`.
         * Just use one of the two `TIMESTAMP` constructors.
         */
        //CAST_AS_DATETIME = "CAST_AS_DATETIME",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS DECIMAL(precision, scale))`
         *   + Max precision : 65
         *   + Max scale     : 30
         * + PostgreSQL     : `CAST(x AS DECIMAL(precision, scale))`
         *   + Max precision : 1000
         *   + Max scale     : 1000
         * + SQLite         : `CAST(x AS DECIMAL(precision, scale))`
         * ```sql
         * SELECT CAST('1e308' AS DECIMAL)
         * > 1e+308
         * ```
         *
         * For SQLite, this doesn't even cast to an arbitrary precision number.
         * SQLite does not support arbitrary precision numbers.
         * You will get a `double` instead.
         *
         * -----
         *
         * Precision and scale cannot be omitted.
         *
         * When omitted, MySQL defaults to `DECIMAL(10, 0)`
         * When omitted, PostgreSQL defaults to a precision and scale that will contain `x`
         *
         * -----
         *
         * ### Notes about MySQL's `DECIMAL`
         *
         * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1253-L1313
         * https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1576-L1598
         *
         * ```js
         * DIG_PER_DEC1 = 9
         * dig2bytes = [0,1,1,2,2,3,3,4,4,4]
         * precision = 65
         * scale = 30
         * //typedef int32 decimal_digit_t;
         * //typedef decimal_digit_t dec1;
         * dec1 = 4
         * function sizeof (arg) { return arg }
         * var
         *      intg = precision - scale,
         *      intg0  = Math.floor(intg / DIG_PER_DEC1),
         *      frac0  = Math.floor(scale / DIG_PER_DEC1),
         *      intg0x = intg - intg0 * DIG_PER_DEC1,
         *      frac0x = scale - frac0 * DIG_PER_DEC1;
         * result = intg0 * sizeof(dec1) + dig2bytes[intg0x] + frac0 * sizeof(dec1) + dig2bytes[frac0x]
         * ```
         *
         * http://ftp.nchu.edu.tw/MySQL/doc/refman/5.0/en/precision-math-decimal-changes.html
         *
         * -----
         *
         * ```js
         * DIG_PER_DEC1 = 9;
         * dig2bytes = [0, 1, 1, 2, 2, 3, 3, 4, 4, 4];
         *
         * res = {};
         *
         * for (let precision = 1; precision < 73; precision++) {
         *      for (let scale = 0; scale <= precision; scale++) {
         *          const intg = precision - scale;
         *          const intg0 = Math.floor(intg / DIG_PER_DEC1);
         *          const frac0 = Math.floor(scale / DIG_PER_DEC1);
         *          const intg0x = intg - intg0 * DIG_PER_DEC1;
         *          const frac0x = scale - frac0 * DIG_PER_DEC1;
         *          const result = (
         *              intg0 * 4 + dig2bytes[intg0x] + frac0 * 4 + dig2bytes[frac0x]
         *          );
         *          res[`${precision}.${scale}`] = result;
         *      }
         * }
         * console.log(res);
         * ```
         *
         * -----
         *
         * ### Notes about PostgreSQL's `DECIMAL`
         *
         * https://doxygen.postgresql.org/numeric_8h.html#a12ab0e498cc609664248b5c9bb6c0a43
         *
         * @karanlyons said,
         * > 511 bytes for 1000 digits in postgres.
         * >
         * > And I think they use the extra byte for some additional bookeeping of the sign, etc.
         * >
         * > So 512, which makes sense!
         * >
         * > <3 u pg.
         * >
         * > Postgres’ source code is way better to read.
         * >
         * > It helps that they’re not insane.
         * >
         * > ~~That extra byte is actually for the type header I think, not internal bookkeeping of the number itself.~~
         * >
         * > The extra byte is for the `typmod` I think, which is 32 bits encoding the precision and scale in the upper 16 and lower 16.
         * >
         * > https://doxygen.postgresql.org/backend_2utils_2adt_2numeric_8c_source.html#l00703
         * >
         * > https://doxygen.postgresql.org/structNumericVar.html
         */
        OperatorType["CAST_AS_DECIMAL"] = "CAST_AS_DECIMAL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL 5.7      : `x + 0e0`
         * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
         * + SQLite         : `CAST(x AS DOUBLE)`
         */
        OperatorType["CAST_AS_DOUBLE"] = "CAST_AS_DOUBLE";
        /*
         * Can't do it in MySQL 5.7.
         */
        //CAST_AS_FLOAT = "CAST_AS_FLOAT",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS JSON)`
         * + PostgreSQL     : `CAST(x AS JSON)`
         * + SQLite         : `CAST(x AS TEXT)`; Or implement with user-defined function.
         *
         *   SQLite does not have a `JSON` data type
         */
        OperatorType["CAST_AS_JSON"] = "CAST_AS_JSON";
        /* *
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         * + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS NCHAR)`
         * + PostgreSQL     : `CAST(x AS VARCHAR) utf8`
         *   + https://dev.mysql.com/doc/refman/8.0/en/charset-national.html
         *   + `utf8` is the charset of MySQL's `NCHAR`
         * + SQLite         : `CAST(x AS TEXT)`
         *   + SQLite does not have character sets
         */
        //CAST_AS_N_CHAR = "CAST_AS_N_CHAR",
        /*
         * The behaviour is too unpredictable on MySQL.
         * > Produces a result of type REAL.
         * This is actually FLOAT if REAL_AS_FLOAT SQL mode is enabled; otherwise the result is of type DOUBLE.
         */
        //CAST_AS_REAL = "CAST_AS_REAL",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS SIGNED INTEGER)`
         *   + Actually gives a signed `bigint`
         *   + Trying to cast `'123e2'` gives `123`
         * + PostgreSQL     : `CAST(x AS bigint)`
         *   + Trying to cast `'123e2'` throws an error
         * + SQLite         : `CAST(x AS BIGINT)`
         *   + Trying to cast `'123e2'` gives `123`
         */
        OperatorType["CAST_AS_BIGINT_SIGNED"] = "CAST_AS_BIGINT_SIGNED";
        /*
         * Use one of the `TIMESTAMP` constructors instead
         */
        //CAST_AS_TIME = "CAST_AS_TIME",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
         * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
         * + https://www.sqlite.org/datatype3.html
         *
         * -----
         *
         * + MySQL          : `CAST(x AS UNSIGNED INTEGER)`
         *   + Actually gives an unsigned `bigint`
         * + PostgreSQL     : `CAST(x AS bigint)`
         *   + PostgreSQL does not have unsigned types!
         * + SQLite         : `CAST(x AS BIGINT)`
         *   + SQLite does not have unsigned types!
         *
         * -----
         *
         * ~~Even though **ONLY** MySQL supports `UNSIGNED` types,~~
         * ~~we're still adding this because it's too useful to give up.~~
         * Support for `BIGINT UNSIGNED` has been dropped.
         *
         * It means that trying to use `BIGINT UNSIGNED` with other databases
         * will produce varying behaviours, though...
         *
         * For example, the range of `BIGINT SIGNED` is much smaller than
         * `BIGINT UNSIGNED` if we are only looking at the non-negative range.
         *
         * Math with `BIGINT UNSIGNED` fails if the result becomes negative.
         * `BIGINT SIGNED` has no such inhibitions.
         */
        //CAST_AS_UNSIGNED_BIG_INTEGER = "CAST_AS_UNSIGNED_BIG_INTEGER",
        /*
            Bit Functions and Operators
            https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x & y AS SIGNED)`
         * + PostgreSQL   : `&`
         * + SQLite       : `&`
         */
        OperatorType["BITWISE_AND"] = "BITWISE_AND";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(~x AS SIGNED)`
         *   + `~1337` === `18446744073709550278`
         *   + `CAST(~1337 AS SIGNED)` === `-1338`
         * + PostgreSQL   : `~x`
         *   + `~1337` === `-1338`
         * + SQLite       : `~x`
         *   + `~1337` === `-1338`
         */
        OperatorType["BITWISE_NOT"] = "BITWISE_NOT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x | y AS SIGNED)`
         * + PostgreSQL   : `|`
         * + SQLite       : `|`
         */
        OperatorType["BITWISE_OR"] = "BITWISE_OR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x ^ y AS SIGNED)`
         * + PostgreSQL   : `#`
         * + SQLite       : None, use `(~(a&b))&(a|b)` instead
         *   + https://stackoverflow.com/questions/16440831/bitwise-xor-in-sqlite-bitwise-not-not-working-as-i-expect
         *   + https://www.mail-archive.com/sqlite-users@mailinglists.sqlite.org/msg02250.html
         */
        OperatorType["BITWISE_XOR"] = "BITWISE_XOR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x << y AS SIGNED)`
         * + PostgreSQL   : `<<`
         * + SQLite       : `<<`
         */
        OperatorType["BITWISE_LEFT_SHIFT"] = "BITWISE_LEFT_SHIFT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
         * + https://www.postgresql.org/docs/9.0/functions-math.html
         * + https://www.sqlite.org/lang_expr.html#binaryops
         *
         * -----
         *
         * + MySQL        : `CAST(x >> y AS SIGNED)`
         * + PostgreSQL   : `>>`
         * + SQLite       : `>>`
         */
        OperatorType["BITWISE_RIGHT_SHIFT"] = "BITWISE_RIGHT_SHIFT";
        /*
            Functions That Create JSON Values
            https://dev.mysql.com/doc/refman/8.0/en/json-creation-functions.html
        */
        /**
         * @todo
         */
        /*
            Functions That Search JSON Values
            https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html
        */
        /**
         * @todo
         */
        /*
            Functions That Modify JSON Values
            https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html
        */
        /**
         * @todo
         */
        /*
            Functions That Return JSON Value Attributes
            https://dev.mysql.com/doc/refman/8.0/en/json-attribute-functions.html
        */
        /**
         * @todo
         */
        /*
            JSON Table Functions
            https://dev.mysql.com/doc/refman/8.0/en/json-table-functions.html
        */
        /**
         * @todo
         */
        /*
            JSON Schema Validation Functions
            https://dev.mysql.com/doc/refman/8.0/en/json-validation-functions.html
        */
        /**
         * @todo
         */
        /*
            JSON Utility Functions
            https://dev.mysql.com/doc/refman/8.0/en/json-utility-functions.html
        */
        /**
         * @todo
         */
        /*
            Spatial Analysis Functions
            https://dev.mysql.com/doc/refman/8.0/en/spatial-analysis-functions.html
    
            @todo Split into subchapters
        */
        /*
            Aggregate (GROUP BY) Function Descriptions
            https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#avg
         *
         * -----
         *
         * + MySQL      : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         * + PostgreSQL : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         * + SQLite     : `AVG(DISTINCT x)/AVG(x)/AVG(x) OVER()`
         */
        OperatorType["AGGREGATE_AVERAGE"] = "AGGREGATE_AVERAGE";
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-and
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `BIT_AND(x)/BIT_AND(x) OVER()`
         *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `18446744073709551615`
         * + PostgreSQL : `BIT_AND(x)/BIT_AND(x) OVER()`
         *   + If `myTable` is empty, `SELECT BIT_AND(myTableId) FROM myTable` === `NULL`
         * + SQLite     : None. Implement with user-defined function.
         */
        //AGGREGATE_BITWISE_AND = "AGGREGATE_BITWISE_AND",
        /*
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-or
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `BIT_OR(x)/BIT_OR(x) OVER()`
         *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `0`
         * + PostgreSQL : `BIT_OR(x)/BIT_OR(x) OVER()`
         *   + If `myTable` is empty, `SELECT BIT_OR(myTableId) FROM myTable` === `NULL`
         * + SQLite     : None. Implement with user-defined function.
         */
        //AGGREGATE_BITWISE_OR = "AGGREGATE_BITWISE_OR",
        /**
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_bit-xor
         */
        //BIT_XOR = "BIT_XOR",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#count
         *
         * -----
         *
         * + MySQL      : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` always returns one row
         * + PostgreSQL : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` can return zero rows
         * + SQLite     : `COUNT(DISTINCT x)/COUNT(x)/COUNT(x) OVER()`
         *   + `COUNT(x) OVER()` can return zero rows
         */
        OperatorType["AGGREGATE_COUNT_EXPR"] = "AGGREGATE_COUNT_EXPR";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#count
         *
         * -----
         *
         * + MySQL      : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         * + PostgreSQL : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         * + SQLite     : `COUNT(*)/COUNT(*) OVER()`
         *   + `COUNT(*) OVER()` can return zero rows
         */
        OperatorType["AGGREGATE_COUNT_ALL"] = "AGGREGATE_COUNT_ALL";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
         *
         * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
         * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
         * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
         *   + The order of the concatenated elements is arbitrary.
         *   + Uses comma as separator
         *
         * -----
         *
         * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
         * for the DB-unified implementation.
         *
         * Unless we modify the SQLite implementation with a user-defined function?
         * @todo Investigate
         */
        OperatorType["AGGREGATE_GROUP_CONCAT_DISTINCT"] = "AGGREGATE_GROUP_CONCAT_DISTINCT";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
         *
         * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
         * + PostgreSQL : `STRING_AGG(expr, separator)`
         * + SQLite     : `GROUP_CONCAT(expr, separator)`
         *   + The order of the concatenated elements is arbitrary.
         */
        OperatorType["AGGREGATE_GROUP_CONCAT_ALL"] = "AGGREGATE_GROUP_CONCAT_ALL";
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-arrayagg
         * @todo?
         *
         * Could also be related to `ARRAY_AGG()` from PostgreSQL,
         */
        //JSON_ARRAYAGG = "JSON_ARRAYAGG",
        /*
         * Appears to be MySQL-specific,
         * https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_json-objectagg
         */
        //JSON_OBJECTAGG = "JSON_OBJECTAGG",
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
         *
         * -----
         *
         * + MySQL      : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         * + PostgreSQL : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         * + SQLite     : `MAX(DISTINCT x)/MAX(x)/MAX(x) OVER()`
         */
        OperatorType["AGGREGATE_MAX"] = "AGGREGATE_MAX";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `MIN(DISTINCT x)/MIN(x) OVER()`
         * + PostgreSQL : `MIN(DISTINCT x)/MIN(x) OVER()`
         * + SQLite     : `MIN(DISTINCT x)/MIN(x)/MIN(x) OVER()`
         */
        OperatorType["AGGREGATE_MIN"] = "AGGREGATE_MIN";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
         *
         * -----
         *
         * + MySQL      : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
         * + PostgreSQL : `STDDEV_POP(x)/STDDEV_POP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        OperatorType["AGGREGATE_POPULATION_STANDARD_DEVIATION"] = "AGGREGATE_POPULATION_STANDARD_DEVIATION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
         *
         * -----
         *
         * + MySQL      : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
         * + PostgreSQL : `STDDEV_SAMP(x)/STDDEV_SAMP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        OperatorType["AGGREGATE_SAMPLE_STANDARD_DEVIATION"] = "AGGREGATE_SAMPLE_STANDARD_DEVIATION";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        OperatorType["AGGREGATE_SUM"] = "AGGREGATE_SUM";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        OperatorType["AGGREGATE_SUM_AS_DECIMAL"] = "AGGREGATE_SUM";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         * + https://www.sqlite.org/lang_corefunc.html#minoreunc
         *
         * -----
         *
         * + MySQL      : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + PostgreSQL : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         * + SQLite     : `SUM(DISTINCT x)/SUM(x)/SUM(x) OVER()`
         */
        OperatorType["AGGREGATE_SUM_AS_BIGINT_SIGNED"] = "AGGREGATE_SUM";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `VAR_POP(x)/VAR_POP(x) OVER()`
         * + PostgreSQL : `VAR_POP(x)/VAR_POP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        OperatorType["AGGREGATE_POPULATION_VARIANCE"] = "AGGREGATE_POPULATION_VARIANCE";
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
         * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
         *
         * -----
         *
         * + MySQL      : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
         * + PostgreSQL : `VAR_SAMP(x)/VAR_SAMP(x) OVER()`
         * + SQLite     : None. Implement with user-defined function.
         *
         * Should only be provided for `double` because MySQL treats all `x` as `double`.
         */
        OperatorType["AGGREGATE_SAMPLE_VARIANCE"] = "AGGREGATE_SAMPLE_VARIANCE";
        /*
            https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html
    
            Subqueries with `EXISTS` or `NOT EXISTS`
        */
        /**
         * + https://dev.mysql.com/doc/refman/5.5/en/exists-and-not-exists-subqueries.html
         * + https://www.postgresql.org/docs/8.1/functions-subquery.html#AEN13171
         * + https://www.sqlite.org/lang_expr.html#exists_op
         *
         * -----
         *
         * + MySQL      : `EXISTS(query)`
         * + PostgreSQL : `EXISTS(query)`
         * + SQLite     : `EXISTS(query)`
         */
        OperatorType["EXISTS"] = "EXISTS";
        /*
            https://dev.mysql.com/doc/refman/5.7/en/information-functions.html
    
            Information Functions
        */
        /**
         * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
         * + https://www.postgresql.org/docs/9.2/functions-info.html
         * + https://www.sqlite.org/lang_attach.html
         *
         * -----
         *
         * + MySQL      : `DATABASE()`
         * + PostgreSQL : `CURRENT_SCHEMA`
         * + SQLite     : `'main'` should always be the current database.
         *   + There's also `'temp'`, I guess
         */
        OperatorType["CURRENT_SCHEMA"] = "CURRENT_SCHEMA";
        /**
         * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
         * + https://www.postgresql.org/docs/9.2/functions-info.html
         * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
         *
         * -----
         *
         * + MySQL      : `CURRENT_USER`
         * + PostgreSQL : `CURRENT_USER`
         * + SQLite     : None. It does not make sense to ask what the current user is.
         */
        OperatorType["CURRENT_USER"] = "CURRENT_USER";
        /*
            Custom library functions
    
            These functions are not standard SQL,
            but can be implemented using standard SQL.
        */
        /*
         * An invalid expression that is syntactically valid.
         * So, it will run.
         * But evaluating it will throw a run-time error.
         *
         * Good for stuff like,
         * ```sql
         *  -- Throw if the condition is false
         *  -- Otherwise, return the expression
         *  IF(
         *      -- condition,
         *      -- expression,
         *      THROW()
         *  )
         * ```
         *
         * Or,
         * ```sql
         *  -- Throw if expression is null
         *  -- Otherwise, return the expression
         *  COALESCE(
         *      -- possibly null expression,
         *      throw()
         *  )
         * ```
         *
         * A good example of such a throwing expression is,
         * ```sql
         *  -- Returns two rows,
         *  (SELECT NULL UNION ALL SELECT NULL)
         * ```
         *
         * @todo Find other such throwing expressions?
         *
         * This cannot be done in PostgreSQL.
         * PostgeSQL's type system does not allow mixing types like,
         * ```sql
         *  COALESCE(true, (SELECT NULL UNION ALL SELECT NULL))
         * ```
         */
        //THROW = "THROW",
        /**
         * + MySQL      - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
         * + PostgreSQL - `COALESCE(x, (SELECT NULL UNION ALL SELECT x))`
         *   Unfortunately, with PostgreSQL, we need to duplicate the expression...
         *   But this is a debug expression, anyway, and should not be used often.
         * + SQLite     - `COALESCE(x, (SELECT NULL UNION ALL SELECT NULL))`
         */
        OperatorType["THROW_IF_NULL"] = "THROW_IF_NULL";
    })(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
});
define("ast/operator-node/operator-operand", ["require", "exports", "operator-type"], function (require, exports, operator_type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const _assertOperatorOperandComplete = undefined;
    _assertOperatorOperandComplete;
});
define("type-hint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TypeHint;
    (function (TypeHint) {
        TypeHint["DECIMAL"] = "DECIMAL";
        TypeHint["STRING"] = "STRING";
        TypeHint["DOUBLE"] = "DOUBLE";
        TypeHint["BIGINT_SIGNED"] = "BIGINT_SIGNED";
        TypeHint["BOOLEAN"] = "BOOLEAN";
        TypeHint["BUFFER"] = "BUFFER";
        TypeHint["NULL"] = "NULL";
        TypeHint["DATE_TIME"] = "DATE_TIME";
    })(TypeHint = exports.TypeHint || (exports.TypeHint = {}));
});
define("ast/operator-node/operator-node", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-0", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-1-to-n", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-2-to-n", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/assert-has-operand-3", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/operator-node/util/predicate/is-operator-node", ["require", "exports", "type-util/index"], function (require, exports, type_util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isOperatorNode(mixed) {
        if (!type_util_1.isObjectWithOwnEnumerableKeys()(mixed, [
            "type",
            "operatorType",
            "operands",
            "typeHint"
        ])) {
            return false;
        }
        return (mixed.type === "Operator");
    }
    exports.isOperatorNode = isOperatorNode;
});
define("ast/operator-node/util/predicate/index", ["require", "exports", "ast/operator-node/util/predicate/is-operator-node"], function (require, exports, is_operator_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_operator_node_1);
});
define("ast/operator-node/util/constructor/operator-node-0", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode0(operatorType, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: [],
            typeHint,
        };
    }
    exports.operatorNode0 = operatorNode0;
});
define("ast/operator-node/util/constructor/operator-node-1-to-n", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode1ToN(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: operands,
            typeHint,
        };
    }
    exports.operatorNode1ToN = operatorNode1ToN;
});
define("ast/operator-node/util/constructor/operator-node-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode1(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: operands,
            typeHint,
        };
    }
    exports.operatorNode1 = operatorNode1;
});
define("ast/operator-node/util/constructor/operator-node-2-to-n", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode2ToN(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: operands,
            typeHint,
        };
    }
    exports.operatorNode2ToN = operatorNode2ToN;
});
define("ast/operator-node/util/constructor/operator-node-2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode2(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: operands,
            typeHint,
        };
    }
    exports.operatorNode2 = operatorNode2;
});
define("ast/operator-node/util/constructor/operator-node-3", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode3(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands: operands,
            typeHint,
        };
    }
    exports.operatorNode3 = operatorNode3;
});
define("ast/operator-node/util/constructor/operator-node", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function operatorNode(operatorType, operands, typeHint) {
        return {
            type: "Operator",
            operatorType,
            operands,
            typeHint,
        };
    }
    exports.operatorNode = operatorNode;
});
define("ast/operator-node/util/constructor/index", ["require", "exports", "ast/operator-node/util/constructor/operator-node-0", "ast/operator-node/util/constructor/operator-node-1-to-n", "ast/operator-node/util/constructor/operator-node-1", "ast/operator-node/util/constructor/operator-node-2-to-n", "ast/operator-node/util/constructor/operator-node-2", "ast/operator-node/util/constructor/operator-node-3", "ast/operator-node/util/constructor/operator-node"], function (require, exports, operator_node_0_1, operator_node_1_to_n_1, operator_node_1_1, operator_node_2_to_n_1, operator_node_2_1, operator_node_3_1, operator_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operator_node_0_1);
    __export(operator_node_1_to_n_1);
    __export(operator_node_1_1);
    __export(operator_node_2_to_n_1);
    __export(operator_node_2_1);
    __export(operator_node_3_1);
    __export(operator_node_1);
});
define("ast/operator-node/util/index", ["require", "exports", "ast/operator-node/util/constructor/index", "ast/operator-node/util/predicate/index"], function (require, exports, constructor_1, predicate_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_1);
    __export(predicate_3);
});
define("ast/operator-node/index", ["require", "exports", "ast/operator-node/util/index"], function (require, exports, OperatorNodeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperatorNodeUtil = OperatorNodeUtil;
});
//import {BuiltInValueExpr} from "../../built-in-value-expr";
//import * as tm from "type-mapping";
define("ast/literal-value-node/literal-value-node", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LiteralValueType;
    (function (LiteralValueType) {
        /**
         * Can only be created using the `decimalLiteral()` function
         */
        LiteralValueType["DECIMAL"] = "DECIMAL";
        /**
         * ```ts
         * typeof x == "string"
         * ```
         */
        LiteralValueType["STRING"] = "STRING";
        /**
         * ```ts
         * typeof x == "number"
         * ```
         */
        LiteralValueType["DOUBLE"] = "DOUBLE";
        /**
         * ```ts
         * tm.TypeUtil.isBigInt(x) &&
         * //bigint signed minimum value
         * tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
         * //bigint signed maximum value
         * tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807"))
         * ```
         */
        LiteralValueType["BIGINT_SIGNED"] = "BIGINT_SIGNED";
        /**
         * ```ts
         * typeof x == "boolean"
         * ```
         */
        LiteralValueType["BOOLEAN"] = "BOOLEAN";
        /**
         * An unsigned char array (8-bit unsigned integer)
         * ```ts
         * x instanceof Uint8Array
         * ```
         * @todo Rename this to `UINT8ARRAY`?
         */
        LiteralValueType["BUFFER"] = "BUFFER";
        /**
         * ```ts
         * x === null
         * ```
         */
        LiteralValueType["NULL"] = "NULL";
        /**
         * ```ts
         * DateUtil.isDate(x)
         * ```
         */
        LiteralValueType["DATE_TIME"] = "DATE_TIME";
    })(LiteralValueType = exports.LiteralValueType || (exports.LiteralValueType = {}));
    exports.literalValueTypeElements = Object.values(LiteralValueType);
});
define("ast/literal-value-node/util/constructor/bigint-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node", "type-mapping"], function (require, exports, literal_value_node_1, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBigIntSigned(x) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return (
        //bigint signed minimum value
        tm.BigIntUtil.greaterThanOrEqual(x, BigInt("-9223372036854775808")) &&
            //bigint signed maximum value
            tm.BigIntUtil.lessThanOrEqual(x, BigInt("9223372036854775807")));
    }
    exports.isBigIntSigned = isBigIntSigned;
    /**
     * @todo Remove
     * @deprecated
     */
    function isBigIntUnsigned(x) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return (
        //bigint unsigned minimum value
        tm.BigIntUtil.greaterThanOrEqual(x, BigInt("0")) &&
            //bigint unsigned maximum value
            tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
    }
    exports.isBigIntUnsigned = isBigIntUnsigned;
    function isBigIntSignedLiteral(x) {
        return isBigIntSigned(x);
    }
    exports.isBigIntSignedLiteral = isBigIntSignedLiteral;
    /**
     * @todo Remove
     * @deprecated
     */
    function isBigIntUnsignedLiteral(x) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return (
        //bigint signed maximum value + 1
        tm.BigIntUtil.greaterThanOrEqual(x, BigInt("9223372036854775808")) &&
            //bigint unsigned maximum value
            tm.BigIntUtil.lessThanOrEqual(x, BigInt("18446744073709551615")));
    }
    exports.isBigIntUnsignedLiteral = isBigIntUnsignedLiteral;
    function bigIntSignedLiteralNode(literalValue) {
        if (isBigIntSignedLiteral(literalValue)) {
            return {
                type: "LiteralValue",
                literalValueType: literal_value_node_1.LiteralValueType.BIGINT_SIGNED,
                literalValue,
            };
        }
        else {
            //Can only really be an `BIGINT UNSIGNED` or `DECIMAL` value
            throw new Error(`Literal value is too small/large to be a signed bigint; consider using BIGINT UNSIGNED or DECIMAL`);
        }
    }
    exports.bigIntSignedLiteralNode = bigIntSignedLiteralNode;
});
define("ast/literal-value-node/util/constructor/boolean-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function booleanLiteralNode(literalValue) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_2.LiteralValueType.BOOLEAN,
            literalValue,
        };
    }
    exports.booleanLiteralNode = booleanLiteralNode;
});
define("ast/literal-value-node/util/constructor/buffer-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function bufferLiteralNode(literalValue) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_3.LiteralValueType.BUFFER,
            literalValue,
        };
    }
    exports.bufferLiteralNode = bufferLiteralNode;
});
define("ast/literal-value-node/util/constructor/date-time-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function dateTimeLiteralNode(literalValue) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_4.LiteralValueType.DATE_TIME,
            literalValue,
        };
    }
    exports.dateTimeLiteralNode = dateTimeLiteralNode;
});
define("decimal/decimal", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("decimal/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/column-identifier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/constructor/from-column-identifier-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumn(column) {
        const result = {
            tableAlias: column.tableAlias,
            columnAlias: column.columnAlias,
        };
        return result;
    }
    exports.fromColumn = fromColumn;
});
define("column-identifier/util/constructor/from-column-map", ["require", "exports", "column-identifier/util/constructor/from-column"], function (require, exports, from_column_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(map) {
        const result = [];
        for (const columnAlias of Object.keys(map)) {
            result.push(from_column_1.fromColumn(map[columnAlias]));
        }
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
});
define("column-identifier/util/constructor/from-column-ref", ["require", "exports", "column-identifier/util/constructor/from-column-map"], function (require, exports, from_column_map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnRef(ref) {
        const result = [];
        for (const tableAlias of Object.keys(ref)) {
            result.push(...from_column_map_1.fromColumnMap(ref[tableAlias]));
        }
        return result;
    }
    exports.fromColumnRef = fromColumnRef;
});
define("expr-select-item/expr-select-item", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr-select-item/util/operation/with-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function withType({ tableAlias, alias, usedRef, unaliasedAst, isAggregate, }, newMapper) {
        const result = {
            mapper: newMapper,
            tableAlias,
            alias,
            usedRef,
            isAggregate,
            unaliasedAst,
        };
        return result;
    }
    exports.withType = withType;
});
define("expr-select-item/util/operation/index", ["require", "exports", "expr-select-item/util/operation/with-type"], function (require, exports, with_type_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(with_type_1);
});
define("expr-select-item/util/predicate/is-expr-select-item", ["require", "exports", "type-util/index"], function (require, exports, type_util_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import {UsedRefUtil} from "../../../used-ref";
    //import {AstUtil} from "../../../ast";
    /**
     * Does not actually check,
     * + `x.usedRef` is `IUsedRef`
     * + `x.unaliasedAst` is `Ast`
     *
     * @todo Consider adding checks for increased type safety.
     */
    function isExprSelectItem(x) {
        if (!type_util_2.isObjectWithOwnEnumerableKeys()(x, [
            "mapper",
            "tableAlias",
            "alias",
            "usedRef",
            "isAggregate",
            "unaliasedAst",
        ])) {
            return false;
        }
        return ((typeof x.mapper == "function") &&
            (typeof x.tableAlias == "string") &&
            (typeof x.alias == "string") //&&
        //UsedRefUtil.isUsedRef(x.usedRef) &&
        //(typeof x.isAggregate == "boolean") &&
        //AstUtil.isAst(x.ast)
        );
    }
    exports.isExprSelectItem = isExprSelectItem;
});
define("expr-select-item/util/predicate/index", ["require", "exports", "expr-select-item/util/predicate/is-expr-select-item"], function (require, exports, is_expr_select_item_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_expr_select_item_1);
});
define("expr-select-item/util/index", ["require", "exports", "expr-select-item/util/operation/index", "expr-select-item/util/predicate/index"], function (require, exports, operation_1, predicate_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_1);
    __export(predicate_4);
});
define("expr-select-item/index", ["require", "exports", "expr-select-item/util/index"], function (require, exports, ExprSelectItemUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExprSelectItemUtil = ExprSelectItemUtil;
});
define("column-identifier/util/constructor/from-expr-select-item", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromExprSelectItem(column) {
        const result = {
            tableAlias: column.tableAlias,
            columnAlias: column.alias,
        };
        return result;
    }
    exports.fromExprSelectItem = fromExprSelectItem;
});
define("column/column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("column-map/util/constructor/from-column-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnArray(columns) {
        const result = {};
        for (const column of columns) {
            result[column.columnAlias] = column;
        }
        return result;
    }
    exports.fromColumnArray = fromColumnArray;
});
define("column-map/util/constructor/from-column-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumn(column) {
        return {
            [column.columnAlias]: column
        };
    }
    exports.fromColumn = fromColumn;
});
define("column-map/util/constructor/from-field-array", ["require", "exports", "column/index"], function (require, exports, column_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromFieldArray(tableAlias, fields) {
        const result = {};
        for (const field of fields) {
            result[field.__name] = new column_1.Column({
                tableAlias: tableAlias,
                columnAlias: field.__name,
                mapper: field,
            }, undefined);
        }
        return result;
    }
    exports.fromFieldArray = fromFieldArray;
});
define("column-map/util/operation/left-compound", ["require", "exports", "type-mapping", "column/index"], function (require, exports, tm, column_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftCompound(mapA, mapB) {
        const result = {};
        for (const columnAlias of Object.keys(mapA)) {
            const columnA = mapA[columnAlias];
            const columnB = mapB[columnAlias];
            if (column_2.ColumnUtil.isColumn(columnB)) {
                result[columnAlias] = new column_2.Column({
                    tableAlias: columnA.tableAlias,
                    columnAlias: columnA.columnAlias,
                    mapper: tm.or(columnA.mapper, mapB[columnAlias].mapper),
                }, columnA.unaliasedAst);
            }
            else {
                result[columnAlias] = columnA;
            }
        }
        return result;
    }
    exports.leftCompound = leftCompound;
    ;
});
define("column-map/util/operation/compound", ["require", "exports", "column-map/util/operation/left-compound"], function (require, exports, left_compound_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compound(mapA, mapB) {
        const left = left_compound_1.leftCompound(mapA, mapB);
        const right = {};
        for (const columnAlias of Object.keys(mapB)) {
            if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
                Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
                continue;
            }
            right[columnAlias] = mapB[columnAlias];
        }
        return {
            ...left,
            ...right,
        };
    }
    exports.compound = compound;
});
define("data-type/util/constructor/make-data-type", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeDataType(mapper, toBuiltInExpr_NonCorrelated, isNullSafeEqual, extraMapper) {
        const myMapper = (extraMapper == undefined ?
            mapper :
            tm.pipe(mapper, extraMapper));
        function dataType(name, mixed) {
            return myMapper(name, mixed);
        }
        dataType.toBuiltInExpr_NonCorrelated = toBuiltInExpr_NonCorrelated;
        dataType.isNullSafeEqual = isNullSafeEqual;
        dataType.orNull = () => {
            return makeDataType(tm.orNull(myMapper), (value) => {
                if (value === null) {
                    return null;
                }
                else {
                    const rawExpr = toBuiltInExpr_NonCorrelated(value);
                    return rawExpr;
                }
            }, (a, b) => {
                if (a === null) {
                    if (b === null) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    if (b === null) {
                        return false;
                    }
                    else {
                        return isNullSafeEqual(a, b);
                    }
                }
            });
        };
        return dataType;
    }
    exports.makeDataType = makeDataType;
});
define("data-type/util/constructor/index", ["require", "exports", "data-type/util/constructor/make-data-type"], function (require, exports, make_data_type_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(make_data_type_1);
});
define("key/key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/operation/remove-duplicates", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeDuplicates(key) {
        const result = [];
        for (const str of key) {
            if (!result.includes(str)) {
                result.push(str);
            }
        }
        return result;
    }
    exports.removeDuplicates = removeDuplicates;
});
define("key/util/operation/append", ["require", "exports", "key/util/operation/remove-duplicates"], function (require, exports, remove_duplicates_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function append(key, str) {
        return remove_duplicates_1.removeDuplicates([...key, str]);
    }
    exports.append = append;
});
define("key/util/operation/concat", ["require", "exports", "key/util/operation/remove-duplicates"], function (require, exports, remove_duplicates_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function concat(a, b) {
        return remove_duplicates_2.removeDuplicates([...a, ...b]);
    }
    exports.concat = concat;
});
define("key/util/operation/extract-sub-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/operation/extract-super-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/operation/remove", ["require", "exports", "key/util/operation/remove-duplicates"], function (require, exports, remove_duplicates_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function remove(key, str) {
        const result = remove_duplicates_3.removeDuplicates(key.filter(s => s != str));
        return result;
    }
    exports.remove = remove;
});
define("key/util/operation/subtract", ["require", "exports", "key/util/operation/remove-duplicates"], function (require, exports, remove_duplicates_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function subtract(a, b) {
        const result = remove_duplicates_4.removeDuplicates(a.filter(s => !b.includes(s)));
        return result;
    }
    exports.subtract = subtract;
});
define("key/util/operation/to-error-message-friendly-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/operation/index", ["require", "exports", "key/util/operation/append", "key/util/operation/concat", "key/util/operation/remove-duplicates", "key/util/operation/remove", "key/util/operation/subtract"], function (require, exports, append_1, concat_1, remove_duplicates_5, remove_1, subtract_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(append_1);
    __export(concat_1);
    __export(remove_duplicates_5);
    __export(remove_1);
    __export(subtract_1);
});
define("key/util/constructor/from-column-array", ["require", "exports", "key/util/operation/index"], function (require, exports, operation_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnArray(columns) {
        const result = operation_2.removeDuplicates(columns.map(c => c.columnAlias));
        return result;
    }
    exports.fromColumnArray = fromColumnArray;
});
define("key/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumn(column) {
        const result = [column.columnAlias];
        return result;
    }
    exports.fromColumn = fromColumn;
});
define("key/util/constructor/index", ["require", "exports", "key/util/constructor/from-column-array", "key/util/constructor/from-column"], function (require, exports, from_column_array_1, from_column_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_array_1);
    __export(from_column_2);
});
define("key/util/predicate/is-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isKey(raw) {
        if (!(Array.isArray(raw))) {
            return false;
        }
        for (const item of raw) {
            if (typeof item != "string") {
                return false;
            }
        }
        return true;
    }
    exports.isKey = isKey;
});
define("key/util/predicate/is-sub-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSubKey(a, b) {
        return a.every(aKey => b.includes(aKey));
    }
    exports.isSubKey = isSubKey;
});
define("key/util/predicate/is-equal", ["require", "exports", "key/util/predicate/is-sub-key"], function (require, exports, is_sub_key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isEqual(a, b) {
        return (is_sub_key_1.isSubKey(a, b) &&
            is_sub_key_1.isSubKey(b, a));
    }
    exports.isEqual = isEqual;
});
define("key/util/predicate/index", ["require", "exports", "key/util/predicate/is-key", "key/util/predicate/is-equal", "key/util/predicate/is-sub-key"], function (require, exports, is_key_1, is_equal_2, is_sub_key_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_key_1);
    __export(is_equal_2);
    __export(is_sub_key_2);
});
define("key/util/query/exclude-if-in-key-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/query/extract-if-in-column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/query/extract-if-in-key-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/query/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/util/index", ["require", "exports", "key/util/constructor/index", "key/util/operation/index", "key/util/predicate/index"], function (require, exports, constructor_2, operation_3, predicate_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_2);
    __export(operation_3);
    __export(predicate_5);
});
define("key/array-util/predicate/has-key", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasKey(arr, key) {
        for (const k of arr) {
            if (KeyUtil.isEqual(k, key)) {
                return true;
            }
        }
        return false;
    }
    exports.hasKey = hasKey;
});
define("key/array-util/predicate/has-sub-key", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasSubKey(arr, key) {
        for (const k of arr) {
            if (KeyUtil.isSubKey(k, key)) {
                return true;
            }
        }
        return false;
    }
    exports.hasSubKey = hasSubKey;
});
define("key/array-util/predicate/has-super-key", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasSuperKey(arr, key) {
        for (const k of arr) {
            if (KeyUtil.isSubKey(key, k)) {
                return true;
            }
        }
        return false;
    }
    exports.hasSuperKey = hasSuperKey;
});
define("key/array-util/predicate/is-key-array", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isKeyArray(raw) {
        if (!Array.isArray(raw)) {
            return false;
        }
        for (const item of raw) {
            if (!KeyUtil.isKey(item)) {
                return false;
            }
        }
        return true;
    }
    exports.isKeyArray = isKeyArray;
});
define("key/array-util/predicate/is-disjoint", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDisjoint(arrayA, arrayB) {
        for (const a of arrayA) {
            for (const b of arrayB) {
                if (KeyUtil.isEqual(a, b)) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.isDisjoint = isDisjoint;
});
define("key/array-util/predicate/index", ["require", "exports", "key/array-util/predicate/has-key", "key/array-util/predicate/has-sub-key", "key/array-util/predicate/has-super-key", "key/array-util/predicate/is-key-array", "key/array-util/predicate/is-disjoint"], function (require, exports, has_key_1, has_sub_key_1, has_super_key_1, is_key_array_1, is_disjoint_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(has_key_1);
    __export(has_sub_key_1);
    __export(has_super_key_1);
    __export(is_key_array_1);
    __export(is_disjoint_1);
});
define("key/array-util/operation/remove-duplicates", ["require", "exports", "key/array-util/predicate/index", "key/util/index"], function (require, exports, predicate_6, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeDuplicates(arr) {
        const result = [];
        for (const key of arr) {
            if (!predicate_6.hasKey(result, key)) {
                result.push(KeyUtil.removeDuplicates(key));
            }
        }
        return result;
    }
    exports.removeDuplicates = removeDuplicates;
});
define("key/array-util/operation/append", ["require", "exports", "key/array-util/operation/remove-duplicates"], function (require, exports, remove_duplicates_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function append(arr, key) {
        return remove_duplicates_6.removeDuplicates([...arr, key]);
    }
    exports.append = append;
});
define("key/array-util/operation/index", ["require", "exports", "key/array-util/operation/append", "key/array-util/operation/remove-duplicates"], function (require, exports, append_2, remove_duplicates_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(append_2);
    __export(remove_duplicates_7);
});
define("key/array-util/query/extract-keys-in-common", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("key/array-util/query/find-sub-key", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function findSubKeys(arr, key) {
        const result = [];
        for (const k of arr) {
            if (KeyUtil.isSubKey(k, key)) {
                result.push(k);
            }
        }
        return result;
    }
    exports.findSubKeys = findSubKeys;
});
define("key/array-util/query/find-super-key", ["require", "exports", "key/util/index"], function (require, exports, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function findSuperKeys(arr, key) {
        const result = [];
        for (const k of arr) {
            if (KeyUtil.isSubKey(key, k)) {
                result.push(k);
            }
        }
        return result;
    }
    exports.findSuperKeys = findSuperKeys;
});
define("key/array-util/query/index", ["require", "exports", "key/array-util/query/find-sub-key", "key/array-util/query/find-super-key"], function (require, exports, find_sub_key_1, find_super_key_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(find_sub_key_1);
    __export(find_super_key_1);
});
define("key/array-util/index", ["require", "exports", "key/array-util/operation/index", "key/array-util/predicate/index", "key/array-util/query/index"], function (require, exports, operation_4, predicate_7, query_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_4);
    __export(predicate_7);
    __export(query_1);
});
define("key/index", ["require", "exports", "key/array-util/index", "key/util/index"], function (require, exports, KeyArrayUtil, KeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyArrayUtil = KeyArrayUtil;
    exports.KeyUtil = KeyUtil;
});
define("aliased-table/aliased-table", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A table can be aliased,
     *
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * CROSS JOIN
     *  (
     *      myTable
     *  ) AS otherTable --This is an `AliasedTable`
     * ```
     *
     * For aliasing a query (derived tables), @see {@link DerivedTable}
     */
    class AliasedTable {
        constructor(data, unaliasedAst) {
            this.isLateral = data.isLateral;
            this.alias = data.alias;
            this.columns = data.columns;
            this.usedRef = data.usedRef;
            this.unaliasedAst = unaliasedAst;
        }
    }
    exports.AliasedTable = AliasedTable;
});
define("aliased-table/util/query/candidate-keys", ["require", "exports", "table/index"], function (require, exports, table_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function candidateKeys(aliasedTable) {
        if (table_1.TableUtil.isTable(aliasedTable)) {
            return aliasedTable.candidateKeys;
        }
        else {
            return [];
        }
    }
    exports.candidateKeys = candidateKeys;
});
define("aliased-table/util/query/delete-enabled", ["require", "exports", "table/index"], function (require, exports, table_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function deleteEnabled(aliasedTable) {
        if (table_2.TableUtil.isTable(aliasedTable)) {
            return aliasedTable.deleteEnabled;
        }
        else {
            return false;
        }
    }
    exports.deleteEnabled = deleteEnabled;
});
define("aliased-table/util/query/extract-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("aliased-table/util/query/mutable-columns", ["require", "exports", "table/index"], function (require, exports, table_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mutableColumns(aliasedTable) {
        if (table_3.TableUtil.isTable(aliasedTable)) {
            return aliasedTable.mutableColumns;
        }
        else {
            return [];
        }
    }
    exports.mutableColumns = mutableColumns;
});
define("aliased-table/util/query/primary-key", ["require", "exports", "table/index"], function (require, exports, table_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function primaryKey(aliasedTable) {
        if (table_4.TableUtil.isTable(aliasedTable)) {
            return aliasedTable.primaryKey;
        }
        else {
            return undefined;
        }
    }
    exports.primaryKey = primaryKey;
});
define("aliased-table/util/query/index", ["require", "exports", "aliased-table/util/query/candidate-keys", "aliased-table/util/query/delete-enabled", "aliased-table/util/query/mutable-columns", "aliased-table/util/query/primary-key"], function (require, exports, candidate_keys_1, delete_enabled_1, mutable_columns_1, primary_key_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(candidate_keys_1);
    __export(delete_enabled_1);
    __export(mutable_columns_1);
    __export(primary_key_1);
});
define("aliased-table/util/index", ["require", "exports", "aliased-table/util/query/index"], function (require, exports, query_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_2);
});
define("aliased-table/array-util/query/duplicate-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function duplicateTableAlias(arr) {
        const result = [];
        for (let i = 0; i < arr.length; ++i) {
            const cur = arr[i].alias;
            for (let j = i + 1; j < arr.length; ++j) {
                const nxt = arr[j].alias;
                if (cur == nxt && !result.includes(cur)) {
                    result.push(cur);
                }
            }
        }
        return result;
    }
    exports.duplicateTableAlias = duplicateTableAlias;
});
define("aliased-table/array-util/query/index", ["require", "exports", "aliased-table/array-util/query/duplicate-table-alias"], function (require, exports, duplicate_table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(duplicate_table_alias_1);
});
define("aliased-table/array-util/predicate/assert-no-duplicate-table-alias", ["require", "exports", "aliased-table/array-util/query/index"], function (require, exports, query_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNoDuplicateTableAlias(arr) {
        const duplicates = query_3.duplicateTableAlias(arr);
        if (duplicates.length > 0) {
            throw new Error(`Duplicate table alias not allowed; ${duplicates.join(", ")}`);
        }
    }
    exports.assertNoDuplicateTableAlias = assertNoDuplicateTableAlias;
});
define("aliased-table/array-util/predicate/index", ["require", "exports", "aliased-table/array-util/predicate/assert-no-duplicate-table-alias"], function (require, exports, assert_no_duplicate_table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_no_duplicate_table_alias_1);
});
define("aliased-table/array-util/index", ["require", "exports", "aliased-table/array-util/predicate/index", "aliased-table/array-util/query/index"], function (require, exports, predicate_8, query_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_8);
    __export(query_4);
});
define("aliased-table/index", ["require", "exports", "aliased-table/aliased-table", "aliased-table/array-util/index", "aliased-table/util/index"], function (require, exports, aliased_table_1, AliasedTableArrayUtil, AliasedTableUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aliased_table_1);
    exports.AliasedTableArrayUtil = AliasedTableArrayUtil;
    exports.AliasedTableUtil = AliasedTableUtil;
});
define("table/table", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/constructor/from-table-alias", ["require", "exports", "table/table-impl", "used-ref/index", "ast/index"], function (require, exports, table_impl_1, used_ref_1, ast_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a table with the given alias
     *
     * @param tableAlias
     */
    function fromTableAlias(tableAlias) {
        const result = new table_impl_1.Table({
            isLateral: false,
            alias: tableAlias,
            columns: {},
            usedRef: used_ref_1.UsedRefUtil.fromColumnRef({}),
            autoIncrement: undefined,
            id: undefined,
            primaryKey: undefined,
            candidateKeys: [],
            insertEnabled: true,
            deleteEnabled: true,
            generatedColumns: [],
            nullableColumns: [],
            explicitDefaultValueColumns: [],
            mutableColumns: [],
            explicitAutoIncrementValueEnabled: false,
        }, ast_1.identifierNode(tableAlias));
        return result;
    }
    exports.fromTableAlias = fromTableAlias;
});
define("table/util/constructor/from-table", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a copy of the `table`
     *
     * @param table
     */
    function fromTable(table) {
        const result = new table_impl_2.Table(table, table.unaliasedAst);
        return result;
    }
    exports.fromTable = fromTable;
});
define("table/util/constructor/index", ["require", "exports", "table/util/constructor/from-table-alias", "table/util/constructor/from-table"], function (require, exports, from_table_alias_1, from_table_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_table_alias_1);
    __export(from_table_1);
});
define("event/transaction-listener-collection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("event/event-base", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class EventBase {
        constructor(args) {
            this.onCommitListeners = [];
            this.onRollbackListeners = [];
            this.pool = args.connection.pool;
            this.connection = args.connection;
        }
        /**
         * If the `listener` has already been added, it will be ignored.
         */
        addOnCommitListener(listener) {
            if (this.onCommitListeners.includes(listener)) {
                /**
                 * We do not want duplicate listener references.
                 */
                return;
            }
            this.onCommitListeners = [...this.onCommitListeners, listener];
        }
        /**
         * If the `listener` has already been added, it will be ignored.
         */
        addOnRollbackListener(listener) {
            if (this.onRollbackListeners.includes(listener)) {
                /**
                 * We do not want duplicate listener references.
                 */
                return;
            }
            this.onRollbackListeners = [...this.onRollbackListeners, listener];
        }
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnCommitListeners() {
            const syncErrors = [];
            for (const listener of this.onCommitListeners) {
                try {
                    listener();
                }
                catch (err) {
                    syncErrors.push(err);
                }
            }
            return { syncErrors };
        }
        /**
         * For now,
         * + This should not throw.
         * + This must not wait for `async` listeners to complete.
         * + This will not catch `async` errors.
         *
         * @returns - All synchronous errors.
         */
        invokeOnRollbackListeners() {
            const syncErrors = [];
            for (const listener of this.onRollbackListeners) {
                try {
                    listener();
                }
                catch (err) {
                    syncErrors.push(err);
                }
            }
            return { syncErrors };
        }
    }
    exports.EventBase = EventBase;
});
define("event/event-handler", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("event/pool-event-emitter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PoolEventEmitter {
        constructor() {
            /**
             * We want to avoid mutating arrays because it may mess up our loops.
             * We might add/remove handlers while invoking a handler.
             */
            this.handlers = [];
        }
        /**
         * If the `handler` has already been added, it will be ignored.
         */
        addHandler(handler) {
            if (this.handlers.includes(handler)) {
                /**
                 * We do not want duplicate handler references.
                 */
                return;
            }
            this.handlers = [...this.handlers, handler];
        }
        removeHandler(handler) {
            /**
             * We should not have duplicates
             */
            const index = this.handlers.indexOf(handler);
            if (index < 0) {
                return;
            }
            this.handlers = [
                ...this.handlers.slice(0, index),
                ...this.handlers.slice(index + 1),
            ];
        }
        getHandlers() {
            return this.handlers;
        }
    }
    exports.PoolEventEmitter = PoolEventEmitter;
});
define("event/connection-event-emitter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ConnectionEventEmitter {
        constructor(poolEventEmitter, addTransactionListenerCollectionImpl) {
            this.poolEventEmitter = poolEventEmitter;
            this.addEventImpl = addTransactionListenerCollectionImpl;
        }
        /**
         * This may throw
         */
        async invoke(event) {
            const handlers = this.poolEventEmitter.getHandlers();
            if (handlers.length == 0) {
                /**
                 * There are no handlers.
                 * There's nothing for us to do here.
                 */
                return;
            }
            //This should not throw.
            this.addEventImpl(event);
            //This loop may throw.
            for (const handler of handlers) {
                await handler(event);
            }
        }
    }
    exports.ConnectionEventEmitter = ConnectionEventEmitter;
});
define("custom-expr/custom-expr", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("on-clause/on-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-ref/column-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
    ;
});
define("column-ref/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setColumn(ref, column) {
        let map = ref[column.tableAlias];
        if (map == undefined) {
            map = {};
            ref[column.tableAlias] = map;
        }
        map[column.columnAlias] = column;
        return ref;
    }
    exports.setColumn = setColumn;
    function fromColumn(column) {
        return setColumn({}, column);
    }
    exports.fromColumn = fromColumn;
});
define("column-ref/util/constructor/from-column-array", ["require", "exports", "column-ref/util/constructor/from-column"], function (require, exports, from_column_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnArray(columns) {
        const result = {};
        for (const column of columns) {
            from_column_3.setColumn(result, column);
        }
        return result;
    }
    exports.fromColumnArray = fromColumnArray;
});
define("column-ref/util/constructor/from-column-map", ["require", "exports", "column-ref/util/constructor/from-column"], function (require, exports, from_column_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setColumnMap(ref, map) {
        for (const columnAlias of Object.keys(map)) {
            from_column_4.setColumn(ref, map[columnAlias]);
        }
    }
    exports.setColumnMap = setColumnMap;
});
define("column-ref/util/constructor/from-join", ["require", "exports", "column-map/index", "column-ref/util/constructor/from-column-map"], function (require, exports, column_map_1, from_column_map_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setJoin(ref, join) {
        from_column_map_2.setColumnMap(ref, column_map_1.ColumnMapUtil.fromJoin(join));
    }
    exports.setJoin = setJoin;
});
define("column-ref/util/constructor/from-join-array", ["require", "exports", "column-ref/util/constructor/from-join"], function (require, exports, from_join_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setJoinArray(ref, joins) {
        for (const join of joins) {
            from_join_1.setJoin(ref, join);
        }
    }
    exports.setJoinArray = setJoinArray;
    function fromJoinArray(joins) {
        const result = {};
        setJoinArray(result, joins);
        return result;
    }
    exports.fromJoinArray = fromJoinArray;
});
define("column-ref/util/constructor/from-from-clause", ["require", "exports", "column-ref/util/constructor/from-join-array"], function (require, exports, from_join_array_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setFromClause(ref, fromClause) {
        if (fromClause.currentJoins != undefined) {
            from_join_array_1.setJoinArray(ref, fromClause.currentJoins);
        }
        if (fromClause.outerQueryJoins != undefined) {
            from_join_array_1.setJoinArray(ref, fromClause.outerQueryJoins);
        }
    }
    exports.setFromClause = setFromClause;
    function fromFromClause(fromClause) {
        const result = {};
        setFromClause(result, fromClause);
        return result;
    }
    exports.fromFromClause = fromFromClause;
});
define("column-ref/util/constructor/from-column-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-ref/util/constructor/from-select-clause", ["require", "exports", "column/index", "column-ref/util/constructor/from-column"], function (require, exports, column_3, from_column_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromSelectClause(selectClause) {
        const result = {};
        for (const column of column_3.ColumnUtil.fromSelectClause(selectClause)) {
            from_column_5.setColumn(result, column);
        }
        return result;
    }
    exports.fromSelectClause = fromSelectClause;
});
define("column-ref/util/constructor/index", ["require", "exports", "column-ref/util/constructor/from-column-array", "column-ref/util/constructor/from-column", "column-ref/util/constructor/from-from-clause", "column-ref/util/constructor/from-join-array", "column-ref/util/constructor/from-select-clause"], function (require, exports, from_column_array_2, from_column_6, from_from_clause_1, from_join_array_2, from_select_clause_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_array_2);
    __export(from_column_6);
    __export(from_from_clause_1);
    __export(from_join_array_2);
    __export(from_select_clause_1);
});
define("column-ref/util/operation/left-compound", ["require", "exports", "column-map/index"], function (require, exports, column_map_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftCompound(refA, refB) {
        const result = {};
        for (const tableAlias of Object.keys(refA)) {
            if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
                result[tableAlias] = column_map_2.ColumnMapUtil.compound(refA[tableAlias], refB[tableAlias]);
            }
            else {
                result[tableAlias] = refA[tableAlias];
            }
        }
        return result;
    }
    exports.leftCompound = leftCompound;
});
define("column-ref/util/operation/compound", ["require", "exports", "column-ref/util/operation/left-compound"], function (require, exports, left_compound_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compound(refA, refB) {
        const left = left_compound_2.leftCompound(refA, refB);
        const right = {};
        for (const tableAlias of Object.keys(refB)) {
            if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
                continue;
            }
            right[tableAlias] = refB[tableAlias];
        }
        return {
            ...left,
            ...right,
        };
    }
    exports.compound = compound;
});
define("column-ref/util/operation/left-intersect", ["require", "exports", "column-map/index"], function (require, exports, column_map_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftIntersect(refA, refB) {
        const result = {};
        for (const tableAlias of Object.keys(refA)) {
            if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
                result[tableAlias] = column_map_3.ColumnMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
            }
            else {
                result[tableAlias] = refA[tableAlias];
            }
        }
        return result;
    }
    exports.leftIntersect = leftIntersect;
});
define("column-ref/util/operation/intersect", ["require", "exports", "column-ref/util/operation/left-intersect"], function (require, exports, left_intersect_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(refA, refB) {
        const left = left_intersect_1.leftIntersect(refA, refB);
        const right = {};
        for (const tableAlias of Object.keys(refB)) {
            if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
                continue;
            }
            right[tableAlias] = refB[tableAlias];
        }
        return {
            ...left,
            ...right,
        };
    }
    exports.intersect = intersect;
});
define("column-ref/util/query/has-one-table", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-ref/util/operation/try-flatten", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryFlatten(ref) {
        const tableAliases = Object.keys(ref);
        if (tableAliases.length == 1) {
            return ref[tableAliases[0]];
        }
        else {
            return ref;
        }
    }
    exports.tryFlatten = tryFlatten;
});
define("column-ref/util/operation/index", ["require", "exports", "column-ref/util/operation/compound", "column-ref/util/operation/intersect", "column-ref/util/operation/try-flatten"], function (require, exports, compound_1, intersect_1, try_flatten_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_1);
    __export(intersect_1);
    __export(try_flatten_1);
});
define("column-ref/util/predicate/is-column-ref", ["require", "exports", "column-map/index"], function (require, exports, column_map_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isColumnRef(mixed) {
        if (!(mixed instanceof Object)) {
            return false;
        }
        for (const tableAlias of Object.keys(mixed)) {
            const possiblyColumnMap = mixed[tableAlias];
            if (!column_map_4.ColumnMapUtil.isColumnMap(possiblyColumnMap)) {
                return false;
            }
        }
        return true;
    }
    exports.isColumnRef = isColumnRef;
});
define("column-ref/util/predicate/index", ["require", "exports", "column-ref/util/predicate/is-column-ref"], function (require, exports, is_column_ref_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_column_ref_1);
});
define("column-ref/util/query/column-alias", ["require", "exports", "column-map/index"], function (require, exports, column_map_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function columnAlias(ref) {
        const result = [];
        for (const tableAlias of Object.keys(ref)) {
            result.push(...column_map_5.ColumnMapUtil.columnAlias(ref[tableAlias]));
        }
        return result;
    }
    exports.columnAlias = columnAlias;
});
define("column-ref/util/query/duplicate-column-alias", ["require", "exports", "column-map/index"], function (require, exports, column_map_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function duplicateColumnAlias(ref) {
        const duplicateTracker = {};
        const result = [];
        for (const tableAlias of Object.keys(ref)) {
            for (const columnAlias of column_map_6.ColumnMapUtil.columnAlias(ref[tableAlias])) {
                const isDuplicate = duplicateTracker[columnAlias];
                if (isDuplicate === undefined) {
                    /**
                     * We had never encountered it, and now we have.
                     * But it isn't a duplicate.
                     */
                    duplicateTracker[columnAlias] = false;
                }
                else if (!isDuplicate) {
                    /**
                     * We had encountered it when it wasn't a duplicate.
                     * Now, it is a duplicate.
                     */
                    duplicateTracker[columnAlias] = true;
                    result.push(columnAlias);
                }
            }
        }
        return result;
    }
    exports.duplicateColumnAlias = duplicateColumnAlias;
});
define("column-ref/util/query/extract-column-identifier", ["require", "exports", "column-map/index"], function (require, exports, column_map_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractColumnIdentifiers(ref, columnIdentifiers) {
        const result = {};
        for (const tableAlias of Object.keys(ref)) {
            const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
            if (arr.length > 0) {
                result[tableAlias] = column_map_7.ColumnMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
            }
        }
        return result;
    }
    exports.extractColumnIdentifiers = extractColumnIdentifiers;
});
define("column-ref/util/query/extract-non-nullable", ["require", "exports", "column-map/index"], function (require, exports, column_map_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractNonNullable(ref) {
        const result = {};
        for (const tableAlias of Object.keys(ref)) {
            result[tableAlias] = column_map_8.ColumnMapUtil.extractNonNullable(ref[tableAlias]);
        }
        return result;
    }
    exports.extractNonNullable = extractNonNullable;
});
define("column-ref/util/query/extract-nullable", ["require", "exports", "column-map/index"], function (require, exports, column_map_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractNullable(ref) {
        const result = {};
        for (const tableAlias of Object.keys(ref)) {
            result[tableAlias] = column_map_9.ColumnMapUtil.extractNullable(ref[tableAlias]);
        }
        return result;
    }
    exports.extractNullable = extractNullable;
});
define("column-ref/util/query/extract-with-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns `ref` without modifying it.
     * Is basically a no-op.
     *
     * This function merely exists to enforce compile-time safety.
     */
    function __noOp_extractWithType() {
        return (ref) => ref;
    }
    exports.__noOp_extractWithType = __noOp_extractWithType;
});
define("column-ref/util/query/find-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-ref/util/query/index", ["require", "exports", "column-ref/util/query/column-alias", "column-ref/util/query/duplicate-column-alias", "column-ref/util/query/extract-column-identifier", "column-ref/util/query/extract-non-nullable", "column-ref/util/query/extract-nullable", "column-ref/util/query/extract-with-type"], function (require, exports, column_alias_1, duplicate_column_alias_1, extract_column_identifier_1, extract_non_nullable_1, extract_nullable_1, extract_with_type_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_alias_1);
    __export(duplicate_column_alias_1);
    __export(extract_column_identifier_1);
    __export(extract_non_nullable_1);
    __export(extract_nullable_1);
    __export(extract_with_type_1);
});
define("column-ref/util/index", ["require", "exports", "column-ref/util/constructor/index", "column-ref/util/operation/index", "column-ref/util/predicate/index", "column-ref/util/query/index"], function (require, exports, constructor_3, operation_5, predicate_9, query_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_3);
    __export(operation_5);
    __export(predicate_9);
    __export(query_5);
});
define("column-ref/index", ["require", "exports", "column-ref/util/index"], function (require, exports, ColumnRefUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnRefUtil = ColumnRefUtil;
});
define("on-clause/util/query/allowed-used-ref", ["require", "exports", "column-ref/index", "join/index", "used-ref/index"], function (require, exports, column_ref_1, join_1, used_ref_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedColumnRef(fromClause, aliasedTable) {
        return column_ref_1.ColumnRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
        /**
         * We don't care about the `JoinType` for this temporary array
         */
        join_1.JoinType.FROM, 
        /**
         * We don't care about the `ON` clause either
         */
        undefined)));
    }
    exports.allowedColumnRef = allowedColumnRef;
    function allowedUsedRef(fromClause, aliasedTable) {
        /**
         * @todo Investigate assignability
         */
        return used_ref_2.UsedRefUtil.fromJoinArray(join_1.JoinArrayUtil.append(join_1.JoinArrayUtil.append(fromClause.currentJoins, ...(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins)), join_1.JoinUtil.fromAliasedTable(aliasedTable, false, 
        /**
         * We don't care about the `JoinType` for this temporary array
         */
        join_1.JoinType.FROM, 
        /**
         * We don't care about the `ON` clause either
         */
        undefined)));
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("on-clause/util/query/index", ["require", "exports", "on-clause/util/query/allowed-used-ref"], function (require, exports, allowed_used_ref_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_used_ref_1);
});
define("on-clause/util/predicate/assert-no-outer-query-used-ref", ["require", "exports", "from-clause/index", "built-in-expr/index"], function (require, exports, from_clause_1, built_in_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNoOuterQueryUsedRef(fromClause, rawOnClause) {
        const outerQueryTableAliases = from_clause_1.FromClauseUtil.outerQueryTableAlias(fromClause);
        const usedOuterQueryTableAliases = Object.keys(built_in_expr_1.BuiltInExprUtil.usedRef(rawOnClause).columns)
            .filter(usedTableAlias => {
            return outerQueryTableAliases.includes(usedTableAlias);
        });
        if (usedOuterQueryTableAliases.length > 0) {
            throw new Error(`ON clause must not reference outer query tables ${usedOuterQueryTableAliases.join(",")}`);
        }
    }
    exports.assertNoOuterQueryUsedRef = assertNoOuterQueryUsedRef;
});
define("on-clause/util/predicate/assert-valid-used-ref", ["require", "exports", "built-in-expr/index", "on-clause/util/query/index", "used-ref/index"], function (require, exports, built_in_expr_2, query_6, used_ref_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidUsedRef(fromClause, aliasedTable, rawOnClause) {
        used_ref_3.UsedRefUtil.assertAllowed(query_6.allowedUsedRef(fromClause, aliasedTable), built_in_expr_2.BuiltInExprUtil.usedRef(rawOnClause));
    }
    exports.assertValidUsedRef = assertValidUsedRef;
});
define("on-clause/util/predicate/index", ["require", "exports", "on-clause/util/predicate/assert-no-outer-query-used-ref", "on-clause/util/predicate/assert-valid-used-ref"], function (require, exports, assert_no_outer_query_used_ref_1, assert_valid_used_ref_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_no_outer_query_used_ref_1);
    __export(assert_valid_used_ref_1);
});
define("on-clause/util/operation/on", ["require", "exports", "on-clause/util/query/index", "on-clause/util/predicate/index", "expr/index"], function (require, exports, query_7, predicate_10, expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function on(fromClause, aliasedTable, onDelegate) {
        const columns = query_7.allowedColumnRef(fromClause, aliasedTable);
        const rawOnClause = onDelegate(columns);
        predicate_10.assertValidUsedRef(fromClause, aliasedTable, rawOnClause);
        return expr_1.ExprUtil.fromBuiltInExpr(rawOnClause);
    }
    exports.on = on;
});
define("on-clause/util/operation/index", ["require", "exports", "on-clause/util/operation/on"], function (require, exports, on_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(on_1);
});
define("on-clause/util/index", ["require", "exports", "on-clause/util/operation/index", "on-clause/util/predicate/index", "on-clause/util/query/index"], function (require, exports, operation_6, predicate_11, query_8) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_6);
    __export(predicate_11);
    __export(query_8);
});
define("on-clause/on-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("on-clause/index", ["require", "exports", "on-clause/util/index"], function (require, exports, OnClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OnClauseUtil = OnClauseUtil;
});
define("join/join", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var JoinType;
    (function (JoinType) {
        JoinType["FROM"] = "FROM";
        JoinType["INNER"] = "INNER";
        JoinType["LEFT"] = "LEFT";
        /**
         * @todo Remove this?
         */
        JoinType["RIGHT"] = "RIGHT";
        JoinType["CROSS"] = "CROSS";
    })(JoinType = exports.JoinType || (exports.JoinType = {}));
    ;
    exports.JoinTypeValues = tm.EnumUtil.getValues(JoinType);
});
define("join/join-impl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Join {
        constructor(data, joinType, onClause, tableAst) {
            this.tableAlias = data.tableAlias;
            this.columns = data.columns;
            this.nullable = data.nullable;
            this.originalColumns = data.originalColumns;
            this.primaryKey = data.primaryKey;
            this.candidateKeys = data.candidateKeys;
            this.deleteEnabled = data.deleteEnabled;
            this.mutableColumns = data.mutableColumns;
            this.joinType = joinType;
            this.onClause = onClause;
            this.tableAst = tableAst;
        }
    }
    exports.Join = Join;
});
define("join/array-util/operation/append", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function append(arr, ...join) {
        return [...arr, ...join];
    }
    exports.append = append;
});
define("join/util/constructor/from-aliased-table", ["require", "exports", "join/join-impl", "aliased-table/index"], function (require, exports, join_impl_1, aliased_table_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromAliasedTable(aliasedTable, nullable, joinType, onClause) {
        const result = new join_impl_1.Join({
            tableAlias: aliasedTable.alias,
            nullable,
            columns: aliasedTable.columns,
            originalColumns: aliasedTable.columns,
            primaryKey: aliased_table_2.AliasedTableUtil.primaryKey(aliasedTable),
            candidateKeys: aliased_table_2.AliasedTableUtil.candidateKeys(aliasedTable),
            deleteEnabled: aliased_table_2.AliasedTableUtil.deleteEnabled(aliasedTable),
            mutableColumns: aliased_table_2.AliasedTableUtil.mutableColumns(aliasedTable),
        }, joinType, onClause, aliasedTable.unaliasedAst);
        return result;
    }
    exports.fromAliasedTable = fromAliasedTable;
});
define("join/util/constructor/index", ["require", "exports", "join/util/constructor/from-aliased-table"], function (require, exports, from_aliased_table_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_aliased_table_1);
});
define("join/util/helper-type/with-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/helper-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/operation/replace-column", ["require", "exports", "column-map/index", "join/join-impl"], function (require, exports, column_map_10, join_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function replaceColumn(join, tableAlias, columnAlias, mapper) {
        if (join.tableAlias == tableAlias &&
            Object.prototype.hasOwnProperty.call(join.columns, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(join.columns, columnAlias)) {
            const { tableAlias, nullable, columns, originalColumns, primaryKey, candidateKeys, deleteEnabled, mutableColumns, } = join;
            const result = new join_impl_2.Join({
                tableAlias,
                nullable,
                columns: column_map_10.ColumnMapUtil.replaceColumn(columns, columnAlias, mapper),
                originalColumns,
                primaryKey,
                candidateKeys,
                deleteEnabled,
                mutableColumns,
            }, join.joinType, join.onClause, join.tableAst);
            return result;
        }
        else {
            return join;
        }
    }
    exports.replaceColumn = replaceColumn;
});
define("join/util/operation/index", ["require", "exports", "join/util/operation/replace-column"], function (require, exports, replace_column_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(replace_column_1);
});
define("join/util/query/extract-with-candidate-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/predicate/has-null-safe-comparable-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/predicate/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/query/extract-with-null-safe-comparable-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/query/extract-with-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/query/extract-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/query/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/util/index", ["require", "exports", "join/util/constructor/index", "join/util/operation/index"], function (require, exports, constructor_4, operation_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_4);
    __export(operation_7);
});
define("join/array-util/operation/replace-column", ["require", "exports", "join/util/index"], function (require, exports, JoinUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function replaceColumn(joins, tableAlias, columnAlias, mapper) {
        return joins.map(join => JoinUtil.replaceColumn(join, tableAlias, columnAlias, mapper));
    }
    exports.replaceColumn = replaceColumn;
});
define("join/array-util/operation/index", ["require", "exports", "join/array-util/operation/append", "join/array-util/operation/replace-column"], function (require, exports, append_3, replace_column_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(append_3);
    __export(replace_column_2);
});
define("join/array-util/query/extract-with-candidate-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractWithCandidateKey(joins) {
        return joins.filter((join) => (join.candidateKeys.length > 0));
    }
    exports.extractWithCandidateKey = extractWithCandidateKey;
});
define("join/array-util/query/extract-with-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractWithPrimaryKey(joins) {
        return joins.filter((join) => (join.primaryKey != undefined));
    }
    exports.extractWithPrimaryKey = extractWithPrimaryKey;
});
define("join/array-util/query/extract-with-null-safe-comparable-primary-key", ["require", "exports", "table/index"], function (require, exports, table_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractWithNullSafeComparablePrimaryKey(joins, columnMap) {
        return joins.filter((join) => {
            if (join.primaryKey == undefined) {
                return false;
            }
            return table_5.TableUtil.hasNullSafeComparablePrimaryKey({
                columns: join.columns,
                primaryKey: join.primaryKey,
            }, columnMap);
        });
    }
    exports.extractWithNullSafeComparablePrimaryKey = extractWithNullSafeComparablePrimaryKey;
});
define("join/array-util/query/extract-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/array-util/query/non-nullable-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/array-util/query/nullable-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/array-util/query/table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("join/array-util/query/index", ["require", "exports", "join/array-util/query/extract-with-candidate-key", "join/array-util/query/extract-with-primary-key", "join/array-util/query/extract-with-null-safe-comparable-primary-key"], function (require, exports, extract_with_candidate_key_1, extract_with_primary_key_1, extract_with_null_safe_comparable_primary_key_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_with_candidate_key_1);
    __export(extract_with_primary_key_1);
    __export(extract_with_null_safe_comparable_primary_key_1);
});
define("join/array-util/index", ["require", "exports", "join/array-util/operation/index", "join/array-util/query/index"], function (require, exports, operation_8, query_9) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_8);
    __export(query_9);
});
define("join/index", ["require", "exports", "join/join-impl", "join/join", "join/array-util/index", "join/util/index"], function (require, exports, join_impl_3, join_2, JoinArrayUtil, JoinUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(join_impl_3);
    __export(join_2);
    exports.JoinArrayUtil = JoinArrayUtil;
    exports.JoinUtil = JoinUtil;
});
define("from-clause/from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/constructor/new-instance", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function newInstance() {
        const result = {
            outerQueryJoins: undefined,
            currentJoins: undefined,
        };
        return result;
    }
    exports.newInstance = newInstance;
});
define("from-clause/util/constructor/index", ["require", "exports", "from-clause/util/constructor/new-instance"], function (require, exports, new_instance_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(new_instance_1);
});
define("from-clause/util/helper-type/after-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/helper-type/before-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/helper-type/correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/helper-type/non-correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/helper-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("from-clause/util/operation/correlate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function correlate(fromClause) {
        return {
            outerQueryJoins: (fromClause.outerQueryJoins == undefined && fromClause.currentJoins == undefined ?
                undefined :
                [
                    ...(fromClause.outerQueryJoins == undefined ?
                        [] :
                        fromClause.outerQueryJoins),
                    ...(fromClause.currentJoins == undefined ?
                        [] :
                        fromClause.currentJoins),
                ]),
            currentJoins: undefined,
        };
    }
    exports.correlate = correlate;
});
define("from-clause/util/predicate/allowed-used-ref", ["require", "exports", "used-ref/index", "column-ref/index", "column-identifier-ref/index"], function (require, exports, used_ref_4, column_ref_2, column_identifier_ref_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedJoinArray(fromClause, aliasedTable) {
        return [
            ...((fromClause.outerQueryJoins != undefined) ?
                fromClause.outerQueryJoins :
                []),
            ...((aliasedTable.isLateral && fromClause.currentJoins != undefined) ?
                fromClause.currentJoins :
                []),
        ];
    }
    exports.allowedJoinArray = allowedJoinArray;
    function allowedColumnRef(fromClause, aliasedTable) {
        return column_ref_2.ColumnRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
    }
    exports.allowedColumnRef = allowedColumnRef;
    function allowedColumnIdentifierRef(fromClause, aliasedTable) {
        return column_identifier_ref_1.ColumnIdentifierRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
    }
    exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
    function allowedUsedRef(fromClause, aliasedTable) {
        return used_ref_4.UsedRefUtil.fromJoinArray(allowedJoinArray(fromClause, aliasedTable));
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("from-clause/util/predicate/assert-after-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertAfterFromClause(fromClause) {
        if (fromClause.currentJoins == undefined) {
            throw new Error(`Must be after FROM clause`);
        }
    }
    exports.assertAfterFromClause = assertAfterFromClause;
});
define("from-clause/util/predicate/assert-before-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertBeforeFromClause(fromClause) {
        if (fromClause.currentJoins != undefined) {
            throw new Error(`Must be before FROM clause`);
        }
    }
    exports.assertBeforeFromClause = assertBeforeFromClause;
});
define("from-clause/util/predicate/assert-no-used-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNoUsedRef(aliasedTable) {
        if (Object.keys(aliasedTable.usedRef.columns).length > 0) {
            throw new Error(`Derived table ${aliasedTable.alias} must not reference outer query tables or tables in the same FROM/JOIN clause`);
        }
    }
    exports.assertNoUsedRef = assertNoUsedRef;
});
define("from-clause/util/predicate/assert-not-in-current-joins", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNotInCurrentJoins(fromClause, aliasedTable) {
        if (fromClause.currentJoins != undefined) {
            if (fromClause.currentJoins.some(j => j.tableAlias == aliasedTable.alias)) {
                throw new Error(`Table alias ${aliasedTable.alias} already used in current query JOINs`);
            }
        }
    }
    exports.assertNotInCurrentJoins = assertNotInCurrentJoins;
});
define("from-clause/util/predicate/assert-not-in-outer-query-joins", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNotInOuterQueryJoins(fromClause, aliasedTable) {
        if (fromClause.outerQueryJoins != undefined) {
            if (fromClause.outerQueryJoins.some(j => j.tableAlias == aliasedTable.alias)) {
                throw new Error(`Table alias ${aliasedTable.alias} already used in outer query JOINs`);
            }
        }
    }
    exports.assertNotInOuterQueryJoins = assertNotInOuterQueryJoins;
});
define("from-clause/util/predicate/assert-not-lateral", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNotLateral(aliasedTable) {
        if (aliasedTable.isLateral) {
            throw new Error(`${aliasedTable.alias} cannot be LATERAL; does your DBMS support it?`);
        }
    }
    exports.assertNotLateral = assertNotLateral;
});
define("from-clause/util/predicate/assert-valid-current-join-base", ["require", "exports", "from-clause/util/predicate/assert-not-in-current-joins", "from-clause/util/predicate/assert-not-in-outer-query-joins", "from-clause/util/predicate/allowed-used-ref", "used-ref/index"], function (require, exports, assert_not_in_current_joins_1, assert_not_in_outer_query_joins_1, allowed_used_ref_2, used_ref_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidCurrentJoinBase(fromClause, aliasedTable) {
        assert_not_in_current_joins_1.assertNotInCurrentJoins(fromClause, aliasedTable);
        assert_not_in_outer_query_joins_1.assertNotInOuterQueryJoins(fromClause, aliasedTable);
        used_ref_5.UsedRefUtil.assertAllowed(allowed_used_ref_2.allowedUsedRef(fromClause, aliasedTable), aliasedTable.usedRef);
    }
    exports.assertValidCurrentJoinBase = assertValidCurrentJoinBase;
});
define("from-clause/util/predicate/assert-valid-outer-query-joins", ["require", "exports", "from-clause/util/predicate/assert-not-in-current-joins", "from-clause/util/predicate/assert-not-in-outer-query-joins", "aliased-table/index"], function (require, exports, assert_not_in_current_joins_2, assert_not_in_outer_query_joins_2, aliased_table_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidOuterQueryJoins(fromClause, aliasedTables) {
        for (const aliasedTable of aliasedTables) {
            assert_not_in_current_joins_2.assertNotInCurrentJoins(fromClause, aliasedTable);
            assert_not_in_outer_query_joins_2.assertNotInOuterQueryJoins(fromClause, aliasedTable);
        }
        aliased_table_3.AliasedTableArrayUtil.assertNoDuplicateTableAlias(aliasedTables);
    }
    exports.assertValidOuterQueryJoins = assertValidOuterQueryJoins;
});
define("from-clause/util/predicate/is-from-clause", ["require", "exports", "type-util/index"], function (require, exports, type_util_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import {UsedRefUtil} from "../../../used-ref";
    //import {AstUtil} from "../../../ast";
    /**
     * Only checks that the properties exist.
     * Does not actually check that they are the right data type!
     *
     * @todo Consider adding checks for increased type safety.
     */
    function isFromClause(x) {
        if (!type_util_3.isObjectWithOwnEnumerableKeys()(x, [
            "outerQueryJoins",
            "currentJoins",
        ])) {
            return false;
        }
        return true;
    }
    exports.isFromClause = isFromClause;
});
define("from-clause/util/predicate/is-after-from-clause", ["require", "exports", "from-clause/util/predicate/is-from-clause"], function (require, exports, is_from_clause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAfterFromClause(x) {
        return is_from_clause_1.isFromClause(x) && (x.currentJoins != undefined);
    }
    exports.isAfterFromClause = isAfterFromClause;
});
define("from-clause/util/predicate/is-before-from-clause", ["require", "exports", "from-clause/util/predicate/is-from-clause"], function (require, exports, is_from_clause_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBeforeFromClause(x) {
        return is_from_clause_2.isFromClause(x) && (x.currentJoins == undefined);
    }
    exports.isBeforeFromClause = isBeforeFromClause;
});
define("from-clause/util/predicate/index", ["require", "exports", "from-clause/util/predicate/allowed-used-ref", "from-clause/util/predicate/assert-after-from-clause", "from-clause/util/predicate/assert-before-from-clause", "from-clause/util/predicate/assert-no-used-ref", "from-clause/util/predicate/assert-not-in-current-joins", "from-clause/util/predicate/assert-not-in-outer-query-joins", "from-clause/util/predicate/assert-not-lateral", "from-clause/util/predicate/assert-valid-current-join-base", "from-clause/util/predicate/assert-valid-outer-query-joins", "from-clause/util/predicate/is-after-from-clause", "from-clause/util/predicate/is-before-from-clause", "from-clause/util/predicate/is-from-clause"], function (require, exports, allowed_used_ref_3, assert_after_from_clause_1, assert_before_from_clause_1, assert_no_used_ref_1, assert_not_in_current_joins_3, assert_not_in_outer_query_joins_3, assert_not_lateral_1, assert_valid_current_join_base_1, assert_valid_outer_query_joins_1, is_after_from_clause_1, is_before_from_clause_1, is_from_clause_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_used_ref_3);
    __export(assert_after_from_clause_1);
    __export(assert_before_from_clause_1);
    __export(assert_no_used_ref_1);
    __export(assert_not_in_current_joins_3);
    __export(assert_not_in_outer_query_joins_3);
    __export(assert_not_lateral_1);
    __export(assert_valid_current_join_base_1);
    __export(assert_valid_outer_query_joins_1);
    __export(is_after_from_clause_1);
    __export(is_before_from_clause_1);
    __export(is_from_clause_3);
});
define("from-clause/util/operation/cross-join", ["require", "exports", "join/index", "from-clause/util/predicate/index"], function (require, exports, join_3, predicate_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function crossJoin(fromClause, aliasedTable) {
        predicate_12.assertAfterFromClause(fromClause);
        predicate_12.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const result = {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_3.JoinArrayUtil.append(fromClause.currentJoins, join_3.JoinUtil.fromAliasedTable(aliasedTable, false, join_3.JoinType.CROSS, undefined)),
        };
        return result;
    }
    exports.crossJoin = crossJoin;
});
define("from-clause/util/operation/from", ["require", "exports", "join/index", "from-clause/util/predicate/index"], function (require, exports, join_4, predicate_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function from(fromClause, aliasedTable) {
        predicate_13.assertBeforeFromClause(fromClause);
        predicate_13.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const result = {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: [
                join_4.JoinUtil.fromAliasedTable(aliasedTable, false, join_4.JoinType.FROM, undefined)
            ],
        };
        return result;
    }
    exports.from = from;
});
define("join-map/join-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("join-map/util/constructor/from-join-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromJoinArray(joins) {
        const result = {};
        for (const join of joins) {
            result[join.tableAlias] = join;
        }
        return result;
    }
    exports.fromJoinArray = fromJoinArray;
});
define("join-map/util/constructor/index", ["require", "exports", "join-map/util/constructor/from-join-array"], function (require, exports, from_join_array_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_join_array_3);
});
define("join-map/util/index", ["require", "exports", "join-map/util/constructor/index"], function (require, exports, constructor_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_5);
});
define("join-map/index", ["require", "exports", "join-map/util/index"], function (require, exports, JoinMapUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JoinMapUtil = JoinMapUtil;
});
define("from-clause/util/operation/inner-join", ["require", "exports", "from-clause/util/predicate/index", "join/index", "on-clause/index"], function (require, exports, predicate_14, join_5, on_clause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * ```sql
     *  INNER JOIN
     *      myTable
     *  ON
     *      --condition
     * ```
     */
    function innerJoin(fromClause, aliasedTable, onDelegate) {
        predicate_14.assertAfterFromClause(fromClause);
        predicate_14.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const result = {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_5.JoinArrayUtil.append(fromClause.currentJoins, join_5.JoinUtil.fromAliasedTable(aliasedTable, false, join_5.JoinType.INNER, on_clause_1.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
        };
        return result;
    }
    exports.innerJoin = innerJoin;
});
define("from-clause/util/operation/inner-join-using-candidate-key", ["require", "exports", "from-clause/util/predicate/index", "join-map/index", "from-clause/util/operation/inner-join", "expr-library/index"], function (require, exports, predicate_15, join_map_1, inner_join_1, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .innerJoin(
     *      otherTable,
     *      () => tsql.eqCandidateKeyOfTable(
     *          myTable,
     *          otherTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      )
     *  )
     * ```
     *
     * ```sql
     *  INNER JOIN
     *      otherTable
     *  ON
     *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
     *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
     *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
     *      --snip
     * ```
     */
    function innerJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        predicate_15.assertAfterFromClause(fromClause);
        predicate_15.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const src = srcDelegate(join_map_1.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const result = inner_join_1.innerJoin(fromClause, aliasedTable, () => {
            /**
             * @todo Investigate assignability
             */
            return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
        });
        return result;
    }
    exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
});
define("from-clause/util/operation/inner-join-using-primary-key", ["require", "exports", "from-clause/util/predicate/index", "join-map/index", "from-clause/util/operation/inner-join", "expr-library/index"], function (require, exports, predicate_16, join_map_2, inner_join_2, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .innerJoin(
     *      otherTable,
     *      () => tsql.eqPrimaryKeyOfTable(
     *          myTable,
     *          otherTable
     *      )
     *  )
     * ```
     *
     * ```sql
     *  INNER JOIN
     *      otherTable
     *  ON
     *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
     *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
     *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
     *      --snip
     * ```
     */
    function innerJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
        predicate_16.assertAfterFromClause(fromClause);
        predicate_16.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const src = srcDelegate(join_map_2.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const result = inner_join_2.innerJoin(fromClause, aliasedTable, () => {
            /**
             * @todo Investigate assignability
             */
            return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
        });
        return result;
    }
    exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
});
define("from-clause/util/operation/left-join", ["require", "exports", "from-clause/util/predicate/index", "join/index", "on-clause/index"], function (require, exports, predicate_17, join_6, on_clause_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * ```sql
     *  LEFT JOIN
     *      myTable
     *  ON
     *      --condition
     * ```
     */
    function leftJoin(fromClause, aliasedTable, onDelegate) {
        predicate_17.assertAfterFromClause(fromClause);
        predicate_17.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const result = {
            outerQueryJoins: fromClause.outerQueryJoins,
            currentJoins: join_6.JoinArrayUtil.append(fromClause.currentJoins, join_6.JoinUtil.fromAliasedTable(aliasedTable, true, join_6.JoinType.LEFT, on_clause_2.OnClauseUtil.on(fromClause, aliasedTable, onDelegate))),
        };
        return result;
    }
    exports.leftJoin = leftJoin;
});
define("from-clause/util/operation/left-join-using-candidate-key", ["require", "exports", "from-clause/util/predicate/index", "join-map/index", "from-clause/util/operation/left-join", "expr-library/index"], function (require, exports, predicate_18, join_map_3, left_join_1, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .leftJoin(
     *      otherTable,
     *      () => tsql.eqCandidateKeyOfTable(
     *          myTable,
     *          otherTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      )
     *  )
     * ```
     *
     * ```sql
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      myTable.otherTableCk0 <=> otherTable.otherTableCk0 AND
     *      myTable.otherTableCk1 <=> otherTable.otherTableCk1 AND
     *      myTable.otherTableCk2 <=> otherTable.otherTableCk2 AND
     *      --snip
     * ```
     */
    function leftJoinUsingCandidateKey(fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        predicate_18.assertAfterFromClause(fromClause);
        predicate_18.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const src = srcDelegate(join_map_3.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const result = left_join_1.leftJoin(fromClause, aliasedTable, () => {
            /**
             * @todo Investigate assignability
             */
            return ExprLib.eqCandidateKeyOfTable(src, aliasedTable, eqCandidateKeyOfTableDelegate);
        });
        return result;
    }
    exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
});
define("from-clause/util/operation/left-join-using-primary-key", ["require", "exports", "from-clause/util/predicate/index", "join-map/index", "from-clause/util/operation/left-join", "expr-library/index"], function (require, exports, predicate_19, join_map_4, left_join_2, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shorthand for,
     * ```ts
     *  //snip
     *  .leftJoin(
     *      otherTable,
     *      () => tsql.eqPrimaryKeyOfTable(
     *          myTable,
     *          otherTable
     *      )
     *  )
     * ```
     *
     * ```sql
     *  LEFT JOIN
     *      otherTable
     *  ON
     *      myTable.otherTablePk0 <=> otherTable.otherTablePk0 AND
     *      myTable.otherTablePk1 <=> otherTable.otherTablePk1 AND
     *      myTable.otherTablePk2 <=> otherTable.otherTablePk2 AND
     *      --snip
     * ```
     */
    function leftJoinUsingPrimaryKey(fromClause, srcDelegate, aliasedTable) {
        predicate_19.assertAfterFromClause(fromClause);
        predicate_19.assertValidCurrentJoinBase(fromClause, aliasedTable);
        const src = srcDelegate(join_map_4.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const result = left_join_2.leftJoin(fromClause, aliasedTable, () => {
            /**
             * @todo Investigate assignability
             */
            return ExprLib.eqPrimaryKeyOfTable(src, aliasedTable);
        });
        return result;
    }
    exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
});
define("from-clause/util/operation/require-outer-query-joins-impl", ["require", "exports", "join/index", "from-clause/util/predicate/index"], function (require, exports, join_7, predicate_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function requireOuterQueryJoinsImpl(fromClause, nullable, ...aliasedTables) {
        if (aliasedTables.length == 0) {
            return fromClause;
        }
        predicate_20.assertValidOuterQueryJoins(fromClause, aliasedTables);
        const required = aliasedTables.map(aliasedTable => (join_7.JoinUtil.fromAliasedTable(aliasedTable, nullable, 
        /**
         * The `JoinType` does not matter for outer query joins.
         */
        join_7.JoinType.FROM, 
        /**
         * The `ON` clause doesn't matter, either.
         */
        undefined)));
        const outerQueryJoins = (fromClause.outerQueryJoins == undefined ?
            required :
            join_7.JoinArrayUtil.append(fromClause.outerQueryJoins, ...required));
        const result = {
            outerQueryJoins,
            currentJoins: fromClause.currentJoins,
        };
        return result;
    }
    exports.requireOuterQueryJoinsImpl = requireOuterQueryJoinsImpl;
});
define("from-clause/util/operation/require-nullable-outer-query-joins", ["require", "exports", "from-clause/util/operation/require-outer-query-joins-impl"], function (require, exports, require_outer_query_joins_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function requireNullableOuterQueryJoins(fromClause, ...aliasedTables) {
        return require_outer_query_joins_impl_1.requireOuterQueryJoinsImpl(fromClause, true, ...aliasedTables);
    }
    exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
});
define("from-clause/util/operation/require-outer-query-joins", ["require", "exports", "from-clause/util/operation/require-outer-query-joins-impl"], function (require, exports, require_outer_query_joins_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function requireOuterQueryJoins(fromClause, ...aliasedTables) {
        return require_outer_query_joins_impl_2.requireOuterQueryJoinsImpl(fromClause, false, ...aliasedTables);
    }
    exports.requireOuterQueryJoins = requireOuterQueryJoins;
});
define("where-clause/where-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("where-clause/util/query/allowed-used-ref", ["require", "exports", "from-clause/index"], function (require, exports, from_clause_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedColumnRef(fromClause) {
        return from_clause_2.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
    }
    exports.allowedColumnRef = allowedColumnRef;
    function allowedUsedRef(fromClause) {
        return from_clause_2.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("where-clause/util/query/index", ["require", "exports", "where-clause/util/query/allowed-used-ref"], function (require, exports, allowed_used_ref_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_used_ref_4);
});
define("where-clause/util/operation/where", ["require", "exports", "column-ref/index", "expr-library/index", "where-clause/util/query/index", "used-ref/index", "built-in-expr/index", "expr/index"], function (require, exports, column_ref_3, ExprLib, query_10, used_ref_6, built_in_expr_3, expr_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `whereClause AND whereDelegate(columns)`
     *
     * @param fromClause
     * @param whereClause
     * @param whereDelegate
     */
    function where(fromClause, whereClause, whereDelegate) {
        const columns = query_10.allowedColumnRef(fromClause);
        /**
         * Explicit type annotation required or `tsc` crashes
         */
        const operand = whereDelegate(column_ref_3.ColumnRefUtil.tryFlatten(columns));
        used_ref_6.UsedRefUtil.assertAllowed({ columns }, built_in_expr_3.BuiltInExprUtil.usedRef(operand));
        const result = (whereClause == undefined ?
            expr_2.ExprUtil.fromBuiltInExpr(operand) :
            ExprLib.and(whereClause, operand));
        return result;
    }
    exports.where = where;
});
define("where-clause/util/operation/index", ["require", "exports", "where-clause/util/operation/where"], function (require, exports, where_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(where_1);
});
define("where-clause/util/index", ["require", "exports", "where-clause/util/operation/index", "where-clause/util/query/index"], function (require, exports, operation_9, query_11) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_9);
    __export(query_11);
});
define("where-clause/where-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("where-clause/index", ["require", "exports", "where-clause/util/index"], function (require, exports, WhereClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WhereClauseUtil = WhereClauseUtil;
});
define("type-map/type-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/constructor/from-column-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/constructor/from-column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/constructor/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/operator/intersect", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/operator/with-value", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/operator/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/util/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-map/index", ["require", "exports", "type-map/util/index"], function (require, exports, TypeMapUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeMapUtil = TypeMapUtil;
});
define("candidate-key/candidate-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("primary-key/primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("primary-key/util/query/mapper", ["require", "exports", "column-map/index", "type-util/index"], function (require, exports, column_map_11, type_util_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(table) {
        return column_map_11.ColumnMapUtil.mapper(type_util_4.pickOwnEnumerable(table.columns, table.primaryKey));
    }
    exports.mapper = mapper;
});
define("primary-key/util/query/index", ["require", "exports", "primary-key/util/query/mapper"], function (require, exports, mapper_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_1);
});
define("primary-key/util/index", ["require", "exports", "primary-key/util/query/index"], function (require, exports, query_12) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_12);
});
define("primary-key/index", ["require", "exports", "primary-key/util/index"], function (require, exports, PrimaryKeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimaryKeyUtil = PrimaryKeyUtil;
});
define("candidate-key/util/query/mapper", ["require", "exports", "type-mapping", "column-map/index", "type-util/index", "primary-key/index"], function (require, exports, tm, column_map_12, type_util_5, primary_key_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(table) {
        return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
            return column_map_12.ColumnMapUtil.mapper(type_util_5.pickOwnEnumerable(table.columns, candidateKey));
        }));
    }
    exports.mapper = mapper;
    function mapperPreferPrimaryKey(table) {
        if (table.primaryKey == undefined) {
            return mapper(table);
        }
        return tm.unsafeOr(primary_key_2.PrimaryKeyUtil.mapper(table), mapper(table));
    }
    exports.mapperPreferPrimaryKey = mapperPreferPrimaryKey;
});
define("candidate-key/util/query/index", ["require", "exports", "candidate-key/util/query/mapper"], function (require, exports, mapper_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_2);
});
define("candidate-key/util/index", ["require", "exports", "candidate-key/util/query/index"], function (require, exports, query_13) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_13);
});
define("candidate-key/index", ["require", "exports", "candidate-key/util/index"], function (require, exports, CandidateKeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CandidateKeyUtil = CandidateKeyUtil;
});
define("from-clause/util/operation/where-eq-candidate-key", ["require", "exports", "join/index", "where-clause/index", "join-map/index", "expr-library/index"], function (require, exports, join_8, where_clause_1, join_map_5, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqCandidateKey(
     *          myTable,
     *          myCandidateKey
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Excess properties are especially dangerous for this function.
     *
     * If your `candidateKeyInput` is actually a super key of two candidate keys,
     * then the candidate key this function compares against is arbitrary.
     *
     * The extra properties will be discarded.
     *
     * If you want to compare against a super key, use `whereEqSuperKey()` instead.
     *
     */
    function whereEqCandidateKey(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereEqCandidateKeyDelegate = args[0];
        const candidateKey = args[1];
        const table = whereEqCandidateKeyDelegate(join_map_5.JoinMapUtil.fromJoinArray(join_8.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
        const result = {
            fromClause,
            whereClause: where_clause_1.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eqCandidateKey(table, candidateKey)),
        };
        return result;
    }
    exports.whereEqCandidateKey = whereEqCandidateKey;
});
define("partial-row/partial-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("partial-row/util/query/mapper", ["require", "exports", "column-map/index"], function (require, exports, column_map_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(table) {
        return column_map_13.ColumnMapUtil.partialMapper(table.columns);
    }
    exports.mapper = mapper;
});
define("partial-row/util/query/index", ["require", "exports", "partial-row/util/query/mapper"], function (require, exports, mapper_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_3);
});
define("partial-row/util/index", ["require", "exports", "partial-row/util/query/index"], function (require, exports, query_14) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_14);
});
define("partial-row/index", ["require", "exports", "partial-row/util/index"], function (require, exports, PartialRowUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PartialRowUtil = PartialRowUtil;
});
define("from-clause/util/operation/where-eq-columns", ["require", "exports", "where-clause/index", "join-map/index", "expr-library/index"], function (require, exports, where_clause_2, join_map_6, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqColumns(
     *          myTable,
     *          myColumns
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    function whereEqColumns(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereEqColumnsDelegate = args[0];
        const columns = args[1];
        /**
         * @todo Investigate assignability
         */
        const table = whereEqColumnsDelegate(join_map_6.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const result = {
            fromClause,
            whereClause: where_clause_2.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eqColumns(table, 
            /**
             * @todo Investigate assignability
             */
            columns)),
        };
        return result;
    }
    exports.whereEqColumns = whereEqColumns;
});
define("from-clause/util/operation/where-eq-inner-query-primary-key", ["require", "exports", "join/index", "where-clause/index", "expr-library/index", "join-map/index"], function (require, exports, join_9, where_clause_3, ExprLib, join_map_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKeyOfTable(
     *          outerQueryTable,
     *          currentQueryTable
     *      ));
     * ```
     * -----
     *
     * + The `outerQueryTable` does not need to have keys.
     * + The `currentQueryTable` must have a primary key.
     * + The `outerQueryTable` must have columns comparable to columns of `currentQueryTable`'s primary key.
     */
    function whereEqInnerQueryPrimaryKey(fromClause, whereClause, srcDelegate, dstDelegate) {
        const src = srcDelegate(join_map_7.JoinMapUtil.fromJoinArray(fromClause.outerQueryJoins));
        const dst = dstDelegate(join_map_7.JoinMapUtil.fromJoinArray(join_9.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.currentJoins, src.columns)));
        const result = {
            fromClause,
            whereClause: where_clause_3.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
        };
        return result;
    }
    exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
});
define("from-clause/util/operation/where-eq-outer-query-candidate-key", ["require", "exports", "join/index", "where-clause/index", "join-map/index"], function (require, exports, join_10, where_clause_4, join_map_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqCandidateKeyOfTable(
     *          currentQueryTable,
     *          outerQueryTable,
     *          columns => [
     *              columns.candidateKey0,
     *              columns.candidateKey1,
     *              //etc.
     *          ]
     *      ));
     * ```
     * -----
     *
     * + The `currentQueryTable` does not need to have keys.
     * + The `outerQueryTable` must have at least one candidate key.
     * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s candidate key.
     */
    function whereEqOuterQueryCandidateKey(fromClause, whereClause, 
    /**
     * @todo Remove this
     */
    eqCandidateKeyOfTable, srcDelegate, dstDelegate, eqCandidateKeyOfTableDelegate) {
        const src = srcDelegate(join_map_8.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const dst = dstDelegate(join_map_8.JoinMapUtil.fromJoinArray(join_10.JoinArrayUtil.extractWithCandidateKey(fromClause.outerQueryJoins)));
        ;
        const result = {
            fromClause,
            whereClause: where_clause_4.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => eqCandidateKeyOfTable(src, dst, eqCandidateKeyOfTableDelegate)),
        };
        return result;
    }
    exports.whereEqOuterQueryCandidateKey = whereEqOuterQueryCandidateKey;
});
define("from-clause/util/operation/where-eq-outer-query-primary-key", ["require", "exports", "join/index", "where-clause/index", "expr-library/index", "join-map/index"], function (require, exports, join_11, where_clause_5, ExprLib, join_map_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKeyOfTable(
     *          currentQueryTable,
     *          outerQueryTable
     *      ));
     * ```
     * -----
     *
     * + The `currentQueryTable` does not need to have keys.
     * + The `outerQueryTable` must have a primary key.
     * + The `currentQueryTable` must have columns comparable to columns of `outerQueryTable`'s primary key.
     */
    function whereEqOuterQueryPrimaryKey(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate, dstDelegate) {
        const src = srcDelegate(join_map_9.JoinMapUtil.fromJoinArray(fromClause.currentJoins));
        const dst = dstDelegate(join_map_9.JoinMapUtil.fromJoinArray(join_11.JoinArrayUtil.extractWithNullSafeComparablePrimaryKey(fromClause.outerQueryJoins, src.columns)));
        const result = {
            fromClause,
            whereClause: where_clause_5.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eqPrimaryKeyOfTable(src, dst)),
        };
        return result;
    }
    exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
});
define("from-clause/util/operation/where-eq-primary-key", ["require", "exports", "join/index", "where-clause/index", "expr-library/index", "join-map/index"], function (require, exports, join_12, where_clause_6, ExprLib, join_map_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqPrimaryKey(
     *          myTable,
     *          myPrimaryKey
     *      ));
     * ```
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    function whereEqPrimaryKey(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereEqPrimaryKeyDelegate = args[0];
        const primaryKey = args[1];
        const table = whereEqPrimaryKeyDelegate(join_map_10.JoinMapUtil.fromJoinArray(join_12.JoinArrayUtil.extractWithPrimaryKey(fromClause.currentJoins)));
        const result = {
            fromClause,
            whereClause: where_clause_6.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eqPrimaryKey(table, 
            /**
             * @todo Investigate assignability
             */
            primaryKey)),
        };
        return result;
    }
    exports.whereEqPrimaryKey = whereEqPrimaryKey;
});
define("super-key/super-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("super-key/util/query/mapper", ["require", "exports", "type-mapping", "column-map/index", "type-util/index"], function (require, exports, tm, column_map_14, type_util_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(table) {
        return tm.unsafeOr(...table.candidateKeys.map((candidateKey) => {
            /**
             * This usage of `tm.deepMerge()` is safe.
             * This is not true, in general.
             *
             * The two objects we'll be deep merging do not share any
             * properties.
             */
            return tm.deepMerge(column_map_14.ColumnMapUtil.mapper(type_util_6.pickOwnEnumerable(table.columns, candidateKey)), column_map_14.ColumnMapUtil.partialMapper(type_util_6.omitOwnEnumerable(table.columns, candidateKey)));
        }));
    }
    exports.mapper = mapper;
});
define("super-key/util/query/index", ["require", "exports", "super-key/util/query/mapper"], function (require, exports, mapper_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_4);
});
define("super-key/util/index", ["require", "exports", "super-key/util/query/index"], function (require, exports, query_15) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_15);
});
define("super-key/index", ["require", "exports", "super-key/util/index"], function (require, exports, SuperKeyUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SuperKeyUtil = SuperKeyUtil;
});
define("from-clause/util/operation/where-eq-super-key", ["require", "exports", "join/index", "where-clause/index", "join-map/index"], function (require, exports, join_13, where_clause_7, join_map_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .where(() => tsql.eqSuperKey(
     *          myTable,
     *          mySuperKey
     *      ));
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     */
    function whereEqSuperKey(fromClause, whereClause, 
    /**
     * @todo Remove this
     */
    eqSuperKey, 
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereEqSuperKeyDelegate = args[0];
        const superKey = args[1];
        const table = whereEqSuperKeyDelegate(join_map_11.JoinMapUtil.fromJoinArray(join_13.JoinArrayUtil.extractWithCandidateKey(fromClause.currentJoins)));
        const result = {
            fromClause,
            whereClause: where_clause_7.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => eqSuperKey(table, superKey)),
        };
        return result;
    }
    exports.whereEqSuperKey = whereEqSuperKey;
});
define("value-expr/util/operation/case-insensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("value-expr/util/operation/null-safe-case-insensitive-narrow", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("value-expr/util/operation/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("value-expr/util/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("value-expr/index", ["require", "exports", "value-expr/util/index"], function (require, exports, ValueExprUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueExprUtil = ValueExprUtil;
});
define("from-clause/util/operation/where-eq", ["require", "exports", "column/index", "join/index", "where-clause/index", "column-ref/index", "column-identifier-ref/index", "expr-library/index", "built-in-expr/index"], function (require, exports, column_4, join_14, where_clause_8, column_ref_4, column_identifier_ref_2, ExprLib, built_in_expr_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Narrows a column's type based on equality to a value
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn = 1
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `1`.
     */
    function whereEq(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereEqDelegate = args[0];
        const value = args[1];
        const columns = column_ref_4.ColumnRefUtil.extractNonNullable(column_ref_4.ColumnRefUtil.fromColumnArray(column_4.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
        const column = whereEqDelegate(column_ref_4.ColumnRefUtil.tryFlatten(columns));
        column_identifier_ref_2.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
        const result = {
            fromClause: {
                outerQueryJoins: fromClause.outerQueryJoins,
                currentJoins: join_14.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
                /**
                 * Cast to the type of `ValueT`
                 */
                /*
                tm.or(
                    BuiltInExprUtil.mapper(value),
                    tm.pipe(
                        column.mapper,
                        BuiltInExprUtil.mapper(value)
                    )
                )*/
                column.mapper),
            },
            whereClause: where_clause_8.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.eq(column, built_in_expr_4.BuiltInExprUtil.fromValueExpr(column, value))),
        };
        return result;
    }
    exports.whereEq = whereEq;
});
define("from-clause/util/operation/where-is-not-null", ["require", "exports", "type-mapping", "column/index", "join/index", "where-clause/index", "column-ref/index", "expr-library/index", "column-identifier-ref/index"], function (require, exports, tm, column_5, join_15, where_clause_9, column_ref_5, ExprLib, column_identifier_ref_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Narrows a column's type to **exclude** `null`
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn IS NOT NULL
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set **WILL NOT** be `null`.
     */
    function whereIsNotNull(fromClause, whereClause, whereIsNotNullDelegate) {
        const columns = column_ref_5.ColumnRefUtil.extractNullable(column_ref_5.ColumnRefUtil.fromColumnArray(column_5.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
        const column = whereIsNotNullDelegate(column_ref_5.ColumnRefUtil.tryFlatten(columns));
        column_identifier_ref_3.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
        const result = {
            fromClause: {
                outerQueryJoins: fromClause.outerQueryJoins,
                currentJoins: join_15.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.excludeLiteral(column.mapper, null)),
            },
            whereClause: where_clause_9.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.isNotNull(column)),
        };
        return result;
    }
    exports.whereIsNotNull = whereIsNotNull;
});
define("from-clause/util/operation/where-is-null", ["require", "exports", "type-mapping", "column/index", "join/index", "where-clause/index", "column-ref/index", "expr-library/index", "column-identifier-ref/index"], function (require, exports, tm, column_6, join_16, where_clause_10, column_ref_6, ExprLib, column_identifier_ref_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Narrows a column's type to `null`
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn IS NULL
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `null`.
     */
    function whereIsNull(fromClause, whereClause, whereIsNullDelegate) {
        const columns = column_ref_6.ColumnRefUtil.extractNullable(column_ref_6.ColumnRefUtil.fromColumnArray(column_6.ColumnUtil.fromJoinArray(fromClause.currentJoins)));
        const column = whereIsNullDelegate(column_ref_6.ColumnRefUtil.tryFlatten(columns));
        column_identifier_ref_4.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
        const result = {
            fromClause: {
                outerQueryJoins: fromClause.outerQueryJoins,
                currentJoins: join_16.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, tm.null()),
            },
            whereClause: where_clause_10.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.isNull(column)),
        };
        return result;
    }
    exports.whereIsNull = whereIsNull;
});
define("from-clause/util/operation/where-null-safe-eq", ["require", "exports", "column/index", "join/index", "where-clause/index", "column-ref/index", "expr-library/index", "column-identifier-ref/index", "built-in-expr/index"], function (require, exports, column_7, join_17, where_clause_11, column_ref_7, ExprLib, column_identifier_ref_5, built_in_expr_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Narrows a column's type based on null-safe equality to a value
     *
     * Given the below expression,
     * ```sql
     *  SELECT
     *      myTable.myColumn
     *  FROM
     *      myTable
     *  WHERE
     *      myTable.myColumn <=> 1
     * ```
     *
     * We know, without even executing the query,
     * that the type of `myTable.myColumn` for all rows
     * in the result set will be `1`.
     */
    function whereNullSafeEq(fromClause, whereClause, 
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const whereNullSafeEqDelegate = args[0];
        const value = args[1];
        const columns = column_ref_7.ColumnRefUtil.fromColumnArray(column_7.ColumnUtil.fromJoinArray(fromClause.currentJoins));
        const column = whereNullSafeEqDelegate(column_ref_7.ColumnRefUtil.tryFlatten(columns));
        column_identifier_ref_5.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, column);
        const result = {
            fromClause: {
                outerQueryJoins: fromClause.outerQueryJoins,
                currentJoins: join_17.JoinArrayUtil.replaceColumn(fromClause.currentJoins, column.tableAlias, column.columnAlias, 
                /**
                 * Cast to the type of `ValueT`
                 */
                /*
                tm.or(
                    BuiltInExprUtil.mapper(value),
                    tm.pipe(
                        column.mapper,
                        BuiltInExprUtil.mapper(value)
                    )
                )*/
                column.mapper),
            },
            whereClause: where_clause_11.WhereClauseUtil.where(fromClause, whereClause, 
            /**
             * @todo Investigate assignability
             */
            () => ExprLib.nullSafeEq(column, built_in_expr_5.BuiltInExprUtil.fromValueExpr(column_7.ColumnUtil.toNullable(column), value))),
        };
        return result;
    }
    exports.whereNullSafeEq = whereNullSafeEq;
});
define("from-clause/util/operation/index", ["require", "exports", "from-clause/util/operation/correlate", "from-clause/util/operation/cross-join", "from-clause/util/operation/from", "from-clause/util/operation/inner-join-using-candidate-key", "from-clause/util/operation/inner-join-using-primary-key", "from-clause/util/operation/inner-join", "from-clause/util/operation/left-join-using-candidate-key", "from-clause/util/operation/left-join-using-primary-key", "from-clause/util/operation/left-join", "from-clause/util/operation/require-nullable-outer-query-joins", "from-clause/util/operation/require-outer-query-joins-impl", "from-clause/util/operation/require-outer-query-joins", "from-clause/util/operation/where-eq-candidate-key", "from-clause/util/operation/where-eq-columns", "from-clause/util/operation/where-eq-inner-query-primary-key", "from-clause/util/operation/where-eq-outer-query-candidate-key", "from-clause/util/operation/where-eq-outer-query-primary-key", "from-clause/util/operation/where-eq-primary-key", "from-clause/util/operation/where-eq-super-key", "from-clause/util/operation/where-eq", "from-clause/util/operation/where-is-not-null", "from-clause/util/operation/where-is-null", "from-clause/util/operation/where-null-safe-eq"], function (require, exports, correlate_1, cross_join_1, from_1, inner_join_using_candidate_key_1, inner_join_using_primary_key_1, inner_join_3, left_join_using_candidate_key_1, left_join_using_primary_key_1, left_join_3, require_nullable_outer_query_joins_1, require_outer_query_joins_impl_3, require_outer_query_joins_1, where_eq_candidate_key_1, where_eq_columns_1, where_eq_inner_query_primary_key_1, where_eq_outer_query_candidate_key_1, where_eq_outer_query_primary_key_1, where_eq_primary_key_1, where_eq_super_key_1, where_eq_1, where_is_not_null_1, where_is_null_1, where_null_safe_eq_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(correlate_1);
    __export(cross_join_1);
    __export(from_1);
    __export(inner_join_using_candidate_key_1);
    __export(inner_join_using_primary_key_1);
    __export(inner_join_3);
    __export(left_join_using_candidate_key_1);
    __export(left_join_using_primary_key_1);
    __export(left_join_3);
    __export(require_nullable_outer_query_joins_1);
    __export(require_outer_query_joins_impl_3);
    __export(require_outer_query_joins_1);
    __export(where_eq_candidate_key_1);
    __export(where_eq_columns_1);
    __export(where_eq_inner_query_primary_key_1);
    __export(where_eq_outer_query_candidate_key_1);
    __export(where_eq_outer_query_primary_key_1);
    __export(where_eq_primary_key_1);
    __export(where_eq_super_key_1);
    __export(where_eq_1);
    __export(where_is_not_null_1);
    __export(where_is_null_1);
    __export(where_null_safe_eq_1);
});
define("from-clause/util/query/outer-query-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function outerQueryTableAlias(fromClause) {
        if (fromClause.outerQueryJoins == undefined) {
            return [];
        }
        else {
            return fromClause.outerQueryJoins.map(join => join.tableAlias);
        }
    }
    exports.outerQueryTableAlias = outerQueryTableAlias;
});
define("from-clause/util/query/index", ["require", "exports", "from-clause/util/query/outer-query-table-alias"], function (require, exports, outer_query_table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(outer_query_table_alias_1);
});
define("from-clause/util/index", ["require", "exports", "from-clause/util/constructor/index", "from-clause/util/operation/index", "from-clause/util/predicate/index", "from-clause/util/query/index"], function (require, exports, constructor_6, operation_10, predicate_21, query_16) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_6);
    __export(operation_10);
    __export(predicate_21);
    __export(query_16);
});
define("from-clause/index", ["require", "exports", "from-clause/util/index"], function (require, exports, FromClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FromClauseUtil = FromClauseUtil;
});
define("compound-query/compound-query", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompoundQueryType;
    (function (CompoundQueryType) {
        CompoundQueryType["UNION"] = "UNION";
        CompoundQueryType["INTERSECT"] = "INTERSECT";
        CompoundQueryType["EXCEPT"] = "EXCEPT";
    })(CompoundQueryType = exports.CompoundQueryType || (exports.CompoundQueryType = {}));
});
define("compound-query/index", ["require", "exports", "compound-query/compound-query"], function (require, exports, compound_query_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_1);
});
define("compound-query-clause/compound-query-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("compound-query-clause/util/predicate/assert-select-clause-compatible", ["require", "exports", "column/index", "expr-select-item/index", "column-map/index", "column-ref/index"], function (require, exports, column_8, expr_select_item_1, column_map_15, column_ref_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertMapCompatibilityError(identifier, a, b) {
        const aColumnAliases = Object.keys(a);
        const bColumnAliases = Object.keys(b);
        const missingColumnAliases = aColumnAliases.filter(columnAlias => !bColumnAliases.includes(columnAlias));
        if (missingColumnAliases.length > 0) {
            throw new Error(`Expected ${identifier.join(" ")} to have columns ${missingColumnAliases.join(", ")}`);
        }
        const extraColumnAliases = bColumnAliases.filter(columnAlias => !aColumnAliases.includes(columnAlias));
        if (extraColumnAliases.length > 0) {
            throw new Error(`${identifier.join(" ")} has extra columns ${extraColumnAliases.join(", ")}`);
        }
        /**
         * Can't check subtype requirement during run-time
         */
    }
    exports.assertMapCompatibilityError = assertMapCompatibilityError;
    function assertRefCompatibilityError(identifier, a, b) {
        const aTableAliases = Object.keys(a);
        const bTableAliases = Object.keys(b);
        const missingTableAliases = aTableAliases.filter(tableAlias => !bTableAliases.includes(tableAlias));
        if (missingTableAliases.length > 0) {
            throw new Error(`Expected ${identifier.join(" ")} to have tables ${missingTableAliases.join(", ")}`);
        }
        const extraTableAliases = bTableAliases.filter(tableAlias => !aTableAliases.includes(tableAlias));
        if (extraTableAliases.length > 0) {
            throw new Error(`${identifier.join(" ")} has extra tables ${extraTableAliases.join(", ")}`);
        }
        for (const tableAlias of aTableAliases) {
            assertMapCompatibilityError([...identifier, "table", tableAlias], a[tableAlias], b[tableAlias]);
        }
    }
    exports.assertRefCompatibilityError = assertRefCompatibilityError;
    function assertSelectClauseCompatible(a, b) {
        if (a.length != b.length) {
            throw new Error(`SELECT clause length mismatch; expected ${a.length} received ${b.length}`);
        }
        for (let index = 0; index < a.length; ++index) {
            const itemA = a[index];
            const itemB = b[index];
            if (column_8.ColumnUtil.isColumn(itemA) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemA)) {
                if (column_8.ColumnUtil.isColumn(itemB) || expr_select_item_1.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                    /**
                     * Can't check subtype requirement during run-time
                     */
                }
                else {
                    throw new Error(`Expected index ${index} to be Column or ExprSelectItem`);
                }
            }
            else if (column_map_15.ColumnMapUtil.isColumnMap(itemA)) {
                if (column_map_15.ColumnMapUtil.isColumnMap(itemB)) {
                    assertMapCompatibilityError(["index", index], itemA, itemB);
                }
                else {
                    throw new Error(`Expected index ${index} to be ColumnMap`);
                }
            }
            else if (column_ref_8.ColumnRefUtil.isColumnRef(itemA)) {
                if (column_ref_8.ColumnRefUtil.isColumnRef(itemB)) {
                    assertRefCompatibilityError(["index", index], itemA, itemB);
                }
                else {
                    throw new Error(`Expected index ${index} to be ColumnRef`);
                }
            }
            else {
                throw new Error(`Unknown SELECT item at index ${index}`);
            }
        }
    }
    exports.assertSelectClauseCompatible = assertSelectClauseCompatible;
});
define("compound-query-clause/util/predicate/assert-outer-query-joins-compatible", ["require", "exports", "used-ref/index"], function (require, exports, used_ref_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertOuterQueryJoinsCompatible(fromClause, targetFromClause) {
        used_ref_7.UsedRefUtil.assertAllowed(used_ref_7.UsedRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins), used_ref_7.UsedRefUtil.fromJoinArray(targetFromClause.outerQueryJoins == undefined ?
            [] :
            targetFromClause.outerQueryJoins));
    }
    exports.assertOuterQueryJoinsCompatible = assertOuterQueryJoinsCompatible;
});
define("compound-query-clause/util/predicate/assert-compatible", ["require", "exports", "compound-query-clause/util/predicate/assert-select-clause-compatible", "compound-query-clause/util/predicate/assert-outer-query-joins-compatible"], function (require, exports, assert_select_clause_compatible_1, assert_outer_query_joins_compatible_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertCompatible(fromClause, selectClause, targetQuery) {
        assert_select_clause_compatible_1.assertSelectClauseCompatible(selectClause, targetQuery.selectClause);
        assert_outer_query_joins_compatible_1.assertOuterQueryJoinsCompatible(fromClause, targetQuery.fromClause);
    }
    exports.assertCompatible = assertCompatible;
});
define("compound-query-clause/util/predicate/index", ["require", "exports", "compound-query-clause/util/predicate/assert-compatible", "compound-query-clause/util/predicate/assert-outer-query-joins-compatible", "compound-query-clause/util/predicate/assert-select-clause-compatible"], function (require, exports, assert_compatible_1, assert_outer_query_joins_compatible_2, assert_select_clause_compatible_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_compatible_1);
    __export(assert_outer_query_joins_compatible_2);
    __export(assert_select_clause_compatible_2);
});
define("compound-query-clause/util/operation/compound-query", ["require", "exports", "select-clause/index", "compound-query-clause/util/predicate/index"], function (require, exports, select_clause_1, predicate_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compoundQuery(fromClause, selectClause, compoundQueryClause, compoundQueryType, isDistinct, targetQuery) {
        predicate_22.assertCompatible(fromClause, selectClause, targetQuery);
        return {
            selectClause: select_clause_1.SelectClauseUtil.leftCompound(selectClause, targetQuery.selectClause),
            compoundQueryClause: [
                ...(compoundQueryClause == undefined ?
                    [] :
                    compoundQueryClause),
                {
                    compoundQueryType,
                    isDistinct,
                    query: targetQuery,
                }
            ]
        };
    }
    exports.compoundQuery = compoundQuery;
});
define("compound-query-clause/util/operation/index", ["require", "exports", "compound-query-clause/util/operation/compound-query"], function (require, exports, compound_query_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_2);
});
define("compound-query-clause/util/index", ["require", "exports", "compound-query-clause/util/operation/index", "compound-query-clause/util/predicate/index"], function (require, exports, operation_11, predicate_23) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_11);
    __export(predicate_23);
});
define("compound-query-clause/index", ["require", "exports", "compound-query-clause/util/index"], function (require, exports, CompoundQueryClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompoundQueryClauseUtil = CompoundQueryClauseUtil;
});
define("limit-clause/limit-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("limit-clause/util/operation/offset-bigint", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ALL_ROW_COUNT = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
    exports.MAX_OFFSET = tm.TypeUtil.getBigIntFactoryFunctionOrError()("9223372036854775807");
    function offsetBigInt(limitClause, offset) {
        if (tm.BigIntUtil.lessThan(offset, 0)) {
            throw new Error(`Cannot OFFSET fewer than zero rows`);
        }
        if (tm.BigIntUtil.greaterThan(offset, exports.MAX_OFFSET)) {
            throw new Error(`Cannot OFFSET more than ${exports.MAX_OFFSET} rows`);
        }
        if (limitClause == undefined) {
            return {
                maxRowCount: exports.ALL_ROW_COUNT,
                offset,
            };
        }
        else {
            return {
                maxRowCount: limitClause.maxRowCount,
                offset,
            };
        }
    }
    exports.offsetBigInt = offsetBigInt;
});
define("limit-clause/util/operation/limit-bigint", ["require", "exports", "type-mapping", "limit-clause/util/operation/offset-bigint"], function (require, exports, tm, offset_bigint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function limitBigInt(limitClause, maxRowCount) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        if (tm.BigIntUtil.lessThan(maxRowCount, 0)) {
            throw new Error(`Cannot LIMIT fewer than zero rows`);
        }
        if (tm.BigIntUtil.greaterThan(maxRowCount, offset_bigint_1.ALL_ROW_COUNT)) {
            throw new Error(`Cannot LIMIT more than ${offset_bigint_1.ALL_ROW_COUNT} rows`);
        }
        if (limitClause == undefined) {
            return {
                maxRowCount,
                offset: BigInt(0),
            };
        }
        else {
            return {
                maxRowCount,
                offset: limitClause.offset,
            };
        }
    }
    exports.limitBigInt = limitBigInt;
});
define("limit-clause/util/operation/limit-number", ["require", "exports", "type-mapping", "limit-clause/util/operation/limit-bigint"], function (require, exports, tm, limit_bigint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function limitNumber(limitClause, maxRowCount) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return limit_bigint_1.limitBigInt(limitClause, 
        /**
         * Will throw a run-time error if `maxRowCount` is not an integer.
         */
        BigInt(maxRowCount));
    }
    exports.limitNumber = limitNumber;
});
define("limit-clause/util/operation/limit", ["require", "exports", "limit-clause/util/operation/limit-bigint", "limit-clause/util/operation/limit-number"], function (require, exports, limit_bigint_2, limit_number_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function limit(limitClause, maxRowCount) {
        if (typeof maxRowCount == "number") {
            return limit_number_1.limitNumber(limitClause, maxRowCount);
        }
        else {
            return limit_bigint_2.limitBigInt(limitClause, maxRowCount);
        }
    }
    exports.limit = limit;
});
define("limit-clause/util/operation/offset-number", ["require", "exports", "type-mapping", "limit-clause/util/operation/offset-bigint"], function (require, exports, tm, offset_bigint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function offsetNumber(limitClause, offset) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return offset_bigint_2.offsetBigInt(limitClause, 
        /**
         * Will throw a run-time error if `offset` is not an integer.
         */
        BigInt(offset));
    }
    exports.offsetNumber = offsetNumber;
});
define("limit-clause/util/operation/offset", ["require", "exports", "limit-clause/util/operation/offset-bigint", "limit-clause/util/operation/offset-number"], function (require, exports, offset_bigint_3, offset_number_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function offset(limitClause, offset) {
        if (typeof offset == "number") {
            return offset_number_1.offsetNumber(limitClause, offset);
        }
        else {
            return offset_bigint_3.offsetBigInt(limitClause, offset);
        }
    }
    exports.offset = offset;
});
define("limit-clause/util/operation/index", ["require", "exports", "limit-clause/util/operation/limit-bigint", "limit-clause/util/operation/limit-number", "limit-clause/util/operation/limit", "limit-clause/util/operation/offset-bigint", "limit-clause/util/operation/offset-number", "limit-clause/util/operation/offset"], function (require, exports, limit_bigint_3, limit_number_2, limit_1, offset_bigint_4, offset_number_2, offset_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(limit_bigint_3);
    __export(limit_number_2);
    __export(limit_1);
    __export(offset_bigint_4);
    __export(offset_number_2);
    __export(offset_1);
});
define("limit-clause/util/index", ["require", "exports", "limit-clause/util/operation/index"], function (require, exports, operation_12) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_12);
});
define("limit-clause/index", ["require", "exports", "limit-clause/util/index"], function (require, exports, LimitClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LimitClauseUtil = LimitClauseUtil;
});
define("group-by-clause/group-by-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("group-by-clause/util/query/allowed-used-ref", ["require", "exports", "column-identifier-ref/index"], function (require, exports, column_identifier_ref_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedColumnIdentifierRef(fromClause) {
        return column_identifier_ref_6.ColumnIdentifierRefUtil.fromJoinArray(fromClause.currentJoins);
    }
    exports.allowedColumnIdentifierRef = allowedColumnIdentifierRef;
});
define("group-by-clause/util/query/index", ["require", "exports", "group-by-clause/util/query/allowed-used-ref"], function (require, exports, allowed_used_ref_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_used_ref_5);
});
define("group-by-clause/util/operation/group-by", ["require", "exports", "from-clause/index", "group-by-clause/util/query/index", "column-identifier-ref/index"], function (require, exports, from_clause_3, query_17, column_identifier_ref_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `...groupByClause, ...groupByDelegate(columns)`
     *
     * -----
     *
     * Consider the following,
     * ```sql
     *  SELECT 1 AS a GROUP BY a
     * ```
     *
     * + The above works on PostgreSQL 9.4
     * + The above **does not** work on MySQL 5.7
     * -----
     *
     * We only allow `GROUP BY` after the `FROM` clause because
     * it isn't very useful without a `FROM` clause.
     *
     * @param fromClause
     * @param selectClause
     * @param groupByClause
     * @param groupByDelegate
     */
    function groupBy(fromClause, groupByClause, groupByDelegate) {
        from_clause_3.FromClauseUtil.assertAfterFromClause(fromClause);
        const columns = query_17.allowedColumnIdentifierRef(fromClause);
        const groupBy = groupByDelegate(column_identifier_ref_7.ColumnIdentifierRefUtil.tryFlatten(columns));
        column_identifier_ref_7.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(columns, groupBy);
        return (groupByClause == undefined ?
            groupBy :
            [...groupByClause, ...groupBy]);
    }
    exports.groupBy = groupBy;
});
define("group-by-clause/util/operation/index", ["require", "exports", "group-by-clause/util/operation/group-by"], function (require, exports, group_by_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(group_by_1);
});
define("group-by-clause/util/predicate/is-non-empty", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNonEmpty(groupByClause) {
        if (groupByClause.length == 0) {
            throw new Error(`GROUP BY clause cannot be empty`);
        }
    }
    exports.assertNonEmpty = assertNonEmpty;
});
define("group-by-clause/util/predicate/index", ["require", "exports", "group-by-clause/util/predicate/is-non-empty"], function (require, exports, is_non_empty_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_non_empty_1);
});
define("group-by-clause/util/index", ["require", "exports", "group-by-clause/util/operation/index", "group-by-clause/util/predicate/index", "group-by-clause/util/query/index"], function (require, exports, operation_13, predicate_24, query_18) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_13);
    __export(predicate_24);
    __export(query_18);
});
define("group-by-clause/group-by-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("group-by-clause/index", ["require", "exports", "group-by-clause/util/index"], function (require, exports, GroupByClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GroupByClauseUtil = GroupByClauseUtil;
});
define("having-clause/having-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("having-clause/util/query/allowed-non-aggregate-used-ref", ["require", "exports", "column-ref/index", "used-ref/index"], function (require, exports, column_ref_9, used_ref_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedNonAggregateColumnRef(fromClause, groupByClause) {
        const outer = column_ref_9.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins);
        const inner = column_ref_9.ColumnRefUtil.extractColumnIdentifiers(column_ref_9.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
            [] :
            fromClause.currentJoins), groupByClause);
        return column_ref_9.ColumnRefUtil.intersect(outer, inner);
    }
    exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
    function allowedNonAggregateUsedRef(fromClause, groupByClause) {
        return used_ref_8.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
    }
    exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
});
define("having-clause/util/query/allowed-used-ref", ["require", "exports", "from-clause/index"], function (require, exports, from_clause_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedColumnRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     */
    function allowedColumnRef(fromClause) {
        return from_clause_4.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
    }
    exports.allowedColumnRef = allowedColumnRef;
    /**
     * For now, this is basically the same as `WhereClauseUtil.AllowedUsedRef<>`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     */
    function allowedUsedRef(fromClause) {
        return from_clause_4.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("having-clause/util/query/index", ["require", "exports", "having-clause/util/query/allowed-non-aggregate-used-ref", "having-clause/util/query/allowed-used-ref"], function (require, exports, allowed_non_aggregate_used_ref_1, allowed_used_ref_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_non_aggregate_used_ref_1);
    __export(allowed_used_ref_6);
});
define("having-clause/util/operation/having", ["require", "exports", "column-ref/index", "expr-library/index", "having-clause/util/query/index", "used-ref/index", "expr/index", "built-in-expr/index", "group-by-clause/index"], function (require, exports, column_ref_10, ExprLib, query_19, used_ref_9, expr_3, built_in_expr_6, group_by_clause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `havingClause AND havingDelegate(columns)`
     *
     * -----
     *
     * For now, this is basically the same as `WhereClauseUtil.where<>()`.
     *
     * They will diverge when,
     * + The `HAVING` clause enforces proper `GROUP BY` interactions.
     *
     * -----
     *
     * @param fromClause
     * @param havingClause
     * @param havingDelegate
     */
    function having(fromClause, groupByClause, havingClause, havingDelegate) {
        group_by_clause_1.GroupByClauseUtil.assertNonEmpty(groupByClause);
        const columns = query_19.allowedColumnRef(fromClause);
        const operand = havingDelegate(column_ref_10.ColumnRefUtil.tryFlatten(columns));
        if (built_in_expr_6.BuiltInExprUtil.isAggregate(operand)) {
            used_ref_9.UsedRefUtil.assertAllowed({ columns }, built_in_expr_6.BuiltInExprUtil.usedRef(operand));
        }
        else {
            used_ref_9.UsedRefUtil.assertAllowed({
                columns: query_19.allowedNonAggregateColumnRef(fromClause, groupByClause),
            }, built_in_expr_6.BuiltInExprUtil.usedRef(operand));
        }
        return (havingClause == undefined ?
            expr_3.ExprUtil.fromBuiltInExpr(operand) :
            ExprLib.and(havingClause, operand));
    }
    exports.having = having;
});
define("having-clause/util/operation/index", ["require", "exports", "having-clause/util/operation/having"], function (require, exports, having_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(having_1);
});
define("having-clause/util/index", ["require", "exports", "having-clause/util/operation/index", "having-clause/util/query/index"], function (require, exports, operation_14, query_20) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_14);
    __export(query_20);
});
define("having-clause/having-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("having-clause/index", ["require", "exports", "having-clause/util/index"], function (require, exports, HavingClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HavingClauseUtil = HavingClauseUtil;
});
define("sort-direction/sort-direction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The direction to sort the result set
     */
    var SortDirection;
    (function (SortDirection) {
        /**
         * Sorts the result set in ascending order
         */
        SortDirection.ASC = "ASC";
        /**
         * Sorts the result set in descending order
         */
        SortDirection.DESC = "DESC";
    })(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
    ;
});
define("sort-direction/util/predicate/is-sort-direction", ["require", "exports", "sort-direction/sort-direction"], function (require, exports, sort_direction_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSortDirection(mixed) {
        return (mixed == sort_direction_1.SortDirection.ASC ||
            mixed == sort_direction_1.SortDirection.DESC);
    }
    exports.isSortDirection = isSortDirection;
});
define("sort-direction/util/predicate/index", ["require", "exports", "sort-direction/util/predicate/is-sort-direction"], function (require, exports, is_sort_direction_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_sort_direction_1);
});
define("sort-direction/util/index", ["require", "exports", "sort-direction/util/predicate/index"], function (require, exports, predicate_25) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_25);
});
define("sort-direction/index", ["require", "exports", "sort-direction/sort-direction", "sort-direction/util/index"], function (require, exports, sort_direction_2, SortDirectionUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(sort_direction_2);
    exports.SortDirectionUtil = SortDirectionUtil;
});
define("order/order", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("order/util/predicate/is-order", ["require", "exports", "sort-direction/index"], function (require, exports, sort_direction_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Checks,
     * + If it is an 2-tuple
     * + If the second element is a `SortDirection`
     *
     * Does not check,
     * + If the first element is a `SortExpr` (for run-time performance)
     *
     * @param mixed
     */
    function isOrder(mixed) {
        return (Array.isArray(mixed) &&
            mixed.length == 2 &&
            sort_direction_3.SortDirectionUtil.isSortDirection(mixed[1]));
    }
    exports.isOrder = isOrder;
});
define("order/util/predicate/is-sort-expr", ["require", "exports", "column/index", "expr/index", "expr-select-item/index"], function (require, exports, column_9, expr_4, expr_select_item_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSortExpr(mixed) {
        return (column_9.ColumnUtil.isColumn(mixed) ||
            expr_4.ExprUtil.isExpr(mixed) ||
            expr_select_item_2.ExprSelectItemUtil.isExprSelectItem(mixed));
    }
    exports.isSortExpr = isSortExpr;
});
define("order/util/predicate/index", ["require", "exports", "order/util/predicate/is-order", "order/util/predicate/is-sort-expr"], function (require, exports, is_order_1, is_sort_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_order_1);
    __export(is_sort_expr_1);
});
define("order/util/constructor/from-raw-order", ["require", "exports", "sort-direction/index", "order/util/predicate/index"], function (require, exports, sort_direction_4, predicate_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromRawOrder(rawOrder) {
        if (predicate_26.isOrder(rawOrder)) {
            return rawOrder;
        }
        else {
            return [rawOrder, sort_direction_4.SortDirection.ASC];
        }
    }
    exports.fromRawOrder = fromRawOrder;
});
define("order/util/constructor/index", ["require", "exports", "order/util/constructor/from-raw-order"], function (require, exports, from_raw_order_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_raw_order_1);
});
define("order/util/query/extract-sort-expr", ["require", "exports", "order/util/predicate/index"], function (require, exports, predicate_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractSortExpr(rawOrder) {
        if (predicate_27.isOrder(rawOrder)) {
            return rawOrder[0];
        }
        else {
            return rawOrder;
        }
    }
    exports.extractSortExpr = extractSortExpr;
});
define("order/util/query/index", ["require", "exports", "order/util/query/extract-sort-expr"], function (require, exports, extract_sort_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_sort_expr_1);
});
define("order/util/index", ["require", "exports", "order/util/constructor/index", "order/util/predicate/index", "order/util/query/index"], function (require, exports, constructor_7, predicate_28, query_21) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_7);
    __export(predicate_28);
    __export(query_21);
});
define("order/index", ["require", "exports", "order/util/index"], function (require, exports, OrderUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderUtil = OrderUtil;
});
define("order-by-clause/order-by-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("order-by-clause/util/query/allowed-non-aggregate-used-ref", ["require", "exports", "column-ref/index", "used-ref/index"], function (require, exports, column_ref_11, used_ref_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause) {
        const inner = column_ref_11.ColumnRefUtil.extractColumnIdentifiers(column_ref_11.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
            [] :
            fromClause.currentJoins), groupByClause);
        const selectClauseColumns = (selectClause == undefined ?
            {} :
            column_ref_11.ColumnRefUtil.fromSelectClause(selectClause));
        const result = column_ref_11.ColumnRefUtil.intersect(inner, selectClauseColumns);
        return result;
    }
    exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
    function allowedNonAggregateUsedRef(fromClause, groupByClause, selectClause) {
        const usedRef = used_ref_10.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause));
        return usedRef;
    }
    exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
});
define("order-by-clause/util/query/allowed-used-ref", ["require", "exports", "column-ref/index", "used-ref/index"], function (require, exports, column_ref_12, used_ref_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * For now, this is basically the same as `HavingClauseUtil.AllowedColumnRef<>`.
     *
     * They will diverge when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    function allowedColumnRef(fromClause, selectClause) {
        const fromClauseColumns = column_ref_12.ColumnRefUtil.fromJoinArray((fromClause.currentJoins != undefined) ?
            fromClause.currentJoins :
            []);
        const selectClauseColumns = (selectClause == undefined ?
            {} :
            column_ref_12.ColumnRefUtil.fromSelectClause(selectClause));
        const result = column_ref_12.ColumnRefUtil.intersect(fromClauseColumns, selectClauseColumns);
        return result;
    }
    exports.allowedColumnRef = allowedColumnRef;
    /**
     * For now, this is basically the same as `HavingClauseUtil.AllowedUsedRef<>`.
     *
     * They will diverge when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     */
    function allowedUsedRef(fromClause, selectClause) {
        const usedRef = used_ref_11.UsedRefUtil.fromColumnRef(allowedColumnRef(fromClause, selectClause));
        return usedRef;
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("order-by-clause/util/query/index", ["require", "exports", "order-by-clause/util/query/allowed-non-aggregate-used-ref", "order-by-clause/util/query/allowed-used-ref"], function (require, exports, allowed_non_aggregate_used_ref_2, allowed_used_ref_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_non_aggregate_used_ref_2);
    __export(allowed_used_ref_7);
});
define("order-by-clause/util/operation/order-by", ["require", "exports", "column-ref/index", "order-by-clause/util/query/index", "used-ref/index", "order/index", "column/index", "column-identifier-ref/index", "built-in-expr/index"], function (require, exports, column_ref_13, query_22, used_ref_12, order_1, column_10, column_identifier_ref_8, built_in_expr_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `...orderBy, orderByDelegate(columns)`
     *
     * This will change when,
     * + The `ORDER BY` clause enforces proper `GROUP BY` interactions.
     *
     * -----
     *
     * @param fromClause
     * @param orderByClause
     * @param orderByDelegate
     */
    function orderBy(fromClause, groupByClause, selectClause, orderByClause, orderByDelegate) {
        const columns = query_22.allowedColumnRef(fromClause, selectClause);
        const orderBy = orderByDelegate(column_ref_13.ColumnRefUtil.tryFlatten(columns));
        if (groupByClause == undefined) {
            for (const rawOrder of orderBy) {
                const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
                if (built_in_expr_7.BuiltInExprUtil.isAggregate(sortExpr)) {
                    throw new Error(`Aggregate expressions in ORDER BY clause not allowed without GROUP BY clause`);
                }
                if (column_10.ColumnUtil.isColumn(sortExpr)) {
                    column_identifier_ref_8.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
                }
                else {
                    used_ref_12.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
                }
            }
        }
        else {
            const nonAggregateColumns = query_22.allowedNonAggregateColumnRef(fromClause, groupByClause, selectClause);
            for (const rawOrder of orderBy) {
                const sortExpr = order_1.OrderUtil.extractSortExpr(rawOrder);
                if (column_10.ColumnUtil.isColumn(sortExpr)) {
                    column_identifier_ref_8.ColumnIdentifierRefUtil.assertHasColumnIdentifier(nonAggregateColumns, sortExpr);
                }
                else {
                    if (built_in_expr_7.BuiltInExprUtil.isAggregate(sortExpr)) {
                        used_ref_12.UsedRefUtil.assertAllowed({ columns }, sortExpr.usedRef);
                    }
                    else {
                        used_ref_12.UsedRefUtil.assertAllowed({ columns: nonAggregateColumns }, sortExpr.usedRef);
                    }
                }
            }
        }
        return (orderByClause == undefined ?
            orderBy.map(order_1.OrderUtil.fromRawOrder) :
            [...orderByClause, ...orderBy.map(order_1.OrderUtil.fromRawOrder)]);
    }
    exports.orderBy = orderBy;
});
define("order-by-clause/util/operation/index", ["require", "exports", "order-by-clause/util/operation/order-by"], function (require, exports, order_by_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(order_by_1);
});
define("order-by-clause/util/index", ["require", "exports", "order-by-clause/util/operation/index", "order-by-clause/util/query/index"], function (require, exports, operation_15, query_23) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_15);
    __export(query_23);
});
define("order-by-clause/order-by-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("order-by-clause/index", ["require", "exports", "order-by-clause/util/index"], function (require, exports, OrderByClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderByClauseUtil = OrderByClauseUtil;
});
define("compound-query-order-by-clause/compound-query-order-by-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("compound-query-order-by-clause/util/query/allowed-used-ref", ["require", "exports", "column-ref/index"], function (require, exports, column_ref_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedColumnRef(selectClause) {
        const result = column_ref_14.ColumnRefUtil.fromSelectClause(selectClause);
        return result;
    }
    exports.allowedColumnRef = allowedColumnRef;
});
define("compound-query-order-by-clause/util/query/index", ["require", "exports", "compound-query-order-by-clause/util/query/allowed-used-ref"], function (require, exports, allowed_used_ref_8) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_used_ref_8);
});
define("tuple-util/pop-front", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("tuple-util/push-front", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("tuple-util/trampoline-util", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("tuple-util/reverse", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("tuple-util/concat", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("tuple-util/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("compound-query-order-by-clause/util/operation/compound-query-order-by", ["require", "exports", "compound-query-order-by-clause/util/query/index", "column-ref/index", "column-identifier-ref/index", "order/index"], function (require, exports, query_24, column_ref_15, column_identifier_ref_9, order_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `...compoundQueryOrderByClause, ...compoundQueryOrderByDelegate(columns)`
     *
     * @param selectClause
     * @param compoundQueryOrderByClause
     * @param compoundQueryOrderByDelegate
     */
    function compoundQueryOrderBy(selectClause, compoundQueryOrderByClause, compoundQueryOrderByDelegate) {
        const columns = query_24.allowedColumnRef(selectClause);
        const compoundQueryOrderBy = compoundQueryOrderByDelegate(column_ref_15.ColumnRefUtil.tryFlatten(columns));
        for (const rawOrder of compoundQueryOrderBy) {
            const sortExpr = order_2.OrderUtil.extractSortExpr(rawOrder);
            column_identifier_ref_9.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, sortExpr);
        }
        return (compoundQueryOrderByClause == undefined ?
            compoundQueryOrderBy.map(order_2.OrderUtil.fromRawOrder) :
            [...compoundQueryOrderByClause, ...compoundQueryOrderBy.map(order_2.OrderUtil.fromRawOrder)]);
    }
    exports.compoundQueryOrderBy = compoundQueryOrderBy;
});
define("compound-query-order-by-clause/util/operation/index", ["require", "exports", "compound-query-order-by-clause/util/operation/compound-query-order-by"], function (require, exports, compound_query_order_by_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_order_by_1);
});
define("compound-query-order-by-clause/util/index", ["require", "exports", "compound-query-order-by-clause/util/operation/index", "compound-query-order-by-clause/util/query/index"], function (require, exports, operation_16, query_25) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_16);
    __export(query_25);
});
define("compound-query-order-by-clause/compound-query-order-by-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("compound-query-order-by-clause/index", ["require", "exports", "compound-query-order-by-clause/util/index"], function (require, exports, CompoundQueryOrderByClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompoundQueryOrderByClauseUtil = CompoundQueryOrderByClauseUtil;
});
define("map-delegate/map-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("map-delegate/util/operation/compose", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compose(cur, nxt) {
        return async (row, connection, originalRow) => {
            const tmp = await cur(row, connection, originalRow);
            const result = await nxt(tmp, connection, originalRow);
            return result;
        };
    }
    exports.compose = compose;
});
define("map-delegate/util/operation/index", ["require", "exports", "map-delegate/util/operation/compose"], function (require, exports, compose_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compose_1);
});
define("map-delegate/util/index", ["require", "exports", "map-delegate/util/operation/index"], function (require, exports, operation_17) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_17);
});
define("map-delegate/index", ["require", "exports", "map-delegate/util/index"], function (require, exports, MapDelegateUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapDelegateUtil = MapDelegateUtil;
});
define("query-base/query-base", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/after-compound-query-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/after-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/after-group-by-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/after-select-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/before-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/before-select-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/before-compound-query-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/mapped", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/non-correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/one-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/one-select-item", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/unmapped", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/zero-or-one-row-using-limit", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/zero-or-one-row-using-compound-query-limit", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/zero-or-one-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/helper-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("derived-table/util/operation/lateral", ["require", "exports", "derived-table/derived-table-impl"], function (require, exports, derived_table_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Makes a derived table a `LATERAL` derived table.
     *
     * -----
     *
     * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      (
     *          SELECT
     *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * However, a `LATERAL` derived table can,
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable
     *  CROSS JOIN
     *      LATERAL (
     *          SELECT
     *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
     *              myTable.x + otherTable.y AS z
     *          FROM
     *              otherTable
     *      ) AS tmpTable
     * ```
     *
     * Note:
     * + Not supported in MySQL 5.7
     * + Supported as of MySQL 8.0.14
     */
    function lateral(derivedTable) {
        const result = new derived_table_impl_1.DerivedTable({
            isLateral: true,
            alias: derivedTable.alias,
            columns: derivedTable.columns,
            usedRef: derivedTable.usedRef,
        }, derivedTable.unaliasedAst);
        return result;
    }
    exports.lateral = lateral;
});
define("derived-table/util/operation/index", ["require", "exports", "derived-table/util/operation/lateral"], function (require, exports, lateral_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(lateral_1);
});
define("derived-table/util/index", ["require", "exports", "derived-table/util/operation/index"], function (require, exports, operation_18) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_18);
});
define("derived-table/derived-table-impl", ["require", "exports", "derived-table/util/index"], function (require, exports, DerivedTableUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A query can be aliased,
     *
     * ```sql
     * SELECT
     *  *
     * FROM
     *  myTable
     * CROSS JOIN
     *  (
     *      SELECT
     *          RAND() AS randomNumber,
     *          UTC_TIMESTAMP() AS timeNow
     *  ) AS tmpTable --This is a `DerivedTable`
     * ```
     *
     */
    class DerivedTable {
        constructor(data, unaliasedAst) {
            this.isLateral = data.isLateral;
            this.alias = data.alias;
            this.columns = data.columns;
            this.usedRef = data.usedRef;
            this.unaliasedAst = unaliasedAst;
        }
        /**
         * Makes a derived table a `LATERAL` derived table.
         *
         * -----
         *
         * Normally, a derived table cannot use a column from a preceding table in the same `FROM` clause,
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable
         *  CROSS JOIN
         *      (
         *          SELECT
         *              --Error, cannot reference `myTable.x`; it is a column in the same `FROM` clause
         *              myTable.x + otherTable.y AS z
         *          FROM
         *              otherTable
         *      ) AS tmpTable
         * ```
         *
         * However, a `LATERAL` derived table can,
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable
         *  CROSS JOIN
         *      LATERAL (
         *          SELECT
         *              --OK! `LATERAL` derived tables can access columns in the same `FROM` clause
         *              myTable.x + otherTable.y AS z
         *          FROM
         *              otherTable
         *      ) AS tmpTable
         * ```
         *
         * Note:
         * + Not supported in MySQL 5.7
         * + Supported as of MySQL 8.0.14
         */
        lateral() {
            return DerivedTableUtil.lateral(this);
        }
    }
    exports.DerivedTable = DerivedTable;
});
define("derived-table/index", ["require", "exports", "derived-table/derived-table-impl", "derived-table/util/index"], function (require, exports, derived_table_impl_2, DerivedTableUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(derived_table_impl_2);
    exports.DerivedTableUtil = DerivedTableUtil;
});
define("query-base/util/query/type-of", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("query-base/util/predicate/is-query", ["require", "exports", "type-util/index"], function (require, exports, type_util_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import {UsedRefUtil} from "../../../used-ref";
    //import {AstUtil} from "../../../ast";
    /**
     * Only checks that the properties exist.
     * Does not actually check that they are the right data type!
     *
     * @todo Consider adding checks for increased type safety.
     */
    function isQuery(x) {
        if (!type_util_7.isObjectWithOwnEnumerableKeys()(x, [
            "fromClause",
            "selectClause",
            "limitClause",
            "compoundQueryClause",
            "compoundQueryLimitClause",
            "mapDelegate",
            "whereClause",
            "groupByClause",
            "havingClause",
            "orderByClause",
            "compoundQueryOrderByClause",
            "isDistinct",
        ])) {
            return false;
        }
        return true;
    }
    exports.isQuery = isQuery;
});
define("query-base/util/predicate/is-after-from-clause", ["require", "exports", "query-base/util/predicate/is-query", "from-clause/index"], function (require, exports, is_query_1, from_clause_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAfterFromClause(x) {
        return is_query_1.isQuery(x) && from_clause_5.FromClauseUtil.isAfterFromClause(x.fromClause);
    }
    exports.isAfterFromClause = isAfterFromClause;
});
define("query-base/util/predicate/is-after-select-clause", ["require", "exports", "query-base/util/predicate/is-query"], function (require, exports, is_query_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAfterSelectClause(x) {
        return is_query_2.isQuery(x) && (x.selectClause != undefined);
    }
    exports.isAfterSelectClause = isAfterSelectClause;
});
define("query-base/util/predicate/is-before-compound-query-clause", ["require", "exports", "query-base/util/predicate/is-query"], function (require, exports, is_query_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBeforeCompoundQueryClause(x) {
        return is_query_3.isQuery(x) && (x.compoundQueryClause == undefined);
    }
    exports.isBeforeCompoundQueryClause = isBeforeCompoundQueryClause;
});
define("query-base/util/predicate/is-before-select-clause", ["require", "exports", "query-base/util/predicate/is-query"], function (require, exports, is_query_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBeforeSelectClause(x) {
        return is_query_4.isQuery(x) && (x.selectClause == undefined);
    }
    exports.isBeforeSelectClause = isBeforeSelectClause;
});
define("query-base/util/predicate/is-one-row", ["require", "exports", "query-base/util/predicate/is-query", "from-clause/index"], function (require, exports, is_query_5, from_clause_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isOneRow(x) {
        return (is_query_5.isQuery(x) &&
            ((from_clause_6.FromClauseUtil.isBeforeFromClause(x.fromClause) &&
                x.compoundQueryClause == undefined) ||
                (x.groupByClause != undefined &&
                    x.groupByClause.length == 0 &&
                    x.compoundQueryClause == undefined)));
    }
    exports.isOneRow = isOneRow;
});
define("query-base/util/predicate/is-one-select-item", ["require", "exports", "query-base/util/predicate/is-after-select-clause", "select-item/index"], function (require, exports, is_after_select_clause_1, select_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isOneSelectItem(x) {
        return (is_after_select_clause_1.isAfterSelectClause(x) &&
            x.selectClause.length == 1 &&
            select_item_1.SelectItemUtil.isSingleValueSelectItem(x.selectClause[0]));
    }
    exports.isOneSelectItem = isOneSelectItem;
});
define("query-base/util/predicate/is-zero-or-one-row-using-limit", ["require", "exports", "type-mapping", "query-base/util/predicate/is-query"], function (require, exports, tm, is_query_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isZeroOrOneRowUsingLimit(x) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return (is_query_6.isQuery(x) &&
            x.limitClause != undefined &&
            (tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(0)) ||
                tm.BigIntUtil.equal(x.limitClause.maxRowCount, BigInt(1))) &&
            x.compoundQueryClause == undefined &&
            x.compoundQueryLimitClause == undefined);
    }
    exports.isZeroOrOneRowUsingLimit = isZeroOrOneRowUsingLimit;
});
define("query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit", ["require", "exports", "type-mapping", "query-base/util/predicate/is-query"], function (require, exports, tm, is_query_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isZeroOrOneRowUsingCompoundQueryLimit(x) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        return (is_query_7.isQuery(x) &&
            x.compoundQueryLimitClause != undefined &&
            (tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(0)) ||
                tm.BigIntUtil.equal(x.compoundQueryLimitClause.maxRowCount, BigInt(1))));
    }
    exports.isZeroOrOneRowUsingCompoundQueryLimit = isZeroOrOneRowUsingCompoundQueryLimit;
});
define("query-base/util/predicate/is-zero-or-one-row", ["require", "exports", "query-base/util/predicate/is-one-row", "query-base/util/predicate/is-zero-or-one-row-using-limit", "query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit"], function (require, exports, is_one_row_1, is_zero_or_one_row_using_limit_1, is_zero_or_one_row_using_compound_query_limit_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isZeroOrOneRow(x) {
        return (
        /**
         * This `OR` expression is sorted from most likely to least likely.
         * Do not change the order unless you have a good reason!
         */
        is_zero_or_one_row_using_limit_1.isZeroOrOneRowUsingLimit(x) ||
            is_zero_or_one_row_using_compound_query_limit_1.isZeroOrOneRowUsingCompoundQueryLimit(x) ||
            is_one_row_1.isOneRow(x));
    }
    exports.isZeroOrOneRow = isZeroOrOneRow;
});
define("query-base/util/predicate/index", ["require", "exports", "query-base/util/predicate/is-after-from-clause", "query-base/util/predicate/is-after-select-clause", "query-base/util/predicate/is-before-compound-query-clause", "query-base/util/predicate/is-before-select-clause", "query-base/util/predicate/is-one-row", "query-base/util/predicate/is-one-select-item", "query-base/util/predicate/is-query", "query-base/util/predicate/is-zero-or-one-row-using-limit", "query-base/util/predicate/is-zero-or-one-row-using-compound-query-limit", "query-base/util/predicate/is-zero-or-one-row"], function (require, exports, is_after_from_clause_2, is_after_select_clause_2, is_before_compound_query_clause_1, is_before_select_clause_1, is_one_row_2, is_one_select_item_1, is_query_8, is_zero_or_one_row_using_limit_2, is_zero_or_one_row_using_compound_query_limit_2, is_zero_or_one_row_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_after_from_clause_2);
    __export(is_after_select_clause_2);
    __export(is_before_compound_query_clause_1);
    __export(is_before_select_clause_1);
    __export(is_one_row_2);
    __export(is_one_select_item_1);
    __export(is_query_8);
    __export(is_zero_or_one_row_using_limit_2);
    __export(is_zero_or_one_row_using_compound_query_limit_2);
    __export(is_zero_or_one_row_1);
});
define("query-base/util/query/mapper", ["require", "exports", "type-mapping", "query-base/util/predicate/index"], function (require, exports, tm, predicate_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(query) {
        if (predicate_29.isOneRow(query)) {
            return query.selectClause[0].mapper;
        }
        else {
            return tm.orNull(query.selectClause[0].mapper);
        }
    }
    exports.mapper = mapper;
});
define("query-base/util/query/index", ["require", "exports", "query-base/util/query/mapper"], function (require, exports, mapper_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_5);
});
define("constants", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This string value `$aliased` was picked
     * as it is unlikely to be part of an identifier
     * in a database.
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  RAND() AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  RAND() AS `$aliased--r`
     * ```
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
     * ```
     *
     * @todo Make this a reserved `tableAlias`
     * No `ITable/IAliasedTable` should be able to have
     * a `tableAlias` value of `typeof ALIASED`.
     *
     * If such a thing were to happen,
     * it would make enforcing safe interactions between
     * `SELECT` and `FROM` clause very difficult/troublesome.
     *
     * But... What's the probability of someone using `$aliased`
     * as a table name?
     */
    exports.ALIASED = "$aliased";
    /**
     * This string value `--` was picked
     * as it is unlikely to be part of an identifier
     * in a database.
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  RAND() AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  RAND() AS `$aliased--r`
     * ```
     *
     * -----
     *
     * This query,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS r
     * ```
     *
     * becomes,
     * ```sql
     * SELECT
     *  (SELECT x FROM myTable LIMIT 1) AS `$aliased--r`
     * ```
     */
    exports.SEPARATOR = "--";
});
define("derived-table-select-item/derived-table-select-item-impl", ["require", "exports", "derived-table/index", "expr/index"], function (require, exports, derived_table_1, expr_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Meant to be a combination of `DerivedTable` and `AliasedExpr`.
     */
    class DerivedTableSelectItem {
        constructor(data, unaliasedAst) {
            this.mapper = data.mapper;
            this.isLateral = data.isLateral;
            this.tableAlias = data.tableAlias;
            this.alias = data.alias;
            this.columns = data.columns;
            this.usedRef = data.usedRef;
            this.isAggregate = data.isAggregate;
            this.ast = unaliasedAst;
            this.unaliasedAst = unaliasedAst;
        }
        /**
         * For now, the moment you use the `LATERAL` modifier,
         * it can no longer be used as an expression or aliased expression.
         *
         * No real reason for this rule, just laziness.
         */
        lateral() {
            return derived_table_1.DerivedTableUtil.lateral(this);
        }
        /**
         * For now, the moment you try to re-alias,
         * it can no longer be used as a derived table.
         *
         * No real reason for this rule, just laziness.
         *
         * -----
         *
         * If you are running into "max instantiation depth" errors,
         * consider adding explicit `TableExpr<>` type annotations.
         *
         * If that doesn't help,
         * consider using `ExprUtil.as()` instead.
         *
         * Also, consider reading this to understand my frustration,
         * https://github.com/microsoft/TypeScript/issues/29511
         *
         * @param alias
         */
        as(alias) {
            return expr_5.ExprUtil.as(this, alias);
        }
        /**
         * ```sql
         * ORDER BY
         *  RAND() ASC
         * ```
         */
        asc() {
            return expr_5.ExprUtil.asc(this);
        }
        /**
         * ```sql
         * ORDER BY
         *  RAND() DESC
         * ```
         */
        desc() {
            return expr_5.ExprUtil.desc(this);
        }
        /**
         * ```sql
         * ORDER BY
         *  (myTable.myColumn IS NOT NULL) ASC,
         *  RAND() DESC
         * ```
         */
        sort(sortDirection) {
            return expr_5.ExprUtil.sort(this, sortDirection);
        }
    }
    exports.DerivedTableSelectItem = DerivedTableSelectItem;
});
define("derived-table-select-item/index", ["require", "exports", "derived-table-select-item/derived-table-select-item-impl"], function (require, exports, derived_table_select_item_impl_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(derived_table_select_item_impl_1);
});
define("query-base/util/operation/as", ["require", "exports", "derived-table/index", "used-ref/index", "column-map/index", "query-base/util/query/index", "constants", "derived-table-select-item/index", "select-clause/index", "query-base/util/predicate/index", "ast/index"], function (require, exports, derived_table_2, used_ref_13, column_map_16, query_26, constants_1, derived_table_select_item_1, select_clause_2, predicate_30, ast_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertAliasable(query) {
        const duplicateColumnAlias = select_clause_2.SelectClauseUtil.duplicateColumnAlias(query.selectClause);
        if (duplicateColumnAlias.length > 0) {
            throw new Error(`Cannot alias query with duplicate names in SELECT clause; ${duplicateColumnAlias.join(", ")}`);
        }
    }
    function as(query, alias) {
        assertAliasable(query);
        if (predicate_30.isOneSelectItem(query) && predicate_30.isZeroOrOneRow(query)) {
            const result = new derived_table_select_item_1.DerivedTableSelectItem({
                mapper: query_26.mapper(query),
                isLateral: false,
                tableAlias: constants_1.ALIASED,
                alias,
                columns: (column_map_16.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
                usedRef: used_ref_13.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                    [] :
                    query.fromClause.outerQueryJoins),
                isAggregate: false,
            }, ast_2.parentheses(query, false));
            /**
             * @todo Investigate why we can't cast to `As<>` directly
             */
            return result;
        }
        else {
            const result = new derived_table_2.DerivedTable({
                isLateral: false,
                alias,
                columns: (column_map_16.ColumnMapUtil.fromSelectClause(query.selectClause, alias, false)),
                usedRef: used_ref_13.UsedRefUtil.fromJoinArray(query.fromClause.outerQueryJoins == undefined ?
                    [] :
                    query.fromClause.outerQueryJoins),
            }, query);
            /**
             * @todo Investigate why we can't cast to `As<>` directly
             */
            return result;
        }
    }
    exports.as = as;
});
define("query-base/util/operation/coalesce", ["require", "exports", "expr-library/index"], function (require, exports, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function coalesce(query, defaultValue) {
        return ExprLib.coalesce(query, defaultValue);
    }
    exports.coalesce = coalesce;
});
define("query-base/util/operation/asc", ["require", "exports", "sort-direction/index", "query-base/util/operation/coalesce"], function (require, exports, sort_direction_5, coalesce_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function asc(query) {
        return [
            coalesce_1.coalesce(query, null),
            sort_direction_5.SortDirection.ASC
        ];
    }
    exports.asc = asc;
});
define("query-base/util/operation/desc", ["require", "exports", "sort-direction/index", "query-base/util/operation/coalesce"], function (require, exports, sort_direction_6, coalesce_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function desc(query) {
        return [
            coalesce_2.coalesce(query, null),
            sort_direction_6.SortDirection.DESC
        ];
    }
    exports.desc = desc;
});
define("query-base/util/operation/sort", ["require", "exports", "query-base/util/operation/coalesce"], function (require, exports, coalesce_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function sort(query, sortDirection) {
        return [
            coalesce_3.coalesce(query, null),
            sortDirection
        ];
    }
    exports.sort = sort;
});
define("query-base/util/operation/throw-if-null", ["require", "exports", "expr-library/index"], function (require, exports, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function throwIfNull(query) {
        return ExprLib.throwIfNull(query);
    }
    exports.throwIfNull = throwIfNull;
});
define("query-base/util/operation/index", ["require", "exports", "query-base/util/operation/as", "query-base/util/operation/asc", "query-base/util/operation/coalesce", "query-base/util/operation/desc", "query-base/util/operation/sort", "query-base/util/operation/throw-if-null"], function (require, exports, as_1, asc_1, coalesce_4, desc_1, sort_1, throw_if_null_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(as_1);
    __export(asc_1);
    __export(coalesce_4);
    __export(desc_1);
    __export(sort_1);
    __export(throw_if_null_1);
});
define("query-base/util/index", ["require", "exports", "query-base/util/operation/index", "query-base/util/predicate/index", "query-base/util/query/index"], function (require, exports, operation_19, predicate_31, query_27) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_19);
    __export(predicate_31);
    __export(query_27);
});
define("query-base/index", ["require", "exports", "query-base/util/index"], function (require, exports, QueryBaseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryBaseUtil = QueryBaseUtil;
});
define("custom-expr/util/query/is-aggregate", ["require", "exports", "built-in-expr/index"], function (require, exports, built_in_expr_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAggregate(customExpr) {
        if (built_in_expr_8.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
            return built_in_expr_8.BuiltInExprUtil.isAggregate(customExpr);
        }
        else {
            return false;
        }
    }
    exports.isAggregate = isAggregate;
});
define("custom-expr/util/query/type-of", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("custom-expr/util/query/used-ref", ["require", "exports", "used-ref/index", "built-in-expr/index"], function (require, exports, used_ref_14, built_in_expr_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function usedRef(customExpr) {
        if (built_in_expr_9.BuiltInExprUtil.isBuiltInExpr(customExpr)) {
            return built_in_expr_9.BuiltInExprUtil.usedRef(customExpr);
        }
        else {
            return used_ref_14.UsedRefUtil.fromColumnRef({});
        }
    }
    exports.usedRef = usedRef;
});
define("custom-expr/util/query/index", ["require", "exports", "custom-expr/util/query/is-aggregate", "custom-expr/util/query/used-ref"], function (require, exports, is_aggregate_1, used_ref_15) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_aggregate_1);
    __export(used_ref_15);
});
define("custom-expr/util/operation/map-non-correlated", ["require", "exports", "column/index", "built-in-expr/index", "used-ref/index", "custom-expr/util/query/index"], function (require, exports, column_11, built_in_expr_10, used_ref_16, query_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * If `value` is `AnyNonValueExpr`, we don't bother checking.
     * We can't really check, anyway.
     *
     * Else, we return `mapper(, value)`,
     * which will throw an error if `value` is invalid.
     */
    function mapNonCorrelated(mapper, customExpr) {
        let valueName = "literal-value";
        if (column_11.ColumnUtil.isColumn(mapper)) {
            valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
            mapper = mapper.mapper;
        }
        if (built_in_expr_10.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
            /**
             * Cannot map a `NonValueExpr`
             */
            used_ref_16.UsedRefUtil.assertEmpty(query_28.usedRef(customExpr));
            return customExpr;
        }
        else {
            return mapper(valueName, customExpr);
        }
    }
    exports.mapNonCorrelated = mapNonCorrelated;
});
define("custom-expr/util/operation/index", ["require", "exports", "custom-expr/util/operation/map-non-correlated"], function (require, exports, map_non_correlated_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(map_non_correlated_1);
});
define("custom-expr/util/index", ["require", "exports", "custom-expr/util/operation/index", "custom-expr/util/query/index"], function (require, exports, operation_20, query_29) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_20);
    __export(query_29);
});
define("custom-expr/index", ["require", "exports", "custom-expr/util/index"], function (require, exports, CustomExprUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomExprUtil = CustomExprUtil;
});
define("insert/insert-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("error/sql-error", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * All errors in this library should extend this class.
     */
    class SqlError extends Error {
        constructor(args) {
            super("innerError" in args ?
                (args.innerError instanceof Object && "message" in args.innerError ?
                    args.innerError.message :
                    String(args.innerError)) :
                args.message);
            if ("innerError" in args && args.innerError instanceof Object && "stack" in args.innerError) {
                this.stack += `\n${args.innerError.stack}`;
            }
            Object.setPrototypeOf(this, SqlError.prototype);
            this.sql = args.sql;
            this.innerError = ("innerError" in args ?
                args.innerError :
                undefined);
        }
    }
    exports.SqlError = SqlError;
    SqlError.prototype.name = "SqlError";
    function isSqlError(mixed) {
        /**
         * @todo Should we check prototype.name or nah?
         */
        return (mixed instanceof Error &&
            (mixed.sql === undefined ||
                typeof mixed.sql == "string") &&
            "innerError" in mixed);
    }
    exports.isSqlError = isSqlError;
});
define("error/clean-insert-row/missing-required-insert-column", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MissingRequiredInsertColumnError extends sql_error_1.SqlError {
        constructor(args) {
            super({
                message: args.message,
                sql: undefined,
            });
            Object.setPrototypeOf(this, MissingRequiredInsertColumnError.prototype);
            this.table = args.table;
            this.columnAlias = args.columnAlias;
        }
    }
    exports.MissingRequiredInsertColumnError = MissingRequiredInsertColumnError;
    MissingRequiredInsertColumnError.prototype.name = "MissingRequiredInsertColumnError";
});
define("error/clean-insert-row/potential-null-in-required-insert-column", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PotentialNullInRequiredInsertColumnError extends sql_error_2.SqlError {
        constructor(args) {
            super({
                message: args.message,
                sql: undefined,
            });
            Object.setPrototypeOf(this, PotentialNullInRequiredInsertColumnError.prototype);
            this.table = args.table;
            this.columnAlias = args.columnAlias;
        }
    }
    exports.PotentialNullInRequiredInsertColumnError = PotentialNullInRequiredInsertColumnError;
    PotentialNullInRequiredInsertColumnError.prototype.name = "PotentialNullInRequiredInsertColumnError";
});
define("error/clean-insert-row/index", ["require", "exports", "error/clean-insert-row/missing-required-insert-column", "error/clean-insert-row/potential-null-in-required-insert-column"], function (require, exports, missing_required_insert_column_1, potential_null_in_required_insert_column_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(missing_required_insert_column_1);
    __export(potential_null_in_required_insert_column_1);
});
define("error/execution/invalid-sql", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This error happens when the database is unable to parse the SQL string.
     *
     * + MySQL      : `ER_SYNTAX_ERROR`, `ER_PARSE_ERROR`
     * + PostgreSQL : `syntax error at`
     */
    class InvalidSqlError extends sql_error_3.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, InvalidSqlError.prototype);
        }
    }
    exports.InvalidSqlError = InvalidSqlError;
    InvalidSqlError.prototype.name = "InvalidSqlError";
});
define("error/execution/row-not-found", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RowNotFoundError extends sql_error_4.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, RowNotFoundError.prototype);
            this.sql = args.sql;
        }
    }
    exports.RowNotFoundError = RowNotFoundError;
    RowNotFoundError.prototype.name = "RowNotFoundError";
});
define("error/execution/too-many-rows-found", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TooManyRowsFoundError extends sql_error_5.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, TooManyRowsFoundError.prototype);
            this.sql = args.sql;
        }
    }
    exports.TooManyRowsFoundError = TooManyRowsFoundError;
    TooManyRowsFoundError.prototype.name = "TooManyRowsFoundError";
});
define("error/execution/index", ["require", "exports", "error/execution/invalid-sql", "error/execution/row-not-found", "error/execution/too-many-rows-found"], function (require, exports, invalid_sql_1, row_not_found_1, too_many_rows_found_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(invalid_sql_1);
    __export(row_not_found_1);
    __export(too_many_rows_found_1);
});
define("error/expr/cannot-count", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CannotCountError extends sql_error_6.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, CannotCountError.prototype);
        }
    }
    exports.CannotCountError = CannotCountError;
    CannotCountError.prototype.name = "CannotCountError";
});
define("error/expr/data-out-of-range", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This error happens when you do something like,
     * + `MAX_BIGINT_SIGNED + 1`
     * + `MIN_BIGINT_SIGNED - 1`
     * + General overflow errors
     *
     * + MySQL      : `ER_DATA_OUT_OF_RANGE`
     * + PostgreSQL : `out of range`
     */
    class DataOutOfRangeError extends sql_error_7.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, DataOutOfRangeError.prototype);
        }
    }
    exports.DataOutOfRangeError = DataOutOfRangeError;
    DataOutOfRangeError.prototype.name = "DataOutOfRangeError";
});
define("error/expr/divide-by-zero", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This error happens when you do something like,
     * + `1 / 0`
     * + `0 / 0`
     *
     * + MySQL      : -NA- (Returns `null`)
     * + PostgreSQL : `division by zero`
     */
    class DivideByZeroError extends sql_error_8.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, DivideByZeroError.prototype);
        }
    }
    exports.DivideByZeroError = DivideByZeroError;
    DivideByZeroError.prototype.name = "DivideByZeroError";
});
define("error/expr/invalid-input", ["require", "exports", "error/sql-error"], function (require, exports, sql_error_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This error happens when you do something like,
     * + `'qwerty'::timestamp` (PostgreSQL)
     * + General input errors
     *
     * + MySQL      : `ER_INVALID_JSON_TEXT_IN_PARAM` (`CAST('qwerty' AS JSON)`), etc.
     * + PostgreSQL : `invalid input syntax for type`
     */
    class InvalidInputError extends sql_error_9.SqlError {
        constructor(args) {
            super(args);
            Object.setPrototypeOf(this, InvalidInputError.prototype);
        }
    }
    exports.InvalidInputError = InvalidInputError;
    InvalidInputError.prototype.name = "InvalidInputError";
});
define("error/expr/index", ["require", "exports", "error/expr/cannot-count", "error/expr/data-out-of-range", "error/expr/divide-by-zero", "error/expr/invalid-input"], function (require, exports, cannot_count_1, data_out_of_range_1, divide_by_zero_1, invalid_input_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(cannot_count_1);
    __export(data_out_of_range_1);
    __export(divide_by_zero_1);
    __export(invalid_input_1);
});
define("error/index", ["require", "exports", "error/clean-insert-row/index", "error/execution/index", "error/expr/index", "error/sql-error"], function (require, exports, clean_insert_row_1, execution_1, expr_6, sql_error_10) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(clean_insert_row_1);
    __export(execution_1);
    __export(expr_6);
    __export(sql_error_10);
});
define("insert/util/operation/clean-insert-column", ["require", "exports", "type-mapping", "built-in-value-expr/index", "built-in-expr/index", "query-base/index", "expr/index", "expr-select-item/index", "error/index"], function (require, exports, tm, built_in_value_expr_1, built_in_expr_11, query_base_1, expr_7, expr_select_item_3, error_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function cleanInsertColumn(table, row, columnAlias, required) {
        const customExpr = (
        /**
         * This is just safer.
         *
         * But how regularly should we access properties of mapped types this way?
         * All the time?
         * If so, why?
         *
         * Sometimes?
         * If so, what's the criteria?
         *
         * @todo Figure this out
         */
        (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
            row[columnAlias] :
            undefined);
        if (customExpr === undefined) {
            if (required) {
                throw new error_1.MissingRequiredInsertColumnError({
                    message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                    table,
                    columnAlias
                });
            }
            else {
                return undefined;
            }
        }
        if (built_in_value_expr_1.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
            return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
        }
        else if (built_in_expr_11.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
            /**
             * Can't really perform many checks here.
             * We can, however, check for `NULL`s.
             */
            if (query_base_1.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
                !tm.canOutputNull(table.columns[columnAlias].mapper)) {
                throw new error_1.PotentialNullInRequiredInsertColumnError({
                    message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                    table,
                    columnAlias
                });
            }
            return customExpr;
        }
        else {
            /**
             * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
             */
            if (expr_7.ExprUtil.isExpr(customExpr) ||
                expr_select_item_3.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
                /**
                 * @todo Should we validate these?
                 * How would one even do that?
                 */
                return customExpr;
            }
            /**
             * Maybe a custom data type?
             */
            return built_in_expr_11.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
        }
    }
    exports.cleanInsertColumn = cleanInsertColumn;
});
define("insert/util/operation/clean-insert-row", ["require", "exports", "table/index", "insert/util/operation/clean-insert-column"], function (require, exports, table_6, clean_insert_column_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + Removes excess properties.
     * + Removes properties with value `undefined`.
     * + Checks required properties are there.
     */
    function cleanInsertRow(table, row) {
        const result = {};
        for (const requiredColumnAlias of table_6.TableUtil.requiredColumnAlias(table)) {
            result[requiredColumnAlias] = clean_insert_column_1.cleanInsertColumn(table, row, requiredColumnAlias, true);
        }
        for (const optionalColumnAlias of table_6.TableUtil.optionalColumnAlias(table)) {
            const value = clean_insert_column_1.cleanInsertColumn(table, row, optionalColumnAlias, false);
            if (value === undefined) {
                continue;
            }
            result[optionalColumnAlias] = value;
        }
        return result;
    }
    exports.cleanInsertRow = cleanInsertRow;
});
define("insert/util/operation/index", ["require", "exports", "insert/util/operation/clean-insert-column", "insert/util/operation/clean-insert-row"], function (require, exports, clean_insert_column_2, clean_insert_row_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(clean_insert_column_2);
    __export(clean_insert_row_2);
});
define("insert/util/index", ["require", "exports", "insert/util/operation/index"], function (require, exports, operation_21) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_21);
});
define("insert/index", ["require", "exports", "insert/util/index"], function (require, exports, InsertUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InsertUtil = InsertUtil;
});
define("row/row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("row/util/query/mapper", ["require", "exports", "column-map/index"], function (require, exports, column_map_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(table) {
        return column_map_17.ColumnMapUtil.mapper(table.columns);
    }
    exports.mapper = mapper;
});
define("row/util/query/index", ["require", "exports", "row/util/query/mapper"], function (require, exports, mapper_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(mapper_6);
});
define("row/util/index", ["require", "exports", "row/util/query/index"], function (require, exports, query_30) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_30);
});
define("row/index", ["require", "exports", "row/util/index"], function (require, exports, RowUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RowUtil = RowUtil;
});
define("event/insert-event", ["require", "exports", "type-mapping", "table/index", "candidate-key/index", "expr-library/index", "event/event-base"], function (require, exports, tm, table_7, candidate_key_1, ExprLib, event_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InsertEvent extends event_base_1.EventBase {
        constructor(args) {
            super(args);
            this.candidateKeysCache = undefined;
            this.fetchPromises = {};
            this.table = args.table;
            this.insertRows = args.insertRows;
            this.insertResult = args.insertResult;
        }
        get candidateKeys() {
            if (this.candidateKeysCache == undefined) {
                const mapper = candidate_key_1.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
                this.candidateKeysCache = this.insertRows.map(insertRow => {
                    const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                    return candidateKeyResult.success ?
                        candidateKeyResult.value :
                        undefined;
                });
            }
            return this.candidateKeysCache;
        }
        async getOrFetch(index) {
            let fetchPromise = this.fetchPromises[index];
            if (fetchPromise == undefined) {
                const candidateKey = this.candidateKeys[index];
                if (candidateKey == undefined) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
                }
                fetchPromise = table_7.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
                this.fetchPromises[index] = fetchPromise;
            }
            return fetchPromise;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.InsertEvent = InsertEvent;
});
define("event/insert-one-event", ["require", "exports", "type-mapping", "table/index", "candidate-key/index", "expr-library/index", "event/event-base"], function (require, exports, tm, table_8, candidate_key_2, ExprLib, event_base_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InsertOneEvent extends event_base_2.EventBase {
        constructor(args) {
            super(args);
            this.candidateKeyCache = "uninitialized";
            this.table = args.table;
            this.insertRow = args.insertRow;
            this.insertResult = args.insertResult;
        }
        get candidateKey() {
            if (this.candidateKeyCache == "uninitialized") {
                const candidateKeyResult = tm.tryMapHandled(candidate_key_2.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
                this.candidateKeyCache = candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            }
            return this.candidateKeyCache;
        }
        async getOrFetch() {
            if (this.fetchPromise == undefined) {
                const candidateKey = this.candidateKey;
                if (candidateKey == undefined) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Could not derive candidateKey from insertRow`);
                }
                this.fetchPromise = table_8.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            }
            return this.fetchPromise;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.InsertOneEvent = InsertOneEvent;
});
define("event/insert-and-fetch-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InsertAndFetchEvent extends event_base_3.EventBase {
        constructor(args) {
            super(args);
            this.table = args.table;
            this.insertRow = args.insertRow;
            this.insertResult = args.insertResult;
            this.fetchedRow = args.fetchedRow;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.InsertAndFetchEvent = InsertAndFetchEvent;
});
define("event/replace-event", ["require", "exports", "type-mapping", "table/index", "candidate-key/index", "expr-library/index", "event/event-base"], function (require, exports, tm, table_9, candidate_key_3, ExprLib, event_base_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ReplaceEvent extends event_base_4.EventBase {
        constructor(args) {
            super(args);
            this.candidateKeysCache = undefined;
            this.fetchPromises = {};
            this.table = args.table;
            this.insertRows = args.insertRows;
            this.replaceResult = args.replaceResult;
        }
        get candidateKeys() {
            if (this.candidateKeysCache == undefined) {
                const mapper = candidate_key_3.CandidateKeyUtil.mapperPreferPrimaryKey(this.table);
                this.candidateKeysCache = this.insertRows.map(insertRow => {
                    const candidateKeyResult = tm.tryMapHandled(mapper, `${this.table.alias}.candidateKey`, insertRow);
                    return candidateKeyResult.success ?
                        candidateKeyResult.value :
                        undefined;
                });
            }
            return this.candidateKeysCache;
        }
        async getOrFetch(index) {
            let fetchPromise = this.fetchPromises[index];
            if (fetchPromise == undefined) {
                const candidateKey = this.candidateKeys[index];
                if (candidateKey == undefined) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Could not derive candidateKey ${index} from insertRow ${index}`);
                }
                fetchPromise = table_9.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
                this.fetchPromises[index] = fetchPromise;
            }
            return fetchPromise;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.ReplaceEvent = ReplaceEvent;
});
define("update/assignment-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("update/assignment-map-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("update/util/operation/clean-assignment-map", ["require", "exports", "used-ref/index", "built-in-expr/index"], function (require, exports, used_ref_17, built_in_expr_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function cleanAssignmentMap(table, raw) {
        const result = {};
        const allowed = used_ref_17.UsedRefUtil.fromColumnMap(table.columns);
        for (const columnAlias of Object.keys(raw)) {
            const customExpr = raw[columnAlias];
            if (customExpr === undefined) {
                continue;
            }
            if (table.mutableColumns.indexOf(columnAlias) < 0) {
                //This columnAlias is not mutable...
                if (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
                    Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias)) {
                    throw new Error(`${table.alias}.${columnAlias} is not mutable`);
                }
                else {
                    //Just some random extra property that is not a `columnAlias` of `TableT`.
                    //This probably only got through because TS does not have exact types at the moment.
                    continue;
                }
            }
            result[columnAlias] = built_in_expr_12.BuiltInExprUtil.fromCustomExpr_MapCorrelated(table.columns[columnAlias], allowed, customExpr);
        }
        /*
        if (Object.keys(result).length == 0) {
            //The user specified an empty assignment map?
            //Very weird...
            if (table.mutableColumns.length == 0) {
                throw new Error(`${table.alias} has no mutable columns`);
            }
            const firstColumnAlias = table.mutableColumns[0];
            const firstColumn = table.columns[firstColumnAlias];
            //We specify a no-op assignment, to prevent the `UpdateConnection` from crashing
            result[firstColumnAlias as keyof typeof result] = firstColumn as any;
        }
        */
        return result;
    }
    exports.cleanAssignmentMap = cleanAssignmentMap;
});
define("update/util/operation/set", ["require", "exports", "update/util/operation/clean-assignment-map"], function (require, exports, clean_assignment_map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function set(table, assignmentMapDelegate) {
        const raw = assignmentMapDelegate(table.columns);
        return clean_assignment_map_1.cleanAssignmentMap(table, raw);
    }
    exports.set = set;
});
define("update/util/operation/index", ["require", "exports", "update/util/operation/clean-assignment-map", "update/util/operation/set"], function (require, exports, clean_assignment_map_2, set_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(clean_assignment_map_2);
    __export(set_1);
});
define("update/util/index", ["require", "exports", "update/util/operation/index"], function (require, exports, operation_22) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_22);
});
define("update/index", ["require", "exports", "update/util/index"], function (require, exports, UpdateUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateUtil = UpdateUtil;
});
define("event/update-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UpdateEvent extends event_base_5.EventBase {
        constructor(args) {
            super(args);
            this.table = args.table;
            this.whereClause = args.whereClause;
            this.assignmentMap = args.assignmentMap;
            this.updateResult = args.updateResult;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.UpdateEvent = UpdateEvent;
});
define("execution/util/helper-type/fetch-all-connection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/mapped-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/type-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/constructor/from-column-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/constructor/from-column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/constructor/from-column-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/constructor/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/query/extract-excess-column-identifier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/query/extract-type-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/query/extract-with-strict-sub-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/query/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/operator/intersect", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/operator/with-value", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/operator/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/util/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-ref/index", ["require", "exports", "type-ref/util/index"], function (require, exports, TypeRefUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeRefUtil = TypeRefUtil;
});
define("execution/util/helper-type/unmapped-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/predicate/can-flatten-unmapped-row", ["require", "exports", "select-clause/index"], function (require, exports, select_clause_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function canFlattenUnmappedRow(query) {
        if (select_clause_3.SelectClauseUtil.duplicateColumnAlias(query.selectClause).length > 0) {
            /**
             * Cannot flatten if we have duplicate `columnAlias`
             */
            return false;
        }
        if (query.fromClause.currentJoins == undefined) {
            /**
             * No `nullable` joins, we can flatten safely
             */
            return true;
        }
        const hasNullableJoins = query.fromClause.currentJoins.some(j => j.nullable);
        return !hasNullableJoins;
    }
    exports.canFlattenUnmappedRow = canFlattenUnmappedRow;
});
define("execution/util/predicate/index", ["require", "exports", "execution/util/predicate/can-flatten-unmapped-row"], function (require, exports, can_flatten_unmapped_row_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(can_flatten_unmapped_row_1);
});
define("execution/util/helper-type/unmapped-flattened-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/fetched-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/fetched-result-set", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/raw-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/mapped-result-set", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/unmapped-flattened-result-set", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/unmapped-result-set", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/helper-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/util/operation/paginate/paginate-args", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * We use `BIGINT SIGNED` because PostgreSQL and SQLite do not support
     * `BIGINT UNSIGNED`.
     */
    const maybePage = tm.mysql.bigIntSigned().orUndefined();
    const maybeRowsPerPage = tm.mysql.bigIntSigned().orUndefined();
    const maybeRowOffset = tm.mysql.bigIntSigned().orUndefined();
    function toPaginateArgs(rawArgs) {
        const page = maybePage.mapMappable("page", rawArgs.page);
        const rowsPerPage = maybeRowsPerPage.mapMappable("rowsPerPage", rawArgs.rowsPerPage);
        const rowOffset = maybeRowOffset.mapMappable("rowOffset", rawArgs.rowOffset);
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        const args = {
            page: (page == undefined || tm.BigIntUtil.lessThan(page, 0)) ?
                //Default
                BigInt(0) :
                page,
            rowsPerPage: (rowsPerPage == undefined || tm.BigIntUtil.lessThan(rowsPerPage, 1)) ?
                //Default
                BigInt(20) :
                rowsPerPage,
            rowOffset: (rowOffset == undefined || tm.BigIntUtil.lessThan(rowOffset, 0)) ?
                //Default
                BigInt(0) :
                rowOffset,
        };
        const paginationStart = getPaginationStart(args);
        if (tm.BigIntUtil.greaterThan(paginationStart, BigInt("9223372036854775807"))) {
            throw new Error(`Cannot have OFFSET greater than 9223372036854775807`);
        }
        return args;
    }
    exports.toPaginateArgs = toPaginateArgs;
    /**
     * It is possible for this value to be greater than
     * `9223372036854775807n`.
     *
     * When this happens, you will get an error from the RDBMS
     */
    function getPaginationStart(args) {
        return tm.BigIntUtil.add(tm.BigIntUtil.mul(args.page, args.rowsPerPage), args.rowOffset);
    }
    exports.getPaginationStart = getPaginationStart;
    function calculatePagesFound(args, rowsFound) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        if (tm.BigIntUtil.lessThan(rowsFound, 0)) {
            /**
             * Should not have negative rows found
             */
            return BigInt(0);
        }
        if (tm.BigIntUtil.lessThanOrEqual(args.rowsPerPage, 0)) {
            /**
             * Avoid divide by zero errors
             */
            return BigInt(0);
        }
        return (tm.BigIntUtil.add(tm.BigIntUtil.div(rowsFound, args.rowsPerPage), (tm.BigIntUtil.equal(tm.BigIntUtil.mod(rowsFound, args.rowsPerPage), BigInt(0)) ?
            BigInt(0) :
            BigInt(1))));
    }
    exports.calculatePagesFound = calculatePagesFound;
});
define("execution/util/operation/paginate/apply-paginate-args", ["require", "exports", "execution/util/operation/paginate/paginate-args", "limit-clause/index"], function (require, exports, paginate_args_1, limit_clause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function applyPaginateArgs(query, args) {
        const paginateLimitClause = limit_clause_1.LimitClauseUtil.offsetBigInt(limit_clause_1.LimitClauseUtil.limitBigInt(undefined, args.rowsPerPage), paginate_args_1.getPaginationStart(args));
        if (query.compoundQueryClause == undefined) {
            return {
                ...query,
                limitClause: paginateLimitClause,
                compoundQueryLimitClause: undefined,
            };
        }
        else {
            return {
                ...query,
                compoundQueryLimitClause: paginateLimitClause,
            };
        }
    }
    exports.applyPaginateArgs = applyPaginateArgs;
});
define("execution/util/operation/impl/ensure-one-or", ["require", "exports", "error/index"], function (require, exports, error_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better naming
     */
    function ensureOneOr(query, fetched, defaultValue) {
        const resultSet = fetched.resultSet;
        if (resultSet.length == 0) {
            return defaultValue;
        }
        else if (resultSet.length == 1) {
            return resultSet[0];
        }
        else {
            if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
                throw new error_2.TooManyRowsFoundError({
                    message: `Expected zero or one row, found more than that`,
                    sql: fetched.sql,
                });
            }
            else {
                throw new error_2.TooManyRowsFoundError({
                    message: `Expected zero or one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                    sql: fetched.sql,
                });
            }
        }
    }
    exports.ensureOneOr = ensureOneOr;
});
define("execution/util/operation/impl/ensure-one", ["require", "exports", "error/index"], function (require, exports, error_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better naming
     */
    function ensureOne(query, fetched) {
        const resultSet = fetched.resultSet;
        if (resultSet.length == 0) {
            if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
                throw new error_3.RowNotFoundError({
                    message: `Expected one row, found zero`,
                    sql: fetched.sql,
                });
            }
            else {
                throw new error_3.RowNotFoundError({
                    message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found zero`,
                    sql: fetched.sql,
                });
            }
        }
        else if (resultSet.length == 1) {
            return resultSet[0];
        }
        else {
            if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
                throw new error_3.TooManyRowsFoundError({
                    message: `Expected one row, found more than that`,
                    sql: fetched.sql,
                });
            }
            else {
                throw new error_3.TooManyRowsFoundError({
                    message: `Expected one row from ${query.fromClause.currentJoins[0].tableAlias}, found more than that`,
                    sql: fetched.sql,
                });
            }
        }
    }
    exports.ensureOne = ensureOne;
});
define("unified-query/query", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("insert-select/insert-select-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("insert-select/insert-select-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("insert-select/util/operation/clean-insert-select-column", ["require", "exports", "type-mapping", "built-in-value-expr/index", "built-in-expr/index", "query-base/index", "expr/index", "expr-select-item/index", "error/index", "column/index", "column-identifier-ref/index"], function (require, exports, tm, built_in_value_expr_2, built_in_expr_13, query_base_2, expr_8, expr_select_item_4, error_4, column_12, column_identifier_ref_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function cleanInsertSelectColumn(allowedColumnRef, table, row, columnAlias, required) {
        const customExpr = (
        /**
         * This is just safer.
         *
         * But how regularly should we access properties of mapped types this way?
         * All the time?
         * If so, why?
         *
         * Sometimes?
         * If so, what's the criteria?
         *
         * @todo Figure this out
         */
        (Object.prototype.hasOwnProperty.call(row, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(row, columnAlias)) ?
            row[columnAlias] :
            undefined);
        if (customExpr === undefined) {
            if (required) {
                throw new error_4.MissingRequiredInsertColumnError({
                    message: `Expected value for ${table.alias}.${columnAlias}; received undefined`,
                    table,
                    columnAlias
                });
            }
            else {
                return undefined;
            }
        }
        if (column_12.ColumnUtil.isColumn(customExpr)) {
            if (!column_identifier_ref_10.ColumnIdentifierRefUtil.hasColumnIdentifier(allowedColumnRef, customExpr)) {
                throw new Error(`Invalid SELECT alias ${customExpr.tableAlias}.${customExpr.columnAlias}`);
            }
            return customExpr;
        }
        else if (built_in_value_expr_2.BuiltInValueExprUtil.isBuiltInValueExpr(customExpr)) {
            return table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, customExpr);
        }
        else if (built_in_expr_13.BuiltInExprUtil.isAnySubqueryExpr(customExpr)) {
            /**
             * Can't really perform many checks here.
             * We can, however, check for `NULL`s.
             */
            if (query_base_2.QueryBaseUtil.isZeroOrOneRow(customExpr) &&
                !tm.canOutputNull(table.columns[columnAlias].mapper)) {
                throw new error_4.PotentialNullInRequiredInsertColumnError({
                    message: `Cannot INSERT possibly NULL subquery expression to ${table.alias}.${columnAlias}`,
                    table,
                    columnAlias
                });
            }
            return customExpr;
        }
        else {
            /**
             * Could be an `IExpr`, `IExprSelectItem`, or a custom data type
             */
            if (expr_8.ExprUtil.isExpr(customExpr) ||
                expr_select_item_4.ExprSelectItemUtil.isExprSelectItem(customExpr)) {
                /**
                 * @todo Should we validate these?
                 * How would one even do that?
                 */
                return customExpr;
            }
            /**
             * Maybe a custom data type?
             */
            return built_in_expr_13.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], customExpr);
        }
    }
    exports.cleanInsertSelectColumn = cleanInsertSelectColumn;
});
define("insert-select/util/operation/clean-insert-select-row", ["require", "exports", "table/index", "insert-select/util/operation/clean-insert-select-column", "column-ref/index"], function (require, exports, table_10, clean_insert_select_column_1, column_ref_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + Removes excess properties.
     * + Removes properties with value `undefined`.
     * + Checks required properties are there.
     */
    function cleanInsertSelectRow(query, table, row) {
        const allowedColumnRef = column_ref_16.ColumnRefUtil.fromSelectClause(query.selectClause);
        const result = {};
        for (const requiredColumnAlias of table_10.TableUtil.requiredColumnAlias(table)) {
            result[requiredColumnAlias] = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, requiredColumnAlias, true);
        }
        for (const optionalColumnAlias of table_10.TableUtil.optionalColumnAlias(table)) {
            const value = clean_insert_select_column_1.cleanInsertSelectColumn(allowedColumnRef, table, row, optionalColumnAlias, false);
            if (value === undefined) {
                continue;
            }
            result[optionalColumnAlias] = value;
        }
        return result;
    }
    exports.cleanInsertSelectRow = cleanInsertSelectRow;
});
define("insert-select/util/operation/index", ["require", "exports", "insert-select/util/operation/clean-insert-select-column", "insert-select/util/operation/clean-insert-select-row"], function (require, exports, clean_insert_select_column_2, clean_insert_select_row_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(clean_insert_select_column_2);
    __export(clean_insert_select_row_1);
});
define("insert-select/util/constructor/insert-select", ["require", "exports", "column-ref/index", "insert-select/util/operation/index"], function (require, exports, column_ref_17, operation_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function insertSelect(query, table, delegate) {
        const columns = column_ref_17.ColumnRefUtil.tryFlatten(column_ref_17.ColumnRefUtil.fromSelectClause(query.selectClause));
        const row = delegate(columns);
        return operation_23.cleanInsertSelectRow(query, table, row);
    }
    exports.insertSelect = insertSelect;
});
define("insert-select/util/constructor/index", ["require", "exports", "insert-select/util/constructor/insert-select"], function (require, exports, insert_select_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(insert_select_1);
});
define("insert-select/util/index", ["require", "exports", "insert-select/util/constructor/index", "insert-select/util/operation/index"], function (require, exports, constructor_8, operation_24) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_8);
    __export(operation_24);
});
define("insert-select/index", ["require", "exports", "insert-select/util/index"], function (require, exports, InsertSelectUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InsertSelectUtil = InsertSelectUtil;
});
define("unified-query/query-impl", ["require", "exports", "unified-query/util/index", "query-base/index", "compound-query/index", "execution/index"], function (require, exports, QueryUtil, query_base_3, compound_query_3, execution_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Query {
        constructor(data, extraData) {
            this.fromClause = data.fromClause;
            this.selectClause = data.selectClause;
            this.limitClause = data.limitClause;
            this.compoundQueryClause = data.compoundQueryClause;
            this.compoundQueryLimitClause = data.compoundQueryLimitClause;
            this.mapDelegate = data.mapDelegate;
            this.groupByClause = data.groupByClause;
            this.whereClause = extraData.whereClause;
            this.havingClause = extraData.havingClause;
            this.orderByClause = extraData.orderByClause;
            this.compoundQueryOrderByClause = extraData.compoundQueryOrderByClause;
            this.isDistinct = extraData.isDistinct;
        }
        limit(maxRowCount) {
            return QueryUtil.limit(this, maxRowCount);
        }
        offset(offset) {
            return QueryUtil.offset(this, offset);
        }
        compoundQueryLimit(maxRowCount) {
            return QueryUtil.compoundQueryLimit(this, maxRowCount);
        }
        compoundQueryOffset(offset) {
            return QueryUtil.compoundQueryOffset(this, offset);
        }
        requireOuterQueryJoins(...aliasedTables) {
            return QueryUtil.requireOuterQueryJoins(this, ...aliasedTables);
        }
        requireNullableOuterQueryJoins(...aliasedTables) {
            return QueryUtil.requireNullableOuterQueryJoins(this, ...aliasedTables);
        }
        from(aliasedTable) {
            return QueryUtil.from(this, aliasedTable);
        }
        crossJoin(aliasedTable) {
            return QueryUtil.crossJoin(this, aliasedTable);
        }
        groupBy(groupByDelegate) {
            return QueryUtil.groupBy(this, groupByDelegate);
        }
        having(havingDelegate) {
            return QueryUtil.having(this, havingDelegate);
        }
        innerJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
            return QueryUtil.innerJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
        }
        innerJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
            return QueryUtil.innerJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
        }
        innerJoin(aliasedTable, onDelegate) {
            return QueryUtil.innerJoin(this, aliasedTable, onDelegate);
        }
        leftJoinUsingCandidateKey(srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
            return QueryUtil.leftJoinUsingCandidateKey(this, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate);
        }
        leftJoinUsingPrimaryKey(srcDelegate, aliasedTable) {
            return QueryUtil.leftJoinUsingPrimaryKey(this, srcDelegate, aliasedTable);
        }
        leftJoin(aliasedTable, onDelegate) {
            return QueryUtil.leftJoin(this, aliasedTable, onDelegate);
        }
        orderBy(orderByDelegate) {
            return QueryUtil.orderBy(this, orderByDelegate);
        }
        selectValue(selectValueDelegate) {
            return QueryUtil.selectValue(this, selectValueDelegate);
        }
        select(selectDelegate) {
            return QueryUtil.select(this, selectDelegate);
        }
        compoundQueryOrderBy(compoundQueryOrderByDelegate) {
            return QueryUtil.compoundQueryOrderBy(this, compoundQueryOrderByDelegate);
        }
        unionDistinct(targetQuery) {
            return QueryUtil.compoundQuery(this, compound_query_3.CompoundQueryType.UNION, true, targetQuery);
        }
        unionAll(targetQuery) {
            return QueryUtil.compoundQuery(this, compound_query_3.CompoundQueryType.UNION, false, targetQuery);
        }
        whereEqCandidateKey(
        /**
         * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereEqCandidateKey(this, ...args);
        }
        whereEqColumns(
        /**
         * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereEqColumns(this, ...args);
        }
        whereEqInnerQueryPrimaryKey(srcDelegate, dstDelegate) {
            return QueryUtil.whereEqInnerQueryPrimaryKey(this, srcDelegate, dstDelegate);
        }
        whereEqOuterQueryPrimaryKey(
        /**
         * This construction effectively makes it impossible for
         * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        srcDelegate, dstDelegate) {
            return QueryUtil.whereEqOuterQueryPrimaryKey(this, srcDelegate, dstDelegate);
        }
        whereEqPrimaryKey(
        /**
         * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereEqPrimaryKey(this, ...args);
        }
        whereEqSuperKey(
        /**
         * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereEqSuperKey(this, ...args);
        }
        whereEq(
        /**
         * This construction effectively makes it impossible for `WhereEqDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereEq(this, ...args);
        }
        whereIsNotNull(whereIsNotNullDelegate) {
            return QueryUtil.whereIsNotNull(this, whereIsNotNullDelegate);
        }
        whereIsNull(whereIsNullDelegate) {
            return QueryUtil.whereIsNull(this, whereIsNullDelegate);
        }
        whereNullSafeEq(
        /**
         * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
         * to return a union type.
         *
         * This is unfortunate but a necessary compromise for now.
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
         *
         * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
         */
        ...args) {
            return QueryUtil.whereNullSafeEq(this, ...args);
        }
        where(whereDelegate) {
            return QueryUtil.where(this, whereDelegate);
        }
        as(alias) {
            return query_base_3.QueryBaseUtil.as(this, alias);
        }
        correlate() {
            return QueryUtil.correlate(this);
        }
        /**
         * @todo Maybe implement `selectDistinct()` as a convenience method?
         */
        distinct() {
            return QueryUtil.distinct(this);
        }
        /**
         * Convenience method for,
         * ```ts
         *  tsql.coalesce(myQuery.limit(1), myDefaultValue);
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).coalesce(myDefaultValue);
         * ```
         */
        coalesce(defaultValue) {
            return query_base_3.QueryBaseUtil.coalesce(this, defaultValue);
        }
        /**
         * Convenience method for,
         * ```ts
         *  tsql.throwIfNull(myQuery.limit(1));
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).throwIfNull();
         * ```
         */
        throwIfNull() {
            return query_base_3.QueryBaseUtil.throwIfNull(this);
        }
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).asc();
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).asc();
         * ```
         */
        asc() {
            return query_base_3.QueryBaseUtil.asc(this);
        }
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).desc();
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).desc();
         * ```
         */
        desc() {
            return query_base_3.QueryBaseUtil.desc(this);
        }
        /**
         * Convenience method for,
         * ```ts
         *  myQuery.limit(1).coalesce(null).sort(sortDirection);
         * ```
         *
         * Usage,
         * ```ts
         *  myQuery.limit(1).sort(sortDirection);
         * ```
         */
        sort(sortDirection) {
            return query_base_3.QueryBaseUtil.sort(this, sortDirection);
        }
        map(mapDelegate) {
            if (this.mapDelegate == undefined) {
                return QueryUtil.mapInitial(this, mapDelegate);
            }
            else {
                return QueryUtil.mapCompose(this, mapDelegate);
            }
        }
        fetchAllMapped(connection) {
            return execution_2.ExecutionUtil.fetchAllMapped(this, connection);
        }
        fetchAllUnmappedFlattened(connection) {
            return execution_2.ExecutionUtil.fetchAllUnmappedFlattened(this, connection);
        }
        fetchAllUnmapped(connection) {
            return execution_2.ExecutionUtil.fetchAllUnmapped(this, connection);
        }
        fetchAll(connection) {
            return execution_2.ExecutionUtil.fetchAll(this, connection);
        }
        fetchOneOrUndefined(connection) {
            return execution_2.ExecutionUtil.fetchOneOrUndefined(this, connection);
        }
        fetchOneOr(connection, defaultValue) {
            return execution_2.ExecutionUtil.fetchOneOr(this, connection, defaultValue);
        }
        fetchOne(connection) {
            return execution_2.ExecutionUtil.fetchOne(this, connection);
        }
        fetchValueArray(connection) {
            return execution_2.ExecutionUtil.fetchValueArray(this, connection);
        }
        fetchValueOrUndefined(connection) {
            return execution_2.ExecutionUtil.fetchValueOrUndefined(this, connection);
        }
        fetchValueOr(connection, defaultValue) {
            return execution_2.ExecutionUtil.fetchValueOr(this, connection, defaultValue);
        }
        fetchValue(connection) {
            return execution_2.ExecutionUtil.fetchValue(this, connection);
        }
        count(connection) {
            return execution_2.ExecutionUtil.count(this, connection);
        }
        paginate(connection, rawArgs) {
            return execution_2.ExecutionUtil.paginate(this, connection, rawArgs);
        }
        exists(connection) {
            return execution_2.ExecutionUtil.exists(this, connection);
        }
        assertExists(connection) {
            return execution_2.ExecutionUtil.assertExists(this, connection);
        }
        emulatedCursor(connection, 
        /**
         * If set, determines the starting `page` of the cursor.
         * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
         */
        rawArgs = {}) {
            return execution_2.ExecutionUtil.emulatedCursor(this, connection, rawArgs);
        }
        insert(connection, table, rowDelegate) {
            return execution_2.ExecutionUtil.insertSelect(connection, this, table, rowDelegate);
        }
        insertIgnore(connection, table, rowDelegate) {
            return execution_2.ExecutionUtil.insertIgnoreSelect(connection, this, table, rowDelegate);
        }
        replace(connection, table, rowDelegate) {
            return execution_2.ExecutionUtil.replaceSelect(connection, this, table, rowDelegate);
        }
    }
    exports.Query = Query;
});
define("unified-query/util/constructor/new-instance", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_7, query_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function newInstance() {
        const result = new query_impl_1.Query({
            fromClause: from_clause_7.FromClauseUtil.newInstance(),
            selectClause: undefined,
            limitClause: undefined,
            compoundQueryClause: undefined,
            compoundQueryLimitClause: undefined,
            mapDelegate: undefined,
            groupByClause: undefined,
        }, {
            whereClause: undefined,
            havingClause: undefined,
            orderByClause: undefined,
            compoundQueryOrderByClause: undefined,
            isDistinct: false,
        });
        return result;
    }
    exports.newInstance = newInstance;
});
define("unified-query/util/constructor/index", ["require", "exports", "unified-query/util/constructor/new-instance"], function (require, exports, new_instance_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(new_instance_2);
});
define("unified-query/util/helper-type/after-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/after-group-by-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/after-select-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/before-from-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/before-compound-query-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/mapped", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/non-correlated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/unmapped", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/helper-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit-bigint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit-number-0-or-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit-number-0", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit-number-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit-number", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-limit/compound-query-limit", ["require", "exports", "limit-clause/index", "unified-query/query-impl"], function (require, exports, limit_clause_2, query_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compoundQueryLimit(query, maxRowCount) {
        const compoundQueryLimitClause = limit_clause_2.LimitClauseUtil.limit(query.compoundQueryLimitClause, maxRowCount);
        const { fromClause, selectClause, limitClause, compoundQueryClause, 
        //compoundQueryLimitClause,
        mapDelegate, groupByClause, } = query;
        const result = new query_impl_2.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.compoundQueryLimit = compoundQueryLimit;
});
define("unified-query/util/operation/compound-query-limit/index", ["require", "exports", "unified-query/util/operation/compound-query-limit/compound-query-limit"], function (require, exports, compound_query_limit_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_limit_1);
});
define("unified-query/util/operation/compound-query-offset/compound-query-offset-bigint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-offset/compound-query-offset-number", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/compound-query-offset/compound-query-offset", ["require", "exports", "limit-clause/index", "unified-query/query-impl"], function (require, exports, limit_clause_3, query_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compoundQueryOffset(query, offset) {
        const compoundQueryLimitClause = limit_clause_3.LimitClauseUtil.offset(query.compoundQueryLimitClause, offset);
        const { fromClause, selectClause, limitClause, compoundQueryClause, 
        //compoundQueryLimitClause,
        mapDelegate, groupByClause, } = query;
        const result = new query_impl_3.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.compoundQueryOffset = compoundQueryOffset;
});
define("unified-query/util/operation/compound-query-offset/index", ["require", "exports", "unified-query/util/operation/compound-query-offset/compound-query-offset"], function (require, exports, compound_query_offset_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_offset_1);
});
define("unified-query/util/operation/limit/limit-bigint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/limit/limit-number-0-or-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/limit/limit-number-0", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/limit/limit-number-1", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/limit/limit-number", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/limit/limit", ["require", "exports", "limit-clause/index", "unified-query/query-impl"], function (require, exports, limit_clause_4, query_impl_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function limit(query, maxRowCount) {
        const limitClause = limit_clause_4.LimitClauseUtil.limit(query.limitClause, maxRowCount);
        const { fromClause, selectClause, 
        //limitClause,
        compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_4.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.limit = limit;
});
define("unified-query/util/operation/limit/index", ["require", "exports", "unified-query/util/operation/limit/limit"], function (require, exports, limit_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(limit_2);
});
define("unified-query/util/operation/map/map-compose", ["require", "exports", "unified-query/query-impl", "map-delegate/index"], function (require, exports, query_impl_5, map_delegate_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapCompose(query, mapDelegate) {
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
        //mapDelegate,
        groupByClause, } = query;
        const result = new query_impl_5.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate: (map_delegate_1.MapDelegateUtil.compose(
            /**
             * @todo Clean up?
             */
            query.mapDelegate, mapDelegate)),
            groupByClause,
        }, query);
        return result;
    }
    exports.mapCompose = mapCompose;
});
define("unified-query/util/operation/map/map-initial", ["require", "exports", "unified-query/query-impl"], function (require, exports, query_impl_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapInitial(query, mapDelegate) {
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, 
        //mapDelegate,
        groupByClause, } = query;
        const result = new query_impl_6.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate: mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.mapInitial = mapInitial;
});
define("unified-query/util/operation/map/map", ["require", "exports", "unified-query/util/operation/map/map-initial", "unified-query/util/operation/map/map-compose"], function (require, exports, map_initial_1, map_compose_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Clean up usages of `any`
     *
     * Removing the usages of `any` will cause build times to jump 30s!
     */
    function map(query, mapDelegate) {
        if (query.mapDelegate == undefined) {
            return map_initial_1.mapInitial(query, mapDelegate);
        }
        else {
            return map_compose_1.mapCompose(query, mapDelegate);
        }
    }
    exports.map = map;
});
define("unified-query/util/operation/map/index", ["require", "exports", "unified-query/util/operation/map/map-compose", "unified-query/util/operation/map/map-initial", "unified-query/util/operation/map/map"], function (require, exports, map_compose_2, map_initial_2, map_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(map_compose_2);
    __export(map_initial_2);
    __export(map_1);
});
define("unified-query/util/operation/offset/offset-bigint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/offset/offset-number", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("unified-query/util/operation/offset/offset", ["require", "exports", "limit-clause/index", "unified-query/query-impl"], function (require, exports, limit_clause_5, query_impl_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function offset(query, offset) {
        const limitClause = limit_clause_5.LimitClauseUtil.offset(query.limitClause, offset);
        const { fromClause, selectClause, 
        //limitClause,
        compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_7.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.offset = offset;
});
define("unified-query/util/operation/offset/index", ["require", "exports", "unified-query/util/operation/offset/offset"], function (require, exports, offset_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(offset_2);
});
define("unified-query/util/operation/compound-query-order-by", ["require", "exports", "compound-query-order-by-clause/index", "unified-query/query-impl"], function (require, exports, compound_query_order_by_clause_1, query_impl_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compoundQueryOrderBy(query, compoundQueryOrderByDelegate) {
        const compoundQueryOrderByClause = compound_query_order_by_clause_1.CompoundQueryOrderByClauseUtil.compoundQueryOrderBy(query.selectClause, query.compoundQueryOrderByClause, compoundQueryOrderByDelegate);
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, 
        //compoundQueryOrderByClause,
        isDistinct, } = query;
        const result = new query_impl_8.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.compoundQueryOrderBy = compoundQueryOrderBy;
});
define("unified-query/util/operation/compound-query", ["require", "exports", "unified-query/query-impl", "compound-query-clause/index"], function (require, exports, query_impl_9, compound_query_clause_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function compoundQuery(query, compoundQueryType, isDistinct, targetQuery) {
        const { selectClause, compoundQueryClause, } = compound_query_clause_1.CompoundQueryClauseUtil.compoundQuery(query.fromClause, query.selectClause, query.compoundQueryClause, compoundQueryType, isDistinct, targetQuery);
        const { fromClause, 
        //selectClause,
        limitClause, 
        //compoundQueryClause,
        compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_9.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.compoundQuery = compoundQuery;
});
define("unified-query/util/operation/correlate", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_8, query_impl_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo A reference to the `query` needs to be added to the following,
     * + `OnDelegate`
     * + `HavingDelegate`
     * + `OrderByDelegate`
     * + `SelectDelegate`
     * + `WhereDelegate`
     *
     * Basically, anywhere a correlated subquery is allowed.
     */
    function correlate(query) {
        const result = new query_impl_10.Query({
            fromClause: from_clause_8.FromClauseUtil.correlate(query.fromClause),
            selectClause: undefined,
            limitClause: undefined,
            compoundQueryClause: undefined,
            compoundQueryLimitClause: undefined,
            mapDelegate: undefined,
            groupByClause: undefined,
        }, {
            whereClause: undefined,
            havingClause: undefined,
            orderByClause: undefined,
            compoundQueryOrderByClause: undefined,
            isDistinct: false,
        });
        return result;
    }
    exports.correlate = correlate;
});
define("unified-query/util/predicate/assert-valid-current-join", ["require", "exports", "from-clause/index"], function (require, exports, from_clause_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidJoinTarget(query, aliasedTable) {
        from_clause_9.FromClauseUtil.assertValidCurrentJoinBase(query.fromClause, aliasedTable);
        from_clause_9.FromClauseUtil.assertNoUsedRef(aliasedTable);
        from_clause_9.FromClauseUtil.assertNotLateral(aliasedTable);
    }
    exports.assertValidJoinTarget = assertValidJoinTarget;
});
define("unified-query/util/predicate/index", ["require", "exports", "unified-query/util/predicate/assert-valid-current-join"], function (require, exports, assert_valid_current_join_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_valid_current_join_1);
});
define("unified-query/util/operation/cross-join", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_10, query_impl_11, predicate_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function crossJoin(query, aliasedTable) {
        predicate_32.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_11.Query({
            fromClause: from_clause_10.FromClauseUtil.crossJoin(query.fromClause, aliasedTable),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.crossJoin = crossJoin;
});
define("unified-query/util/operation/distinct", ["require", "exports", "unified-query/query-impl"], function (require, exports, query_impl_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function distinct(query) {
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, } = query;
        const result = new query_impl_12.Query(
        /**
         * If you replace the below object literal with
         * just the variable `query`, you will cause `tsc`
         * to OOM.
         */
        //query
        {
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct: true,
        });
        return result;
    }
    exports.distinct = distinct;
});
define("unified-query/util/operation/from", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_11, query_impl_13, predicate_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function from(query, aliasedTable) {
        predicate_33.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_13.Query({
            fromClause: from_clause_11.FromClauseUtil.from(query.fromClause, aliasedTable),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.from = from;
});
define("unified-query/util/operation/group-by", ["require", "exports", "group-by-clause/index", "unified-query/query-impl"], function (require, exports, group_by_clause_2, query_impl_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function groupBy(query, groupByDelegate) {
        const groupByClause = group_by_clause_2.GroupByClauseUtil.groupBy(query.fromClause, query.groupByClause, groupByDelegate);
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, whereClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_14.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.groupBy = groupBy;
});
define("unified-query/util/operation/having", ["require", "exports", "having-clause/index", "unified-query/query-impl"], function (require, exports, having_clause_1, query_impl_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function having(query, havingDelegate) {
        const havingClause = having_clause_1.HavingClauseUtil.having(query.fromClause, query.groupByClause, query.havingClause, havingDelegate);
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_15.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.having = having;
});
define("unified-query/util/operation/inner-join-using-candidate-key", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_12, query_impl_16, predicate_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function innerJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        predicate_34.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_16.Query({
            fromClause: from_clause_12.FromClauseUtil.innerJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.innerJoinUsingCandidateKey = innerJoinUsingCandidateKey;
});
define("unified-query/util/operation/inner-join-using-primary-key", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_13, query_impl_17, predicate_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function innerJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
        predicate_35.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_17.Query({
            fromClause: from_clause_13.FromClauseUtil.innerJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.innerJoinUsingPrimaryKey = innerJoinUsingPrimaryKey;
});
define("unified-query/util/operation/inner-join", ["require", "exports", "from-clause/index", "on-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_14, on_clause_3, query_impl_18, predicate_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function innerJoin(query, aliasedTable, onDelegate) {
        predicate_36.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_18.Query({
            fromClause: from_clause_14.FromClauseUtil.innerJoin(query.fromClause, aliasedTable, columns => {
                const rawOnClause = onDelegate(columns);
                /**
                 * @todo Investigate assignability
                 */
                const result = rawOnClause;
                on_clause_3.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
                return result;
            }),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.innerJoin = innerJoin;
});
define("unified-query/util/operation/left-join-using-candidate-key", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_15, query_impl_19, predicate_37) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftJoinUsingCandidateKey(query, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate) {
        predicate_37.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_19.Query({
            fromClause: from_clause_15.FromClauseUtil.leftJoinUsingCandidateKey(query.fromClause, srcDelegate, aliasedTable, eqCandidateKeyOfTableDelegate),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.leftJoinUsingCandidateKey = leftJoinUsingCandidateKey;
});
define("unified-query/util/operation/left-join-using-primary-key", ["require", "exports", "from-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_16, query_impl_20, predicate_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftJoinUsingPrimaryKey(query, srcDelegate, aliasedTable) {
        predicate_38.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_20.Query({
            fromClause: from_clause_16.FromClauseUtil.leftJoinUsingPrimaryKey(query.fromClause, srcDelegate, aliasedTable),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.leftJoinUsingPrimaryKey = leftJoinUsingPrimaryKey;
});
define("unified-query/util/operation/left-join", ["require", "exports", "from-clause/index", "on-clause/index", "unified-query/query-impl", "unified-query/util/predicate/index"], function (require, exports, from_clause_17, on_clause_4, query_impl_21, predicate_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftJoin(query, aliasedTable, onDelegate) {
        predicate_39.assertValidJoinTarget(query, aliasedTable);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_21.Query({
            fromClause: from_clause_17.FromClauseUtil.leftJoin(query.fromClause, aliasedTable, columns => {
                const rawOnClause = onDelegate(columns);
                /**
                 * @todo Investigate assignability
                 */
                const result = rawOnClause;
                on_clause_4.OnClauseUtil.assertNoOuterQueryUsedRef(query.fromClause, result);
                return result;
            }),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.leftJoin = leftJoin;
});
define("unified-query/util/operation/order-by", ["require", "exports", "order-by-clause/index", "unified-query/query-impl", "unified-query/util/operation/correlate"], function (require, exports, order_by_clause_1, query_impl_22, correlate_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function orderBy(query, orderByDelegate) {
        const orderByClause = order_by_clause_1.OrderByClauseUtil.orderBy(query.fromClause, query.groupByClause, query.selectClause, query.orderByClause, (columns) => {
            return orderByDelegate(columns, correlate_2.correlate(query));
        });
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, whereClause, havingClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_22.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.orderBy = orderBy;
});
define("unified-query/util/operation/require-nullable-outer-query-joins", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_18, query_impl_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function requireNullableOuterQueryJoins(query, ...aliasedTables) {
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_23.Query({
            fromClause: from_clause_18.FromClauseUtil.requireNullableOuterQueryJoins(query.fromClause, ...aliasedTables),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
});
define("unified-query/util/operation/require-outer-query-joins", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_19, query_impl_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function requireOuterQueryJoins(query, ...aliasedTables) {
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_24.Query({
            fromClause: from_clause_19.FromClauseUtil.requireOuterQueryJoins(query.fromClause, ...aliasedTables),
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, query);
        return result;
    }
    exports.requireOuterQueryJoins = requireOuterQueryJoins;
});
define("unified-query/util/operation/select", ["require", "exports", "select-clause/index", "query-base/index", "unified-query/query-impl", "unified-query/util/operation/correlate", "built-in-expr/index"], function (require, exports, select_clause_4, query_base_4, query_impl_25, correlate_3, built_in_expr_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(query, selectDelegate
    //selectDelegate : SelectDelegate<QueryT["fromClause"], QueryT["selectClause"], SelectsT>
    ) {
        if (!query_base_4.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
            throw new Error(`Cannot SELECT after COMPOUND QUERY clause; this will change the number of columns`);
        }
        //const correlated = correlate<QueryT>(query);
        const selectClause = select_clause_4.SelectClauseUtil.select(query.fromClause, query.groupByClause, query.selectClause, (columns) => {
            return selectDelegate(columns, correlate_3.correlate(query));
        });
        const { fromClause, 
        //selectClause,
        limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, } = query;
        const result = new query_impl_25.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause: (groupByClause != undefined ?
                groupByClause :
                selectClause.some(selectItem => (built_in_expr_14.BuiltInExprUtil.isBuiltInExpr(selectItem) &&
                    built_in_expr_14.BuiltInExprUtil.isAggregate(selectItem))) ?
                    [] :
                    undefined),
        }, query);
        return result;
    }
    exports.select = select;
});
define("unified-query/util/operation/select-value", ["require", "exports", "select-clause/index", "unified-query/util/operation/select"], function (require, exports, select_clause_5, select_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Rename to `selectScalar`?
     */
    function selectValue(query, selectValueDelegate) {
        return select_1.select(query, (columns, subquery) => select_clause_5.SelectClauseUtil.valueFromBuiltInExpr(selectValueDelegate(columns, subquery)));
    }
    exports.selectValue = selectValue;
});
define("unified-query/util/operation/where-eq-candidate-key", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_20, query_impl_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqCandidateKey(query, 
    /**
     * This construction effectively makes it impossible for `WhereEqCandidateKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_20.FromClauseUtil.whereEqCandidateKey(query.fromClause, query.whereClause, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_26.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqCandidateKey = whereEqCandidateKey;
});
define("unified-query/util/operation/where-eq-columns", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_21, query_impl_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqColumns(query, 
    /**
     * This construction effectively makes it impossible for `WhereEqColumnsDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_21.FromClauseUtil.whereEqColumns(query.fromClause, query.whereClause, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_27.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqColumns = whereEqColumns;
});
define("unified-query/util/operation/where-eq-inner-query-primary-key", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_22, query_impl_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqInnerQueryPrimaryKey(query, srcDelegate, dstDelegate) {
        const { fromClause, whereClause, } = from_clause_22.FromClauseUtil.whereEqInnerQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_28.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqInnerQueryPrimaryKey = whereEqInnerQueryPrimaryKey;
});
define("unified-query/util/operation/where-eq-outer-query-primary-key", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_23, query_impl_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqOuterQueryPrimaryKey(query, 
    /**
     * This construction effectively makes it impossible for
     * `WhereEqOuterQueryPrimaryKeySrcDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    srcDelegate, dstDelegate) {
        const { fromClause, whereClause, } = from_clause_23.FromClauseUtil.whereEqOuterQueryPrimaryKey(query.fromClause, query.whereClause, srcDelegate, dstDelegate);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_29.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqOuterQueryPrimaryKey = whereEqOuterQueryPrimaryKey;
});
define("unified-query/util/operation/where-eq-primary-key", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_24, query_impl_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqPrimaryKey(query, 
    /**
     * This construction effectively makes it impossible for `WhereEqPrimaryKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_24.FromClauseUtil.whereEqPrimaryKey(query.fromClause, query.whereClause, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_30.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqPrimaryKey = whereEqPrimaryKey;
});
define("unified-query/util/operation/where-eq-super-key", ["require", "exports", "from-clause/index", "unified-query/query-impl", "expr-library/index"], function (require, exports, from_clause_25, query_impl_31, expr_library_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEqSuperKey(query, 
    /**
     * This construction effectively makes it impossible for `WhereEqSuperKeyDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_25.FromClauseUtil.whereEqSuperKey(query.fromClause, query.whereClause, expr_library_1.eqSuperKey, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_31.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEqSuperKey = whereEqSuperKey;
});
define("unified-query/util/operation/where-eq", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_26, query_impl_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereEq(query, 
    /**
     * This construction effectively makes it impossible for `WhereEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_26.FromClauseUtil.whereEq(query.fromClause, query.whereClause, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_32.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereEq = whereEq;
});
define("unified-query/util/operation/where-is-not-null", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_27, query_impl_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereIsNotNull(query, whereIsNotNullDelegate) {
        const { fromClause, whereClause, } = from_clause_27.FromClauseUtil.whereIsNotNull(query.fromClause, query.whereClause, whereIsNotNullDelegate);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_33.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereIsNotNull = whereIsNotNull;
});
define("unified-query/util/operation/where-is-null", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_28, query_impl_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereIsNull(query, whereIsNullDelegate) {
        const { fromClause, whereClause, } = from_clause_28.FromClauseUtil.whereIsNull(query.fromClause, query.whereClause, whereIsNullDelegate);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_34.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereIsNull = whereIsNull;
});
define("unified-query/util/operation/where-null-safe-eq", ["require", "exports", "from-clause/index", "unified-query/query-impl"], function (require, exports, from_clause_29, query_impl_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function whereNullSafeEq(query, 
    /**
     * This construction effectively makes it impossible for `WhereNullSafeEqDelegate<>`
     * to return a union type.
     *
     * This is unfortunate but a necessary compromise for now.
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520199818
     *
     * https://github.com/microsoft/TypeScript/issues/32804#issuecomment-520201877
     */
    ...args) {
        const { fromClause, whereClause, } = from_clause_29.FromClauseUtil.whereNullSafeEq(query.fromClause, query.whereClause, ...args);
        const { 
        //fromClause,
        selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_35.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.whereNullSafeEq = whereNullSafeEq;
});
define("unified-query/util/operation/where", ["require", "exports", "where-clause/index", "unified-query/query-impl"], function (require, exports, where_clause_12, query_impl_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function where(query, whereDelegate) {
        const whereClause = where_clause_12.WhereClauseUtil.where(query.fromClause, query.whereClause, whereDelegate);
        const { fromClause, selectClause, limitClause, compoundQueryClause, compoundQueryLimitClause, mapDelegate, groupByClause, havingClause, orderByClause, compoundQueryOrderByClause, isDistinct, } = query;
        const result = new query_impl_36.Query({
            fromClause,
            selectClause,
            limitClause,
            compoundQueryClause,
            compoundQueryLimitClause,
            mapDelegate,
            groupByClause,
        }, {
            whereClause,
            havingClause,
            orderByClause,
            compoundQueryOrderByClause,
            isDistinct,
        });
        return result;
    }
    exports.where = where;
});
define("unified-query/util/operation/index", ["require", "exports", "unified-query/util/operation/compound-query-limit/index", "unified-query/util/operation/compound-query-offset/index", "unified-query/util/operation/limit/index", "unified-query/util/operation/map/index", "unified-query/util/operation/offset/index", "unified-query/util/operation/compound-query-order-by", "unified-query/util/operation/compound-query", "unified-query/util/operation/correlate", "unified-query/util/operation/cross-join", "unified-query/util/operation/distinct", "unified-query/util/operation/from", "unified-query/util/operation/group-by", "unified-query/util/operation/having", "unified-query/util/operation/inner-join-using-candidate-key", "unified-query/util/operation/inner-join-using-primary-key", "unified-query/util/operation/inner-join", "unified-query/util/operation/left-join-using-candidate-key", "unified-query/util/operation/left-join-using-primary-key", "unified-query/util/operation/left-join", "unified-query/util/operation/order-by", "unified-query/util/operation/require-nullable-outer-query-joins", "unified-query/util/operation/require-outer-query-joins", "unified-query/util/operation/select-value", "unified-query/util/operation/select", "unified-query/util/operation/where-eq-candidate-key", "unified-query/util/operation/where-eq-columns", "unified-query/util/operation/where-eq-inner-query-primary-key", "unified-query/util/operation/where-eq-outer-query-primary-key", "unified-query/util/operation/where-eq-primary-key", "unified-query/util/operation/where-eq-super-key", "unified-query/util/operation/where-eq", "unified-query/util/operation/where-is-not-null", "unified-query/util/operation/where-is-null", "unified-query/util/operation/where-null-safe-eq", "unified-query/util/operation/where"], function (require, exports, compound_query_limit_2, compound_query_offset_2, limit_3, map_2, offset_3, compound_query_order_by_2, compound_query_4, correlate_4, cross_join_2, distinct_1, from_2, group_by_2, having_2, inner_join_using_candidate_key_2, inner_join_using_primary_key_2, inner_join_4, left_join_using_candidate_key_2, left_join_using_primary_key_2, left_join_4, order_by_2, require_nullable_outer_query_joins_2, require_outer_query_joins_2, select_value_1, select_2, where_eq_candidate_key_2, where_eq_columns_2, where_eq_inner_query_primary_key_2, where_eq_outer_query_primary_key_2, where_eq_primary_key_2, where_eq_super_key_2, where_eq_2, where_is_not_null_2, where_is_null_2, where_null_safe_eq_2, where_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_query_limit_2);
    __export(compound_query_offset_2);
    __export(limit_3);
    __export(map_2);
    __export(offset_3);
    __export(compound_query_order_by_2);
    __export(compound_query_4);
    __export(correlate_4);
    __export(cross_join_2);
    __export(distinct_1);
    __export(from_2);
    __export(group_by_2);
    __export(having_2);
    __export(inner_join_using_candidate_key_2);
    __export(inner_join_using_primary_key_2);
    __export(inner_join_4);
    __export(left_join_using_candidate_key_2);
    __export(left_join_using_primary_key_2);
    __export(left_join_4);
    __export(order_by_2);
    __export(require_nullable_outer_query_joins_2);
    __export(require_outer_query_joins_2);
    __export(select_value_1);
    __export(select_2);
    __export(where_eq_candidate_key_2);
    __export(where_eq_columns_2);
    __export(where_eq_inner_query_primary_key_2);
    __export(where_eq_outer_query_primary_key_2);
    __export(where_eq_primary_key_2);
    __export(where_eq_super_key_2);
    __export(where_eq_2);
    __export(where_is_not_null_2);
    __export(where_is_null_2);
    __export(where_null_safe_eq_2);
    __export(where_2);
});
define("unified-query/util/index", ["require", "exports", "unified-query/util/constructor/index", "unified-query/util/operation/index", "unified-query/util/predicate/index"], function (require, exports, constructor_9, operation_25, predicate_40) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_9);
    __export(operation_25);
    __export(predicate_40);
});
define("unified-query/convenience", ["require", "exports", "unified-query/util/index"], function (require, exports, QueryUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function from(aliasedTable) {
        return QueryUtil.newInstance()
            .from(aliasedTable);
    }
    exports.from = from;
    function requireOuterQueryJoins(...aliasedTables) {
        return QueryUtil.newInstance()
            .requireOuterQueryJoins(...aliasedTables);
    }
    exports.requireOuterQueryJoins = requireOuterQueryJoins;
    function requireNullableOuterQueryJoins(...aliasedTables) {
        return QueryUtil.newInstance()
            .requireNullableOuterQueryJoins(...aliasedTables);
    }
    exports.requireNullableOuterQueryJoins = requireNullableOuterQueryJoins;
    function select(selectDelegate) {
        return QueryUtil.newInstance()
            .select(selectDelegate);
    }
    exports.select = select;
    function selectValue(selectValueDelegate) {
        return QueryUtil.newInstance()
            .selectValue(selectValueDelegate);
    }
    exports.selectValue = selectValue;
});
define("unified-query/index", ["require", "exports", "unified-query/convenience", "unified-query/query-impl", "unified-query/util/index"], function (require, exports, convenience_1, query_impl_37, QueryUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(convenience_1);
    __export(query_impl_37);
    exports.QueryUtil = QueryUtil;
});
define("execution/util/operation/impl/try-set-limit-2", ["require", "exports", "limit-clause/index"], function (require, exports, limit_clause_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * We use `LIMIT 2`,
     * because if we fetch more than one row,
     * we've messed up.
     *
     * But I don't want to fetch 1 million rows if we mess up.
     * This limits our failure.
     *
     * @todo Better naming
     */
    function trySetLimit2(query) {
        const limitedQuery = (query.compoundQueryClause == undefined ?
            (query.limitClause == undefined ?
                {
                    ...query,
                    limitClause: limit_clause_6.LimitClauseUtil.limitNumber(undefined, 2),
                } :
                /**
                 * The user already specified a custom limit.
                 * We don't want to mess with it.
                 *
                 * @todo Decide if we **should** mess with it anyway?
                 * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
                 * But any higher?
                 *
                 * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
                 */
                query) :
            (query.compoundQueryLimitClause == undefined ?
                {
                    ...query,
                    compoundQueryLimitClause: limit_clause_6.LimitClauseUtil.limitNumber(undefined, 2),
                } :
                /**
                 * The user already specified a custom limit.
                 * We don't want to mess with it.
                 *
                 * @todo Decide if we **should** mess with it anyway?
                 * If they set it to `LIMIT 0/1/2`, there's no real reason to mess with it.
                 * But any higher?
                 *
                 * An explicit `LIMIT 1000000` can safely be changed to `LIMIT 2`, though.
                 */
                query));
        return limitedQuery;
    }
    exports.trySetLimit2 = trySetLimit2;
});
define("execution/util/operation/impl/fetch-all-unmapped-impl", ["require", "exports", "column-ref/index", "constants"], function (require, exports, column_ref_18, constants_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllUnmappedImpl(query, connection) {
        const rawResult = await connection.select(query);
        const hasNullableJoins = (query.fromClause.currentJoins == undefined) ?
            false :
            query.fromClause.currentJoins.some(j => j.nullable);
        const ref = column_ref_18.ColumnRefUtil.fromSelectClause(query.selectClause);
        const rows = [];
        for (const rawRow of rawResult.rows) {
            const row = {};
            for (const k of Object.keys(rawRow)) {
                const separatorIndex = k.indexOf(constants_2.SEPARATOR);
                const tableAlias = k.substr(0, separatorIndex);
                const columnAlias = k.substr(separatorIndex + constants_2.SEPARATOR.length);
                try {
                    const value = ref[tableAlias][columnAlias].mapper(`${tableAlias}.${columnAlias}`, rawRow[k]);
                    let table = row[tableAlias];
                    if (table == undefined) {
                        table = {};
                        row[tableAlias] = table;
                    }
                    table[columnAlias] = value;
                }
                catch (err) {
                    Object.defineProperty(err, "sql", {
                        value: rawResult.query.sql,
                        enumerable: false,
                        writable: true,
                    });
                    throw err;
                }
            }
            if (hasNullableJoins) {
                for (const tableAlias of Object.keys(row)) {
                    if (query.fromClause.currentJoins != undefined &&
                        query.fromClause.currentJoins.findIndex(j => j.tableAlias == tableAlias) < 0) {
                        //Probably `$aliased`
                        continue;
                    }
                    if (query.fromClause.currentJoins != undefined) {
                        const join = query.fromClause.currentJoins.find(j => j.tableAlias == tableAlias);
                        if (join != undefined && !join.nullable) {
                            //This is not a nullable join, do not make it `undefined`,
                            //no matter what.
                            continue;
                        }
                    }
                    const map = row[tableAlias];
                    if (map == undefined) {
                        continue;
                    }
                    const allNull = Object.keys(map)
                        .every(columnAlias => map[columnAlias] === null);
                    if (allNull) {
                        row[tableAlias] = undefined;
                    }
                }
            }
            rows.push(row);
        }
        return {
            sql: rawResult.query.sql,
            resultSet: rows,
        };
    }
    exports.fetchAllUnmappedImpl = fetchAllUnmappedImpl;
});
define("execution/util/operation/impl/fetch-value-array-impl", ["require", "exports", "query-base/index", "execution/util/operation/impl/fetch-all-unmapped-impl"], function (require, exports, query_base_5, fetch_all_unmapped_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchValueArrayImpl(query, connection) {
        if (!query_base_5.QueryBaseUtil.isOneSelectItem(query)) {
            throw new Error(`Expected query with one select item`);
        }
        const unmapped = await fetch_all_unmapped_impl_1.fetchAllUnmappedImpl(query, connection);
        const resultSet = unmapped.resultSet;
        if (resultSet.length == 0) {
            return {
                sql: unmapped.sql,
                resultSet: [],
            };
        }
        /**
         * This should always be a `string` if
         * `isOneSelectItem()` and `fetchAllUnmappedImpl()` are working
         * correctly.
         */
        const tableAlias = Object.keys(resultSet[0])[0];
        const columnAlias = Object.keys(resultSet[0][tableAlias])[0];
        return {
            sql: unmapped.sql,
            resultSet: resultSet.map((row) => row[tableAlias][columnAlias]),
        };
    }
    exports.fetchValueArrayImpl = fetchValueArrayImpl;
});
define("execution/util/operation/impl/fetch-value-impl", ["require", "exports", "execution/util/operation/impl/try-set-limit-2", "execution/util/operation/impl/fetch-value-array-impl", "execution/util/operation/impl/ensure-one", "execution/util/operation/impl/ensure-one-or"], function (require, exports, try_set_limit_2_1, fetch_value_array_impl_1, ensure_one_1, ensure_one_or_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchValueImpl(query, connection) {
        try {
            const limitedQuery = try_set_limit_2_1.trySetLimit2(query);
            const p = fetch_value_array_impl_1.fetchValueArrayImpl(limitedQuery, connection);
            const result = p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    value: ensure_one_1.ensureOne(limitedQuery, fetched),
                };
            });
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return p
                    .then((fetched) => {
                    return {
                        sql: fetched.sql,
                        value: ensure_one_or_1.ensureOneOr(limitedQuery, fetched, defaultValue),
                    };
                });
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result.or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchValueImpl = fetchValueImpl;
});
define("execution/util/operation/impl/exists-impl", ["require", "exports", "unified-query/index", "expr-library/index", "execution/util/operation/impl/fetch-value-impl"], function (require, exports, unified_query_1, ExprLib, fetch_value_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function existsImpl(query, connection) {
        const fetched = await fetch_value_impl_1.fetchValueImpl(unified_query_1.QueryUtil.newInstance()
            .selectValue(() => ExprLib.exists(query)), connection);
        return {
            sql: fetched.sql,
            exists: fetched.value,
        };
    }
    exports.existsImpl = existsImpl;
});
define("execution/util/operation/impl/fetch-all-mapped-impl", ["require", "exports", "execution/util/operation/impl/fetch-all-unmapped-impl"], function (require, exports, fetch_all_unmapped_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllMappedImpl(query, 
    /**
     * We need a full `IConnection` to pass to the `MapDelegate`.
     * However, ideally, it would only need to use transaction and `SELECT` statements...
     */
    connection) {
        const unmapped = await fetch_all_unmapped_impl_2.fetchAllUnmappedImpl(query, connection);
        const unmappedResultSet = unmapped.resultSet;
        if (unmappedResultSet.length == 0) {
            return unmapped;
        }
        const mappedResultSet = [];
        for (const unmappedRow of unmappedResultSet) {
            mappedResultSet.push(await query.mapDelegate(unmappedRow, connection, unmappedRow));
        }
        return {
            sql: unmapped.sql,
            resultSet: mappedResultSet,
        };
    }
    exports.fetchAllMappedImpl = fetchAllMappedImpl;
});
define("execution/util/operation/impl/fetch-all-unmapped-flattened-impl", ["require", "exports", "execution/util/predicate/index", "execution/util/operation/impl/fetch-all-unmapped-impl"], function (require, exports, predicate_41, fetch_all_unmapped_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllUnmappedFlattenedImpl(query, connection) {
        const unmapped = await fetch_all_unmapped_impl_3.fetchAllUnmappedImpl(query, connection);
        const unmappedResultSet = unmapped.resultSet;
        if (unmappedResultSet.length == 0 || !predicate_41.canFlattenUnmappedRow(query)) {
            return unmapped;
        }
        return {
            sql: unmapped.sql,
            resultSet: unmappedResultSet.map(unmappedRow => {
                const flattened = {};
                for (const tableAlias of Object.keys(unmappedRow)) {
                    const table = unmappedRow[tableAlias];
                    if (table == undefined) {
                        continue;
                    }
                    for (const columnAlias of Object.keys(table)) {
                        flattened[columnAlias] = table[columnAlias];
                    }
                }
                return flattened;
            }),
        };
    }
    exports.fetchAllUnmappedFlattenedImpl = fetchAllUnmappedFlattenedImpl;
});
define("execution/util/operation/impl/fetch-all-impl", ["require", "exports", "execution/util/operation/impl/fetch-all-unmapped-flattened-impl", "execution/util/operation/impl/fetch-all-mapped-impl"], function (require, exports, fetch_all_unmapped_flattened_impl_1, fetch_all_mapped_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchAllImpl(query, connection) {
        if (query.mapDelegate == undefined) {
            return fetch_all_unmapped_flattened_impl_1.fetchAllUnmappedFlattenedImpl(query, connection);
        }
        else {
            return fetch_all_mapped_impl_1.fetchAllMappedImpl(query, connection);
        }
    }
    exports.fetchAllImpl = fetchAllImpl;
});
define("execution/util/operation/impl/fetch-one-impl", ["require", "exports", "execution/util/operation/impl/try-set-limit-2", "execution/util/operation/impl/fetch-all-impl", "execution/util/operation/impl/ensure-one", "execution/util/operation/impl/ensure-one-or"], function (require, exports, try_set_limit_2_2, fetch_all_impl_1, ensure_one_2, ensure_one_or_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOneImpl(query, connection) {
        try {
            const limitedQuery = try_set_limit_2_2.trySetLimit2(query);
            const p = fetch_all_impl_1.fetchAllImpl(limitedQuery, connection);
            const result = p
                .then((fetched) => {
                return {
                    sql: fetched.sql,
                    row: ensure_one_2.ensureOne(limitedQuery, fetched),
                };
            });
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return p
                    .then((fetched) => {
                    return {
                        sql: fetched.sql,
                        row: ensure_one_or_2.ensureOneOr(limitedQuery, fetched, defaultValue),
                    };
                });
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result.or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchOneImpl = fetchOneImpl;
});
define("execution/util/operation/impl/fetch-one-or-impl", ["require", "exports", "execution/util/operation/impl/fetch-one-impl"], function (require, exports, fetch_one_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchOneOrImpl(query, connection, defaultValue) {
        return fetch_one_impl_1.fetchOneImpl(query, connection)
            .or(defaultValue);
    }
    exports.fetchOneOrImpl = fetchOneOrImpl;
});
define("execution/util/operation/impl/fetch-value-or-impl", ["require", "exports", "execution/util/operation/impl/fetch-value-impl"], function (require, exports, fetch_value_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchValueOrImpl(query, connection, defaultValue) {
        return fetch_value_impl_2.fetchValueImpl(query, connection)
            .or(defaultValue);
    }
    exports.fetchValueOrImpl = fetchValueOrImpl;
});
define("execution/util/operation/impl/index", ["require", "exports", "execution/util/operation/impl/ensure-one-or", "execution/util/operation/impl/ensure-one", "execution/util/operation/impl/exists-impl", "execution/util/operation/impl/fetch-all-mapped-impl", "execution/util/operation/impl/fetch-all-unmapped-flattened-impl", "execution/util/operation/impl/fetch-all-unmapped-impl", "execution/util/operation/impl/fetch-all-impl", "execution/util/operation/impl/fetch-one-or-impl", "execution/util/operation/impl/fetch-one-impl", "execution/util/operation/impl/fetch-value-array-impl", "execution/util/operation/impl/fetch-value-or-impl", "execution/util/operation/impl/fetch-value-impl", "execution/util/operation/impl/try-set-limit-2"], function (require, exports, ensure_one_or_3, ensure_one_3, exists_impl_1, fetch_all_mapped_impl_2, fetch_all_unmapped_flattened_impl_2, fetch_all_unmapped_impl_4, fetch_all_impl_2, fetch_one_or_impl_1, fetch_one_impl_2, fetch_value_array_impl_2, fetch_value_or_impl_1, fetch_value_impl_3, try_set_limit_2_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ensure_one_or_3);
    __export(ensure_one_3);
    __export(exists_impl_1);
    __export(fetch_all_mapped_impl_2);
    __export(fetch_all_unmapped_flattened_impl_2);
    __export(fetch_all_unmapped_impl_4);
    __export(fetch_all_impl_2);
    __export(fetch_one_or_impl_1);
    __export(fetch_one_impl_2);
    __export(fetch_value_array_impl_2);
    __export(fetch_value_or_impl_1);
    __export(fetch_value_impl_3);
    __export(try_set_limit_2_3);
});
define("execution/util/operation/fetch-value", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchValue(query, connection) {
        try {
            const p = impl_1.fetchValueImpl(query, connection);
            const result = p.then(({ value }) => value);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return p.or(defaultValue).then(({ value }) => value);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result
                    .or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchValue = fetchValue;
});
define("execution/util/operation/count", ["require", "exports", "type-mapping", "query-base/index", "unified-query/index", "execution/util/operation/fetch-value", "select-clause/index", "expr-library/index", "error/index", "ast/index", "expr/index", "used-ref/index", "execution/util/operation/paginate/index"], function (require, exports, tm, query_base_6, unified_query_2, fetch_value_1, select_clause_6, ExprLib, error_5, ast_3, expr_9, used_ref_18, paginate_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Optimize this further?
     * Or keep trusting DBMS execution engine?
     */
    async function count(query, connection) {
        /**
         * The following clauses may have a reference to the `SELECT` clause,
         *
         * + `groupByClause`
         * + `orderByClause`
         * + `compoundQueryClause`
         * + `compoundQueryOrderByClause`
         *
         */
        if (query_base_6.QueryBaseUtil.isAfterSelectClause(query)) {
            return fetch_value_1.fetchValue(unified_query_2.QueryUtil.selectValue(unified_query_2.QueryUtil.newInstance(), () => expr_9.expr({
                /**
                 * Should not return a value less than zero
                 */
                mapper: tm.mysql.bigIntUnsigned(),
                usedRef: used_ref_18.UsedRefUtil.fromColumnRef({}),
                isAggregate: false,
            }, ast_3.parentheses(
            /**
             * @todo **THIS** is not database agnostic. Change it to a proper AST
             * @todo Find other such occurrences,
             * where we assume the implementing DB will be able to execute SQL strings
             *
             * This should be fine for now, since most DB engines should be able to handle this.
             */
            [
                "SELECT COUNT(*) FROM",
                ast_3.parentheses(paginate_1.removePaginateArgs(query), false),
                "AS tmp"
            ], false))), connection);
        }
        if (query_base_6.QueryBaseUtil.isBeforeSelectClause(query) &&
            query_base_6.QueryBaseUtil.isBeforeCompoundQueryClause(query)) {
            return fetch_value_1.fetchValue({
                ...query,
                selectClause: select_clause_6.SelectClauseUtil.selectValue(query.fromClause, query.groupByClause, query.selectClause, () => ExprLib.countAll()),
                compoundQueryClause: query.compoundQueryClause,
            }, connection);
        }
        else {
            //This should never happen...
            if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
                throw new error_5.CannotCountError({
                    message: `Cannot get count`,
                    sql: undefined,
                });
            }
            else {
                throw new error_5.CannotCountError({
                    message: `Cannot get count of ${query.fromClause.currentJoins[0].tableAlias}`,
                    sql: undefined,
                });
            }
        }
    }
    exports.count = count;
});
define("execution/util/operation/paginate/remove-paginate-args", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removePaginateArgs(query) {
        if (query.compoundQueryClause == undefined) {
            return {
                ...query,
                limitClause: undefined,
                compoundQueryLimitClause: undefined,
            };
        }
        else {
            return {
                ...query,
                compoundQueryLimitClause: undefined,
            };
        }
    }
    exports.removePaginateArgs = removePaginateArgs;
});
define("execution/util/operation/paginate/paginate", ["require", "exports", "execution/util/operation/impl/index", "execution/util/operation/paginate/paginate-args", "execution/util/operation/paginate/apply-paginate-args", "execution/util/operation/count", "execution/util/operation/paginate/remove-paginate-args"], function (require, exports, impl_2, paginate_args_2, apply_paginate_args_1, count_1, remove_paginate_args_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function paginate(query, connection, rawArgs) {
        const args = paginate_args_2.toPaginateArgs(rawArgs);
        const paginateQuery = apply_paginate_args_1.applyPaginateArgs(query, args);
        const fetched = await impl_2.fetchAllImpl(paginateQuery, connection);
        const rowsFound = await count_1.count(remove_paginate_args_1.removePaginateArgs(paginateQuery), connection);
        const pagesFound = paginate_args_2.calculatePagesFound(args, rowsFound);
        const info = {
            rowsFound,
            pagesFound,
            page: args.page,
            rowsPerPage: args.rowsPerPage,
            rowOffset: args.rowOffset,
        };
        return {
            info,
            /**
             * @todo Investigate assignability
             */
            rows: fetched.resultSet,
        };
    }
    exports.paginate = paginate;
});
define("execution/util/operation/paginate/index", ["require", "exports", "execution/util/operation/paginate/apply-paginate-args", "execution/util/operation/paginate/paginate-args", "execution/util/operation/paginate/paginate", "execution/util/operation/paginate/remove-paginate-args"], function (require, exports, apply_paginate_args_2, paginate_args_3, paginate_2, remove_paginate_args_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(apply_paginate_args_2);
    __export(paginate_args_3);
    __export(paginate_2);
    __export(remove_paginate_args_2);
});
define("execution/util/operation/emulated-cursor/emulated-cursor", ["require", "exports", "execution/util/operation/emulated-cursor/emulated-cursor-impl"], function (require, exports, emulated_cursor_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Considerations:
     * + MySQL **does not** support cursors at the protocol level
     *   + https://github.com/sidorares/node-mysql2/issues/1014
     *   + https://github.com/sidorares/node-mysql2/pull/822#issuecomment-409415308
     *   + https://github.com/sidorares/node-mysql2/blob/9404163b0dc4bdc24f6dddd18144532f41115842/lib/commands/query.js#L239
     *   + https://github.com/mysqljs/mysql/issues/274
     * + Cursors are useful for processing large amounts of data without loading everything into memory at once
     * + Cursors can prevent out-of-memory exceptions, since data is loaded in batches
     *
     * -----
     *
     * Since cursors are not natively supported (by MySQL), we emulate it using pagination.
     * So, we use the `LIMIT` and `OFFSET` clauses, and load rows in batches as we iterate.
     *
     * -----
     *
     * ### Preventing Duplicate Items
     *
     * ```ts
     *  const cursor = myQuery.emulatedCursor();
     *  for await (const row of cursor) {
     *      console.log(row);
     *      //snip operations on `row`
     *  }
     * ```
     *
     * Given the above, we might be expecting output like,
     * ```ts
     * //batch 1
     * > { rowId : 1 }
     * > { rowId : 2 }
     *
     * //batch 2
     * > { rowId : 3 }
     * > { rowId : 4 }
     *
     * //batch n
     * > etc.
     * ```
     *
     * We might actually get,
     * ```ts
     * //batch 1
     * > { rowId : 1 }
     * > { rowId : 2 }
     *
     * //batch 2
     * > { rowId : 2 } //This is a duplicate item, what gives?
     * > { rowId : 3 }
     *
     * //batch 3
     * > { rowId : 4 }
     * > { rowId : 5 }
     *
     * //batch n
     * > etc.
     * ```
     *
     * This can happen for a variety of reasons,
     * + Missing `ORDER BY` clause
     *   + Without an `ORDER BY` clause, the order that rows are returned in is undefined behaviour.
     *   + Rows are retrieved in batches and a row may appear in multiple batches.
     *   + To fix, add an `ORDER BY` clause
     *
     * + Non-unique ordering
     *   + The `ORDER BY` clause may not guarantee a unique ordering
     *   + To fix, modify the `ORDER BY` clause and guarantee a unique ordering
     *
     * + Not using a transaction
     *   + A different connection may have inserted a row into the table you are iterating over
     *
     *     The new row may have pushed other rows "down" the table,
     *     causing the next retrieved batch to contain rows already seen.
     *
     *   + To fix, use the cursor in a transaction
     *
     * + Modifying the table being iterated over
     *   + `INSERT/DELETE/UPDATE` statements may modify the table you are iterating over.
     *   + Consider buffering mutations into a temporary table first,
     *     then apply the mutations after you are done iterating.
     *   + Consider performing your mutations in a way that does not interfere with your `ORDER BY` clause.
     *
     * -----
     *
     * With an `ORDER BY` clause that guarantees a unique ordering, you can pretend the above `cursor` code is,
     * ```ts
     * declare const cursor : MyRowT[];
     * for (const row of cursor) {
     *      console.log(row);
     *      //snip operations on `row`
     * }
     * ```
     *
     * Modifying the `cursor` array may cause unexpected behaviour during iteration.
     *
     * There are ways to safely iterate and modify an array at the same time,
     * like iterating backwards while adding elements to the end of the array.
     *
     * -----
     *
     * ### Preventing Infinite Loops
     *
     * ```ts
     *  const cursor = myQuery.emulatedCursor();
     *  for await (const row of cursor) {
     *      console.log(row);
     *      const nextRowId = row.rowId+1;
     *      //INSERT INTO myTable (rowId) VALUES(:nextRowId)
     *  }
     * ```
     *
     * Given the above, it is possible for the loop to never terminate.
     * Or, rather, it will terminate after it uses all the disk space it has access to.
     *
     * -----
     *
     * The above code is similar to the following,
     * ```ts
     *  arr = [1];
     *  for (const i of arr) {
     *      console.log(i);
     *      arr.push(i+1);
     *  }
     * ```
     *
     * This will result in an infinite loop (or crash when out of memory).
     */
    function emulatedCursor(query, connection, 
    /**
     * If set, determines the starting `page` of the cursor.
     * The `rowsPerPage` setting determines how many rows are buffered into memory at a time.
     */
    rawArgs = {}) {
        return new emulated_cursor_impl_1.EmulatedCursorImpl(query, connection, rawArgs);
    }
    exports.emulatedCursor = emulatedCursor;
});
define("execution/util/operation/emulated-cursor/emulated-cursor-impl", ["require", "exports", "type-mapping", "execution/util/operation/paginate/index"], function (require, exports, tm, paginate_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //In case Symbol.asyncIterator is not defined
    if (Symbol.asyncIterator == undefined) {
        Object.defineProperty(Symbol, "asyncIterator", {
            value: Symbol.for("Symbol.asyncIterator")
        });
    }
    class EmulatedCursorImpl {
        constructor(query, connection, rawArgs) {
            this.buffer = undefined;
            this.query = query;
            this.connection = connection;
            const args = paginate_3.toPaginateArgs(rawArgs);
            this.startPage = args.page;
            this.rowsPerPage = args.rowsPerPage;
            this.rowOffset = args.rowOffset;
            this.BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
            this.rowIndex = 0;
            if (tm.BigIntUtil.greaterThan(this.rowsPerPage, Number.MAX_SAFE_INTEGER)) {
                throw new Error(`Cannot safely emulate cursor when buffer size is greater than ${Number.MAX_SAFE_INTEGER}`);
            }
        }
        async getOrFetchBuffer() {
            if (this.buffer == undefined) {
                this.rowIndex = 0;
                this.buffer = await paginate_3.paginate(this.query, this.connection, {
                    page: this.startPage,
                    rowsPerPage: this.rowsPerPage,
                    rowOffset: this.rowOffset,
                });
            }
            return this.buffer;
        }
        async tryGetNextRow() {
            const buffer = await this.getOrFetchBuffer();
            if (this.rowIndex < buffer.rows.length) {
                const row = buffer.rows[this.rowIndex];
                ++this.rowIndex;
                return row;
            }
            else {
                return undefined;
            }
        }
        async tryFetchNextPage() {
            const buffer = await this.getOrFetchBuffer();
            const nextPage = tm.BigIntUtil.add(buffer.info.page, this.BigInt(1));
            if (tm.BigIntUtil.lessThan(nextPage, buffer.info.pagesFound)) {
                this.rowIndex = 0;
                this.buffer = await paginate_3.paginate(this.query, this.connection, {
                    page: nextPage,
                    rowsPerPage: this.rowsPerPage,
                    rowOffset: this.rowOffset,
                });
                return buffer;
            }
            else {
                return undefined;
            }
        }
        async next() {
            /**
             * Try and get the next row of the current page
             */
            const row = await this.tryGetNextRow();
            if (row !== undefined) {
                return {
                    done: false,
                    value: row,
                };
            }
            /**
             * If we're here, we passed the end of the current page
             */
            {
                await this.tryFetchNextPage();
                const row = await this.tryGetNextRow();
                if (row !== undefined) {
                    return {
                        done: false,
                        value: row,
                    };
                }
                else {
                    /**
                     * We passed the end of the last page
                     */
                    return {
                        done: true,
                        /**
                         * The `IteratorResult<>` type really needs to be updated...
                         */
                        value: undefined,
                    };
                }
            }
        }
        [Symbol.asyncIterator]() {
            return this;
        }
    }
    exports.EmulatedCursorImpl = EmulatedCursorImpl;
});
define("execution/util/operation/emulated-cursor/index", ["require", "exports", "execution/util/operation/emulated-cursor/emulated-cursor-impl", "execution/util/operation/emulated-cursor/emulated-cursor"], function (require, exports, emulated_cursor_impl_2, emulated_cursor_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(emulated_cursor_impl_2);
    __export(emulated_cursor_1);
});
define("execution/util/operation/assert-exists", ["require", "exports", "error/index", "execution/util/operation/impl/index"], function (require, exports, error_6, impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function assertExists(query, connection) {
        const result = await impl_3.existsImpl(query, connection);
        if (!result.exists) {
            if (query.fromClause.currentJoins == undefined || query.fromClause.currentJoins.length == 0) {
                throw new error_6.RowNotFoundError({
                    message: `Row does not exist`,
                    sql: result.sql,
                });
            }
            else {
                throw new error_6.RowNotFoundError({
                    message: `Row of ${query.fromClause.currentJoins[0].tableAlias} does not exist`,
                    sql: result.sql,
                });
            }
        }
    }
    exports.assertExists = assertExists;
});
define("execution/util/operation/exists", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function exists(query, connection) {
        return impl_4.existsImpl(query, connection)
            .then(({ exists }) => exists);
    }
    exports.exists = exists;
});
define("execution/util/operation/fetch-all-mapped", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllMapped(query, 
    /**
     * We need a full `IConnection` to pass to the `MapDelegate`.
     * However, ideally, it would only need to use transaction and `SELECT` statements...
     */
    connection) {
        return impl_5.fetchAllMappedImpl(query, connection)
            .then(({ resultSet }) => resultSet);
    }
    exports.fetchAllMapped = fetchAllMapped;
});
define("execution/util/operation/fetch-all-unmapped-flattened", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllUnmappedFlattened(query, connection) {
        return impl_6.fetchAllUnmappedFlattenedImpl(query, connection)
            .then(({ resultSet }) => resultSet);
    }
    exports.fetchAllUnmappedFlattened = fetchAllUnmappedFlattened;
});
define("execution/util/operation/fetch-all-unmapped", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchAllUnmapped(query, connection) {
        return impl_7.fetchAllUnmappedImpl(query, connection)
            .then(({ resultSet }) => resultSet);
    }
    exports.fetchAllUnmapped = fetchAllUnmapped;
});
define("execution/util/operation/fetch-all", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Combines `fetchAllUnmappedFlattened()` and `fetchAllMapped()` for convenience.
     */
    function fetchAll(query, connection) {
        return impl_8.fetchAllImpl(query, connection)
            .then(({ resultSet }) => resultSet);
    }
    exports.fetchAll = fetchAll;
});
define("execution/util/operation/fetch-one-or-undefined", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchOneOrUndefined(query, connection) {
        return impl_9.fetchOneOrImpl(query, connection, undefined)
            .then(({ row }) => row);
    }
    exports.fetchOneOrUndefined = fetchOneOrUndefined;
});
define("execution/util/operation/fetch-one-or", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchOneOr(query, connection, defaultValue) {
        return impl_10.fetchOneOrImpl(query, connection, defaultValue)
            .then(({ row }) => row);
    }
    exports.fetchOneOr = fetchOneOr;
});
define("execution/util/operation/fetch-one", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOne(query, connection) {
        try {
            const p = impl_11.fetchOneImpl(query, connection);
            const result = p.then(({ row }) => row);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return p.or(defaultValue).then(({ row }) => row);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result
                    .or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchOne = fetchOne;
});
define("execution/util/operation/fetch-value-array", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchValueArray(query, connection) {
        return impl_12.fetchValueArrayImpl(query, connection)
            .then(({ resultSet }) => resultSet);
    }
    exports.fetchValueArray = fetchValueArray;
});
define("execution/util/operation/fetch-value-or-undefined", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchValueOrUndefined(query, connection) {
        return impl_13.fetchValueOrImpl(query, connection, undefined)
            .then(({ value }) => value);
    }
    exports.fetchValueOrUndefined = fetchValueOrUndefined;
});
define("execution/util/operation/fetch-value-or", ["require", "exports", "execution/util/operation/impl/index"], function (require, exports, impl_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchValueOr(query, connection, defaultValue) {
        return impl_14.fetchValueOrImpl(query, connection, defaultValue)
            .then(({ value }) => value);
    }
    exports.fetchValueOr = fetchValueOr;
});
define("execution/util/operation/index", ["require", "exports", "execution/util/operation/emulated-cursor/index", "execution/util/operation/impl/index", "execution/util/operation/paginate/index", "execution/util/operation/assert-exists", "execution/util/operation/count", "execution/util/operation/exists", "execution/util/operation/fetch-all-mapped", "execution/util/operation/fetch-all-unmapped-flattened", "execution/util/operation/fetch-all-unmapped", "execution/util/operation/fetch-all", "execution/util/operation/fetch-one-or-undefined", "execution/util/operation/fetch-one-or", "execution/util/operation/fetch-one", "execution/util/operation/fetch-value-array", "execution/util/operation/fetch-value-or-undefined", "execution/util/operation/fetch-value-or", "execution/util/operation/fetch-value"], function (require, exports, emulated_cursor_2, impl_15, paginate_4, assert_exists_1, count_2, exists_1, fetch_all_mapped_1, fetch_all_unmapped_flattened_1, fetch_all_unmapped_1, fetch_all_1, fetch_one_or_undefined_1, fetch_one_or_1, fetch_one_1, fetch_value_array_1, fetch_value_or_undefined_1, fetch_value_or_1, fetch_value_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(emulated_cursor_2);
    __export(impl_15);
    __export(paginate_4);
    __export(assert_exists_1);
    __export(count_2);
    __export(exists_1);
    __export(fetch_all_mapped_1);
    __export(fetch_all_unmapped_flattened_1);
    __export(fetch_all_unmapped_1);
    __export(fetch_all_1);
    __export(fetch_one_or_undefined_1);
    __export(fetch_one_or_1);
    __export(fetch_one_1);
    __export(fetch_value_array_1);
    __export(fetch_value_or_undefined_1);
    __export(fetch_value_or_1);
    __export(fetch_value_2);
});
define("execution/util/operation-delete/delete", ["require", "exports", "type-mapping", "table/index", "where-clause/index", "from-clause/index", "event/index"], function (require, exports, tm, table_11, where_clause_13, from_clause_30, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteImplNoEvent(table, connection, whereDelegate) {
        table_11.TableUtil.assertDeleteEnabled(table);
        const whereClause = where_clause_13.WhereClauseUtil.where(from_clause_30.FromClauseUtil.from(from_clause_30.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
        const deleteResult = await connection.delete(table, whereClause);
        return {
            whereClause,
            deleteResult,
        };
    }
    exports.deleteImplNoEvent = deleteImplNoEvent;
    async function del(table, connection, whereDelegate) {
        return connection.lock(async (connection) => {
            const { whereClause, deleteResult, } = await deleteImplNoEvent(table, connection, whereDelegate);
            if (tm.BigIntUtil.greaterThan(deleteResult.deletedRowCount, tm.BigInt(0))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onDelete.invoke(new event_1.DeleteEvent({
                        connection: fullConnection,
                        table,
                        whereClause,
                        deleteResult,
                    }));
                }
            }
            return deleteResult;
        });
    }
    exports.delete = del;
});
define("isolation-level", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Isolation levels ranked from weakest to strongest,
     * 1. `READ_UNCOMMITTED`
     * 2. `READ_COMMITTED`
     * 3. `REPEATABLE_READ`
     * 4. `SERIALIZABLE`
     *
     * https://github.com/AnyhowStep/tsql/issues/14
     */
    var IsolationLevel;
    (function (IsolationLevel) {
        IsolationLevel["READ_UNCOMMITTED"] = "READ_UNCOMMITTED";
        IsolationLevel["READ_COMMITTED"] = "READ_COMMITTED";
        IsolationLevel["REPEATABLE_READ"] = "REPEATABLE_READ";
        IsolationLevel["SERIALIZABLE"] = "SERIALIZABLE";
    })(IsolationLevel = exports.IsolationLevel || (exports.IsolationLevel = {}));
    var IsolationLevelUtil;
    (function (IsolationLevelUtil) {
        const isolationLevelStrengths = {
            [IsolationLevel.READ_UNCOMMITTED]: 0,
            [IsolationLevel.READ_COMMITTED]: 1,
            [IsolationLevel.REPEATABLE_READ]: 2,
            [IsolationLevel.SERIALIZABLE]: 3,
        };
        /**
         * Is isolation level `a` weaker than `b`?
         */
        function isWeakerThan(a, b) {
            return isolationLevelStrengths[a] < isolationLevelStrengths[b];
        }
        IsolationLevelUtil.isWeakerThan = isWeakerThan;
    })(IsolationLevelUtil = exports.IsolationLevelUtil || (exports.IsolationLevelUtil = {}));
});
define("execution/util/operation-delete/delete-one", ["require", "exports", "type-mapping", "table/index", "execution/util/operation-delete/delete", "error/index", "event/index", "isolation-level"], function (require, exports, tm, table_12, impl, error_7, event_2, isolation_level_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteOne(table, connection, whereDelegate) {
        table_12.TableUtil.assertDeleteEnabled(table);
        return connection.lock(async (connection) => {
            /**
             * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
             * It should execute no other statements.
             */
            const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_1.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
                return connection.savepoint(async (connection) => {
                    const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                    if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0))) {
                        throw new error_7.RowNotFoundError({
                            message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                            sql: deleteResult.query.sql,
                        });
                    }
                    if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                        return {
                            whereClause,
                            deleteResult: deleteResult,
                        };
                    }
                    throw new error_7.TooManyRowsFoundError({
                        message: `Expected to delete one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                        sql: deleteResult.query.sql,
                    });
                });
            });
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onDelete.invoke(new event_2.DeleteEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    deleteResult,
                }));
            }
            return deleteResult;
        });
    }
    exports.deleteOne = deleteOne;
});
define("execution/util/operation-delete/delete-zero-or-one", ["require", "exports", "type-mapping", "table/index", "execution/util/operation-delete/delete", "error/index", "event/index", "isolation-level"], function (require, exports, tm, table_13, impl, error_8, event_3, isolation_level_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteZeroOrOne(table, connection, whereDelegate) {
        table_13.TableUtil.assertDeleteEnabled(table);
        return connection.lock(async (connection) => {
            /**
             * `READ_UNCOMMITTED` because this should be a simple `DELETE` statement.
             * It should execute no other statements.
             */
            const { whereClause, deleteResult, } = await connection.transactionIfNotInOne(isolation_level_2.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
                return connection.savepoint(async (connection) => {
                    const { whereClause, deleteResult, } = await impl.deleteImplNoEvent(table, connection, whereDelegate);
                    if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(0)) ||
                        tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                        return {
                            whereClause,
                            deleteResult: deleteResult,
                        };
                    }
                    throw new error_8.TooManyRowsFoundError({
                        message: `Expected to delete zero or one row of ${table.alias}; found ${deleteResult.deletedRowCount} rows`,
                        sql: deleteResult.query.sql,
                    });
                });
            });
            if (tm.BigIntUtil.equal(deleteResult.deletedRowCount, tm.BigInt(1))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onDelete.invoke(new event_3.DeleteEvent({
                        connection: fullConnection,
                        table,
                        whereClause,
                        deleteResult,
                    }));
                }
            }
            return deleteResult;
        });
    }
    exports.deleteZeroOrOne = deleteZeroOrOne;
});
define("execution/util/operation-delete/index", ["require", "exports", "execution/util/operation-delete/delete-one", "execution/util/operation-delete/delete-zero-or-one", "execution/util/operation-delete/delete"], function (require, exports, delete_one_1, delete_zero_or_one_1, delete_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(delete_one_1);
    __export(delete_zero_or_one_1);
    __export(delete_1);
});
define("execution/util/operation-insert/insert-one", ["require", "exports", "type-mapping", "table/index", "insert/index", "data-type/index", "event/index"], function (require, exports, tm, table_14, insert_1, data_type_1, event_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function insertOneImplNoEvent(table, connection, row) {
        table_14.TableUtil.assertInsertEnabled(table);
        /**
         * Should contain only `BuiltInExpr` now
         */
        row = insert_1.InsertUtil.cleanInsertRow(table, row);
        if (table.autoIncrement == undefined) {
            return {
                insertRow: row,
                insertResult: await connection.insertOne(table, row),
            };
        }
        let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
        if (explicitAutoIncrementBuiltInExpr === undefined) {
            const insertResult = await connection.insertOne(table, row);
            if (insertResult.autoIncrementId != undefined) {
                return {
                    insertRow: row,
                    insertResult: {
                        ...insertResult,
                        [table.autoIncrement]: insertResult.autoIncrementId,
                    },
                };
            }
            /**
             * @todo Custom error type
             */
            throw new Error(`Successful insertOne() to ${table.alias} should return autoIncrementId`);
        }
        explicitAutoIncrementBuiltInExpr = await data_type_1.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
        const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
        const insertResult = await connection.insertOne(table, {
            ...row,
            [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
        });
        /**
         * We defer to the `autoIncrementId` of the `insertResult`.
         * We assume the `connection` always knows best.
         */
        if (insertResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertResult,
                    [table.autoIncrement]: insertResult.autoIncrementId,
                },
            };
        }
        /**
         * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
         * Use it.
         */
        return {
            insertRow: row,
            insertResult: {
                ...insertResult,
                autoIncrementId: autoIncrementBigInt,
                [table.autoIncrement]: autoIncrementBigInt,
            },
        };
    }
    exports.insertOneImplNoEvent = insertOneImplNoEvent;
    function createInsertOneEvents(table, fullConnection, insertRow, insertResult) {
        const augmentedInsertRow = (table.autoIncrement == undefined ?
            insertRow :
            {
                ...insertRow,
                /**
                 * The column may be specified to be `string|number|bigint`.
                 * So, we need to use the column's mapper,
                 * to get the desired data type.
                 */
                [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
                /**
                 * This **should** be `bigint`
                 */
                insertResult.autoIncrementId),
            });
        const insertEvent = new event_4.InsertEvent({
            connection: fullConnection,
            table,
            insertRows: [augmentedInsertRow],
            insertResult,
        });
        const insertOneEvent = new event_4.InsertOneEvent({
            connection: fullConnection,
            table,
            insertRow: augmentedInsertRow,
            insertResult,
        });
        return {
            insertEvent,
            insertOneEvent,
        };
    }
    exports.createInsertOneEvents = createInsertOneEvents;
    /**
     * Only inserts one row
     * ```sql
     *  INSERT INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     */
    async function insertOne(table, connection, row) {
        return connection.lock(async (connection) => {
            const { insertRow, insertResult, } = await insertOneImplNoEvent(table, connection, row);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                const { insertEvent, insertOneEvent, } = createInsertOneEvents(table, fullConnection, insertRow, insertResult);
                await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
                await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
            }
            return insertResult;
        });
    }
    exports.insertOne = insertOne;
});
define("execution/util/operation-insert/insert-and-fetch", ["require", "exports", "table/index", "execution/util/operation-insert/insert-one", "expr-library/index", "data-type/index", "event/index", "isolation-level"], function (require, exports, table_15, insert_one_1, ExprLib, data_type_2, event_5, isolation_level_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function insertAndFetchImplNoEvent(table, connection, row) {
        table_15.TableUtil.assertInsertEnabled(table);
        table_15.TableUtil.assertHasCandidateKey(table);
        /**
         * @todo Check if `SERIALIZABLE` is better.
         * Intuitively, `REPEATABLE_READ` makes sense because
         * we're just reading a row we've inserted inside this transaction.
         */
        return connection.transactionIfNotInOne(isolation_level_3.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                if (table.autoIncrement == undefined) {
                    const candidateKeyResult = await data_type_2.DataTypeUtil.tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row);
                    if (!candidateKeyResult.success) {
                        throw candidateKeyResult.error;
                    }
                    row = {
                        ...row,
                        ...candidateKeyResult.outputRow,
                    };
                    const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                    const fetchedRow = await table_15.TableUtil.fetchOne(table, connection, () => ExprLib.eqCandidateKey(table, candidateKeyResult.outputRow));
                    return {
                        ...insertOneImplResult,
                        fetchedRow,
                    };
                }
                else {
                    const insertOneImplResult = await insert_one_1.insertOneImplNoEvent(table, connection, row);
                    const fetchedRow = await table_15.TableUtil.fetchOne(table, connection, 
                    /**
                     * We use this instead of `eqPrimaryKey()` because it's possible
                     * for an `AUTO_INCREMENT` column to not be a primary key
                     * with some databases...
                     *
                     * It's also possible for it to not be a candidate key!
                     */
                    () => ExprLib.eqColumns(table, {
                        [table.autoIncrement]: insertOneImplResult.insertResult.autoIncrementId,
                    }));
                    return {
                        ...insertOneImplResult,
                        fetchedRow,
                    };
                }
            });
        });
    }
    /**
     * Convenience method for
     * ```ts
     *  connection.transactionIfNotInOne(IsolationLevel.REPEATABLE_READ, async (connection) => {
     *      await table.insertOne(connection, ...);
     *      return table.fetchOne(connection, ...);
     *  });
     * ```
     */
    async function insertAndFetch(table, connection, row, insertAndFetchOptions) {
        table_15.TableUtil.assertInsertEnabled(table);
        table_15.TableUtil.assertHasCandidateKey(table);
        return connection.lock(async (connection) => {
            const { insertRow, insertResult, fetchedRow, } = await insertAndFetchImplNoEvent((insertAndFetchOptions == undefined ?
                table :
                {
                    ...table,
                    ...insertAndFetchOptions,
                }), connection, row);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                const { insertEvent, insertOneEvent, } = insert_one_1.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
                await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
                await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
                await fullConnection.eventEmitters.onInsertAndFetch.invoke(new event_5.InsertAndFetchEvent({
                    connection: fullConnection,
                    table,
                    insertRow: insertOneEvent.insertRow,
                    insertResult: insertOneEvent.insertResult,
                    fetchedRow: fetchedRow,
                }));
            }
            return fetchedRow;
        });
    }
    exports.insertAndFetch = insertAndFetch;
});
define("execution/util/operation-insert/insert-ignore-many", ["require", "exports", "type-mapping", "table/index", "insert/index", "event/index"], function (require, exports, tm, table_16, insert_2, event_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Inserts zero-to-many rows
     * ```sql
     *  INSERT IGNORE INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    async function insertIgnoreMany(table, connection, rows) {
        table_16.TableUtil.assertInsertEnabled(table);
        if (rows.length == 0) {
            return {
                query: {
                    /**
                     * No rows were inserted.
                     * No SQL string was execute.
                     */
                    sql: "",
                },
                insertedRowCount: tm.BigInt(0),
                /**
                 * Should this be considered a warning?
                 * Probably not.
                 */
                warningCount: tm.BigInt(0),
                message: "No rows to insert",
            };
        }
        return connection.lock(async (connection) => {
            const insertRows = rows.map(row => insert_2.InsertUtil.cleanInsertRow(table, row));
            const insertResult = await connection.insertIgnoreMany(table, insertRows);
            if (!tm.BigIntUtil.equal(insertResult.insertedRowCount, tm.BigInt(0))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onInsert.invoke(new event_6.InsertEvent({
                        connection: fullConnection,
                        table,
                        insertRows,
                        insertResult,
                    }));
                }
            }
            return insertResult;
        });
    }
    exports.insertIgnoreMany = insertIgnoreMany;
});
define("execution/util/operation-insert/insert-ignore-one", ["require", "exports", "type-mapping", "table/index", "insert/index", "execution/util/operation-insert/insert-one"], function (require, exports, tm, table_17, insert_3, insert_one_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isIgnoredResult(result) {
        return tm.BigIntUtil.equal(result.insertedRowCount, tm.BigInt(0));
    }
    function isInsertOneResult(result) {
        return !isIgnoredResult(result);
    }
    /**
     * Does not invoke events.
     */
    async function insertIgnoreOneImpl(table, connection, row) {
        table_17.TableUtil.assertInsertEnabled(table);
        /**
         * Should contain only `BuiltInExpr` now
         */
        row = insert_3.InsertUtil.cleanInsertRow(table, row);
        if (table.autoIncrement == undefined) {
            return {
                insertRow: row,
                insertResult: await connection.insertIgnoreOne(table, row),
            };
        }
        const explicitAutoIncrementValue = row[table.autoIncrement];
        if (explicitAutoIncrementValue === undefined) {
            const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
            if (isIgnoredResult(insertIgnoreResult)) {
                return {
                    insertRow: row,
                    insertResult: {
                        ...insertIgnoreResult,
                        [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                    },
                };
            }
            if (insertIgnoreResult.autoIncrementId != undefined) {
                return {
                    insertRow: row,
                    insertResult: {
                        ...insertIgnoreResult,
                        [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                    },
                };
            }
            /**
             * @todo Custom error type
             */
            throw new Error(`Successful insertIgnoreOne() to ${table.alias} should return autoIncrementId`);
        }
        if (typeof explicitAutoIncrementValue != "number" &&
            typeof explicitAutoIncrementValue != "string" &&
            !tm.TypeUtil.isBigInt(explicitAutoIncrementValue)) {
            /**
             * @todo Custom error type
             */
            throw new Error(`Explicit autoIncrement value for ${table.alias} must be bigint|number|string`);
        }
        const insertIgnoreResult = await connection.insertIgnoreOne(table, row);
        if (isIgnoredResult(insertIgnoreResult)) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        if (insertIgnoreResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                insertResult: {
                    ...insertIgnoreResult,
                    [table.autoIncrement]: insertIgnoreResult.autoIncrementId,
                },
            };
        }
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        /**
         * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
         * Use it.
         */
        return {
            insertRow: row,
            insertResult: {
                ...insertIgnoreResult,
                autoIncrementId: BigInt(explicitAutoIncrementValue),
                [table.autoIncrement]: BigInt(explicitAutoIncrementValue),
            },
        };
    }
    /**
     * Only inserts zero or one row
     * ```sql
     *  INSERT IGNORE INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     */
    async function insertIgnoreOne(table, connection, row) {
        return connection.lock(async (connection) => {
            const { insertRow, insertResult, } = await insertIgnoreOneImpl(table, connection, row);
            if (isInsertOneResult(insertResult)) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    const { insertEvent, insertOneEvent, } = insert_one_2.createInsertOneEvents(table, fullConnection, insertRow, insertResult);
                    await fullConnection.eventEmitters.onInsert.invoke(insertEvent);
                    await fullConnection.eventEmitters.onInsertOne.invoke(insertOneEvent);
                }
            }
            return insertResult;
        });
    }
    exports.insertIgnoreOne = insertIgnoreOne;
});
define("execution/util/operation-insert/insert-many", ["require", "exports", "type-mapping", "table/index", "insert/index", "event/index"], function (require, exports, tm, table_18, insert_4, event_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Inserts zero-to-many rows
     * ```sql
     *  INSERT INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    async function insertMany(table, connection, rows) {
        table_18.TableUtil.assertInsertEnabled(table);
        if (rows.length == 0) {
            return {
                query: {
                    /**
                     * No rows were inserted.
                     * No SQL string was execute.
                     */
                    sql: "",
                },
                insertedRowCount: tm.BigInt(0),
                /**
                 * Should this be considered a warning?
                 * Probably not.
                 */
                warningCount: tm.BigInt(0),
                message: "No rows to insert",
            };
        }
        return connection.lock(async (connection) => {
            const insertRows = rows.map(row => insert_4.InsertUtil.cleanInsertRow(table, row));
            const insertResult = await connection.insertMany(table, insertRows);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onInsert.invoke(new event_7.InsertEvent({
                    connection: fullConnection,
                    table,
                    insertRows,
                    insertResult,
                }));
            }
            return insertResult;
        });
    }
    exports.insertMany = insertMany;
});
define("execution/util/operation-insert/replace-many", ["require", "exports", "type-mapping", "table/index", "insert/index", "event/index"], function (require, exports, tm, table_19, insert_5, event_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Inserts/Replaces zero-to-many rows
     * ```sql
     *  REPLACE INTO
     *      myTable (...column_list)
     *  VALUES
     *      ...row_list;
     * ```
     */
    async function replaceMany(table, connection, rows) {
        table_19.TableUtil.assertInsertEnabled(table);
        table_19.TableUtil.assertDeleteEnabled(table);
        if (rows.length == 0) {
            return {
                query: {
                    /**
                     * No rows were inserted.
                     * No SQL string was execute.
                     */
                    sql: "",
                },
                insertedOrReplacedRowCount: tm.BigInt(0),
                /**
                 * Should this be considered a warning?
                 * Probably not.
                 */
                warningCount: tm.BigInt(0),
                message: "No rows to insert",
            };
        }
        return connection.lock(async (connection) => {
            const insertRows = rows.map(row => insert_5.InsertUtil.cleanInsertRow(table, row));
            const replaceResult = await connection.replaceMany(table, insertRows);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onReplace.invoke(new event_8.ReplaceEvent({
                    connection: fullConnection,
                    table,
                    insertRows,
                    replaceResult,
                }));
            }
            return replaceResult;
        });
    }
    exports.replaceMany = replaceMany;
});
define("execution/util/operation-insert/replace-one", ["require", "exports", "type-mapping", "table/index", "insert/index", "data-type/index", "event/index"], function (require, exports, tm, table_20, insert_6, data_type_3, event_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function replaceOneImplNoEvent(table, connection, row) {
        table_20.TableUtil.assertInsertEnabled(table);
        table_20.TableUtil.assertDeleteEnabled(table);
        /**
         * Should contain only `BuiltInExpr` now
         */
        row = insert_6.InsertUtil.cleanInsertRow(table, row);
        if (table.autoIncrement == undefined) {
            return {
                insertRow: row,
                replaceResult: await connection.replaceOne(table, row),
            };
        }
        let explicitAutoIncrementBuiltInExpr = row[table.autoIncrement];
        if (explicitAutoIncrementBuiltInExpr === undefined) {
            const replaceResult = await connection.replaceOne(table, row);
            if (replaceResult.autoIncrementId != undefined) {
                return {
                    insertRow: row,
                    replaceResult: {
                        ...replaceResult,
                        [table.autoIncrement]: replaceResult.autoIncrementId,
                    },
                };
            }
            /**
             * @todo Custom error type
             */
            throw new Error(`Successful replaceOne() to ${table.alias} should return autoIncrementId`);
        }
        explicitAutoIncrementBuiltInExpr = await data_type_3.DataTypeUtil.evaluateCustomExpr(table.columns[table.autoIncrement], connection, explicitAutoIncrementBuiltInExpr);
        const autoIncrementBigInt = tm.BigInt(explicitAutoIncrementBuiltInExpr);
        const replaceResult = await connection.replaceOne(table, {
            ...row,
            [table.autoIncrement]: explicitAutoIncrementBuiltInExpr,
        });
        /**
         * We defer to the `autoIncrementId` of the `replaceResult`.
         * We assume the `connection` always knows best.
         */
        if (replaceResult.autoIncrementId != undefined) {
            return {
                insertRow: row,
                replaceResult: {
                    ...replaceResult,
                    [table.autoIncrement]: replaceResult.autoIncrementId,
                },
            };
        }
        /**
         * User supplied an explicit value for the `AUTO_INCREMENT`/`SERIAL` column, for whatever reason.
         * Use it.
         */
        return {
            insertRow: row,
            replaceResult: {
                ...replaceResult,
                autoIncrementId: autoIncrementBigInt,
                [table.autoIncrement]: autoIncrementBigInt,
            },
        };
    }
    exports.replaceOneImplNoEvent = replaceOneImplNoEvent;
    function createReplaceOneEvents(table, fullConnection, insertRow, replaceResult) {
        const augmentedInsertRow = (table.autoIncrement == undefined ?
            insertRow :
            {
                ...insertRow,
                /**
                 * The column may be specified to be `string|number|bigint`.
                 * So, we need to use the column's mapper,
                 * to get the desired data type.
                 */
                [table.autoIncrement]: table.columns[table.autoIncrement].mapper(`${table.alias}.${table.autoIncrement}`, 
                /**
                 * This **should** be `bigint`
                 */
                replaceResult.autoIncrementId),
            });
        const replaceEvent = new event_9.ReplaceEvent({
            connection: fullConnection,
            table,
            insertRows: [augmentedInsertRow],
            replaceResult,
        });
        const replaceOneEvent = new event_9.ReplaceOneEvent({
            connection: fullConnection,
            table,
            insertRow: augmentedInsertRow,
            replaceResult,
        });
        return {
            replaceEvent,
            replaceOneEvent,
        };
    }
    exports.createReplaceOneEvents = createReplaceOneEvents;
    /**
     * Only inserts/replaces one row
     * ```sql
     *  REPLACE INTO
     *      myTable (...column_list)
     *  VALUES
     *      (...value_list);
     * ```
     *
     * The table must allow both `INSERT` and `DELETE`.
     * Replacing a row is essentially deleting the old row and inserting a new row.
     */
    async function replaceOne(table, connection, row) {
        return connection.lock(async (connection) => {
            const { insertRow, replaceResult, } = await replaceOneImplNoEvent(table, connection, row);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                const { replaceEvent, replaceOneEvent, } = createReplaceOneEvents(table, fullConnection, insertRow, replaceResult);
                await fullConnection.eventEmitters.onReplace.invoke(replaceEvent);
                await fullConnection.eventEmitters.onReplaceOne.invoke(replaceOneEvent);
            }
            return replaceResult;
        });
    }
    exports.replaceOne = replaceOne;
});
define("execution/util/operation-insert/index", ["require", "exports", "execution/util/operation-insert/insert-and-fetch", "execution/util/operation-insert/insert-ignore-many", "execution/util/operation-insert/insert-ignore-one", "execution/util/operation-insert/insert-many", "execution/util/operation-insert/insert-one", "execution/util/operation-insert/replace-many", "execution/util/operation-insert/replace-one"], function (require, exports, insert_and_fetch_1, insert_ignore_many_1, insert_ignore_one_1, insert_many_1, insert_one_3, replace_many_1, replace_one_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(insert_and_fetch_1);
    __export(insert_ignore_many_1);
    __export(insert_ignore_one_1);
    __export(insert_many_1);
    __export(insert_one_3);
    __export(replace_many_1);
    __export(replace_one_1);
});
define("execution/util/operation-insert-select/insert-ignore-select", ["require", "exports", "table/index", "insert-select/index", "event/index"], function (require, exports, table_21, insert_select_2, event_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function insertIgnoreSelect(connection, query, table, rowDelegate) {
        table_21.TableUtil.assertInsertEnabled(table);
        return connection.lock(async (connection) => {
            const insertSelectRow = insert_select_2.InsertSelectUtil.insertSelect(query, table, rowDelegate);
            const insertResult = await connection.insertIgnoreSelect(query, table, insertSelectRow);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onInsertSelect.invoke(new event_10.InsertSelectEvent({
                    connection: fullConnection,
                    query,
                    table,
                    insertSelectRow,
                    insertResult,
                }));
            }
            return insertResult;
        });
    }
    exports.insertIgnoreSelect = insertIgnoreSelect;
});
define("execution/util/operation-insert-select/insert-select", ["require", "exports", "table/index", "insert-select/index", "event/index"], function (require, exports, table_22, insert_select_3, event_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function insertSelect(connection, query, table, rowDelegate) {
        table_22.TableUtil.assertInsertEnabled(table);
        return connection.lock(async (connection) => {
            const insertSelectRow = insert_select_3.InsertSelectUtil.insertSelect(query, table, rowDelegate);
            const insertResult = await connection.insertSelect(query, table, insertSelectRow);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onInsertSelect.invoke(new event_11.InsertSelectEvent({
                    connection: fullConnection,
                    query,
                    table,
                    insertSelectRow,
                    insertResult,
                }));
            }
            return insertResult;
        });
    }
    exports.insertSelect = insertSelect;
});
define("execution/util/operation-insert-select/replace-select", ["require", "exports", "table/index", "insert-select/index", "event/index"], function (require, exports, table_23, insert_select_4, event_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function replaceSelect(connection, query, table, rowDelegate) {
        table_23.TableUtil.assertInsertEnabled(table);
        table_23.TableUtil.assertDeleteEnabled(table);
        return connection.lock(async (connection) => {
            const replaceSelectRow = insert_select_4.InsertSelectUtil.insertSelect(query, table, rowDelegate);
            const replaceResult = await connection.replaceSelect(query, table, replaceSelectRow);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onReplaceSelect.invoke(new event_12.ReplaceSelectEvent({
                    connection: fullConnection,
                    query,
                    table,
                    replaceSelectRow,
                    replaceResult,
                }));
            }
            return replaceResult;
        });
    }
    exports.replaceSelect = replaceSelect;
});
define("execution/util/operation-insert-select/index", ["require", "exports", "execution/util/operation-insert-select/insert-ignore-select", "execution/util/operation-insert-select/insert-select", "execution/util/operation-insert-select/replace-select"], function (require, exports, insert_ignore_select_1, insert_select_5, replace_select_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(insert_ignore_select_1);
    __export(insert_select_5);
    __export(replace_select_1);
});
define("execution/util/operation-update/update", ["require", "exports", "type-mapping", "where-clause/index", "from-clause/index", "update/index", "event/index"], function (require, exports, tm, where_clause_14, from_clause_31, update_1, event_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
        const whereClause = where_clause_14.WhereClauseUtil.where(from_clause_31.FromClauseUtil.from(from_clause_31.FromClauseUtil.newInstance(), table), undefined, whereDelegate);
        const assignmentMap = update_1.UpdateUtil.set(table, assignmentMapDelegate);
        const updateResult = await connection.update(table, whereClause, assignmentMap);
        return {
            whereClause,
            assignmentMap,
            updateResult,
        };
    }
    exports.updateImplNoEvent = updateImplNoEvent;
    async function update(table, connection, whereDelegate, assignmentMapDelegate) {
        return connection.lock(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onUpdate.invoke(new event_13.UpdateEvent({
                        connection: fullConnection,
                        table,
                        whereClause,
                        assignmentMap,
                        updateResult,
                    }));
                }
            }
            return updateResult;
        });
    }
    exports.update = update;
});
define("execution/util/operation-update/update-one", ["require", "exports", "type-mapping", "execution/util/operation-update/update", "error/index", "event/index", "isolation-level"], function (require, exports, tm, impl, error_9, event_14, isolation_level_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
         * It should execute no other statements.
         */
        return connection.transactionIfNotInOne(isolation_level_4.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
                if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                    throw new error_9.RowNotFoundError({
                        message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                        sql: updateResult.query.sql,
                    });
                }
                if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                    if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                        tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                        return {
                            whereClause,
                            assignmentMap,
                            updateResult: updateResult,
                        };
                    }
                    else {
                        //Should never happen...
                        throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                    }
                }
                throw new error_9.TooManyRowsFoundError({
                    message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                    sql: updateResult.query.sql,
                });
            });
        });
    }
    exports.updateOneImplNoEvent = updateOneImplNoEvent;
    async function updateOne(table, connection, whereDelegate, assignmentMapDelegate) {
        return connection.lock(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await updateOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_14.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause,
                    assignmentMap,
                    updateResult,
                }));
            }
            return updateResult;
        });
    }
    exports.updateOne = updateOne;
});
define("execution/util/operation-update/update-and-fetch-one-impl", ["require", "exports", "table/index", "execution/util/operation-update/update-one", "event/index", "isolation-level"], function (require, exports, table_24, update_one_1, event_15, isolation_level_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This should not be called directly by users.
     *
     * A lot can go wrong here...
     */
    async function updateAndFetchOneImpl(table, connection, initCallback) {
        return connection.lock(async (connection) => {
            /**
             * `REPEATABLE_READ` should be fine because we're not creating any new rows.
             */
            const { updateWhereClause, updateResult, assignmentMap, } = await connection.transactionIfNotInOne(isolation_level_5.IsolationLevel.REPEATABLE_READ, async (connection) => {
                return connection.savepoint(async (connection) => {
                    const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = await initCallback(connection);
                    const { whereClause: updateWhereClause, updateResult: updateOneResult, } = await update_one_1.updateOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                    const row = await table_24.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                    return {
                        updateWhereClause,
                        updateResult: {
                            ...updateOneResult,
                            row,
                        },
                        assignmentMap,
                    };
                });
            });
            const fullConnection = connection.tryGetFullConnection();
            if (fullConnection != undefined) {
                await fullConnection.eventEmitters.onUpdate.invoke(new event_15.UpdateEvent({
                    connection: fullConnection,
                    table,
                    whereClause: updateWhereClause,
                    assignmentMap,
                    updateResult,
                }));
                await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_15.UpdateAndFetchEvent({
                    connection: fullConnection,
                    table,
                    assignmentMap,
                    updateResult: updateResult,
                }));
            }
            return updateResult;
        });
    }
    exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
});
define("execution/util/operation-update/update-and-fetch-one-by-candidate-key", ["require", "exports", "table/index", "candidate-key/index", "built-in-expr/index", "expr-library/index", "error/index", "execution/util/operation-update/update-and-fetch-one-impl"], function (require, exports, table_25, candidate_key_4, built_in_expr_15, ExprLib, error_10, update_and_fetch_one_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    async function __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        candidateKey = candidate_key_4.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${table.alias}[candidateKey]`, candidateKey);
        const assignmentMap = assignmentMapDelegate(table.columns);
        const newCandidateKey = {};
        for (const candidateColumnAlias of Object.keys(candidateKey)) {
            const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, candidateColumnAlias) &&
                Object.prototype.propertyIsEnumerable.call(assignmentMap, candidateColumnAlias)) ?
                assignmentMap[candidateColumnAlias] :
                undefined);
            if (newCustomExpr === undefined) {
                /**
                 * This `candidateKey` column's value will not be updated.
                 */
                newCandidateKey[candidateColumnAlias] = candidateKey[candidateColumnAlias];
            }
            else {
                if (table.mutableColumns.indexOf(candidateColumnAlias) < 0) {
                    throw new Error(`${table.alias}.${candidateColumnAlias} is not a mutable candidate key column`);
                }
                /**
                 * This `candidateKey` column's value will be updated.
                 * We need to know what its updated value will be.
                 */
                if (built_in_expr_15.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                    const evaluatedNewValue = await table_25.TableUtil.fetchValue(table, connection, () => ExprLib.eqCandidateKey(table, candidateKey), () => newCustomExpr).catch((err) => {
                        if (err instanceof error_10.RowNotFoundError) {
                            return err;
                        }
                        else {
                            throw err;
                        }
                    });
                    if (evaluatedNewValue instanceof error_10.RowNotFoundError) {
                        return {
                            success: false,
                            rowNotFoundError: evaluatedNewValue,
                        };
                    }
                    newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, evaluatedNewValue);
                }
                else {
                    newCandidateKey[candidateColumnAlias] = table.columns[candidateColumnAlias].mapper(`${table.alias}.${candidateColumnAlias}[newValue]`, newCustomExpr);
                }
                /**
                 * If it was an expression, it is now a value.
                 */
                assignmentMap[candidateColumnAlias] = newCandidateKey[candidateColumnAlias];
            }
        }
        return {
            success: true,
            curCandidateKey: candidateKey,
            assignmentMap,
            newCandidateKey,
        };
    }
    exports.__updateAndFetchOneByCandidateKeyHelper = __updateAndFetchOneByCandidateKeyHelper;
    async function updateAndFetchOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return update_and_fetch_one_impl_1.updateAndFetchOneImpl(table, connection, async (connection) => {
            const helperResult = await __updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
            if (!helperResult.success) {
                throw helperResult.rowNotFoundError;
            }
            const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
            return {
                updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
                fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
});
define("execution/util/operation-update/update-and-fetch-one-by-primary-key", ["require", "exports", "table/index", "expr-library/index", "primary-key/index", "error/index", "built-in-expr/index", "execution/util/operation-update/update-and-fetch-one-impl"], function (require, exports, table_26, ExprLib, primary_key_3, error_11, built_in_expr_16, update_and_fetch_one_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    async function __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate) {
        primaryKey = primary_key_3.PrimaryKeyUtil.mapper(table)(`${table.alias}[primaryKey]`, primaryKey);
        const assignmentMap = assignmentMapDelegate(table.columns);
        const newPrimaryKey = {};
        for (const primaryColumnAlias of Object.keys(primaryKey)) {
            const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, primaryColumnAlias) &&
                Object.prototype.propertyIsEnumerable.call(assignmentMap, primaryColumnAlias)) ?
                assignmentMap[primaryColumnAlias] :
                undefined);
            if (newCustomExpr === undefined) {
                /**
                 * This `primaryKey` column's value will not be updated.
                 */
                newPrimaryKey[primaryColumnAlias] = primaryKey[primaryColumnAlias];
            }
            else {
                if (table.mutableColumns.indexOf(primaryColumnAlias) < 0) {
                    throw new Error(`${table.alias}.${primaryColumnAlias} is not a mutable primary key column`);
                }
                /**
                 * This `primaryKey` column's value will be updated.
                 * We need to know what its updated value will be.
                 */
                if (built_in_expr_16.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                    const evaluatedNewValue = await table_26.TableUtil.fetchValue(table, connection, () => ExprLib.eqPrimaryKey(table, primaryKey), () => newCustomExpr).catch((err) => {
                        if (err instanceof error_11.RowNotFoundError) {
                            return err;
                        }
                        else {
                            throw err;
                        }
                    });
                    if (evaluatedNewValue instanceof error_11.RowNotFoundError) {
                        return {
                            success: false,
                            rowNotFoundError: evaluatedNewValue,
                        };
                    }
                    newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, evaluatedNewValue);
                }
                else {
                    newPrimaryKey[primaryColumnAlias] = table.columns[primaryColumnAlias].mapper(`${table.alias}.${primaryColumnAlias}[newValue]`, newCustomExpr);
                }
                /**
                 * If it was an expression, it is now a value.
                 */
                assignmentMap[primaryColumnAlias] = newPrimaryKey[primaryColumnAlias];
            }
        }
        return {
            success: true,
            curPrimaryKey: primaryKey,
            assignmentMap,
            newPrimaryKey,
        };
    }
    exports.__updateAndFetchOneByPrimaryKeyHelper = __updateAndFetchOneByPrimaryKeyHelper;
    async function updateAndFetchOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
        return update_and_fetch_one_impl_2.updateAndFetchOneImpl(table, connection, async (connection) => {
            const helperResult = await __updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
            if (!helperResult.success) {
                throw helperResult.rowNotFoundError;
            }
            const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
            return {
                updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
                fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
});
define("execution/util/operation-update/update-and-fetch-one-by-super-key", ["require", "exports", "table/index", "expr-library/index", "super-key/index", "error/index", "built-in-expr/index", "execution/util/operation-update/update-and-fetch-one-impl"], function (require, exports, table_27, ExprLib, super_key_1, error_12, built_in_expr_17, update_and_fetch_one_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    async function __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate) {
        superKey = super_key_1.SuperKeyUtil.mapper(table)(`${table.alias}[superKey]`, superKey);
        const assignmentMap = assignmentMapDelegate(table.columns);
        const newSuperKey = {};
        for (const superColumnAlias of Object.keys(superKey)) {
            if (superKey[superColumnAlias] === undefined) {
                continue;
            }
            const newCustomExpr = ((Object.prototype.hasOwnProperty.call(assignmentMap, superColumnAlias) &&
                Object.prototype.propertyIsEnumerable.call(assignmentMap, superColumnAlias)) ?
                assignmentMap[superColumnAlias] :
                undefined);
            if (newCustomExpr === undefined) {
                /**
                 * This `superKey` column's value will not be updated.
                 */
                newSuperKey[superColumnAlias] = superKey[superColumnAlias];
            }
            else {
                if (table.mutableColumns.indexOf(superColumnAlias) < 0) {
                    throw new Error(`${table.alias}.${superColumnAlias} is not a mutable super key column`);
                }
                /**
                 * This `superKey` column's value will be updated.
                 * We need to know what its updated value will be.
                 */
                if (built_in_expr_17.BuiltInExprUtil.isAnyNonValueExpr(newCustomExpr)) {
                    const evaluatedNewValue = await table_27.TableUtil.fetchValue(table, connection, () => ExprLib.eqSuperKey(table, superKey), () => newCustomExpr).catch((err) => {
                        if (err instanceof error_12.RowNotFoundError) {
                            return err;
                        }
                        else {
                            throw err;
                        }
                    });
                    if (evaluatedNewValue instanceof error_12.RowNotFoundError) {
                        return {
                            success: false,
                            rowNotFoundError: evaluatedNewValue,
                        };
                    }
                    newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, evaluatedNewValue);
                }
                else {
                    newSuperKey[superColumnAlias] = table.columns[superColumnAlias].mapper(`${table.alias}.${superColumnAlias}[newValue]`, newCustomExpr);
                }
                /**
                 * If it was an expression, it is now a value.
                 */
                assignmentMap[superColumnAlias] = newSuperKey[superColumnAlias];
            }
        }
        return {
            success: true,
            curSuperKey: superKey,
            assignmentMap,
            newSuperKey,
        };
    }
    exports.__updateAndFetchOneBySuperKeyHelper = __updateAndFetchOneBySuperKeyHelper;
    async function updateAndFetchOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
        return update_and_fetch_one_impl_3.updateAndFetchOneImpl(table, connection, async (connection) => {
            const helperResult = await __updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
            if (!helperResult.success) {
                throw helperResult.rowNotFoundError;
            }
            const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
            return {
                updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
                fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
});
define("execution/util/operation-update/update-and-fetch-one", ["require", "exports", "table/index", "expr-library/index", "error/index", "execution/util/operation-update/update-and-fetch-one-impl", "unified-query/index", "execution/index", "execution/util/operation-update/update-and-fetch-one-by-candidate-key"], function (require, exports, table_28, ExprLib, error_13, update_and_fetch_one_impl_4, unified_query_3, __1, update_and_fetch_one_by_candidate_key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally
     *
     * @todo Better name
     */
    async function __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate) {
        table_28.TableUtil.assertHasCandidateKey(table);
        /**
         * Prefer `primaryKey`
         */
        const candidateKeyColumnAliases = table.primaryKey != undefined ?
            table.primaryKey :
            table.candidateKeys[0];
        const curCandidateKeyOrError = await __1.ExecutionUtil
            .fetchOne(unified_query_3.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate)
            .select((columns) => candidateKeyColumnAliases.map(columnAlias => columns[columnAlias])), connection)
            .then((curCandidateKey) => {
            return curCandidateKey;
        }, (err) => {
            if (err instanceof error_13.RowNotFoundError) {
                return err;
            }
            else {
                throw err;
            }
        });
        if (curCandidateKeyOrError instanceof error_13.RowNotFoundError) {
            return {
                success: false,
                rowNotFoundError: curCandidateKeyOrError,
            };
        }
        else {
            return update_and_fetch_one_by_candidate_key_1.__updateAndFetchOneByCandidateKeyHelper(table, connection, curCandidateKeyOrError, assignmentMapDelegate);
        }
    }
    exports.__updateAndFetchOneHelper = __updateAndFetchOneHelper;
    async function updateAndFetchOne(table, connection, whereDelegate, assignmentMapDelegate) {
        return update_and_fetch_one_impl_4.updateAndFetchOneImpl(table, connection, async (connection) => {
            const helperResult = await __updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
            if (!helperResult.success) {
                throw helperResult.rowNotFoundError;
            }
            const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
            return {
                updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
                fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchOne = updateAndFetchOne;
});
define("execution/util/operation-update/update-zero-or-one", ["require", "exports", "type-mapping", "execution/util/operation-update/update", "error/index", "event/index", "isolation-level"], function (require, exports, tm, impl, error_14, event_16, isolation_level_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate) {
        /**
         * `READ_UNCOMMITTED` because this should be a simple `UPDATE` statement.
         * It should execute no other statements.
         */
        return connection.transactionIfNotInOne(isolation_level_6.IsolationLevel.READ_UNCOMMITTED, async (connection) => {
            return connection.savepoint(async (connection) => {
                const { whereClause, assignmentMap, updateResult, } = await impl.updateImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
                if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(0))) {
                    if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                        return {
                            whereClause,
                            assignmentMap,
                            updateResult: updateResult,
                        };
                    }
                    else {
                        //Should never happen...
                        throw new Error(`Expected to update zero rows of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                    }
                }
                if (tm.BigIntUtil.equal(updateResult.foundRowCount, tm.BigInt(1))) {
                    if (tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0)) ||
                        tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(1))) {
                        return {
                            whereClause,
                            assignmentMap,
                            updateResult: updateResult,
                        };
                    }
                    else {
                        //Should never happen...
                        throw new Error(`Expected to update zero or one row of ${table.alias}; updated ${updateResult.updatedRowCount}`);
                    }
                }
                throw new error_14.TooManyRowsFoundError({
                    message: `Expected to find one row of ${table.alias}; found ${updateResult.foundRowCount} rows`,
                    sql: updateResult.query.sql,
                });
            });
        });
    }
    exports.updateZeroOrOneImplNoEvent = updateZeroOrOneImplNoEvent;
    async function updateZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
        return connection.lock(async (connection) => {
            const { whereClause, assignmentMap, updateResult, } = await updateZeroOrOneImplNoEvent(table, connection, whereDelegate, assignmentMapDelegate);
            if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onUpdate.invoke(new event_16.UpdateEvent({
                        connection: fullConnection,
                        table,
                        whereClause,
                        assignmentMap,
                        updateResult,
                    }));
                }
            }
            return updateResult;
        });
    }
    exports.updateZeroOrOne = updateZeroOrOne;
});
define("execution/util/operation-update/update-and-fetch-zero-or-one-impl", ["require", "exports", "type-mapping", "table/index", "event/index", "execution/util/operation-update/update-zero-or-one", "isolation-level"], function (require, exports, tm, table_29, event_17, update_zero_or_one_1, isolation_level_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This should not be called directly by users.
     *
     * A lot can go wrong here...
     */
    async function updateAndFetchZeroOrOneImpl(table, connection, initCallback) {
        return connection.lock(async (connection) => {
            /**
             * `REPEATABLE_READ` should be fine because we're not creating any new rows.
             */
            const updateAndFetchResult = await connection.transactionIfNotInOne(isolation_level_7.IsolationLevel.REPEATABLE_READ, async (connection) => {
                return connection.savepoint(async (connection) => {
                    const initResult = await initCallback(connection);
                    if (!initResult.success) {
                        return {
                            success: false,
                            updateResult: {
                                query: {
                                    sql: initResult.rowNotFoundError.sql,
                                },
                                //Alias for affectedRows
                                foundRowCount: tm.BigInt(0),
                                //Alias for changedRows
                                updatedRowCount: tm.BigInt(0),
                                /**
                                 * May be the duplicate row count, or some other value.
                                 */
                                warningCount: tm.BigInt(0),
                                /**
                                 * An arbitrary message.
                                 * May be an empty string.
                                 */
                                message: "",
                                row: undefined,
                            },
                        };
                    }
                    const { updateWhereDelegate, fetchWhereDelegate, assignmentMap, } = initResult;
                    const { whereClause: updateWhereClause, updateResult: updateZeroOrOneResult, } = await update_zero_or_one_1.updateZeroOrOneImplNoEvent(table, connection, updateWhereDelegate, () => assignmentMap);
                    if (tm.BigIntUtil.equal(updateZeroOrOneResult.foundRowCount, tm.BigInt(0))) {
                        const notFoundUpdateResult = updateZeroOrOneResult;
                        return {
                            success: true,
                            updateWhereClause,
                            updateResult: {
                                ...notFoundUpdateResult,
                                row: undefined,
                            },
                            assignmentMap,
                        };
                    }
                    else {
                        const updateOneResult = updateZeroOrOneResult;
                        const row = await table_29.TableUtil.__fetchOneHelper(table, connection, fetchWhereDelegate);
                        return {
                            success: true,
                            updateWhereClause,
                            updateResult: {
                                ...updateOneResult,
                                row,
                            },
                            assignmentMap,
                        };
                    }
                });
            });
            if (!updateAndFetchResult.success) {
                return updateAndFetchResult.updateResult;
            }
            const { updateWhereClause, updateResult, assignmentMap, } = updateAndFetchResult;
            if (!tm.BigIntUtil.equal(updateResult.updatedRowCount, tm.BigInt(0))) {
                const fullConnection = connection.tryGetFullConnection();
                if (fullConnection != undefined) {
                    await fullConnection.eventEmitters.onUpdate.invoke(new event_17.UpdateEvent({
                        connection: fullConnection,
                        table,
                        whereClause: updateWhereClause,
                        assignmentMap,
                        updateResult,
                    }));
                    await fullConnection.eventEmitters.onUpdateAndFetch.invoke(new event_17.UpdateAndFetchEvent({
                        connection: fullConnection,
                        table,
                        assignmentMap,
                        updateResult: updateResult,
                    }));
                }
            }
            return updateResult;
        });
    }
    exports.updateAndFetchZeroOrOneImpl = updateAndFetchZeroOrOneImpl;
});
define("execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key", ["require", "exports", "expr-library/index", "execution/util/operation-update/update-and-fetch-one-by-candidate-key", "execution/util/operation-update/update-and-fetch-zero-or-one-impl"], function (require, exports, ExprLib, update_and_fetch_one_by_candidate_key_2, update_and_fetch_zero_or_one_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneByCandidateKey(table, connection, candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return update_and_fetch_zero_or_one_impl_1.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
            const helperResult = await update_and_fetch_one_by_candidate_key_2.__updateAndFetchOneByCandidateKeyHelper(table, connection, candidateKey, assignmentMapDelegate);
            if (!helperResult.success) {
                return helperResult;
            }
            const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
            return {
                success: true,
                updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
                fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
});
define("execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key", ["require", "exports", "expr-library/index", "execution/util/operation-update/update-and-fetch-one-by-primary-key", "execution/util/operation-update/update-and-fetch-zero-or-one-impl"], function (require, exports, ExprLib, update_and_fetch_one_by_primary_key_1, update_and_fetch_zero_or_one_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneByPrimaryKey(table, connection, primaryKey, assignmentMapDelegate) {
        return update_and_fetch_zero_or_one_impl_2.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
            const helperResult = await update_and_fetch_one_by_primary_key_1.__updateAndFetchOneByPrimaryKeyHelper(table, connection, primaryKey, assignmentMapDelegate);
            if (!helperResult.success) {
                return helperResult;
            }
            const { curPrimaryKey, assignmentMap, newPrimaryKey, } = helperResult;
            return {
                success: true,
                updateWhereDelegate: () => ExprLib.eqPrimaryKey(table, curPrimaryKey),
                fetchWhereDelegate: () => ExprLib.eqPrimaryKey(table, newPrimaryKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
});
define("execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key", ["require", "exports", "expr-library/index", "execution/util/operation-update/update-and-fetch-one-by-super-key", "execution/util/operation-update/update-and-fetch-zero-or-one-impl"], function (require, exports, ExprLib, update_and_fetch_one_by_super_key_1, update_and_fetch_zero_or_one_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneBySuperKey(table, connection, superKey, assignmentMapDelegate) {
        return update_and_fetch_zero_or_one_impl_3.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
            const helperResult = await update_and_fetch_one_by_super_key_1.__updateAndFetchOneBySuperKeyHelper(table, connection, superKey, assignmentMapDelegate);
            if (!helperResult.success) {
                return helperResult;
            }
            const { curSuperKey, assignmentMap, newSuperKey, } = helperResult;
            return {
                success: true,
                updateWhereDelegate: () => ExprLib.eqSuperKey(table, curSuperKey),
                fetchWhereDelegate: () => ExprLib.eqSuperKey(table, newSuperKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
});
define("execution/util/operation-update/update-and-fetch-zero-or-one", ["require", "exports", "expr-library/index", "execution/util/operation-update/update-and-fetch-zero-or-one-impl", "execution/util/operation-update/update-and-fetch-one"], function (require, exports, ExprLib, update_and_fetch_zero_or_one_impl_4, update_and_fetch_one_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOne(table, connection, whereDelegate, assignmentMapDelegate) {
        return update_and_fetch_zero_or_one_impl_4.updateAndFetchZeroOrOneImpl(table, connection, async (connection) => {
            const helperResult = await update_and_fetch_one_1.__updateAndFetchOneHelper(table, connection, whereDelegate, assignmentMapDelegate);
            if (!helperResult.success) {
                return helperResult;
            }
            const { curCandidateKey, assignmentMap, newCandidateKey, } = helperResult;
            return {
                success: true,
                updateWhereDelegate: () => ExprLib.eqCandidateKey(table, curCandidateKey),
                fetchWhereDelegate: () => ExprLib.eqCandidateKey(table, newCandidateKey),
                /**
                 * This cast is unsound.
                 * What we have is not `AssignmentMapT`.
                 *
                 * We have a `BuiltInExpr` version of `AssignmentMapT`,
                 * with some parts possibly being evaluated to a value expression.
                 *
                 * However, this will not affect the correctness of
                 * our results.
                 */
                assignmentMap: assignmentMap,
            };
        });
    }
    exports.updateAndFetchZeroOrOne = updateAndFetchZeroOrOne;
});
define("execution/util/operation-update/index", ["require", "exports", "execution/util/operation-update/update-and-fetch-one-by-candidate-key", "execution/util/operation-update/update-and-fetch-one-by-primary-key", "execution/util/operation-update/update-and-fetch-one-by-super-key", "execution/util/operation-update/update-and-fetch-one-impl", "execution/util/operation-update/update-and-fetch-one", "execution/util/operation-update/update-and-fetch-zero-or-one-by-candidate-key", "execution/util/operation-update/update-and-fetch-zero-or-one-by-primary-key", "execution/util/operation-update/update-and-fetch-zero-or-one-by-super-key", "execution/util/operation-update/update-and-fetch-zero-or-one-impl", "execution/util/operation-update/update-and-fetch-zero-or-one", "execution/util/operation-update/update-one", "execution/util/operation-update/update-zero-or-one", "execution/util/operation-update/update"], function (require, exports, update_and_fetch_one_by_candidate_key_3, update_and_fetch_one_by_primary_key_2, update_and_fetch_one_by_super_key_2, update_and_fetch_one_impl_5, update_and_fetch_one_2, update_and_fetch_zero_or_one_by_candidate_key_1, update_and_fetch_zero_or_one_by_primary_key_1, update_and_fetch_zero_or_one_by_super_key_1, update_and_fetch_zero_or_one_impl_5, update_and_fetch_zero_or_one_1, update_one_2, update_zero_or_one_2, update_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(update_and_fetch_one_by_candidate_key_3);
    __export(update_and_fetch_one_by_primary_key_2);
    __export(update_and_fetch_one_by_super_key_2);
    __export(update_and_fetch_one_impl_5);
    __export(update_and_fetch_one_2);
    __export(update_and_fetch_zero_or_one_by_candidate_key_1);
    __export(update_and_fetch_zero_or_one_by_primary_key_1);
    __export(update_and_fetch_zero_or_one_by_super_key_1);
    __export(update_and_fetch_zero_or_one_impl_5);
    __export(update_and_fetch_zero_or_one_1);
    __export(update_one_2);
    __export(update_zero_or_one_2);
    __export(update_2);
});
define("execution/util/index", ["require", "exports", "execution/util/operation/index", "execution/util/operation-delete/index", "execution/util/operation-insert/index", "execution/util/operation-insert-select/index", "execution/util/operation-update/index", "execution/util/predicate/index"], function (require, exports, operation_26, operation_delete_1, operation_insert_1, operation_insert_select_1, operation_update_1, predicate_42) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_26);
    __export(operation_delete_1);
    __export(operation_insert_1);
    __export(operation_insert_select_1);
    __export(operation_update_1);
    __export(predicate_42);
});
define("event/update-and-fetch-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UpdateAndFetchEvent extends event_base_6.EventBase {
        constructor(args) {
            super(args);
            this.table = args.table;
            this.assignmentMap = args.assignmentMap;
            this.updateResult = args.updateResult;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.UpdateAndFetchEvent = UpdateAndFetchEvent;
});
define("event/delete-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeleteEvent extends event_base_7.EventBase {
        constructor(args) {
            super(args);
            this.table = args.table;
            this.whereClause = args.whereClause;
            this.deleteResult = args.deleteResult;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.DeleteEvent = DeleteEvent;
});
define("event/replace-one-event", ["require", "exports", "type-mapping", "table/index", "candidate-key/index", "expr-library/index", "event/event-base"], function (require, exports, tm, table_30, candidate_key_5, ExprLib, event_base_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ReplaceOneEvent extends event_base_8.EventBase {
        constructor(args) {
            super(args);
            this.candidateKeyCache = "uninitialized";
            this.table = args.table;
            this.insertRow = args.insertRow;
            this.replaceResult = args.replaceResult;
        }
        get candidateKey() {
            if (this.candidateKeyCache == "uninitialized") {
                const candidateKeyResult = tm.tryMapHandled(candidate_key_5.CandidateKeyUtil.mapperPreferPrimaryKey(this.table), `${this.table.alias}.candidateKey`, this.insertRow);
                this.candidateKeyCache = candidateKeyResult.success ?
                    candidateKeyResult.value :
                    undefined;
            }
            return this.candidateKeyCache;
        }
        async getOrFetch() {
            if (this.fetchPromise == undefined) {
                const candidateKey = this.candidateKey;
                if (candidateKey == undefined) {
                    /**
                     * @todo Custom Error type
                     */
                    throw new Error(`Could not derive candidateKey from insertRow`);
                }
                this.fetchPromise = table_30.TableUtil.fetchOne(this.table, this.connection, () => ExprLib.eqCandidateKey(this.table, candidateKey));
            }
            return this.fetchPromise;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.ReplaceOneEvent = ReplaceOneEvent;
});
define("event/insert-select-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InsertSelectEvent extends event_base_9.EventBase {
        constructor(args) {
            super(args);
            this.query = args.query;
            this.table = args.table;
            this.insertSelectRow = args.insertSelectRow;
            this.insertResult = args.insertResult;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.InsertSelectEvent = InsertSelectEvent;
});
define("event/replace-select-event", ["require", "exports", "event/event-base"], function (require, exports, event_base_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ReplaceSelectEvent extends event_base_10.EventBase {
        constructor(args) {
            super(args);
            this.query = args.query;
            this.table = args.table;
            this.replaceSelectRow = args.replaceSelectRow;
            this.replaceResult = args.replaceResult;
        }
        isFor(table) {
            return this.table === table;
        }
    }
    exports.ReplaceSelectEvent = ReplaceSelectEvent;
});
define("event/connection-event-emitter-collection", ["require", "exports", "event/connection-event-emitter"], function (require, exports, connection_event_emitter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ConnectionEventEmitterCollection {
        constructor(pool) {
            /**
             * We want to avoid mutating arrays because it may mess up our loops.
             * We might add/remove events while invoking a handler.
             */
            this.transactionListenerCollections = [
                []
            ];
            this.addTransactionListenerCollectionImpl = (event) => {
                const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
                const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
                this.transactionListenerCollections = [
                    ...parentAndAncestors,
                    [
                        ...bottom,
                        event
                    ]
                ];
            };
            this.onInsert = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsert, this.addTransactionListenerCollectionImpl);
            this.onInsertOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertOne, this.addTransactionListenerCollectionImpl);
            this.onInsertAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertAndFetch, this.addTransactionListenerCollectionImpl);
            this.onInsertSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onInsertSelect, this.addTransactionListenerCollectionImpl);
            this.onReplace = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplace, this.addTransactionListenerCollectionImpl);
            this.onReplaceOne = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceOne, this.addTransactionListenerCollectionImpl);
            this.onReplaceSelect = new connection_event_emitter_1.ConnectionEventEmitter(pool.onReplaceSelect, this.addTransactionListenerCollectionImpl);
            this.onUpdate = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdate, this.addTransactionListenerCollectionImpl);
            this.onUpdateAndFetch = new connection_event_emitter_1.ConnectionEventEmitter(pool.onUpdateAndFetch, this.addTransactionListenerCollectionImpl);
            this.onDelete = new connection_event_emitter_1.ConnectionEventEmitter(pool.onDelete, this.addTransactionListenerCollectionImpl);
        }
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is created
         */
        savepoint() {
            this.transactionListenerCollections = [
                ...this.transactionListenerCollections,
                []
            ];
        }
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is released
         */
        releaseSavepoint() {
            if (this.transactionListenerCollections.length == 1) {
                throw new Error(`Cannot unnest top-level transaction listener collection`);
            }
            const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
            const parent = this.transactionListenerCollections[this.transactionListenerCollections.length - 2];
            const ancestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 2);
            this.transactionListenerCollections = [
                ...ancestors,
                [
                    ...parent,
                    ...bottom
                ]
            ];
        }
        /**
         * @todo Better name
         *
         * Used whenever a savepoint is rolled back
         */
        rollbackToSavepoint() {
            if (this.transactionListenerCollections.length == 1) {
                throw new Error(`Cannot unnest top-level transaction listener collection`);
            }
            const bottom = this.transactionListenerCollections[this.transactionListenerCollections.length - 1];
            const parentAndAncestors = this.transactionListenerCollections.slice(0, this.transactionListenerCollections.length - 1);
            this.transactionListenerCollections = parentAndAncestors;
            const syncErrors = [];
            for (const collection of bottom) {
                const invokeResult = collection.invokeOnRollbackListeners();
                syncErrors.push(...invokeResult.syncErrors);
            }
            return { syncErrors };
        }
        /**
         * This should not throw
         *
         * Used when a transaction is committed
         */
        commit() {
            const syncErrors = [];
            const scopes = this.transactionListenerCollections;
            this.transactionListenerCollections = [[]];
            for (const scope of scopes) {
                for (const collection of scope) {
                    const invokeResult = collection.invokeOnCommitListeners();
                    syncErrors.push(...invokeResult.syncErrors);
                }
            }
            return { syncErrors };
        }
        /**
         * This should not throw
         *
         * Used when a transaction is rolled back
         */
        rollback() {
            const syncErrors = [];
            const scopes = this.transactionListenerCollections;
            this.transactionListenerCollections = [[]];
            for (const scope of scopes) {
                for (const collection of scope) {
                    const invokeResult = collection.invokeOnRollbackListeners();
                    syncErrors.push(...invokeResult.syncErrors);
                }
            }
            return { syncErrors };
        }
    }
    exports.ConnectionEventEmitterCollection = ConnectionEventEmitterCollection;
});
define("event/index", ["require", "exports", "event/connection-event-emitter-collection", "event/connection-event-emitter", "event/delete-event", "event/event-base", "event/insert-and-fetch-event", "event/insert-event", "event/insert-one-event", "event/insert-select-event", "event/pool-event-emitter", "event/replace-event", "event/replace-one-event", "event/replace-select-event", "event/update-and-fetch-event", "event/update-event"], function (require, exports, connection_event_emitter_collection_1, connection_event_emitter_2, delete_event_1, event_base_11, insert_and_fetch_event_1, insert_event_1, insert_one_event_1, insert_select_event_1, pool_event_emitter_1, replace_event_1, replace_one_event_1, replace_select_event_1, update_and_fetch_event_1, update_event_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(connection_event_emitter_collection_1);
    __export(connection_event_emitter_2);
    __export(delete_event_1);
    __export(event_base_11);
    __export(insert_and_fetch_event_1);
    __export(insert_event_1);
    __export(insert_one_event_1);
    __export(insert_select_event_1);
    __export(pool_event_emitter_1);
    __export(replace_event_1);
    __export(replace_one_event_1);
    __export(replace_select_event_1);
    __export(update_and_fetch_event_1);
    __export(update_event_1);
});
define("execution/connection/component/delete", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("transaction-access-mode", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Transaction access modes ranked from least to most permissive,
     * 1. `READ_ONLY`
     * 2. `READ_WRITE`
     *
     * https://github.com/AnyhowStep/tsql/issues/14
     */
    var TransactionAccessMode;
    (function (TransactionAccessMode) {
        TransactionAccessMode["READ_ONLY"] = "READ_ONLY";
        TransactionAccessMode["READ_WRITE"] = "READ_WRITE";
    })(TransactionAccessMode = exports.TransactionAccessMode || (exports.TransactionAccessMode = {}));
    var TransactionAccessModeUtil;
    (function (TransactionAccessModeUtil) {
        const transactionAccessModePermissions = {
            [TransactionAccessMode.READ_ONLY]: 0,
            [TransactionAccessMode.READ_WRITE]: 1,
        };
        /**
         * Is transaction access mode `a` less permissive than `b`?
         */
        function isLessPermissiveThan(a, b) {
            return transactionAccessModePermissions[a] < transactionAccessModePermissions[b];
        }
        TransactionAccessModeUtil.isLessPermissiveThan = isLessPermissiveThan;
    })(TransactionAccessModeUtil = exports.TransactionAccessModeUtil || (exports.TransactionAccessModeUtil = {}));
});
define("execution/connection/component/in-transaction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-ignore-many", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-one", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-ignore-one", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-ignore-select", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-many", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/insert-select", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/is-deallocated", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/is-in-transaction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/lockable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/raw-query", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/isolable-connection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/read-only-transaction-if-not-in-one", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/read-only-transaction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/replace-many", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/replace-one", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/replace-select", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/savepoint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/select", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/transaction-if-not-in-one", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/transaction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/try-fetch-generated-column-expression", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-introspection/candidate-key-meta", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-introspection/column-meta", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-introspection/table-meta", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-introspection/schema-meta", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-introspection/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/try-fetch-schema-meta", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/try-get-full-connection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/update", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/component/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/pool/pool", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/pool/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/connection", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("execution/connection/index", ["require", "exports", "execution/connection/component/index"], function (require, exports, ConnectionComponent) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionComponent = ConnectionComponent;
});
define("execution/index", ["require", "exports", "execution/connection/index", "execution/util/index"], function (require, exports, connection_1, ExecutionUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(connection_1);
    exports.ExecutionUtil = ExecutionUtil;
});
define("table/util/execution/assert-exists", ["require", "exports", "unified-query/index"], function (require, exports, unified_query_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function assertExists(table, connection, whereDelegate) {
        return unified_query_4.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate)
            .assertExists(connection);
    }
    exports.assertExists = assertExists;
});
define("table/util/execution/exists", ["require", "exports", "unified-query/index"], function (require, exports, unified_query_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function exists(table, connection, whereDelegate) {
        return unified_query_5.QueryUtil.newInstance()
            .from(table)
            .where(whereDelegate)
            .exists(connection);
    }
    exports.exists = exists;
});
define("table/util/execution/fetch-one", ["require", "exports", "unified-query/index"], function (require, exports, unified_query_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOne(table, connection, whereDelegate, selectDelegate) {
        try {
            const query = unified_query_6.QueryUtil.newInstance()
                .from(table)
                .where(whereDelegate);
            if (selectDelegate == undefined) {
                return query
                    .select(((columns) => [columns]))
                    .fetchOne(connection);
            }
            else {
                return query
                    .select(selectDelegate)
                    .fetchOne(connection);
            }
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchOne = fetchOne;
    /**
     * Not meant to be invoked directly
     */
    function __fetchOneHelper(table, connection, whereDelegate, selectDelegate) {
        if (selectDelegate == undefined) {
            return fetchOne(table, connection, whereDelegate);
        }
        else {
            return fetchOne(table, connection, whereDelegate, selectDelegate);
        }
    }
    exports.__fetchOneHelper = __fetchOneHelper;
});
define("table/util/execution/fetch-value", ["require", "exports", "unified-query/index"], function (require, exports, unified_query_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchValue(table, connection, whereDelegate, selectValueDelegate) {
        try {
            return unified_query_7.QueryUtil.newInstance()
                .from(table)
                .where(whereDelegate)
                .selectValue(selectValueDelegate)
                .fetchValue(connection);
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchValue = fetchValue;
});
define("table/util/execution/index", ["require", "exports", "table/util/execution/assert-exists", "table/util/execution/exists", "table/util/execution/fetch-one", "table/util/execution/fetch-value"], function (require, exports, assert_exists_2, exists_2, fetch_one_2, fetch_value_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_exists_2);
    __export(exists_2);
    __export(fetch_one_2);
    __export(fetch_value_3);
});
define("table/util/query/column-alias", ["require", "exports", "column-map/index"], function (require, exports, column_map_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Pluralize this and others where relevant?
     * Be more consistent with pluralization.
     */
    function columnAlias(table) {
        return column_map_18.ColumnMapUtil.columnAlias(table.columns);
    }
    exports.columnAlias = columnAlias;
});
define("table/util/query/extract-candidate-keys-in-common", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/extract-candidate-keys-with-column-alias-in-table", ["require", "exports", "key/index"], function (require, exports, key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractCandidateKeysWithColumnAliasInTable(candidateKeysTable, columnAliasesTable) {
        const result = [];
        const columnAliases = Object.keys(columnAliasesTable.columns);
        for (const candidateKey of candidateKeysTable.candidateKeys) {
            if (key_1.KeyUtil.isSubKey(candidateKey, columnAliases)) {
                result.push(candidateKey);
            }
        }
        return result;
    }
    exports.extractCandidateKeysWithColumnAliasInTable = extractCandidateKeysWithColumnAliasInTable;
});
define("table/util/query/column-arrays-from-candidate-keys", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/column-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/explicit-auto-increment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isExplicitAutoIncrement(table, columnAlias) {
        if (table.explicitAutoIncrementValueEnabled) {
            return columnAlias === table.autoIncrement;
        }
        else {
            return false;
        }
    }
    exports.isExplicitAutoIncrement = isExplicitAutoIncrement;
    function isImplicitAutoIncrement(table, columnAlias) {
        if (!table.explicitAutoIncrementValueEnabled) {
            return columnAlias === table.autoIncrement;
        }
        else {
            return false;
        }
    }
    exports.isImplicitAutoIncrement = isImplicitAutoIncrement;
});
define("table/util/query/extract-candidate-keys-with-column-alias-in-one-of-column-array", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/extract-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/extract-with-generated-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/query/insertable-column-alias", ["require", "exports", "table/util/query/column-alias", "table/util/query/explicit-auto-increment"], function (require, exports, column_alias_2, explicit_auto_increment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isInsertableColumnAlias(table, columnAlias) {
        return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
            !table.generatedColumns.includes(columnAlias) &&
            !explicit_auto_increment_1.isImplicitAutoIncrement(table, columnAlias));
    }
    exports.isInsertableColumnAlias = isInsertableColumnAlias;
    function insertableColumnAlias(table) {
        return column_alias_2.columnAlias(table).filter((columnAlias) => (isInsertableColumnAlias(table, columnAlias)));
    }
    exports.insertableColumnAlias = insertableColumnAlias;
});
define("table/util/query/optional-column-alias", ["require", "exports", "table/util/query/column-alias", "table/util/query/explicit-auto-increment"], function (require, exports, column_alias_3, explicit_auto_increment_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isOptionalColumnAlias(table, columnAlias) {
        return (explicit_auto_increment_2.isExplicitAutoIncrement(table, columnAlias) ||
            ((table.nullableColumns.indexOf(columnAlias) >= 0 ||
                table.explicitDefaultValueColumns.indexOf(columnAlias) >= 0) &&
                table.generatedColumns.indexOf(columnAlias) < 0));
    }
    exports.isOptionalColumnAlias = isOptionalColumnAlias;
    function optionalColumnAlias(table) {
        return column_alias_3.columnAlias(table).filter((columnAlias) => (isOptionalColumnAlias(table, columnAlias)));
    }
    exports.optionalColumnAlias = optionalColumnAlias;
});
define("table/util/query/required-column-alias", ["require", "exports", "table/util/query/column-alias"], function (require, exports, column_alias_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isRequiredColumnAlias(table, columnAlias) {
        return (Object.prototype.hasOwnProperty.call(table.columns, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(table.columns, columnAlias) &&
            table.generatedColumns.indexOf(columnAlias) < 0 &&
            table.nullableColumns.indexOf(columnAlias) < 0 &&
            table.explicitDefaultValueColumns.indexOf(columnAlias) < 0 &&
            table.autoIncrement !== columnAlias);
    }
    exports.isRequiredColumnAlias = isRequiredColumnAlias;
    function requiredColumnAlias(table) {
        return column_alias_4.columnAlias(table).filter((columnAlias) => (isRequiredColumnAlias(table, columnAlias)));
    }
    exports.requiredColumnAlias = requiredColumnAlias;
});
define("table/util/query/try-get-schema-name", ["require", "exports", "ast/index"], function (require, exports, ast_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryGetSchemaName(table) {
        return ((ast_4.isIdentifierNode(table.unaliasedAst) &&
            table.unaliasedAst.identifiers.length == 2) ?
            table.unaliasedAst.identifiers[0] :
            undefined);
    }
    exports.tryGetSchemaName = tryGetSchemaName;
});
define("table/util/query/index", ["require", "exports", "table/util/query/column-alias", "table/util/query/explicit-auto-increment", "table/util/query/extract-candidate-keys-with-column-alias-in-table", "table/util/query/insertable-column-alias", "table/util/query/optional-column-alias", "table/util/query/required-column-alias", "table/util/query/try-get-schema-name"], function (require, exports, column_alias_5, explicit_auto_increment_3, extract_candidate_keys_with_column_alias_in_table_1, insertable_column_alias_1, optional_column_alias_1, required_column_alias_1, try_get_schema_name_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_alias_5);
    __export(explicit_auto_increment_3);
    __export(extract_candidate_keys_with_column_alias_in_table_1);
    __export(insertable_column_alias_1);
    __export(optional_column_alias_1);
    __export(required_column_alias_1);
    __export(try_get_schema_name_1);
});
define("table/util/operation/add-all-mutable", ["require", "exports", "table/table-impl", "column/index", "key/index", "table/util/query/index"], function (require, exports, table_impl_3, column_13, key_2, query_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Makes all non-generated columns, and non-implicit auto-increment mutable.
     *
     * + Mutable columns may be modified with `UPDATE` statements using this library.
     * + Immutable columns may not be modified with this library
     *   (but could still be modified outside of this library)
     *
     * @param table
     */
    function addAllMutable(table) {
        const mutableColumns = (key_2.KeyUtil.fromColumnArray(column_13.ColumnArrayUtil
            .fromColumnMap(table.columns)
            .filter(column => {
            return (!table.generatedColumns.includes(column.columnAlias) &&
                !query_31.isImplicitAutoIncrement(table, column.columnAlias));
        })));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_3.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.addAllMutable = addAllMutable;
});
define("table/util/predicate/assert-delete-enabled", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDeleteEnabled(table) {
        return table.deleteEnabled;
    }
    exports.isDeleteEnabled = isDeleteEnabled;
    function assertDeleteEnabled(table) {
        if (!isDeleteEnabled(table)) {
            throw new Error(`Cannot DELETE FROM/REPLACE INTO ${table.alias}`);
        }
    }
    exports.assertDeleteEnabled = assertDeleteEnabled;
});
define("table/util/predicate/assert-has-candidate-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertHasCandidateKey(table) {
        if (table.candidateKeys.length == 0) {
            throw new Error(`${table.alias} must have a candidate key`);
        }
    }
    exports.assertHasCandidateKey = assertHasCandidateKey;
});
define("table/util/predicate/assert-has-column-identifiers", ["require", "exports", "column-identifier-map/index"], function (require, exports, column_identifier_map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A run-time check mostly for JS-land users.
     *
     * Checks that the `table` contains all `columns` passed through,
     * using just the `tableAlias` and `columnAlias`.
     *
     * @param table
     * @param columns
     */
    function assertHasColumnIdentifiers(table, columns) {
        for (const column of columns) {
            column_identifier_map_1.ColumnIdentifierMapUtil.assertHasColumnIdentifier(table.columns, column);
        }
    }
    exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
});
define("table/util/predicate/has-null-safe-comparable-primary-key", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring PK columns and `columnMap` columns
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    function hasNullSafeComparablePrimaryKey(table, columnMap) {
        /**
         * Ideally, we'd want to have run-time checks
         * ensuring PK columns and `columnMap` columns
         * have null-safe comparable types.
         *
         * However, due to how the project is structured,
         * this is not possible.
         *
         * So, at the very least, we just check
         * the columns exist.
         */
        const myColumnAliases = Object.keys(table.columns);
        for (const pkColumnAlias of table.primaryKey) {
            if (!myColumnAliases.includes(pkColumnAlias)) {
                /**
                 * My column does not exist
                 */
                return false;
            }
        }
        const otherColumnAliases = Object.keys(columnMap);
        for (const pkColumnAlias of table.primaryKey) {
            if (!otherColumnAliases.includes(pkColumnAlias)) {
                /**
                 * Other column does not exist
                 */
                return false;
            }
        }
        return true;
    }
    exports.hasNullSafeComparablePrimaryKey = hasNullSafeComparablePrimaryKey;
});
define("table/util/predicate/assert-has-null-safe-comparable-primary-key", ["require", "exports", "column-map/index", "table/util/predicate/has-null-safe-comparable-primary-key"], function (require, exports, column_map_19, has_null_safe_comparable_primary_key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertHasNullSafeComparablePrimaryKey(table, columnMap) {
        if (!has_null_safe_comparable_primary_key_1.hasNullSafeComparablePrimaryKey(table, columnMap)) {
            const myTableAlias = column_map_19.ColumnMapUtil.tableAlias(table.columns);
            const myPrimaryKey = table.primaryKey.join(",");
            const otherTableAlias = column_map_19.ColumnMapUtil.tableAlias(columnMap);
            const otherColumnAliases = table.primaryKey
                .filter(pk => (Object.prototype.hasOwnProperty.call(columnMap, pk) &&
                Object.prototype.propertyIsEnumerable.call(columnMap, pk)))
                .join(",");
            throw new Error(`${myTableAlias} primary key (${myPrimaryKey}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
        }
    }
    exports.assertHasNullSafeComparablePrimaryKey = assertHasNullSafeComparablePrimaryKey;
});
define("table/util/predicate/assert-insert-enabled", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isInsertEnabled(table) {
        return table.insertEnabled;
    }
    exports.isInsertEnabled = isInsertEnabled;
    function assertInsertEnabled(table) {
        if (!isInsertEnabled(table)) {
            throw new Error(`Cannot INSERT INTO ${table.alias}`);
        }
    }
    exports.assertInsertEnabled = assertInsertEnabled;
});
define("table/util/predicate/has-explicit-default-value", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/predicate/is-nullable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/predicate/is-mutable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("table/util/predicate/is-table", ["require", "exports", "type-util/index"], function (require, exports, type_util_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Actually only checks if it has all the properties of `ITable`.
     *
     * So, if it has all the properties but they're of the wrong data type...
     */
    function isTable(mixed) {
        return type_util_8.isObjectWithOwnEnumerableKeys()(mixed, [
            "isLateral",
            "alias",
            "columns",
            "usedRef",
            "unaliasedAst",
            "autoIncrement",
            "id",
            "primaryKey",
            "candidateKeys",
            "insertEnabled",
            "deleteEnabled",
            "generatedColumns",
            "nullableColumns",
            "explicitDefaultValueColumns",
            "mutableColumns",
            "explicitAutoIncrementValueEnabled",
        ]);
    }
    exports.isTable = isTable;
});
define("table/util/predicate/index", ["require", "exports", "table/util/predicate/assert-delete-enabled", "table/util/predicate/assert-has-candidate-key", "table/util/predicate/assert-has-column-identifiers", "table/util/predicate/assert-has-null-safe-comparable-primary-key", "table/util/predicate/assert-insert-enabled", "table/util/predicate/has-null-safe-comparable-primary-key", "table/util/predicate/is-table"], function (require, exports, assert_delete_enabled_1, assert_has_candidate_key_1, assert_has_column_identifiers_1, assert_has_null_safe_comparable_primary_key_1, assert_insert_enabled_1, has_null_safe_comparable_primary_key_2, is_table_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_delete_enabled_1);
    __export(assert_has_candidate_key_1);
    __export(assert_has_column_identifiers_1);
    __export(assert_has_null_safe_comparable_primary_key_1);
    __export(assert_insert_enabled_1);
    __export(has_null_safe_comparable_primary_key_2);
    __export(is_table_1);
});
define("table/util/operation/add-candidate-key", ["require", "exports", "table/table-impl", "key/index", "table/util/predicate/index"], function (require, exports, table_impl_4, key_3, predicate_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNotEmptyKey(columns) {
        if (columns.length == 0) {
            throw new Error(`Key cannot be empty`);
        }
    }
    exports.assertNotEmptyKey = assertNotEmptyKey;
    function assertNotSubKey(table, columns) {
        const key = key_3.KeyUtil.fromColumnArray(columns);
        const superKeys = key_3.KeyArrayUtil.findSuperKeys(table.candidateKeys, key);
        if (superKeys.length > 0) {
            throw new Error(`${key.join("|")} is a sub key of ${superKeys[0].join("|")}`);
        }
    }
    exports.assertNotSubKey = assertNotSubKey;
    function assertNotSuperKey(table, columns) {
        const key = key_3.KeyUtil.fromColumnArray(columns);
        const subKeys = key_3.KeyArrayUtil.findSubKeys(table.candidateKeys, key);
        if (subKeys.length > 0) {
            throw new Error(`${key.join("|")} is a super key of ${subKeys[0].join("|")}`);
        }
    }
    exports.assertNotSuperKey = assertNotSuperKey;
    function assertValidCandidateKey(table, columns) {
        predicate_43.assertHasColumnIdentifiers(table, columns);
        assertNotEmptyKey(columns);
        assertNotSubKey(table, columns);
        assertNotSuperKey(table, columns);
    }
    exports.assertValidCandidateKey = assertValidCandidateKey;
    /**
     * Adds a candidate key to the table.
     *
     * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
     *
     * + A table may have zero-to-many candidate keys. (recommended to have at least one)
     * + A candidate key cannot be a subset of other candidate keys.
     * + A candidate key cannot be a superset of other candidate keys.
     * + A candidate key can intersect other candidate keys.
     * + A candidate key can be disjoint from other candidate keys.
     *
     * @param table
     * @param delegate
     */
    function addCandidateKey(table, delegate) {
        const newCandidateKey = delegate(table.columns);
        assertValidCandidateKey(table, newCandidateKey);
        const candidateKeys = key_3.KeyArrayUtil.append(table.candidateKeys, key_3.KeyUtil.fromColumnArray(newCandidateKey));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, 
        //candidateKeys,
        insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_4.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.addCandidateKey = addCandidateKey;
});
define("table/util/operation/add-columns-from-field-array", ["require", "exports", "table/table-impl", "column-map/index"], function (require, exports, table_impl_5, column_map_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts an array of fields to columns of the table
     *
     * @param table
     * @param fields
     *
     * @deprecated
     */
    function addColumnsFromFieldArray(table, fields) {
        //https://github.com/Microsoft/TypeScript/issues/28592
        const tableColumns = table.columns;
        //https://github.com/Microsoft/TypeScript/issues/28592
        const columnMapFromFieldArray = column_map_20.ColumnMapUtil.fromFieldArray(table.alias, fields);
        const columns = column_map_20.ColumnMapUtil.intersect(tableColumns, columnMapFromFieldArray);
        const nullableColumns = column_map_20.ColumnMapUtil.nullableColumnAliases(columns);
        const result = new table_impl_5.Table({
            /**
             * This fails,
             * ```ts
             * ...table
             * ```
             *
             * This fails,
             * ```ts
             * ...(table as ITable)
             * ```
             *
             * This succeeds,
             * ```ts
             * ...(table as TableData)
             * ```
             *
             * @todo Investigate and possibly file issue
             */
            ...table,
            columns,
            nullableColumns,
        }, table.unaliasedAst);
        return result;
    }
    exports.addColumnsFromFieldArray = addColumnsFromFieldArray;
});
define("mapper-map/mapper-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("mapper-map/util/query/nullable-key", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function nullableKeys(map) {
        const columnAliases = Object.keys(map);
        return columnAliases.filter(columnAlias => tm.canOutputNull(map[columnAlias]));
    }
    exports.nullableKeys = nullableKeys;
});
define("mapper-map/util/query/index", ["require", "exports", "mapper-map/util/query/nullable-key"], function (require, exports, nullable_key_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(nullable_key_1);
});
define("mapper-map/util/index", ["require", "exports", "mapper-map/util/query/index"], function (require, exports, query_32) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(query_32);
});
define("mapper-map/index", ["require", "exports", "mapper-map/util/index"], function (require, exports, MapperMapUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapperMapUtil = MapperMapUtil;
});
define("table/util/operation/add-columns-from-mapper-map", ["require", "exports", "table/table-impl", "column-map/index"], function (require, exports, table_impl_6, column_map_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts a map of `columnAlias -> mapper` to columns of the table
     *
     * @param table
     * @param mapperMap
     */
    function addColumnsFromMapperMap(table, mapperMap) {
        //https://github.com/Microsoft/TypeScript/issues/28592
        const tableColumns = table.columns;
        const columns = column_map_21.ColumnMapUtil.intersect(tableColumns, column_map_21.ColumnMapUtil.fromMapperMap(table.alias, mapperMap));
        const nullableColumns = column_map_21.ColumnMapUtil.nullableColumnAliases(columns);
        const result = new table_impl_6.Table({
            ...table,
            columns,
            nullableColumns,
        }, table.unaliasedAst);
        return result;
    }
    exports.addColumnsFromMapperMap = addColumnsFromMapperMap;
});
define("table/util/operation/add-columns", ["require", "exports", "table/util/operation/add-columns-from-field-array", "table/util/operation/add-columns-from-mapper-map"], function (require, exports, add_columns_from_field_array_1, add_columns_from_mapper_map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addColumns(table, rawColumns) {
        if (Array.isArray(rawColumns)) {
            return add_columns_from_field_array_1.addColumnsFromFieldArray(table, rawColumns);
        }
        else {
            return add_columns_from_mapper_map_1.addColumnsFromMapperMap(table, rawColumns);
        }
    }
    exports.addColumns = addColumns;
});
define("table/util/operation/add-explicit-default-value", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index"], function (require, exports, table_impl_7, column_14, key_4, type_util_9, column_identifier_map_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addExplicitDefaultValueColumnMap(table) {
        const result = type_util_9.pickOwnEnumerable(table.columns, column_14.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (!table.generatedColumns.includes(column.columnAlias) &&
                //!table.nullableColumns.includes(column.columnAlias) &&
                (table.autoIncrement != column.columnAlias) &&
                !table.explicitDefaultValueColumns.includes(column.columnAlias));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.addExplicitDefaultValueColumnMap = addExplicitDefaultValueColumnMap;
    /**
     * Tells the library that these columns have explicit `DEFAULT` values.
     *
     * An example of an "explicit" default value,
     * ```sql
     * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
     * ```
     *
     * + Columns with server default values are optional with `INSERT` statements.
     * + Generated columns have implicit default values.
     * + Nullable columns have implicit default values.
     * + `AUTO_INCREMENT` columns have implicit default values
     *
     * -----
     *
     * @param table
     * @param delegate
     */
    function addExplicitDefaultValue(table, delegate) {
        const columnMap = addExplicitDefaultValueColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_2.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const explicitDefaultValueColumns = key_4.KeyUtil.concat(table.explicitDefaultValueColumns, key_4.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
        //explicitDefaultValueColumns,
        mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_7.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.addExplicitDefaultValue = addExplicitDefaultValue;
});
define("table/util/operation/add-generated", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index"], function (require, exports, table_impl_8, column_15, key_5, type_util_10, column_identifier_map_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addGeneratedColumnMap(table) {
        const result = type_util_10.pickOwnEnumerable(table.columns, column_15.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (!table.generatedColumns.includes(column.columnAlias) &&
                column.columnAlias != table.autoIncrement);
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.addGeneratedColumnMap = addGeneratedColumnMap;
    /**
     * Adds a `GENERATED` column to the table.
     *
     * + Setting generated column values will not be allowed with `INSERT` statements.
     * + Updating generated column values will also not be allowed with `UPDATE` statements.
     *
     * @param table
     * @param delegate
     */
    function addGenerated(table, delegate) {
        const columnMap = addGeneratedColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_3.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const generatedColumns = key_5.KeyUtil.concat(table.generatedColumns, key_5.KeyUtil.fromColumnArray(columnsT));
        const explicitDefaultValueColumns = key_5.KeyUtil.subtract(table.explicitDefaultValueColumns, key_5.KeyUtil.fromColumnArray(columnsT));
        const mutableColumns = key_5.KeyUtil.subtract(table.mutableColumns, key_5.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
        //generatedColumns,
        nullableColumns, 
        //explicitDefaultValueColumns,
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_8.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.addGenerated = addGenerated;
});
define("table/util/operation/add-mutable", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index", "table/util/query/index"], function (require, exports, table_impl_9, column_16, key_6, type_util_11, column_identifier_map_4, query_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addMutableColumnMap(table) {
        const result = type_util_11.pickOwnEnumerable(table.columns, column_16.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (!table.generatedColumns.includes(column.columnAlias) &&
                !table.mutableColumns.includes(column.columnAlias) &&
                !query_33.isImplicitAutoIncrement(table, column.columnAlias));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.addMutableColumnMap = addMutableColumnMap;
    /**
     * Lets these columns be updated through this library.
     *
     * @param table
     * @param delegate
     */
    function addMutable(table, delegate) {
        const columnMap = addMutableColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_4.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const mutableColumns = key_6.KeyUtil.concat(table.mutableColumns, key_6.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_9.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.addMutable = addMutable;
});
define("table/util/operation/as", ["require", "exports", "column-map/index", "table/table-impl"], function (require, exports, column_map_22, table_impl_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Aliases a table reference in a query.
     *
     * ```sql
     *  SELECT
     *      *
     *  FROM
     *      myTable AS aliasedTable
     * ```
     */
    function as(table, newTableAlias) {
        const { isLateral, 
        //alias,
        columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_10.Table({
            isLateral,
            alias: newTableAlias,
            columns: column_map_22.ColumnMapUtil.withTableAlias(columns, newTableAlias),
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.as = as;
});
define("table/util/operation/disable-delete", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Prevents rows of this table from being deleted through this library.
     *
     * Good for look-up tables, or append-only tables.
     *
     * @param table
     */
    function disableDelete(table) {
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, 
        //deleteEnabled,
        generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_11.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled: false,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.disableDelete = disableDelete;
});
define("table/util/operation/disable-insert", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Prevents rows from being inserted through this library.
     *
     * Good for look-up tables.
     *
     * @param table
     */
    function disableInsert(table) {
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
        //insertEnabled,
        deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_12.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled: false,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.disableInsert = disableInsert;
});
define("table/util/operation/enable-explicit-auto-increment-value", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Allows explicit values for auto-increment columns.
     */
    function enableExplicitAutoIncrementValue(table) {
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, } = table;
        const result = new table_impl_13.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled: true,
        }, table.unaliasedAst);
        return result;
    }
    exports.enableExplicitAutoIncrementValue = enableExplicitAutoIncrementValue;
});
define("table/util/operation/enable-insert", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function enableInsert(table) {
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, 
        //insertEnabled,
        deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_14.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled: true,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.enableInsert = enableInsert;
});
define("table/util/operation/pick-columns", ["require", "exports", "aliased-table/index", "type-util/index"], function (require, exports, aliased_table_4, type_util_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function pickColumns(table, delegate) {
        const newColumns = delegate(table.columns);
        const { isLateral, alias, columns, usedRef, } = table;
        const result = new aliased_table_4.AliasedTable({
            isLateral,
            alias,
            columns: type_util_12.pickOwnEnumerable(columns, newColumns.map(column => column.columnAlias)),
            usedRef,
        }, table.unaliasedAst);
        return result;
    }
    exports.pickColumns = pickColumns;
});
define("table/util/operation/remove-all-mutable", ["require", "exports", "table/table-impl"], function (require, exports, table_impl_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Makes all columns immutable.
     *
     * @param table
     */
    function removeAllMutable(table) {
        const mutableColumns = [];
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_15.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.removeAllMutable = removeAllMutable;
});
define("table/util/operation/remove-explicit-default-value", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index"], function (require, exports, table_impl_16, column_17, key_7, type_util_13, column_identifier_map_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeExplicitDefaultValueColumnMap(table) {
        const result = type_util_13.pickOwnEnumerable(table.columns, column_17.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (table.explicitDefaultValueColumns.includes(column.columnAlias));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.removeExplicitDefaultValueColumnMap = removeExplicitDefaultValueColumnMap;
    /**
     * Removes columns from the set of columns with explicit `DEFAULT` values
     *
     * @param table
     * @param delegate
     */
    function removeExplicitDefaultValue(table, delegate) {
        const columnMap = removeExplicitDefaultValueColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_5.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const explicitDefaultValueColumns = key_7.KeyUtil.subtract(table.explicitDefaultValueColumns, key_7.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, 
        //explicitDefaultValueColumns,
        mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_16.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.removeExplicitDefaultValue = removeExplicitDefaultValue;
});
define("table/util/operation/remove-generated", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index"], function (require, exports, table_impl_17, column_18, key_8, type_util_14, column_identifier_map_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeGeneratedColumnMap(table) {
        const result = type_util_14.pickOwnEnumerable(table.columns, column_18.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (table.generatedColumns.includes(column.columnAlias));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.removeGeneratedColumnMap = removeGeneratedColumnMap;
    /**
     * Removes columns from the set of `GENERATED` columns.
     *
     * @param table
     * @param delegate
     */
    function removeGenerated(table, delegate) {
        const columnMap = removeGeneratedColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_6.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const generatedColumns = key_8.KeyUtil.subtract(table.generatedColumns, key_8.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, 
        //generatedColumns,
        nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_17.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.removeGenerated = removeGenerated;
});
define("table/util/operation/remove-mutable", ["require", "exports", "table/table-impl", "column/index", "key/index", "type-util/index", "column-identifier-map/index"], function (require, exports, table_impl_18, column_19, key_9, type_util_15, column_identifier_map_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeMutableColumnMap(table) {
        const result = type_util_15.pickOwnEnumerable(table.columns, column_19.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (table.mutableColumns.includes(column.columnAlias));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.removeMutableColumnMap = removeMutableColumnMap;
    /**
     * Removes columns from the set of mutable columns.
     *
     * You will not be able to update them through this library.
     *
     * @param table
     * @param delegate
     */
    function removeMutable(table, delegate) {
        const columnMap = removeMutableColumnMap(table);
        const columnsT = delegate(columnMap);
        column_identifier_map_7.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columnMap, columnsT);
        const mutableColumns = key_9.KeyUtil.subtract(table.mutableColumns, key_9.KeyUtil.fromColumnArray(columnsT));
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, 
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_18.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.removeMutable = removeMutable;
});
define("table/util/operation/set-primary-key", ["require", "exports", "type-mapping", "table/table-impl", "column/index", "table/util/operation/add-candidate-key", "key/index", "type-util/index"], function (require, exports, tm, table_impl_19, column_20, add_candidate_key_1, key_10, type_util_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setPrimaryKeyColumnMap(table) {
        const result = type_util_16.pickOwnEnumerable(table.columns, column_20.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => !tm.canOutputNull(column.mapper))
            .map(column => column.columnAlias));
        return result;
    }
    exports.setPrimaryKeyColumnMap = setPrimaryKeyColumnMap;
    function assertValidPrimaryKey(table, columns) {
        //An extra run-time check, just to be safe...
        //For all the JS-land users
        for (const column of columns) {
            if (tm.canOutputNull(column.mapper)) {
                throw new Error(`${column.tableAlias}.${column.columnAlias} cannot be part of a PRIMARY KEY; it is nullable`);
            }
        }
        add_candidate_key_1.assertValidCandidateKey(table, columns);
    }
    exports.assertValidPrimaryKey = assertValidPrimaryKey;
    /**
     * Sets the `PRIMARY KEY` of the table.
     *
     * In MySQL, a `PRIMARY KEY` is just a candidate key
     * where all its columns are non-nullable.
     *
     * -----
     *
     * + `PRIMARY KEY` columns cannot be nullable
     * + `PRIMARY KEY` columns must be a candidate key
     */
    function setPrimaryKey(table, delegate) {
        const newPrimaryKey = delegate(setPrimaryKeyColumnMap(table));
        assertValidPrimaryKey(table, newPrimaryKey);
        const primaryKey = (key_10.KeyUtil.fromColumnArray(newPrimaryKey));
        const candidateKeys = key_10.KeyArrayUtil.append(table.candidateKeys, primaryKey);
        const { isLateral, alias, columns, usedRef, autoIncrement, id, 
        //primaryKey,
        //candidateKeys,
        insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_19.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.setPrimaryKey = setPrimaryKey;
});
define("table/util/operation/set-auto-increment", ["require", "exports", "type-mapping", "table/table-impl", "column/index", "key/index", "type-util/index", "table/util/operation/set-primary-key", "column-identifier-map/index"], function (require, exports, tm, table_impl_20, column_21, key_11, type_util_17, set_primary_key_1, column_identifier_map_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setAutoIncrementColumnMap(table) {
        const result = type_util_17.pickOwnEnumerable(table.columns, column_21.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (!tm.canOutputNull(column.mapper) &&
                !key_11.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.setAutoIncrementColumnMap = setAutoIncrementColumnMap;
    function assertValidAutoIncrement(table, autoIncrement) {
        const columnMap = setAutoIncrementColumnMap(table);
        column_identifier_map_8.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, autoIncrement);
        set_primary_key_1.assertValidPrimaryKey(table, [autoIncrement]);
    }
    exports.assertValidAutoIncrement = assertValidAutoIncrement;
    /**
     * Designates one column as the `AUTO_INCREMENT` column.
     *
     * -----
     *
     * + `AUTO_INCREMENT` columns cannot be nullable
     * + `AUTO_INCREMENT` columns must be a candidate key
     * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
     * + The `number|string|bigint` requirement is only a compile-time constraint
     *
     * @todo Consider having run-time checks to see if it allows 1,2,3,4,5,... ?
     */
    function setAutoIncrement(table, delegate) {
        const newAutoIncrement = delegate(setAutoIncrementColumnMap(table));
        assertValidAutoIncrement(table, newAutoIncrement);
        const primaryKey = (key_11.KeyUtil.fromColumn(newAutoIncrement));
        const candidateKeys = key_11.KeyArrayUtil.append(table.candidateKeys, primaryKey);
        const generatedColumns = key_11.KeyUtil.remove(table.generatedColumns, newAutoIncrement.columnAlias);
        const explicitDefaultValueColumns = key_11.KeyUtil.remove(table.explicitDefaultValueColumns, newAutoIncrement.columnAlias);
        const mutableColumns = key_11.KeyUtil.remove(table.mutableColumns, newAutoIncrement.columnAlias);
        const { isLateral, alias, columns, usedRef, 
        //autoIncrement,
        //id,
        //primaryKey,
        //candidateKeys,
        insertEnabled, deleteEnabled, 
        //generatedColumns,
        nullableColumns, 
        //explicitDefaultValueColumns,
        //mutableColumns,
        explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_20.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement: newAutoIncrement.columnAlias,
            id: newAutoIncrement.columnAlias,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.setAutoIncrement = setAutoIncrement;
});
define("table/util/operation/set-id", ["require", "exports", "type-mapping", "table/table-impl", "column/index", "key/index", "table/util/operation/set-primary-key", "type-util/index", "column-identifier-map/index"], function (require, exports, tm, table_impl_21, column_22, key_12, set_primary_key_2, type_util_18, column_identifier_map_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setIdColumnMap(table) {
        const result = type_util_18.pickOwnEnumerable(table.columns, column_22.ColumnArrayUtil.fromColumnMap(table.columns)
            .filter(column => {
            return (!tm.canOutputNull(column.mapper) &&
                !key_12.KeyArrayUtil.hasSuperKey(table.candidateKeys, [column.columnAlias]));
        })
            .map(column => column.columnAlias));
        return result;
    }
    exports.setIdColumnMap = setIdColumnMap;
    function assertValidId(table, id) {
        const columnMap = setIdColumnMap(table);
        column_identifier_map_9.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columnMap, id);
        set_primary_key_2.assertValidPrimaryKey(table, [id]);
    }
    exports.assertValidId = assertValidId;
    /**
     * Sets a column as the single-column identifier for this table.
     *
     * -----
     *
     * + `id-column`s cannot be nullable
     * + `id-column`s must be a candidate key
     * + `id-column`s must be a `PRIMARY KEY`
     *
     */
    function setId(table, delegate) {
        const newId = delegate(setIdColumnMap(table));
        assertValidId(table, newId);
        const primaryKey = (key_12.KeyUtil.fromColumn(newId));
        const candidateKeys = key_12.KeyArrayUtil.append(table.candidateKeys, primaryKey);
        const { isLateral, alias, columns, usedRef, autoIncrement, 
        //id,
        //primaryKey,
        //candidateKeys,
        insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        const result = new table_impl_21.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id: newId.columnAlias,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, table.unaliasedAst);
        return result;
    }
    exports.setId = setId;
});
define("table/util/operation/set-schema-name", ["require", "exports", "table/table-impl", "ast/index"], function (require, exports, table_impl_22, ast_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sets the `schema` that this table belongs to.
     *
     * This is usually not required because the schema used
     * will be the one your database connection session is using.
     *
     * -----
     *
     * This library does not support cross-schema compile-time safe queries.
     *
     * However, if you **do** need cross-schema support,
     * this library can support it somewhat.
     *
     * -----
     *
     * @param table
     * @param newSchemaName
     */
    function setSchemaName(table, newSchemaName) {
        const { isLateral, alias, columns, usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        return new table_impl_22.Table({
            isLateral,
            alias,
            columns,
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, (ast_5.isIdentifierNode(table.unaliasedAst) ?
            ast_5.identifierNode(newSchemaName, 
            //The table alias on the database
            table.unaliasedAst.identifiers[table.unaliasedAst.identifiers.length - 1]) :
            ast_5.identifierNode(newSchemaName, alias)));
    }
    exports.setSchemaName = setSchemaName;
});
define("table/util/operation/set-table-alias", ["require", "exports", "table/table-impl", "column-map/index", "ast/index"], function (require, exports, table_impl_23, column_map_23, ast_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Changes the alias of the table.
     *
     * Useful if you have multiple tables with exactly the same structure.
     *
     * This is different from `.as()`!
     *
     * -----
     *
     * You will have to call `.setSchemaName()` again if you called it before.
     *
     * @param table
     * @param newTableAlias
     */
    function setTableAlias(table, newTableAlias) {
        //https://github.com/Microsoft/TypeScript/issues/28592
        const columns = table.columns;
        const { isLateral, 
        //tableAlias,
        //columns,
        usedRef, autoIncrement, id, primaryKey, candidateKeys, insertEnabled, deleteEnabled, generatedColumns, nullableColumns, explicitDefaultValueColumns, mutableColumns, explicitAutoIncrementValueEnabled, } = table;
        return new table_impl_23.Table({
            isLateral,
            alias: newTableAlias,
            columns: column_map_23.ColumnMapUtil.withTableAlias(columns, newTableAlias),
            usedRef,
            autoIncrement,
            id,
            primaryKey,
            candidateKeys,
            insertEnabled,
            deleteEnabled,
            generatedColumns,
            nullableColumns,
            explicitDefaultValueColumns,
            mutableColumns,
            explicitAutoIncrementValueEnabled,
        }, ((ast_6.isIdentifierNode(table.unaliasedAst) &&
            table.unaliasedAst.identifiers.length == 2) ?
            ast_6.identifierNode(
            //The `schemaName`
            table.unaliasedAst.identifiers[0], newTableAlias) :
            ast_6.identifierNode(newTableAlias)));
    }
    exports.setTableAlias = setTableAlias;
});
define("table/util/operation/index", ["require", "exports", "table/util/operation/add-all-mutable", "table/util/operation/add-candidate-key", "table/util/operation/add-columns-from-field-array", "table/util/operation/add-columns-from-mapper-map", "table/util/operation/add-columns", "table/util/operation/add-explicit-default-value", "table/util/operation/add-generated", "table/util/operation/add-mutable", "table/util/operation/as", "table/util/operation/disable-delete", "table/util/operation/disable-insert", "table/util/operation/enable-explicit-auto-increment-value", "table/util/operation/enable-insert", "table/util/operation/pick-columns", "table/util/operation/remove-all-mutable", "table/util/operation/remove-explicit-default-value", "table/util/operation/remove-generated", "table/util/operation/remove-mutable", "table/util/operation/set-auto-increment", "table/util/operation/set-id", "table/util/operation/set-primary-key", "table/util/operation/set-schema-name", "table/util/operation/set-table-alias"], function (require, exports, add_all_mutable_1, add_candidate_key_2, add_columns_from_field_array_2, add_columns_from_mapper_map_2, add_columns_1, add_explicit_default_value_1, add_generated_1, add_mutable_1, as_2, disable_delete_1, disable_insert_1, enable_explicit_auto_increment_value_1, enable_insert_1, pick_columns_1, remove_all_mutable_1, remove_explicit_default_value_1, remove_generated_1, remove_mutable_1, set_auto_increment_1, set_id_1, set_primary_key_3, set_schema_name_1, set_table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(add_all_mutable_1);
    __export(add_candidate_key_2);
    __export(add_columns_from_field_array_2);
    __export(add_columns_from_mapper_map_2);
    __export(add_columns_1);
    __export(add_explicit_default_value_1);
    __export(add_generated_1);
    __export(add_mutable_1);
    __export(as_2);
    __export(disable_delete_1);
    __export(disable_insert_1);
    __export(enable_explicit_auto_increment_value_1);
    __export(enable_insert_1);
    __export(pick_columns_1);
    __export(remove_all_mutable_1);
    __export(remove_explicit_default_value_1);
    __export(remove_generated_1);
    __export(remove_mutable_1);
    __export(set_auto_increment_1);
    __export(set_id_1);
    __export(set_primary_key_3);
    __export(set_schema_name_1);
    __export(set_table_alias_1);
});
define("table/util/index", ["require", "exports", "table/util/constructor/index", "table/util/execution/index", "table/util/operation/index", "table/util/predicate/index", "table/util/query/index"], function (require, exports, constructor_10, execution_3, operation_27, predicate_44, query_34) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_10);
    __export(execution_3);
    __export(operation_27);
    __export(predicate_44);
    __export(query_34);
});
define("table-where/table-where", ["require", "exports", "execution/index", "table/index", "expr-library/index"], function (require, exports, execution_4, table_31, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Implement something like `TableWhereOrderBy`?
     *
     * `.fetchAll()` is not provided here
     * because "proper" usage would minimally require,
     * + `ORDER BY` clause - For deterministic ordering
     * + `LIMIT` clause - To prevent accidental OOMs
     *
     * `.paginate()`, `.emulatedCursor()` are not provided here
     * because "proper" usage of them would minimally require,
     * + `ORDER BY` clause - For deterministic ordering
     *
     */
    /**
     * @todo Better name
     * This is basically a `table` + `WHERE` clause.
     */
    class TableWhere {
        constructor(table, whereDelegate) {
            this.table = table;
            this.whereDelegate = whereDelegate;
        }
        where(whereDelegate) {
            return new TableWhere(this.table, (columns) => {
                return ExprLib.and(this.whereDelegate(columns), whereDelegate(columns));
            });
        }
        assertExists(connection) {
            return table_31.TableUtil.assertExists(this.table, connection, this.whereDelegate);
        }
        exists(connection) {
            return table_31.TableUtil.exists(this.table, connection, this.whereDelegate);
        }
        fetchOne(connection, selectDelegate) {
            return table_31.TableUtil.__fetchOneHelper(this.table, connection, this.whereDelegate, selectDelegate);
        }
        fetchValue(connection, selectValueDelegate) {
            return table_31.TableUtil.fetchValue(this.table, connection, this.whereDelegate, selectValueDelegate);
        }
        delete(connection) {
            return execution_4.ExecutionUtil.delete(this.table, connection, this.whereDelegate);
        }
        deleteOne(connection) {
            return execution_4.ExecutionUtil.deleteOne(this.table, connection, this.whereDelegate);
        }
        deleteZeroOrOne(connection) {
            return execution_4.ExecutionUtil.deleteZeroOrOne(this.table, connection, this.whereDelegate);
        }
        update(connection, assignmentMapDelegate) {
            return execution_4.ExecutionUtil.update(this.table, connection, this.whereDelegate, assignmentMapDelegate);
        }
        updateOne(connection, assignmentMapDelegate) {
            return execution_4.ExecutionUtil.updateOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
        }
        updateZeroOrOne(connection, assignmentMapDelegate) {
            return execution_4.ExecutionUtil.updateZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
        }
        /**
         * The `table` must have at least one `candidateKey` to use this method.
         *
         * Internally,
         * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
         * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
         *    (if the candidate key will not be updated, this step is skipped)
         * 3. Run the `UPDATE` statement.
         * 4. Fetch the row using the new candidate key.
         *
         * This algorithm will probably fail if you have triggers that modify the candidate key
         * `ON UPDATE`.
         */
        updateAndFetchOne(connection, assignmentMapDelegate) {
            return execution_4.ExecutionUtil.updateAndFetchOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
        }
        /**
         * The `table` must have at least one `candidateKey` to use this method.
         *
         * Internally,
         * 1. Fetch the candidate key of the row specified by the `WHERE` clause.
         * 2. Calculate what the new candidate key will be after the `UPDATE` statement is run.
         *    (if the candidate key will not be updated, this step is skipped)
         * 3. Run the `UPDATE` statement.
         * 4. Fetch the row using the new candidate key (if any were found during the `UPDATE`)
         *
         * This algorithm will probably fail if you have triggers that modify the candidate key
         * `ON UPDATE`.
         */
        updateAndFetchZeroOrOne(connection, assignmentMapDelegate) {
            return execution_4.ExecutionUtil.updateAndFetchZeroOrOne(this.table, connection, this.whereDelegate, assignmentMapDelegate);
        }
    }
    exports.TableWhere = TableWhere;
});
define("table-where/index", ["require", "exports", "table-where/table-where"], function (require, exports, table_where_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(table_where_1);
});
define("table/table-impl", ["require", "exports", "table/util/index", "execution/index", "expr-library/index", "table-where/index"], function (require, exports, TableUtil, execution_5, ExprLib, table_where_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Table {
        /**
         * You should never need to explicitly instantiate a `Table`.
         * Use `table()` instead.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data, unaliasedAst) {
            this.isLateral = data.isLateral;
            this.alias = data.alias;
            this.columns = data.columns;
            this.usedRef = data.usedRef;
            this.unaliasedAst = unaliasedAst;
            this.insertEnabled = data.insertEnabled;
            this.deleteEnabled = data.deleteEnabled;
            this.autoIncrement = data.autoIncrement;
            this.id = data.id;
            this.primaryKey = data.primaryKey;
            this.candidateKeys = data.candidateKeys;
            this.generatedColumns = data.generatedColumns;
            this.nullableColumns = data.nullableColumns;
            this.explicitDefaultValueColumns = data.explicitDefaultValueColumns;
            this.mutableColumns = data.mutableColumns;
            this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
        }
        /**
         * Makes all non-generated columns mutable.
         *
         * + Mutable columns may be modified with `UPDATE` statements using this library.
         * + Immutable columns may not be modified with this library
         *   (but could still be modified outside of this library)
         */
        addAllMutable() {
            return TableUtil.addAllMutable(this);
        }
        /**
         * Adds a candidate key to the table.
         *
         * A candidate key is a minimal set of columns that uniquely identifies a row in a table.
         *
         * + A table may have zero-to-many candidate keys. (recommended to have at least one)
         * + A candidate key cannot be a subset of other candidate keys.
         * + A candidate key cannot be a superset of other candidate keys.
         * + A candidate key can intersect other candidate keys.
         * + A candidate key can be disjoint from other candidate keys.
         */
        addCandidateKey(delegate) {
            return TableUtil.addCandidateKey(this, delegate);
        }
        addColumns(rawColumns) {
            return TableUtil.addColumns(this, rawColumns);
        }
        /**
         * Tells the library that these columns have explicit `DEFAULT` values.
         *
         * An example of an "explicit" default value,
         * ```sql
         * `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
         * ```
         *
         * + Columns with server default values are optional with `INSERT` statements.
         * + Generated columns have implicit default values.
         * + Nullable columns have implicit default values.
         * + `AUTO_INCREMENT` columns have implicit default values
         */
        addExplicitDefaultValue(delegate) {
            return TableUtil.addExplicitDefaultValue(this, delegate);
        }
        /**
         * Adds a `GENERATED` column to the table.
         *
         * + Setting generated column values will not be allowed with `INSERT` statements.
         * + Updating generated column values will also not be allowed with `UPDATE` statements.
         */
        addGenerated(delegate) {
            return TableUtil.addGenerated(this, delegate);
        }
        /**
         * Lets these columns be updated through this library.
         */
        addMutable(delegate) {
            return TableUtil.addMutable(this, delegate);
        }
        /**
         * Aliases a table reference in a query.
         *
         * ```sql
         *  SELECT
         *      *
         *  FROM
         *      myTable AS aliasedTable
         * ```
         */
        as(newTableAlias) {
            return TableUtil.as(this, newTableAlias);
        }
        /**
         * Prevents rows of this table from being deleted through this library.
         *
         * Good for look-up tables, or append-only tables.
         */
        disableDelete() {
            return TableUtil.disableDelete(this);
        }
        /**
         * Prevents rows from being inserted through this library.
         *
         * Good for look-up tables.
         */
        disableInsert() {
            return TableUtil.disableInsert(this);
        }
        /**
         * The opposite of `disableInsert()`.
         * You really shouldn't need to use this as tables allow insert by default.
         */
        enableInsert() {
            return TableUtil.enableInsert(this);
        }
        /**
         * Makes all columns immutable.
         */
        removeAllMutable() {
            return TableUtil.removeAllMutable(this);
        }
        /**
         * Removes columns from the set of columns with explicit `DEFAULT` values
         *
         */
        removeExplicitDefaultValue(delegate) {
            return TableUtil.removeExplicitDefaultValue(this, delegate);
        }
        /**
         * Removes columns from the set of `GENERATED` columns.
         *
         */
        removeGenerated(delegate) {
            return TableUtil.removeGenerated(this, delegate);
        }
        /**
         * Removes columns from the set of mutable columns.
         *
         * You will not be able to update them through this library.
         *
         */
        removeMutable(delegate) {
            return TableUtil.removeMutable(this, delegate);
        }
        /**
         * Designates one column as the `AUTO_INCREMENT` column.
         *
         * -----
         *
         * + `AUTO_INCREMENT` columns cannot be nullable
         * + `AUTO_INCREMENT` columns must be a candidate key
         * + `AUTO_INCREMENT` columns must be a `PRIMARY KEY`
         * + The `number|string|bigint` requirement is only a compile-time constraint
         */
        setAutoIncrement(delegate) {
            return TableUtil.setAutoIncrement(this, delegate);
        }
        enableExplicitAutoIncrementValue() {
            return TableUtil.enableExplicitAutoIncrementValue(this);
        }
        /**
         * Sets a column as the single-column identifier for this table.
         *
         * -----
         *
         * + `id-column`s cannot be nullable
         * + `id-column`s must be a candidate key
         * + `id-column`s must be a `PRIMARY KEY`
         *
         */
        setId(delegate) {
            return TableUtil.setId(this, delegate);
        }
        /**
         * Sets the `PRIMARY KEY` of the table.
         *
         * In MySQL, a `PRIMARY KEY` is just a candidate key
         * where all its columns are non-nullable.
         *
         * -----
         *
         * + `PRIMARY KEY` columns cannot be nullable
         * + `PRIMARY KEY` columns must be a candidate key
         */
        setPrimaryKey(delegate) {
            return TableUtil.setPrimaryKey(this, delegate);
        }
        /**
         * Sets the `schema` that this table belongs to.
         *
         * This is usually not required because the schema used
         * will be the one your database connection session is using.
         *
         * -----
         *
         * This library does not support cross-schema compile-time safe queries.
         *
         * However, if you **do** need cross-schema support,
         * this library can support it somewhat.
         */
        setSchemaName(newSchemaName) {
            return TableUtil.setSchemaName(this, newSchemaName);
        }
        /**
         * Changes the alias of the table.
         *
         * Useful if you have multiple tables with exactly the same structure.
         *
         * This is different from `.as()`!
         *
         * -----
         *
         * You will have to call `.setSchemaName()` again if you called it before.
         */
        setTableAlias(newTableAlias) {
            return TableUtil.setTableAlias(this, newTableAlias);
        }
        ;
        /*
        addParent<
            ParentT extends ITable
        > (
            parent : TableUtil.Parent<this, ParentT>
        ) : (
            TableUtil.AddParent<this, ParentT>
        ) {
            return TableUtil.addParent<this, ParentT>(this, parent);
        }
    
        /*
        validate (connection : IConnection, result : TableUtil.ValidateTableResult) {
            return TableUtil.validate(this, connection, result);
        }*/
        pickColumns(delegate) {
            return TableUtil.pickColumns(this, delegate);
        }
        insertOne(connection, row) {
            return execution_5.ExecutionUtil.insertOne(this, connection, row);
        }
        insertMany(connection, rows) {
            return execution_5.ExecutionUtil.insertMany(this, connection, rows);
        }
        insertIgnoreOne(connection, row) {
            return execution_5.ExecutionUtil.insertIgnoreOne(this, connection, row);
        }
        insertIgnoreMany(connection, rows) {
            return execution_5.ExecutionUtil.insertIgnoreMany(this, connection, rows);
        }
        replaceOne(connection, row) {
            return execution_5.ExecutionUtil.replaceOne(this, connection, row);
        }
        replaceMany(connection, rows) {
            return execution_5.ExecutionUtil.replaceMany(this, connection, rows);
        }
        insertAndFetch(connection, row) {
            return execution_5.ExecutionUtil.insertAndFetch(this, connection, row);
        }
        where(whereDelegate) {
            return new table_where_2.TableWhere(this, whereDelegate);
        }
        whereEqCandidateKey(candidateKey) {
            return new table_where_2.TableWhere(this, () => ExprLib.eqCandidateKey(this, candidateKey));
        }
        whereEqPrimaryKey(primaryKey) {
            return new table_where_2.TableWhere(this, () => ExprLib.eqPrimaryKey(this, primaryKey));
        }
        whereEqSuperKey(superKey) {
            return new table_where_2.TableWhere(this, () => ExprLib.eqSuperKey(this, superKey));
        }
    }
    exports.Table = Table;
});
define("table/index", ["require", "exports", "table/table-impl", "table/util/index", "table/util/index"], function (require, exports, table_impl_24, TableUtil, util_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(table_impl_24);
    exports.TableUtil = TableUtil;
    exports.table = util_1.fromTableAlias;
});
define("data-type/util/operation/evaluate-columns", ["require", "exports", "type-mapping", "execution/index", "unified-query/index", "expr/index", "column-map/index"], function (require, exports, tm, execution_6, unified_query_8, expr_10, column_map_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function tryEvaluateColumns(table, connection, name, columnAliases, row) {
        /**
         * We do not want extra properties
         */
        row = tm.TypeUtil.pick(row, ...columnAliases);
        const rowKeys = Object.keys(row);
        if (rowKeys.length < columnAliases.length) {
            const missingColumns = columnAliases
                .filter(columnAlias => !rowKeys.includes(columnAlias));
            return {
                success: false,
                error: new Error(`Input row is missing columns ${missingColumns.join(", ")}`),
            };
        }
        const outputRowMapper = column_map_24.ColumnMapUtil.mapper(column_map_24.ColumnMapUtil.pick(table.columns, columnAliases));
        const outputRowResult = tm.tryMapHandled(outputRowMapper, name, row);
        if (outputRowResult.success) {
            /**
             * The best case scenario
             */
            return {
                success: true,
                outputRow: outputRowResult.value,
            };
        }
        /**
         * Not so great.
         * We have to make a DB call to evaluate the expression(s)
         */
        const query = unified_query_8.QueryUtil
            .newInstance()
            .select(() => columnAliases
            .map(columnAlias => {
            const rawExprInput = row[columnAlias];
            return expr_10.ExprUtil.fromRawExprNoUsedRefInput(table.columns[columnAlias], rawExprInput).as(columnAlias);
        }));
        row = await execution_6.ExecutionUtil.fetchOne(query, connection);
        const outputRowResult2 = tm.tryMapHandled(outputRowMapper, name, row);
        if (outputRowResult2.success) {
            return {
                success: true,
                outputRow: outputRowResult2.value,
            };
        }
        else {
            return {
                success: false,
                error: outputRowResult2.mappingError,
            };
        }
    }
    exports.tryEvaluateColumns = tryEvaluateColumns;
});
define("data-type/util/operation/evaluate-primary-key", ["require", "exports", "data-type/util/operation/evaluate-columns"], function (require, exports, evaluate_columns_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function tryEvaluatePrimaryKey(table, connection, row) {
        return evaluate_columns_1.tryEvaluateColumns(table, connection, `${table.alias}.primaryKey`, table.primaryKey, row);
    }
    exports.tryEvaluatePrimaryKey = tryEvaluatePrimaryKey;
});
define("data-type/util/operation/evaluate-candidate-key", ["require", "exports", "type-mapping", "data-type/util/operation/evaluate-columns", "data-type/util/operation/evaluate-primary-key"], function (require, exports, tm, evaluate_columns_2, evaluate_primary_key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function tryEvaluateCandidateKey(table, connection, row) {
        const mappingErrors = [];
        for (const candidateKey of table.candidateKeys) {
            const evaluateResult = await evaluate_columns_2.tryEvaluateColumns(table, connection, `${table.alias}.candidateKey`, candidateKey, row);
            if (evaluateResult.success) {
                return evaluateResult;
            }
            if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
                mappingErrors.push(evaluateResult.error);
            }
        }
        return {
            success: false,
            error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.candidateKey`, row, mappingErrors),
        };
    }
    exports.tryEvaluateCandidateKey = tryEvaluateCandidateKey;
    async function tryEvaluateCandidateKeyPreferPrimaryKey(table, connection, row) {
        if (table.primaryKey == undefined) {
            return tryEvaluateCandidateKey(table, connection, row);
        }
        const evaluatePrimaryKeyResult = await evaluate_primary_key_1.tryEvaluatePrimaryKey(table, connection, row);
        if (evaluatePrimaryKeyResult.success) {
            return evaluatePrimaryKeyResult;
        }
        return tryEvaluateCandidateKey(table, connection, row);
    }
    exports.tryEvaluateCandidateKeyPreferPrimaryKey = tryEvaluateCandidateKeyPreferPrimaryKey;
});
define("built-in-expr/util/query/is-aggregate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAggregate(builtInExpr) {
        if (builtInExpr instanceof Object &&
            "isAggregate" in builtInExpr &&
            typeof builtInExpr.isAggregate == "boolean") {
            return builtInExpr.isAggregate;
        }
        /**
         * If this came from the`SELECT` clause,
         * it may be an aggregate expression, or a non-aggregate expression.
         *
         * We need to know if this is an aggregate expression to avoid the following query,
         * ```sql
         *  SELECT
         *      COUNT(*) AS x
         *  FROM
         *      T
         *  GROUP BY
         *      id
         *  ORDER BY
         *      -- Error, Cannot nest aggregate expressions
         *      SUM(x) ASC;
         * ```
         *
         * @todo Fix the `OrderByDelegate` to not use `ColumnRef`
         */
        return false;
    }
    exports.isAggregate = isAggregate;
});
define("built-in-expr/util/query/type-of", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-expr/util/query/mapper", ["require", "exports", "type-mapping", "expr/index", "column/index", "expr-select-item/index", "query-base/index", "date-util/index"], function (require, exports, tm, expr_11, column_23, expr_select_item_5, query_base_7, date_util_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(builtInExpr) {
        //Check built-in cases first
        if (typeof builtInExpr == "number") {
            /**
             * The SQL standard forbids NaN, Infinity, -Infinity.
             * However, SQLite supports infinities.
             *
             * The job of throwing on these 3 values will have to
             * fall to the sqlfiers.
             */
            return tm.toUnsafeNumber();
        }
        if (tm.TypeUtil.isBigInt(builtInExpr)) {
            return tm.toBigInt();
        }
        if (typeof builtInExpr == "string") {
            return tm.string();
        }
        if (typeof builtInExpr == "boolean") {
            return (
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            builtInExpr ?
                tm.mysql.true() :
                tm.mysql.false());
        }
        if (date_util_3.isDate(builtInExpr)) {
            return tm.mysql.dateTime(3);
        }
        if (builtInExpr instanceof Uint8Array) {
            return tm.instanceOfUint8Array();
        }
        if (builtInExpr === null) {
            return tm.null();
        }
        if (expr_11.ExprUtil.isExpr(builtInExpr)) {
            return builtInExpr.mapper;
        }
        if (column_23.ColumnUtil.isColumn(builtInExpr)) {
            return builtInExpr.mapper;
        }
        if (query_base_7.QueryBaseUtil.isOneSelectItem(builtInExpr) &&
            query_base_7.QueryBaseUtil.isZeroOrOneRow(builtInExpr)) {
            return query_base_7.QueryBaseUtil.mapper(builtInExpr);
        }
        if (expr_select_item_5.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
            return builtInExpr.mapper;
        }
        throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
    }
    exports.mapper = mapper;
});
define("built-in-expr/util/query/used-ref", ["require", "exports", "type-mapping", "built-in-value-expr/index", "used-ref/index", "expr/index", "column/index", "expr-select-item/index", "query-base/index"], function (require, exports, tm, built_in_value_expr_3, used_ref_19, expr_12, column_24, expr_select_item_6, query_base_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function usedRef(builtInExpr) {
        //Check built-in cases first
        if (built_in_value_expr_3.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr)) {
            return used_ref_19.UsedRefUtil.fromColumnRef({});
        }
        if (expr_12.ExprUtil.isExpr(builtInExpr)) {
            return builtInExpr.usedRef;
        }
        if (column_24.ColumnUtil.isColumn(builtInExpr)) {
            return used_ref_19.UsedRefUtil.fromColumn(builtInExpr);
        }
        if (query_base_8.QueryBaseUtil.isQuery(builtInExpr)) {
            return used_ref_19.UsedRefUtil.fromFromClause(builtInExpr.fromClause);
        }
        if (expr_select_item_6.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
            return builtInExpr.usedRef;
        }
        throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
    }
    exports.usedRef = usedRef;
});
define("built-in-expr/util/query/index", ["require", "exports", "built-in-expr/util/query/is-aggregate", "built-in-expr/util/query/mapper", "built-in-expr/util/query/used-ref"], function (require, exports, is_aggregate_2, mapper_7, used_ref_20) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_aggregate_2);
    __export(mapper_7);
    __export(used_ref_20);
});
define("built-in-expr/util/predicate/assert-non-aggregate", ["require", "exports", "built-in-expr/util/query/index"], function (require, exports, query_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNonAggregate(name, builtInExpr) {
        if (query_35.isAggregate(builtInExpr)) {
            throw new Error(`${name} must not be an aggregate expression`);
        }
    }
    exports.assertNonAggregate = assertNonAggregate;
    function assertAllNonAggregate(name, builtInExprArr) {
        for (let i = 0; i < builtInExprArr.length; ++i) {
            assertNonAggregate(`${name}[${i}]`, builtInExprArr[i]);
        }
    }
    exports.assertAllNonAggregate = assertAllNonAggregate;
});
define("built-in-expr/util/predicate/assert-non-null", ["require", "exports", "type-mapping", "built-in-expr/util/query/index"], function (require, exports, tm, query_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Rename to `assertNonNullable`
     */
    function assertNonNull(name, builtInExpr) {
        if (tm.canOutputNull(query_36.mapper(builtInExpr))) {
            throw new Error(`${name} must not be nullable`);
        }
    }
    exports.assertNonNull = assertNonNull;
});
define("built-in-expr/util/predicate/is-any-non-value-expr", ["require", "exports", "built-in-value-expr/index", "expr/index", "column/index", "query-base/index", "expr-select-item/index"], function (require, exports, built_in_value_expr_4, expr_13, column_25, query_base_9, expr_select_item_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAnyNonValueExpr(mixed) {
        if (built_in_value_expr_4.BuiltInValueExprUtil.isBuiltInValueExpr(mixed)) {
            return false;
        }
        if (expr_13.ExprUtil.isExpr(mixed)) {
            return true;
        }
        if (column_25.ColumnUtil.isColumn(mixed)) {
            return true;
        }
        if (query_base_9.QueryBaseUtil.isOneSelectItem(mixed)) {
            return true;
        }
        if (expr_select_item_7.ExprSelectItemUtil.isExprSelectItem(mixed)) {
            return true;
        }
        return false;
    }
    exports.isAnyNonValueExpr = isAnyNonValueExpr;
});
define("built-in-expr/util/predicate/is-any-subquery-expr", ["require", "exports", "query-base/index"], function (require, exports, query_base_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isAnySubqueryExpr(x) {
        return query_base_10.QueryBaseUtil.isOneSelectItem(x) && query_base_10.QueryBaseUtil.isZeroOrOneRow(x);
    }
    exports.isAnySubqueryExpr = isAnySubqueryExpr;
});
define("built-in-expr/util/predicate/is-built-in-expr", ["require", "exports", "built-in-value-expr/index", "built-in-expr/util/predicate/is-any-non-value-expr"], function (require, exports, built_in_value_expr_5, is_any_non_value_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBuiltInExpr(raw) {
        return (built_in_value_expr_5.BuiltInValueExprUtil.isBuiltInValueExpr(raw) ||
            is_any_non_value_expr_1.isAnyNonValueExpr(raw));
    }
    exports.isBuiltInExpr = isBuiltInExpr;
});
define("built-in-expr/util/predicate/index", ["require", "exports", "built-in-expr/util/predicate/assert-non-aggregate", "built-in-expr/util/predicate/assert-non-null", "built-in-expr/util/predicate/is-any-non-value-expr", "built-in-expr/util/predicate/is-any-subquery-expr", "built-in-expr/util/predicate/is-built-in-expr"], function (require, exports, assert_non_aggregate_1, assert_non_null_1, is_any_non_value_expr_2, is_any_subquery_expr_1, is_built_in_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_non_aggregate_1);
    __export(assert_non_null_1);
    __export(is_any_non_value_expr_2);
    __export(is_any_subquery_expr_1);
    __export(is_built_in_expr_1);
});
define("built-in-expr/util/constructor/from-value-expr", ["require", "exports", "type-mapping", "built-in-value-expr/index", "column/index", "data-type/index"], function (require, exports, tm, built_in_value_expr_6, column_26, data_type_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
     * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
     */
    function fromValueExpr(mapper, value) {
        let valueName = "literal-value";
        if (column_26.ColumnUtil.isColumn(mapper)) {
            valueName = `${mapper.tableAlias}${mapper.columnAlias}`;
            mapper = mapper.mapper;
        }
        if (data_type_4.DataTypeUtil.isDataType(mapper)) {
            return mapper.toBuiltInExpr_NonCorrelated(
            /**
             * Validate the incoming value again, just to be sure...
             */
            mapper(valueName, value));
        }
        else {
            if (built_in_value_expr_6.BuiltInValueExprUtil.isBuiltInValueExpr(value)) {
                return mapper(valueName, value);
            }
            else {
                /**
                 * @todo Custom `Error` type
                 */
                throw new Error(`Don't know how to convert ${tm.TypeUtil.toTypeStr(value)} value with keys ${Object.keys(value).map(k => JSON.stringify(k)).join(", ")} to RawExpr`);
            }
        }
    }
    exports.fromValueExpr = fromValueExpr;
});
define("built-in-expr/util/constructor/from-custom-expr-map-correlated", ["require", "exports", "built-in-expr/util/predicate/index", "used-ref/index", "built-in-expr/util/query/index", "built-in-expr/util/constructor/from-value-expr"], function (require, exports, predicate_45, used_ref_21, query_37, from_value_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * If `mapper` is `IDataType`, it uses `mapper.toBuiltInExpr_NonCorrelated()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`.
     * If the `value` is not a `BuiltInValueExpr`, an error is thrown.
     */
    function fromCustomExpr_MapCorrelated(mapper, allowed, customExpr) {
        if (predicate_45.isAnyNonValueExpr(customExpr)) {
            used_ref_21.UsedRefUtil.assertAllowed(allowed, query_37.usedRef(customExpr));
            return customExpr;
        }
        else {
            return from_value_expr_1.fromValueExpr(mapper, customExpr);
        }
    }
    exports.fromCustomExpr_MapCorrelated = fromCustomExpr_MapCorrelated;
});
define("built-in-expr/util/constructor/index", ["require", "exports", "built-in-expr/util/constructor/from-custom-expr-map-correlated", "built-in-expr/util/constructor/from-value-expr"], function (require, exports, from_custom_expr_map_correlated_1, from_value_expr_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_custom_expr_map_correlated_1);
    __export(from_value_expr_2);
});
define("built-in-expr/util/operation/build-ast", ["require", "exports", "type-mapping", "ast/index", "expr/index", "column/index", "query-base/index", "expr-select-item/index", "date-util/index"], function (require, exports, tm, ast_7, expr_14, column_27, query_base_11, expr_select_item_8, date_util_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + `bigint` is considered a `signed bigint` by this library.
     * +`DECIMAL` is not supported by this function.
     * +`BIGINT UNSIGNED` is not supported by this function.
     */
    function buildAst(builtInExpr) {
        //Check built-in cases first
        if (typeof builtInExpr == "number") {
            return ast_7.LiteralValueNodeUtil.doubleLiteralNode(builtInExpr);
        }
        if (tm.TypeUtil.isBigInt(builtInExpr)) {
            return ast_7.LiteralValueNodeUtil.bigIntSignedLiteralNode(builtInExpr);
        }
        if (typeof builtInExpr == "string") {
            return ast_7.LiteralValueNodeUtil.stringLiteralNode(builtInExpr);
        }
        if (typeof builtInExpr == "boolean") {
            return ast_7.LiteralValueNodeUtil.booleanLiteralNode(builtInExpr);
        }
        if (date_util_4.isDate(builtInExpr)) {
            return ast_7.LiteralValueNodeUtil.dateTimeLiteralNode(builtInExpr);
        }
        if (builtInExpr instanceof Uint8Array) {
            //escape(Buffer.from("hello")) == "X'68656c6c6f'"
            return ast_7.LiteralValueNodeUtil.bufferLiteralNode(builtInExpr);
        }
        if (builtInExpr === null) {
            return ast_7.LiteralValueNodeUtil.nullLiteralNode(builtInExpr);
        }
        if (expr_14.ExprUtil.isExpr(builtInExpr)) {
            return builtInExpr.ast;
        }
        if (column_27.ColumnUtil.isColumn(builtInExpr)) {
            return column_27.ColumnUtil.buildAst(builtInExpr);
        }
        if (query_base_11.QueryBaseUtil.isOneSelectItem(builtInExpr)) {
            /**
             * @todo Check if this is desirable
             */
            //return builtInExpr.buildExprAst();
            return ast_7.parentheses(builtInExpr, false /*canUnwrap*/);
        }
        if (expr_select_item_8.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
            /**
             * @todo Check if this is desirable.
             * If anything, the `query` ast, when used as a value query,
             * should wrap an unwrappable parentheses around itself.
             */
            //return Parentheses.Create(builtInExpr.unaliasedAst, false/*canUnwrap*/);
            return ast_7.parentheses(builtInExpr.unaliasedAst);
        }
        throw new Error(`Unknown builtInExpr ${tm.TypeUtil.toTypeStr(builtInExpr)}`);
    }
    exports.buildAst = buildAst;
});
define("built-in-expr/util/operation/intersect-used-ref", ["require", "exports", "built-in-expr/util/query/index", "used-ref/index"], function (require, exports, query_38, used_ref_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersectUsedRef(...arr) {
        const result = used_ref_22.UsedRefUtil.intersect(...arr.map(u => query_38.usedRef(u)));
        return result;
    }
    exports.intersectUsedRef = intersectUsedRef;
});
define("built-in-expr/util/operation/index", ["require", "exports", "built-in-expr/util/operation/build-ast", "built-in-expr/util/operation/intersect-used-ref"], function (require, exports, build_ast_1, intersect_used_ref_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(build_ast_1);
    __export(intersect_used_ref_1);
});
define("built-in-expr/util/index", ["require", "exports", "built-in-expr/util/constructor/index", "built-in-expr/util/operation/index", "built-in-expr/util/predicate/index", "built-in-expr/util/query/index"], function (require, exports, constructor_11, operation_28, predicate_46, query_39) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_11);
    __export(operation_28);
    __export(predicate_46);
    __export(query_39);
});
define("data-type/util/operation/evaluate-custom-expr", ["require", "exports", "type-mapping", "unified-query/index", "built-in-expr/util/index"], function (require, exports, tm, unified_query_9, util_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Given a type `T`, we may have a `CustomExpr_NonCorrelated<T>`.
     *
     * This may be `T` itself, or `IExpr<T>` or `IColumn<T>` or
     * any other non-`T`.
     *
     * However, we **want** `T`.
     * This function helps us resolve non-`T` types to `T` itself.
     */
    async function evaluateCustomExpr(column, connection, customExpr) {
        if (util_2.isAnyNonValueExpr(customExpr)) {
            //We have a non-value expression, evaluate it to figure out what its value is
            const rawEvaluatedValue = await unified_query_9.QueryUtil
                .newInstance()
                .selectValue(() => customExpr)
                .fetchValue(connection);
            //We must have a value now
            const evaluatedValue = column.mapper(`${column.tableAlias}.${column.columnAlias}`, rawEvaluatedValue);
            return evaluatedValue;
        }
        const valueResult = tm.mapHandled(column.mapper, `${column.tableAlias}.${column.columnAlias}`, customExpr);
        return valueResult;
    }
    exports.evaluateCustomExpr = evaluateCustomExpr;
});
define("data-type/util/operation/evaluate-insertable-candidate-key", ["require", "exports", "type-mapping", "table/index", "data-type/util/operation/evaluate-columns", "data-type/util/operation/evaluate-primary-key", "key/index"], function (require, exports, tm, table_32, evaluate_columns_3, evaluate_primary_key_2, key_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function tryEvaluateInsertableCandidateKey(table, connection, row) {
        const insertableColumnAliases = table_32.TableUtil.insertableColumnAlias(table);
        const mappingErrors = [];
        for (const candidateKey of table.candidateKeys) {
            if (!key_13.KeyUtil.isSubKey(candidateKey, insertableColumnAliases)) {
                continue;
            }
            const evaluateResult = await evaluate_columns_3.tryEvaluateColumns(table, connection, `${table.alias}.insertableCandidateKey`, candidateKey, row);
            if (evaluateResult.success) {
                return evaluateResult;
            }
            if (tm.ErrorUtil.isMappingError(evaluateResult.error)) {
                mappingErrors.push(evaluateResult.error);
            }
        }
        return {
            success: false,
            error: tm.ErrorUtil.makeNormalizedUnionError(`${table.alias}.insertableCandidateKey`, row, mappingErrors),
        };
    }
    exports.tryEvaluateInsertableCandidateKey = tryEvaluateInsertableCandidateKey;
    async function tryEvaluateInsertableCandidateKeyPreferPrimaryKey(table, connection, row) {
        if (table.primaryKey == undefined) {
            return tryEvaluateInsertableCandidateKey(table, connection, row);
        }
        if (table.primaryKey.every(columnAlias => table_32.TableUtil.isInsertableColumnAlias(table, columnAlias))) {
            const evaluatePrimaryKeyResult = await evaluate_primary_key_2.tryEvaluatePrimaryKey(table, connection, row);
            if (evaluatePrimaryKeyResult.success) {
                return evaluatePrimaryKeyResult;
            }
        }
        return tryEvaluateInsertableCandidateKey(table, connection, row);
    }
    exports.tryEvaluateInsertableCandidateKeyPreferPrimaryKey = tryEvaluateInsertableCandidateKeyPreferPrimaryKey;
});
define("data-type/util/predicate/is-data-type", ["require", "exports", "type-util/index"], function (require, exports, type_util_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDataType(raw) {
        if (typeof raw != "function") {
            return false;
        }
        if (!type_util_19.isObjectWithOwnEnumerableKeys()(raw, [
            "toBuiltInExpr_NonCorrelated",
            "isNullSafeEqual",
        ])) {
            return false;
        }
        return ((typeof raw.toBuiltInExpr_NonCorrelated == "function") &&
            (typeof raw.isNullSafeEqual == "function"));
    }
    exports.isDataType = isDataType;
});
define("data-type/util/predicate/is-null-safe-equal", ["require", "exports", "type-mapping", "data-type/util/predicate/is-data-type", "built-in-value-expr/index", "column/index"], function (require, exports, tm, is_data_type_1, built_in_value_expr_7, column_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * If `mapper` is `IDataType`, it uses `mapper.isNullSafeEqual()`.
     *
     * Else, it uses a fallback algorithm that works fine for `BuiltInValueExpr`,
     * but may not be suitable for custom data types.
     */
    function isNullSafeEqual(mapper, a, b) {
        if (column_28.ColumnUtil.isColumn(mapper)) {
            mapper = mapper.mapper;
        }
        if (is_data_type_1.isDataType(mapper)) {
            return mapper.isNullSafeEqual(a, b);
        }
        else {
            if (built_in_value_expr_7.BuiltInValueExprUtil.isBuiltInValueExpr(a)) {
                if (built_in_value_expr_7.BuiltInValueExprUtil.isBuiltInValueExpr(b)) {
                    return built_in_value_expr_7.BuiltInValueExprUtil.isEqual(a, b);
                }
                else {
                    return false;
                }
            }
            else {
                return tm.TypeUtil.strictEqual(a, b);
            }
        }
    }
    exports.isNullSafeEqual = isNullSafeEqual;
});
define("data-type/util/predicate/index", ["require", "exports", "data-type/util/predicate/is-data-type", "data-type/util/predicate/is-null-safe-equal"], function (require, exports, is_data_type_2, is_null_safe_equal_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_data_type_2);
    __export(is_null_safe_equal_1);
});
define("data-type/util/operation/intersect", ["require", "exports", "type-mapping", "data-type/util/predicate/index", "data-type/util/constructor/index", "built-in-expr/index", "built-in-value-expr/index"], function (require, exports, tm, predicate_47, constructor_12, built_in_expr_18, built_in_value_expr_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Implement something more efficient to generalize intersect `N` mappers.
     *
     * This runs a `mixed` value through both `mapperA` and `mapperB`.
     * Then, it checks that both mapped results are equal.
     *
     * It **does not** try to "deep-merge" both mapped results.
     *
     * So, you cannot combine mappers for `{x:number}` and `{y:number}`
     * and hope to have a value of type `{x:number, y:number}` during run-time.
     *
     * it will just throw a run-time error because a value of exactly type `{x:number}`
     * is not equal to a value of exactly type `{y:number}`.
     */
    function intersect(mapperA, mapperB) {
        if (predicate_47.isDataType(mapperA)) {
            if (predicate_47.isDataType(mapperB)) {
                return constructor_12.makeDataType((name, mixed) => {
                    const mappedA = mapperA(name, mixed);
                    const mappedB = mapperB(name, mixed);
                    if (!mapperA.isNullSafeEqual(mappedA, 
                    /**
                     * This may throw
                     */
                    mapperA(name, mappedB))) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    if (!mapperB.isNullSafeEqual(mappedB, 
                    /**
                     * This may throw
                     */
                    mapperB(name, mappedA))) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} ${tm.TypeUtil.toTypeStr(mappedB)} fails RHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    /**
                     * Since the two values are "equal",
                     * it should not matter which we return.
                     */
                    return mappedA;
                }, (value) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to convert to a built-in expr.
                     */
                    return mapperA.toBuiltInExpr_NonCorrelated(value);
                }, (a, b) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to say they
                     * are null-safe-equal.
                     */
                    return mapperA.isNullSafeEqual(a, b);
                });
            }
            else {
                return constructor_12.makeDataType((name, mixed) => {
                    const mappedA = mapperA(name, mixed);
                    const mappedB = mapperB(name, mixed);
                    if (!mapperA.isNullSafeEqual(mappedA, 
                    /**
                     * This may throw
                     */
                    mapperA(name, mappedB))) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    /**
                     * Since the two values are "equal",
                     * it should not matter which we return.
                     *
                     * Well, we couldn't perform RHS equality checks...
                     */
                    return mappedA;
                }, (value) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to convert to a built-in expr.
                     */
                    return mapperA.toBuiltInExpr_NonCorrelated(value);
                }, (a, b) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to say they
                     * are null-safe-equal.
                     */
                    return mapperA.isNullSafeEqual(a, b);
                });
            }
        }
        else {
            if (predicate_47.isDataType(mapperB)) {
                return constructor_12.makeDataType((name, mixed) => {
                    const mappedA = mapperA(name, mixed);
                    const mappedB = mapperB(name, mixed);
                    if (!mapperB.isNullSafeEqual(mappedB, 
                    /**
                     * This may throw
                     */
                    mapperB(name, mappedA))) {
                        /**
                         * @todo Find a way to make better messages.
                         */
                        throw tm.ErrorUtil.makeMappingError({
                            message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            inputName: name,
                            actualValue: mixed,
                            expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                            expectedMeta: {
                                mapperA,
                                mapperB,
                            },
                        });
                    }
                    /**
                     * Since the two values are "equal",
                     * it should not matter which we return.
                     *
                     * Well, we couldn't perform LHS equality checks...
                     */
                    return mappedB;
                }, (value) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to convert to a built-in expr.
                     */
                    return mapperB.toBuiltInExpr_NonCorrelated(value);
                }, (a, b) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to say they
                     * are null-safe-equal.
                     */
                    return mapperB.isNullSafeEqual(a, b);
                });
            }
            else {
                return constructor_12.makeDataType((name, mixed) => {
                    const mappedA = mapperA(name, mixed);
                    const mappedB = mapperB(name, mixed);
                    if (built_in_value_expr_8.BuiltInValueExprUtil.isBuiltInValueExpr(mappedA)) {
                        if (built_in_value_expr_8.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                            if (!built_in_value_expr_8.BuiltInValueExprUtil.isEqual(mappedA, mappedB)) {
                                /**
                                 * @todo Find a way to make better messages.
                                 */
                                throw tm.ErrorUtil.makeMappingError({
                                    message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                    inputName: name,
                                    actualValue: mixed,
                                    expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                    expectedMeta: {
                                        mapperA,
                                        mapperB,
                                    },
                                });
                            }
                        }
                        else {
                            /**
                             * @todo Find a way to make better messages.
                             */
                            throw tm.ErrorUtil.makeMappingError({
                                message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                inputName: name,
                                actualValue: mixed,
                                expected: `${tm.TypeUtil.toTypeStr(mappedA)} LHS equality check`,
                                expectedMeta: {
                                    mapperA,
                                    mapperB,
                                },
                            });
                        }
                    }
                    else {
                        if (built_in_value_expr_8.BuiltInValueExprUtil.isBuiltInValueExpr(mappedB)) {
                            /**
                             * @todo Find a way to make better messages.
                             */
                            throw tm.ErrorUtil.makeMappingError({
                                message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                                inputName: name,
                                actualValue: mixed,
                                expected: `${tm.TypeUtil.toTypeStr(mappedB)} RHS equality check`,
                                expectedMeta: {
                                    mapperA,
                                    mapperB,
                                },
                            });
                        }
                        else {
                            /**
                             * @todo Find a way to make better messages.
                             */
                            throw tm.ErrorUtil.makeMappingError({
                                message: `${name} fails ${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check; use IDataType instead of SafeMapper`,
                                inputName: name,
                                actualValue: mixed,
                                expected: `${tm.TypeUtil.toTypeStr(mappedA)}/${tm.TypeUtil.toTypeStr(mappedB)} LHS/RHS equality check`,
                                expectedMeta: {
                                    mapperA,
                                    mapperB,
                                },
                            });
                        }
                    }
                    /**
                     * Since the two values are "equal",
                     * it should not matter which we return.
                     */
                    return mappedA;
                }, (value) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we only need one mapper to convert to a built-in expr.
                     *
                     * So, we can assume they are built-in values
                     */
                    return built_in_expr_18.BuiltInExprUtil.fromValueExpr(mapperA, value);
                }, (a, b) => {
                    /**
                     * We assume that `a` and `b`
                     * have already gone through the above mapping function.
                     *
                     * So, we can assume they are built-in values
                     */
                    return (built_in_value_expr_8.BuiltInValueExprUtil.isBuiltInValueExpr(a) &&
                        built_in_value_expr_8.BuiltInValueExprUtil.isBuiltInValueExpr(b) &&
                        built_in_value_expr_8.BuiltInValueExprUtil.isEqual(a, b));
                });
            }
        }
    }
    exports.intersect = intersect;
});
define("data-type/util/operation/index", ["require", "exports", "data-type/util/operation/evaluate-candidate-key", "data-type/util/operation/evaluate-columns", "data-type/util/operation/evaluate-custom-expr", "data-type/util/operation/evaluate-insertable-candidate-key", "data-type/util/operation/evaluate-primary-key", "data-type/util/operation/intersect"], function (require, exports, evaluate_candidate_key_1, evaluate_columns_4, evaluate_custom_expr_1, evaluate_insertable_candidate_key_1, evaluate_primary_key_3, intersect_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(evaluate_candidate_key_1);
    __export(evaluate_columns_4);
    __export(evaluate_custom_expr_1);
    __export(evaluate_insertable_candidate_key_1);
    __export(evaluate_primary_key_3);
    __export(intersect_2);
});
define("data-type/util/index", ["require", "exports", "data-type/util/constructor/index", "data-type/util/operation/index", "data-type/util/predicate/index"], function (require, exports, constructor_13, operation_29, predicate_48) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_13);
    __export(operation_29);
    __export(predicate_48);
});
define("data-type/non-built-in-value-expr/decimal", ["require", "exports", "type-mapping", "data-type/util/index", "expr-library/index"], function (require, exports, tm, DataTypeUtil, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeDecimalDataType(mapperFactory) {
        return (
        /**
         * + PostgreSQL's min precision is `1`
         * + MySQL's max precision is `65`
         */
        precision, 
        /**
         * + The min scale is `0`.
         * + MySQL's max scale is `30`.
         * + `scale` must be <= `precision`.
         */
        scale, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(precision, scale), value => ExprLib.decimalLiteral(value, precision, scale), 
        /**
         * We consider +0 and -0 to be the same
         */
        (a, b) => {
            if (a === b) {
                //Early-exit
                return true;
            }
            if (a.toString() === b.toString()) {
                //Early-exit
                return true;
            }
            const parsedA = tm.FixedPointUtil.tryParse(a.toString());
            if (parsedA == undefined) {
                /**
                 * This should never happen...
                 */
                throw new Error(`Invalid DECIMAL a found`);
            }
            const parsedB = tm.FixedPointUtil.tryParse(b.toString());
            if (parsedB == undefined) {
                /**
                 * This should never happen...
                 */
                throw new Error(`Invalid DECIMAL b found`);
            }
            return tm.FixedPointUtil.isEqual(parsedA, parsedB, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL);
        }, extraMapper);
    }
    exports.makeDecimalDataType = makeDecimalDataType;
    /**
     * Fixed-point number.
     *
     * + MySQL      : `DECIMAL(p, s)`
     * + PostgreSQL : `DECIMAL(p, s)`
     * + SQLite     : -NA-; Should be emulated using `TEXT` and custom functions.
     *
     * @param precision
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     *
     * @param scale
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     *
     * @param extraMapper
     */
    exports.dtDecimal = makeDecimalDataType(tm.mysql.decimal);
});
define("data-type/non-built-in-value-expr/index", ["require", "exports", "data-type/non-built-in-value-expr/decimal"], function (require, exports, decimal_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(decimal_1);
});
define("data-type/built-in-value-expr/blob", ["require", "exports", "type-mapping", "data-type/util/index"], function (require, exports, tm, DataTypeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const equals = tm.ArrayBufferUtil.equals;
    function makeBlobDataType(mapperFactory) {
        const result = (a, b, c) => {
            if (c != undefined) {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals, c);
            }
            else if (b != undefined) {
                if (typeof b == "number") {
                    return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, equals);
                }
                else {
                    return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals, b);
                }
            }
            else if (a != undefined) {
                if (typeof a == "number") {
                    return DataTypeUtil.makeDataType(mapperFactory(a), value => value, equals);
                }
                else {
                    return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals, a);
                }
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, equals);
            }
        };
        result.maxLength = mapperFactory.maxLength;
        return result;
    }
    exports.makeBlobDataType = makeBlobDataType;
    /**
     * + MySQL      : `BINARY`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `BINARY` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    exports.dtBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
    /**
     * + MySQL      : `VARBINARY`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `VARBINARY` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    exports.dtVarBinary = makeBlobDataType(tm.mysql.uint8ArrayBinary);
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `TINY BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `TINY BLOB` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    exports.dtTinyBlob = makeBlobDataType(tm.mysql.uint8ArrayTinyBlob);
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `BLOB` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    exports.dtBlob = makeBlobDataType(tm.mysql.uint8ArrayBlob);
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `MEDIUM BLOB`
     * + PostgreSQL : `bytea`
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `MEDIUM BLOB` data type.
     * + Max length: `16,777,215`; `(2^24)-1`
     */
    exports.dtMediumBlob = makeBlobDataType(tm.mysql.uint8ArrayMediumBlob);
    /**
     * Short for "Binary Large OBject"
     *
     * + MySQL      : `LONG BLOB`
     * + PostgreSQL : `LO` (Large Object)
     * + SQLite     : `BLOB`
     *
     *
     * This corresponds to MySQL's `LONG BLOB` data type.
     * + Max length: `4,294,967,295`; `(2^32)-1`
     *
     * -----
     *
     * `bytea` supports up to 1GB. So, we cannot use `bytea`.
     *
     * https://dba.stackexchange.com/questions/127270/what-are-the-limits-of-postgresqls-large-object-facility
     * > A large object cannot exceed 4TB for PostgreSQL 9.3 or newer, or 2GB for older versions.
     * > This is based on the [release notes](https://www.postgresql.org/docs/9.3/release-9-3.html)
     *
     * From the release notes,
     * > Increase the maximum size of large objects from 2GB to 4TB (Nozomi Anzai, Yugo Nagata)
     *
     * -----
     *
     * Realistically, SQLite should support this,
     * https://www.sqlite.org/limits.html
     *
     * However, it is possible that the underlying implementation
     * may be restricted from having a `Uint8Array` of that length.
     */
    exports.dtLongBlob = makeBlobDataType(tm.mysql.uint8ArrayLongBlob);
});
define("data-type/built-in-value-expr/boolean", ["require", "exports", "type-mapping", "data-type/util/index"], function (require, exports, tm, DataTypeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeBooleanDataType(mapper) {
        return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
    }
    exports.makeBooleanDataType = makeBooleanDataType;
    /**
     * + MySQL      : `TINYINT` (Emulates `boolean`)
     * + PostgreSQL : `boolean`
     * + SQLite     : `INTEGER` (Emulates `boolean`)
     */
    exports.dtBoolean = makeBooleanDataType(tm.mysql.boolean());
});
define("data-type/built-in-value-expr/date-time", ["require", "exports", "type-mapping", "data-type/util/index", "built-in-value-expr/index"], function (require, exports, tm, DataTypeUtil, built_in_value_expr_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeDateTimeDataType(mapperFactory) {
        return (fractionalSecondPrecision /*|4|5|6*/, extraMapper) => DataTypeUtil.makeDataType(mapperFactory(fractionalSecondPrecision), value => value, (a, b) => built_in_value_expr_9.BuiltInValueExprUtil.isEqual(a, b), extraMapper);
    }
    exports.makeDateTimeDataType = makeDateTimeDataType;
    /**
     * + MySQL      : `DATETIME`
     * + PostgreSQL : `TIMESTAMP`
     * + SQLite     : `TEXT` (Emulates `DATETIME`)
     *
     * SQLite only supports up to millisecond precision.
     *
     * JS only supports up to millisecond precision.
     *
     * + `0` = second
     * + `1` = deci-second
     * + `2` = centi-second
     * + `3` = millisecond
     *
     * @param fractionalSecondPrecision - `3` is recommended; millisecond precision.
     */
    exports.dtDateTime = makeDateTimeDataType(tm.mysql.dateTime);
});
define("data-type/built-in-value-expr/double", ["require", "exports", "type-mapping", "data-type/util/index"], function (require, exports, tm, DataTypeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeDoubleDataType(mapper) {
        return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => a === b, extraMapper);
    }
    exports.makeDoubleDataType = makeDoubleDataType;
    /**
     * 8-byte floating point number.
     *
     * + MySQL      : `DOUBLE`
     * + PostgreSQL : `double precision`
     * + SQLite     : `REAL`; is actually 8-byte floating point number
     *
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    exports.dtDouble = makeDoubleDataType(tm.toUnsafeNumber());
    /**
     * 4-byte floating point number.
     *
     * JS does not have a 4-byte floating point number type.
     * So, attempting to use `FLOAT` will cause a loss in precision.
     *
     * + MySQL      : `FLOAT`
     * + PostgreSQL : `real`
     * + SQLite     : `REAL`; does not actually have 4-byte floating point numbers
     *
     * The SQL standard forbids NaN, Infinity, -Infinity.
     * However, SQLite supports infinities.
     *
     * The job of throwing on these 3 values will have to
     * fall to the sqlfiers.
     */
    exports.dtFloat = makeDoubleDataType(tm.toUnsafeNumber());
});
define("data-type/built-in-value-expr/integer", ["require", "exports", "type-mapping", "data-type/util/index"], function (require, exports, tm, DataTypeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeIntegerDataType(mapper) {
        return (extraMapper) => DataTypeUtil.makeDataType(mapper, value => value, (a, b) => tm.TypeUtil.strictEqual(a, b), extraMapper);
    }
    exports.makeIntegerDataType = makeIntegerDataType;
    /**
     * 1-byte integer.
     *
     * + MySQL      : `TINYINT SIGNED`
     * + PostgreSQL : `smallint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `TINYINT SIGNED` data type.
     * + Min: -128; `-(2^7)`
     * + Max:  127; `(2^7)-1`
     */
    exports.dtTinyIntSigned = makeIntegerDataType(tm.mysql.tinyIntSigned());
    /**
     * 2-byte integer.
     *
     * + MySQL      : `SMALLINT SIGNED`
     * + PostgreSQL : `smallint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `SMALLINT SIGNED` data type.
     * + Min: -32,768; `-(2^15)`
     * + Max:  32,767; `(2^15)-1`
     */
    exports.dtSmallIntSigned = makeIntegerDataType(tm.mysql.smallIntSigned());
    /**
     * 3-byte integer.
     *
     * + MySQL      : `MEDIUMINT SIGNED`
     * + PostgreSQL : `integer`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `MEDIUMINT SIGNED` data type.
     * + Min: -8,388,608; `-(2^23)`
     * + Max:  8,388,607; `(2^23)-1`
     */
    exports.dtMediumIntSigned = makeIntegerDataType(tm.mysql.mediumIntSigned());
    /**
     * 4-byte integer.
     *
     * + MySQL      : `INT SIGNED`
     * + PostgreSQL : `integer`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `INT SIGNED` data type.
     * + Min: -2,147,483,648; `-(2^31)`
     * + Max:  2,147,483,647; `(2^31)-1`
     */
    exports.dtIntSigned = makeIntegerDataType(tm.mysql.intSigned());
    /**
     * 8-byte integer.
     *
     * + MySQL      : `BIGINT SIGNED`
     * + PostgreSQL : `bigint`
     * + SQLite     : `INTEGER`
     *
     * This corresponds to MySQL's `BIGINT SIGNED` data type.
     * + Min: -9,223,372,036,854,775,808; `-(2^63)`
     * + Max:  9,223,372,036,854,775,807; `(2^63)-1`
     */
    exports.dtBigIntSigned = makeIntegerDataType(tm.mysql.bigIntSigned());
});
define("data-type/built-in-value-expr/text", ["require", "exports", "type-mapping", "data-type/util/index"], function (require, exports, tm, DataTypeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeTextDataType(mapperFactory) {
        const result = (a, b, c) => {
            if (c != undefined) {
                return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b, c);
            }
            else if (b != undefined) {
                if (typeof b == "number") {
                    return DataTypeUtil.makeDataType(mapperFactory(a, b), value => value, (a, b) => a === b);
                }
                else {
                    return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b, b);
                }
            }
            else if (a != undefined) {
                if (typeof a == "number") {
                    return DataTypeUtil.makeDataType(mapperFactory(a), value => value, (a, b) => a === b);
                }
                else {
                    return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b, a);
                }
            }
            else {
                return DataTypeUtil.makeDataType(mapperFactory(), value => value, (a, b) => a === b);
            }
        };
        result.maxLength = mapperFactory.maxLength;
        return result;
    }
    exports.makeTextDataType = makeTextDataType;
    /**
     * + MySQL      : `CHAR`
     * + PostgreSQL : `CHAR`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `CHAR` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    exports.dtChar = makeTextDataType(tm.mysql.char);
    /**
     * + MySQL      : `VARCHAR`
     * + PostgreSQL : `VARCHAR`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `VARCHAR` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    exports.dtVarChar = makeTextDataType(tm.mysql.varChar);
    /**
     * + MySQL      : `TINY TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `TINY TEXT` data type.
     * + Max length: `255`; `(2^8)-1`
     */
    exports.dtTinyText = makeTextDataType(tm.mysql.tinyText);
    /**
     * + MySQL      : `TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `TEXT` data type.
     * + Max length: `65,535`; `(2^16)-1`
     */
    exports.dtText = makeTextDataType(tm.mysql.text);
    /**
     * + MySQL      : `MEDIUM TEXT`
     * + PostgreSQL : `text`
     * + SQLite     : `TEXT`
     *
     *
     * This corresponds to MySQL's `MEDIUM TEXT` data type.
     * + Max length: `16,777,215`; `(2^24)-1`
     */
    exports.dtMediumText = makeTextDataType(tm.mysql.mediumText);
    /**
     * + MySQL      : `LONG TEXT`
     * + PostgreSQL : -NA-
     * + SQLite     : `TEXT`
     *
     * This corresponds to MySQL's `LONG TEXT` data type.
     * + Max length: `4,294,967,295`; `(2^32)-1`
     *
     * -----
     *
     * `text` supports up to 1GB. So, we cannot use `text`.
     *
     * https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F
     *
     * > Maximum size for a field? 1 GB
     *
     * -----
     *
     * Realistically, SQLite should support this,
     * https://www.sqlite.org/limits.html
     *
     * However, it is possible that the underlying implementation
     * may be restricted from having a `string` of that length.
     */
    exports.dtLongText = makeTextDataType(tm.mysql.longText);
});
define("data-type/built-in-value-expr/index", ["require", "exports", "data-type/built-in-value-expr/blob", "data-type/built-in-value-expr/boolean", "data-type/built-in-value-expr/date-time", "data-type/built-in-value-expr/double", "data-type/built-in-value-expr/integer", "data-type/built-in-value-expr/text"], function (require, exports, blob_1, boolean_1, date_time_1, double_1, integer_1, text_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(blob_1);
    __export(boolean_1);
    __export(date_time_1);
    __export(double_1);
    __export(integer_1);
    __export(text_1);
});
define("data-type/index", ["require", "exports", "data-type/non-built-in-value-expr/index", "data-type/built-in-value-expr/index", "data-type/util/index"], function (require, exports, non_built_in_value_expr_1, built_in_value_expr_10, DataTypeUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(non_built_in_value_expr_1);
    __export(built_in_value_expr_10);
    exports.DataTypeUtil = DataTypeUtil;
});
define("column-map/util/operation/left-intersect", ["require", "exports", "column/index", "data-type/index"], function (require, exports, column_29, data_type_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftIntersect(mapA, mapB) {
        const result = {};
        for (const columnAlias of Object.keys(mapA)) {
            const columnA = mapA[columnAlias];
            const columnB = mapB[columnAlias];
            if (column_29.ColumnUtil.isColumn(columnB)) {
                result[columnAlias] = new column_29.Column({
                    tableAlias: columnA.tableAlias,
                    columnAlias: columnA.columnAlias,
                    mapper: data_type_5.DataTypeUtil.intersect(columnA.mapper, mapB[columnAlias].mapper),
                }, columnA.unaliasedAst);
            }
            else {
                result[columnAlias] = columnA;
            }
        }
        return result;
    }
    exports.leftIntersect = leftIntersect;
    ;
});
define("column-map/util/operation/intersect", ["require", "exports", "column-map/util/operation/left-intersect"], function (require, exports, left_intersect_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(mapA, mapB) {
        const left = left_intersect_2.leftIntersect(mapA, mapB);
        const right = {};
        for (const columnAlias of Object.keys(mapB)) {
            if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
                Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
                continue;
            }
            right[columnAlias] = mapB[columnAlias];
        }
        return {
            ...left,
            ...right,
        };
    }
    exports.intersect = intersect;
});
define("column-map/util/operation/omit", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function omit(map, arr) {
        const result = {};
        for (const columnAlias of Object.keys(map)) {
            if (arr.indexOf(columnAlias) < 0) {
                result[columnAlias] = map[columnAlias];
            }
        }
        return result;
    }
    exports.omit = omit;
});
define("column-map/util/operation/pick", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function pick(map, arr) {
        const result = {};
        for (const columnAlias of Object.keys(map)) {
            if (arr.indexOf(columnAlias) >= 0) {
                result[columnAlias] = map[columnAlias];
            }
        }
        return result;
    }
    exports.pick = pick;
});
define("column-map/util/operation/replace-column", ["require", "exports", "column/index"], function (require, exports, column_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function replaceColumn(map, columnAlias, mapper) {
        const result = {};
        for (const myColumnAlias of Object.keys(map)) {
            if (myColumnAlias == columnAlias) {
                result[myColumnAlias] = column_30.ColumnUtil.withType(map[myColumnAlias], mapper);
            }
            else {
                result[myColumnAlias] = map[myColumnAlias];
            }
        }
        return result;
    }
    exports.replaceColumn = replaceColumn;
});
define("column-map/util/operation/to-nullable", ["require", "exports", "column/index"], function (require, exports, column_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toNullable(columnMap) {
        const result = {};
        for (const columnAlias of Object.keys(columnMap)) {
            result[columnAlias] = column_31.ColumnUtil.toNullable(columnMap[columnAlias]);
        }
        return result;
    }
    exports.toNullable = toNullable;
});
define("column-map/util/operation/with-table-alias", ["require", "exports", "column/index"], function (require, exports, column_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function withTableAlias(columnMap, newTableAlias) {
        const result = {};
        for (const columnAlias of Object.keys(columnMap)) {
            result[columnAlias] = column_32.ColumnUtil.withTableAlias(columnMap[columnAlias], newTableAlias);
        }
        return result;
    }
    exports.withTableAlias = withTableAlias;
});
define("column-map/util/operation/index", ["require", "exports", "column-map/util/operation/compound", "column-map/util/operation/intersect", "column-map/util/operation/left-compound", "column-map/util/operation/left-intersect", "column-map/util/operation/omit", "column-map/util/operation/pick", "column-map/util/operation/replace-column", "column-map/util/operation/to-nullable", "column-map/util/operation/with-table-alias"], function (require, exports, compound_2, intersect_3, left_compound_3, left_intersect_3, omit_1, pick_1, replace_column_3, to_nullable_1, with_table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(compound_2);
    __export(intersect_3);
    __export(left_compound_3);
    __export(left_intersect_3);
    __export(omit_1);
    __export(pick_1);
    __export(replace_column_3);
    __export(to_nullable_1);
    __export(with_table_alias_1);
});
define("column-map/util/constructor/from-join", ["require", "exports", "column-map/util/operation/index"], function (require, exports, operation_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromJoin(join) {
        if (join.nullable) {
            return operation_30.toNullable(join.columns);
        }
        else {
            return join.columns;
        }
    }
    exports.fromJoin = fromJoin;
});
define("column-map/util/constructor/from-mapper-map", ["require", "exports", "column/index"], function (require, exports, column_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromMapperMap(tableAlias, mapperMap) {
        const result = {};
        for (const columnAlias of Object.keys(mapperMap)) {
            result[columnAlias] = new column_33.Column({
                tableAlias,
                columnAlias,
                mapper: mapperMap[columnAlias],
            }, undefined);
        }
        return result;
    }
    exports.fromMapperMap = fromMapperMap;
});
define("column-map/util/query/column-alias-with-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/query/column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function columnAlias(map) {
        return Object.keys(map);
    }
    exports.columnAlias = columnAlias;
});
define("column-map/util/query/extract-column-identifier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Does not check `tableAlias`
     */
    function extractColumnIdentifiers(map, columnIdentifiers) {
        const result = {};
        for (const columnAlias of Object.keys(map)) {
            if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
                result[columnAlias] = map[columnAlias];
            }
        }
        return result;
    }
    exports.extractColumnIdentifiers = extractColumnIdentifiers;
});
define("column-map/util/query/non-nullable-column-alias", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function nonNullableColumnAliases(map) {
        return Object.keys(map)
            .filter(columnAlias => !tm.canOutputNull(map[columnAlias].mapper));
    }
    exports.nonNullableColumnAliases = nonNullableColumnAliases;
});
define("column-map/util/query/extract-non-nullable", ["require", "exports", "column-map/util/query/non-nullable-column-alias"], function (require, exports, non_nullable_column_alias_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractNonNullable(map) {
        const result = {};
        for (const columnAlias of non_nullable_column_alias_1.nonNullableColumnAliases(map)) {
            result[columnAlias] = map[columnAlias];
        }
        return result;
    }
    exports.extractNonNullable = extractNonNullable;
});
define("column-map/util/query/nullable-column-alias", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function nullableColumnAliases(map) {
        return Object.keys(map)
            .filter(columnAlias => tm.canOutputNull(map[columnAlias].mapper));
    }
    exports.nullableColumnAliases = nullableColumnAliases;
});
define("column-map/util/query/extract-nullable", ["require", "exports", "column-map/util/query/nullable-column-alias"], function (require, exports, nullable_column_alias_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractNullable(map) {
        const result = {};
        for (const columnAlias of nullable_column_alias_1.nullableColumnAliases(map)) {
            result[columnAlias] = map[columnAlias];
        }
        return result;
    }
    exports.extractNullable = extractNullable;
});
define("column-map/util/query/extract-with-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/query/find-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/query/find-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/query/mapper", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mapper(map) {
        const fields = [];
        for (const columnAlias of Object.keys(map)) {
            /**
             * It's possible that this is not an `IColumnUtil`.
             * But, in general, if we pass in candidateKey and columnMap
             * without any outside hack-ery, this should be correct.
             */
            const column = map[columnAlias];
            fields.push(tm.withName(column.mapper, column.columnAlias));
        }
        return tm.objectFromArray(...fields);
    }
    exports.mapper = mapper;
});
define("column-map/util/query/partial-mapper", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function partialMapper(map) {
        const fields = [];
        for (const columnAlias of Object.keys(map)) {
            /**
             * It's possible that this is not an `IColumnUtil`.
             * But, in general, if we pass in candidateKey and columnMap
             * without any outside hack-ery, this should be correct.
             */
            const column = map[columnAlias];
            fields.push(tm.withName(column.mapper, column.columnAlias));
        }
        return tm.partialObjectFromArray(...fields);
    }
    exports.partialMapper = partialMapper;
});
define("column-map/util/query/table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the **first** table alias found.
     *
     * All columns in a `ColumnMap` should have the same table alias.
     * If multiple table aliases exist, the one it returns is arbitrary.
     *
     * If no columns exist, it throws an error.
     */
    function tableAlias(map) {
        const columnAliases = Object.keys(map);
        if (columnAliases.length == 0) {
            throw new Error(`No columns in ColumnMap`);
        }
        else {
            return map[columnAliases[0]].tableAlias;
        }
    }
    exports.tableAlias = tableAlias;
});
define("column-map/util/query/index", ["require", "exports", "column-map/util/query/column-alias", "column-map/util/query/extract-column-identifier", "column-map/util/query/extract-non-nullable", "column-map/util/query/extract-nullable", "column-map/util/query/mapper", "column-map/util/query/non-nullable-column-alias", "column-map/util/query/nullable-column-alias", "column-map/util/query/partial-mapper", "column-map/util/query/table-alias"], function (require, exports, column_alias_6, extract_column_identifier_2, extract_non_nullable_2, extract_nullable_2, mapper_8, non_nullable_column_alias_2, nullable_column_alias_2, partial_mapper_1, table_alias_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_alias_6);
    __export(extract_column_identifier_2);
    __export(extract_non_nullable_2);
    __export(extract_nullable_2);
    __export(mapper_8);
    __export(non_nullable_column_alias_2);
    __export(nullable_column_alias_2);
    __export(partial_mapper_1);
    __export(table_alias_1);
});
define("column-map/util/constructor/from-expr-select-item", ["require", "exports", "column-map/util/constructor/from-column", "column/index"], function (require, exports, from_column_7, column_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromExprSelectItem(item) {
        return from_column_7.fromColumn(column_34.ColumnUtil.fromExprSelectItem(item));
    }
    exports.fromExprSelectItem = fromExprSelectItem;
});
define("column-map/util/constructor/from-column-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnRef(ref) {
        const result = {};
        for (const tableAlias of Object.keys(ref)) {
            const columnMap = ref[tableAlias];
            for (const columnAlias in columnMap) {
                const column = columnMap[columnAlias];
                result[column.columnAlias] = column;
            }
        }
        return result;
    }
    exports.fromColumnRef = fromColumnRef;
});
define("column-map/util/predicate/is-null-safe-comparable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Ideally, we'd want to have run-time checks
     * ensuring columns in `a` and columns in `b`
     * have null-safe comparable types.
     *
     * However, due to how the project is structured,
     * this is not possible.
     *
     * So, at the very least, we just check
     * the columns exist.
     */
    function isNullSafeComparable(a, b) {
        /**
         * Ideally, we'd want to have run-time checks
         * ensuring columns in `a` and columns in `b`
         * have null-safe comparable types.
         *
         * However, due to how the project is structured,
         * this is not possible.
         *
         * So, at the very least, we just check
         * the columns exist.
         */
        const otherColumnAliases = Object.keys(b);
        for (const myColumnAlias of Object.keys(a)) {
            if (!otherColumnAliases.includes(myColumnAlias)) {
                /**
                 * Other column does not exist
                 */
                return false;
            }
        }
        return true;
    }
    exports.isNullSafeComparable = isNullSafeComparable;
});
define("column-map/util/predicate/assert-is-null-safe-comparable", ["require", "exports", "column-map/util/predicate/is-null-safe-comparable", "column-map/util/query/index"], function (require, exports, is_null_safe_comparable_1, query_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertIsNullSafeComparable(a, b) {
        if (!is_null_safe_comparable_1.isNullSafeComparable(a, b)) {
            const myTableAlias = query_40.tableAlias(a);
            const myColumnAliases = Object.keys(a).join(",");
            const otherTableAlias = query_40.tableAlias(b);
            const otherColumnAliases = Object.keys(a)
                .filter(myColumnAlias => (Object.prototype.hasOwnProperty.call(b, myColumnAlias) &&
                Object.prototype.propertyIsEnumerable.call(b, myColumnAlias)))
                .join(",");
            throw new Error(`${myTableAlias} (${myColumnAliases}) is not null-safe comparable to ${otherTableAlias} (${otherColumnAliases})`);
        }
    }
    exports.assertIsNullSafeComparable = assertIsNullSafeComparable;
});
define("column-map/util/predicate/assert-is-null-safe-comparable-if-same-own-enumerable-keys", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-map/util/predicate/has-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasColumnAlias(map, columnAlias) {
        return (Object.prototype.hasOwnProperty.call(map, columnAlias) &&
            Object.prototype.propertyIsEnumerable.call(map, columnAlias));
    }
    exports.hasColumnAlias = hasColumnAlias;
});
define("column-map/util/predicate/is-column-map", ["require", "exports", "column/index"], function (require, exports, column_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isColumnMap(mixed) {
        if (!(mixed instanceof Object)) {
            return false;
        }
        for (const columnAlias of Object.keys(mixed)) {
            const possiblyColumn = mixed[columnAlias];
            if (!column_35.ColumnUtil.isColumn(possiblyColumn)) {
                return false;
            }
        }
        return true;
    }
    exports.isColumnMap = isColumnMap;
});
define("column-map/util/predicate/index", ["require", "exports", "column-map/util/predicate/assert-is-null-safe-comparable", "column-map/util/predicate/has-column-alias", "column-map/util/predicate/is-column-map", "column-map/util/predicate/is-null-safe-comparable"], function (require, exports, assert_is_null_safe_comparable_1, has_column_alias_1, is_column_map_1, is_null_safe_comparable_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_is_null_safe_comparable_1);
    __export(has_column_alias_1);
    __export(is_column_map_1);
    __export(is_null_safe_comparable_2);
});
define("column-map/util/constructor/from-select-item", ["require", "exports", "column-map/util/constructor/from-column", "expr-select-item/index", "column-ref/index", "column-map/util/constructor/from-expr-select-item", "column-map/util/constructor/from-column-ref", "column/index", "column-map/util/predicate/index"], function (require, exports, from_column_8, expr_select_item_9, column_ref_19, from_expr_select_item_1, from_column_ref_1, column_36, predicate_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromSelectItem(item) {
        if (column_36.ColumnUtil.isColumn(item)) {
            return from_column_8.fromColumn(item);
        }
        else if (expr_select_item_9.ExprSelectItemUtil.isExprSelectItem(item)) {
            return from_expr_select_item_1.fromExprSelectItem(item);
        }
        else if (predicate_49.isColumnMap(item)) {
            return item;
        }
        else if (column_ref_19.ColumnRefUtil.isColumnRef(item)) {
            return from_column_ref_1.fromColumnRef(item);
        }
        else {
            throw new Error(`Unknown select item`);
        }
    }
    exports.fromSelectItem = fromSelectItem;
});
define("column-map/util/constructor/from-select-clause", ["require", "exports", "column/index", "column-map/util/constructor/from-select-item"], function (require, exports, column_37, from_select_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Assumes no duplicate `columnAlias` in `SelectClauseT`
     */
    function fromSelectClause(selectsClause, tableAlias, preserveUnaliasedAst) {
        const result = {};
        for (const item of selectsClause) {
            const map = from_select_item_1.fromSelectItem(item);
            for (const columnAlias of Object.keys(map)) {
                if (preserveUnaliasedAst) {
                    result[columnAlias] = column_37.ColumnUtil.withTableAlias(map[columnAlias], tableAlias);
                }
                else {
                    result[columnAlias] = column_37.ColumnUtil.withUnaliasedAst(column_37.ColumnUtil.withTableAlias(map[columnAlias], tableAlias), undefined);
                }
            }
        }
        return result;
    }
    exports.fromSelectClause = fromSelectClause;
});
define("column-map/util/constructor/index", ["require", "exports", "column-map/util/constructor/from-column-array", "column-map/util/constructor/from-column", "column-map/util/constructor/from-field-array", "column-map/util/constructor/from-join", "column-map/util/constructor/from-mapper-map", "column-map/util/constructor/from-select-clause"], function (require, exports, from_column_array_3, from_column_9, from_field_array_1, from_join_2, from_mapper_map_1, from_select_clause_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_array_3);
    __export(from_column_9);
    __export(from_field_array_1);
    __export(from_join_2);
    __export(from_mapper_map_1);
    __export(from_select_clause_2);
});
define("column-map/util/index", ["require", "exports", "column-map/util/constructor/index", "column-map/util/operation/index", "column-map/util/predicate/index", "column-map/util/query/index"], function (require, exports, constructor_14, operation_31, predicate_50, query_41) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_14);
    __export(operation_31);
    __export(predicate_50);
    __export(query_41);
});
define("column-map/index", ["require", "exports", "column-map/util/index"], function (require, exports, ColumnMapUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnMapUtil = ColumnMapUtil;
});
define("column/util/constructor/from-column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(map) {
        const result = [];
        for (const columnAlias of Object.keys(map)) {
            result.push(map[columnAlias]);
        }
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
});
define("column/util/constructor/from-column-ref", ["require", "exports", "column/util/constructor/from-column-map"], function (require, exports, from_column_map_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnRef(ref) {
        const result = [];
        for (const tableAlias of Object.keys(ref)) {
            const map = ref[tableAlias];
            result.push(...from_column_map_3.fromColumnMap(map));
        }
        return result;
    }
    exports.fromColumnRef = fromColumnRef;
});
define("expr-column/expr-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr-column/expr-column-impl", ["require", "exports", "column/index"], function (require, exports, column_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ExprColumn {
        /**
         * You should never need to explicitly instantiate an `ExprColumn`.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data, unaliasedAst) {
            this.tableAlias = data.tableAlias;
            this.columnAlias = data.columnAlias;
            this.mapper = data.mapper;
            this.isAggregate = data.isAggregate;
            this.unaliasedAst = unaliasedAst;
        }
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC
         * ```
         */
        asc() {
            return column_38.ColumnUtil.asc(this);
        }
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn DESC
         * ```
         */
        desc() {
            return column_38.ColumnUtil.desc(this);
        }
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC,
         *  myTable.myOtherColumn DESC
         * ```
         */
        sort(sortDirection) {
            return column_38.ColumnUtil.sort(this, sortDirection);
        }
    }
    exports.ExprColumn = ExprColumn;
});
define("expr-column/util/predicate/is-expr-column", ["require", "exports", "type-util/index", "ast/index"], function (require, exports, type_util_20, ast_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isExprColumn(raw) {
        if (!type_util_20.isObjectWithOwnEnumerableKeys()(raw, [
            "tableAlias",
            "columnAlias",
            "mapper",
            "isAggregate",
            "unaliasedAst",
        ])) {
            return false;
        }
        return ((typeof raw.tableAlias == "string") &&
            (typeof raw.columnAlias == "string") &&
            (typeof raw.mapper == "function") &&
            (typeof raw.isAggregate == "boolean") &&
            (raw.unaliasedAst == undefined ||
                ast_8.AstUtil.isAst(raw.unaliasedAst)));
    }
    exports.isExprColumn = isExprColumn;
});
define("expr-column/util/predicate/index", ["require", "exports", "expr-column/util/predicate/is-expr-column"], function (require, exports, is_expr_column_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_expr_column_1);
});
define("expr-column/util/index", ["require", "exports", "expr-column/util/predicate/index"], function (require, exports, predicate_51) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_51);
});
define("expr-column/index", ["require", "exports", "expr-column/expr-column-impl", "expr-column/util/index"], function (require, exports, expr_column_impl_1, ExprColumnUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(expr_column_impl_1);
    exports.ExprColumnUtil = ExprColumnUtil;
});
define("column/util/constructor/from-expr-select-item", ["require", "exports", "expr-column/index"], function (require, exports, expr_column_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromExprSelectItem(exprSelectItem) {
        const result = new expr_column_1.ExprColumn({
            tableAlias: exprSelectItem.tableAlias,
            columnAlias: exprSelectItem.alias,
            mapper: exprSelectItem.mapper,
            isAggregate: exprSelectItem.isAggregate,
        }, exprSelectItem.unaliasedAst);
        return result;
    }
    exports.fromExprSelectItem = fromExprSelectItem;
});
define("column/util/constructor/from-join", ["require", "exports", "column-map/index", "column/util/constructor/from-column-map"], function (require, exports, column_map_25, from_column_map_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromJoin(join) {
        const result = from_column_map_4.fromColumnMap(column_map_25.ColumnMapUtil.fromJoin(join));
        return result;
    }
    exports.fromJoin = fromJoin;
});
define("column/util/constructor/from-join-array", ["require", "exports", "column/util/constructor/from-join"], function (require, exports, from_join_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromJoinArray(joins) {
        const result = [];
        for (const join of joins) {
            result.push(...from_join_3.fromJoin(join));
        }
        return result;
    }
    exports.fromJoinArray = fromJoinArray;
});
define("column/util/constructor/from-select-item", ["require", "exports", "expr-select-item/index", "column/util/constructor/from-expr-select-item", "column-ref/index", "column/util/constructor/from-column-ref", "column-map/index", "column/util/constructor/from-column-map", "column/index"], function (require, exports, expr_select_item_10, from_expr_select_item_2, column_ref_20, from_column_ref_2, column_map_26, from_column_map_5, column_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromSelectItem(selectItem) {
        if (expr_select_item_10.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            return [from_expr_select_item_2.fromExprSelectItem(selectItem)];
        }
        else if (column_39.ColumnUtil.isColumn(selectItem)) {
            return [selectItem];
        }
        else if (column_map_26.ColumnMapUtil.isColumnMap(selectItem)) {
            return from_column_map_5.fromColumnMap(selectItem);
        }
        else if (column_ref_20.ColumnRefUtil.isColumnRef(selectItem)) {
            return from_column_ref_2.fromColumnRef(selectItem);
        }
        else {
            throw new Error(`Unknown SelectItem`);
        }
    }
    exports.fromSelectItem = fromSelectItem;
});
define("column/util/constructor/from-select-clause", ["require", "exports", "column/util/constructor/from-select-item"], function (require, exports, from_select_item_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Does not remove duplicate identifiers
     *
     * @param selectClause
     */
    function fromSelectClause(selectClause) {
        const result = [];
        for (const selectItem of selectClause) {
            result.push(...from_select_item_2.fromSelectItem(selectItem));
        }
        return result;
    }
    exports.fromSelectClause = fromSelectClause;
});
define("column/util/constructor/index", ["require", "exports", "column/util/constructor/from-column-map", "column/util/constructor/from-column-ref", "column/util/constructor/from-expr-select-item", "column/util/constructor/from-join-array", "column/util/constructor/from-join", "column/util/constructor/from-select-clause", "column/util/constructor/from-select-item"], function (require, exports, from_column_map_6, from_column_ref_3, from_expr_select_item_3, from_join_array_4, from_join_4, from_select_clause_3, from_select_item_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_6);
    __export(from_column_ref_3);
    __export(from_expr_select_item_3);
    __export(from_join_array_4);
    __export(from_join_4);
    __export(from_select_clause_3);
    __export(from_select_item_3);
});
define("column/util/operation/build-ast", ["require", "exports", "constants", "ast/index"], function (require, exports, constants_3, ast_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function buildAst({ tableAlias, columnAlias, unaliasedAst, }) {
        if (tableAlias == constants_3.ALIASED) {
            /**
             * When you want to write,
             * `(1 + 2) AS three`
             *
             * You write,
             * `add(1, 2).as("three")`
             *
             * This `"three"` is an `IExprSelectItem` but has no `tableAlias`
             * associated with it.
             *
             * So, this library makes up a table alias that is very
             * unlikely to be used naturally by others.
             *
             * The table alias is the value of the variable `ALIASED`,
             * which should be `$aliased`
             */
            return ast_9.identifierNode(`${tableAlias}${constants_3.SEPARATOR}${columnAlias}`);
        }
        else {
            if (unaliasedAst == undefined) {
                /*
                    The most common case, I think.
                */
                return ast_9.identifierNode(tableAlias, columnAlias);
            }
            else {
                /**
                 * @todo Investigate what should be here.
                 * Does the `SELECT` clause even ever have an `IColumn` with `unaliasedAst` set?
                 * Initial inspection says "No"
                 */
                //throw new Error(`Should use unaliasedAst, tableAlias, columnAlias in SELECT clause, use tableAlias, columnAlias in ORDER BY clause`);
                return ast_9.identifierNode(`${tableAlias}${constants_3.SEPARATOR}${columnAlias}`);
            }
        }
    }
    exports.buildAst = buildAst;
});
define("aliased-expr/aliased-expr-impl", ["require", "exports", "expr/index"], function (require, exports, expr_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An aliased expression
     *
     * ```sql
     *  SELECT
     *      (1+2) AS x --This is an `AliasedExpr`
     * ```
     *
     * -----
     *
     * ### Using `AliasedExpr` as "normal" expression
     *
     * Normally, you cannot use an aliased expression as a "normal" expression.
     *
     * This is usually invalid,
     * ```sql
     *  SELECT
     *      (((1+2) AS x) + 3) AS y
     * ```
     *
     * However, `tsql` allows this!
     *
     * When the query is generated, it extracts the inner unaliased expression,
     *
     * ```sql
     *  SELECT
     *      ((1+2) + 3) AS y
     * ```
     *
     * -----
     *
     * Allowing the above lets us write composable expressions that
     * can also be used in `SELECT` clauses more consistently!
     *
     * For example,
     * ```ts
     *  function x () {
     *      return tsql.add(1, 2).as("x");
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //SELECT (1+2) AS x, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     * If we did not allow aliased expressions to be used as "normal" expressions,
     * we would have an increased risk of typos,
     *
     * ```ts
     *  function x () {
     *      //Removed `.as("x")`
     *      return tsql.add(1, 2);
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x().as("x"),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //Intended: SELECT (1+2) AS x, (1+2+3+4+5) AS y
     *  //Actual  : SELECT (1+2) AS typo, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x().as("typo"),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     * -----
     *
     * ### Re-aliasing
     *
     * Normally, you can only alias an expression once,
     * ```sql
     *  SELECT
     *      (1+2) AS x AS y --Error: Cannot alias an expression more than once!
     * ```
     *
     * However, `tsql` allows this!
     *
     * When the query is generated, it uses the **last** set alias,
     * ```sql
     *  SELECT
     *      (1+2) AS y
     * ```
     *
     * -----
     *
     * With re-aliasing, you can set a **default alias** for your composable expressions.
     * Then, when you want a different alias, you can change it.
     *
     * For example,
     * ```ts
     *  function x () {
     *      //Default alias is `x`
     *      return tsql.add(1, 2).as("x");
     *  }
     *  //SELECT (1+2) AS x, (1+2+3) AS y
     *  tsql.select(() => [
     *      x(),
     *      tsql.add(x(), 3).as("y"),
     *  ]);
     *  //SELECT (1+2) AS realiased, (1+2+3+4+5) AS y
     *  tsql.select(() => [
     *      x().as("realiased"),
     *      tsql.add(x(), 3, 4, 5).as("y"),
     *  ]);
     * ```
     *
     */
    class AliasedExpr extends expr_15.ExprImpl {
        constructor(data, ast) {
            super(data, ast);
            this.tableAlias = data.tableAlias;
            this.alias = data.alias;
            this.unaliasedAst = ast;
        }
    }
    exports.AliasedExpr = AliasedExpr;
});
define("aliased-expr/index", ["require", "exports", "aliased-expr/aliased-expr-impl"], function (require, exports, aliased_expr_impl_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aliased_expr_impl_1);
});
define("column/util/operation/as", ["require", "exports", "column/util/operation/build-ast", "used-ref/index", "aliased-expr/index"], function (require, exports, build_ast_2, used_ref_23, aliased_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function as(column, alias) {
        return new aliased_expr_1.AliasedExpr({
            usedRef: used_ref_23.UsedRefUtil.fromColumn(column),
            mapper: column.mapper,
            tableAlias: column.tableAlias,
            alias: alias,
            isAggregate: false,
        }, build_ast_2.buildAst(column));
        /*
        return {
            usedRef : UsedRefUtil.fromColumn(column),
            mapper : column.mapper,
            tableAlias : column.tableAlias,
            alias : alias,
            unaliasedAst : buildAst(column),
        };
        */
    }
    exports.as = as;
});
define("column/util/operation/asc", ["require", "exports", "sort-direction/index"], function (require, exports, sort_direction_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function asc(column) {
        return [column, sort_direction_7.SortDirection.ASC];
    }
    exports.asc = asc;
});
define("column/util/operation/desc", ["require", "exports", "sort-direction/index"], function (require, exports, sort_direction_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function desc(column) {
        return [column, sort_direction_8.SortDirection.DESC];
    }
    exports.desc = desc;
});
define("column/util/operation/sort", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function sort(column, sortDirection) {
        return [column, sortDirection];
    }
    exports.sort = sort;
});
define("column/util/operation/to-non-nullable", ["require", "exports", "type-mapping", "column/column-impl"], function (require, exports, tm, column_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toNonNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
        return new column_impl_1.Column({
            tableAlias,
            columnAlias,
            mapper: tm.notNull(mapper),
        }, unaliasedAst);
    }
    exports.toNonNullable = toNonNullable;
});
define("column/util/operation/to-nullable", ["require", "exports", "type-mapping", "column/column-impl"], function (require, exports, tm, column_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toNullable({ tableAlias, columnAlias, mapper, unaliasedAst, }) {
        return new column_impl_2.Column({
            tableAlias,
            columnAlias,
            mapper: tm.orNull(mapper),
        }, unaliasedAst);
    }
    exports.toNullable = toNullable;
});
define("column/util/operation/to-error-message-friendly-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column/util/operation/with-table-alias", ["require", "exports", "column/column-impl"], function (require, exports, column_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function withTableAlias({ columnAlias, mapper, unaliasedAst, }, newTableAlias) {
        const result = new column_impl_3.Column({
            tableAlias: newTableAlias,
            columnAlias,
            mapper,
        }, unaliasedAst);
        return result;
    }
    exports.withTableAlias = withTableAlias;
});
define("column/util/operation/with-type", ["require", "exports", "column/column-impl"], function (require, exports, column_impl_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function withType({ tableAlias, columnAlias, unaliasedAst, }, newMapper) {
        const result = new column_impl_4.Column({
            tableAlias,
            columnAlias,
            mapper: newMapper,
        }, unaliasedAst);
        return result;
    }
    exports.withType = withType;
});
define("column/util/operation/with-unaliased-ast", ["require", "exports", "column/column-impl"], function (require, exports, column_impl_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function withUnaliasedAst({ tableAlias, columnAlias, mapper, }, unaliasedAst) {
        const result = new column_impl_5.Column({
            tableAlias,
            columnAlias,
            mapper,
        }, unaliasedAst);
        return result;
    }
    exports.withUnaliasedAst = withUnaliasedAst;
});
define("column/util/operation/index", ["require", "exports", "column/util/operation/as", "column/util/operation/asc", "column/util/operation/build-ast", "column/util/operation/desc", "column/util/operation/sort", "column/util/operation/to-non-nullable", "column/util/operation/to-nullable", "column/util/operation/with-table-alias", "column/util/operation/with-type", "column/util/operation/with-unaliased-ast"], function (require, exports, as_3, asc_2, build_ast_3, desc_2, sort_2, to_non_nullable_1, to_nullable_2, with_table_alias_2, with_type_2, with_unaliased_ast_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(as_3);
    __export(asc_2);
    __export(build_ast_3);
    __export(desc_2);
    __export(sort_2);
    __export(to_non_nullable_1);
    __export(to_nullable_2);
    __export(with_table_alias_2);
    __export(with_type_2);
    __export(with_unaliased_ast_1);
});
define("column/util/predicate/is-column", ["require", "exports", "type-util/index", "ast/index"], function (require, exports, type_util_21, ast_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isColumn(raw) {
        if (!type_util_21.isObjectWithOwnEnumerableKeys()(raw, [
            "tableAlias",
            "columnAlias",
            "mapper",
            "unaliasedAst",
        ])) {
            return false;
        }
        return ((typeof raw.tableAlias == "string") &&
            (typeof raw.columnAlias == "string") &&
            (typeof raw.mapper == "function") &&
            (raw.unaliasedAst == undefined ||
                ast_10.AstUtil.isAst(raw.unaliasedAst)));
    }
    exports.isColumn = isColumn;
});
define("column/util/predicate/index", ["require", "exports", "column/util/predicate/is-column"], function (require, exports, is_column_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_column_1);
});
define("column/util/query/extract-non-nullable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column/util/query/extract-nullable", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractNullable(columns) {
        const result = [];
        for (const column of columns) {
            if (tm.canOutputNull(column.mapper)) {
                result.push(column);
            }
        }
        return result;
    }
    exports.extractNullable = extractNullable;
});
define("column/util/query/extract-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column/util/query/extract-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column/util/query/extract-with-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column/util/query/index", ["require", "exports", "column/util/query/extract-nullable"], function (require, exports, extract_nullable_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_nullable_3);
});
define("column/util/index", ["require", "exports", "column/util/constructor/index", "column/util/operation/index", "column/util/predicate/index", "column/util/query/index"], function (require, exports, constructor_15, operation_32, predicate_52, query_42) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_15);
    __export(operation_32);
    __export(predicate_52);
    __export(query_42);
});
define("column/column-impl", ["require", "exports", "column/util/index"], function (require, exports, ColumnUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Column {
        /**
         * You should never need to explicitly instantiate a `Column`.
         * Use `myTable.addColumns()` instead.
         *
         * @param data
         * @param unaliasedAst
         */
        constructor(data, unaliasedAst) {
            this.tableAlias = data.tableAlias;
            this.columnAlias = data.columnAlias;
            this.mapper = data.mapper;
            this.unaliasedAst = unaliasedAst;
        }
        /**
         * ```sql
         * SELECT
         *  myTable.myColumn AS alias
         * FROM
         *  myTable
         * ```
         *
         * @param alias - The new column name
         */
        as(alias) {
            return ColumnUtil.as(this, alias);
        }
        ;
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC
         * ```
         */
        asc() {
            return ColumnUtil.asc(this);
        }
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn DESC
         * ```
         */
        desc() {
            return ColumnUtil.desc(this);
        }
        /**
         * ```sql
         * SELECT
         *  *
         * FROM
         *  myTable
         * ORDER BY
         *  myTable.myColumn ASC,
         *  myTable.myOtherColumn DESC
         * ```
         */
        sort(sortDirection) {
            return ColumnUtil.sort(this, sortDirection);
        }
    }
    exports.Column = Column;
});
define("column/array-util/constructor/from-column-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(columnMap) {
        const result = [];
        for (const columnAlias of Object.keys(columnMap)) {
            result.push(columnMap[columnAlias]);
        }
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
    function fromColumnMapArray(columnMapArr) {
        const result = [];
        for (const columnMap of columnMapArr) {
            for (const columnAlias of Object.keys(columnMap)) {
                result.push(columnMap[columnAlias]);
            }
        }
        return result;
    }
    exports.fromColumnMapArray = fromColumnMapArray;
});
define("column/array-util/constructor/index", ["require", "exports", "column/array-util/constructor/from-column-map"], function (require, exports, from_column_map_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_7);
});
define("column/array-util/index", ["require", "exports", "column/array-util/constructor/index"], function (require, exports, constructor_16) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_16);
});
define("column/index", ["require", "exports", "column/column-impl", "column/array-util/index", "column/util/index"], function (require, exports, column_impl_6, ColumnArrayUtil, ColumnUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_impl_6);
    exports.ColumnArrayUtil = ColumnArrayUtil;
    exports.ColumnUtil = ColumnUtil;
});
define("select-item/select-item", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-item/util/predicate/is-single-value-select-item", ["require", "exports", "column/index", "expr-select-item/index"], function (require, exports, column_40, expr_select_item_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSingleValueSelectItem(x) {
        return (column_40.ColumnUtil.isColumn(x) ||
            expr_select_item_11.ExprSelectItemUtil.isExprSelectItem(x));
    }
    exports.isSingleValueSelectItem = isSingleValueSelectItem;
});
define("select-item/util/predicate/index", ["require", "exports", "select-item/util/predicate/is-single-value-select-item"], function (require, exports, is_single_value_select_item_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_single_value_select_item_1);
});
define("select-item/util/query/column-alias", ["require", "exports", "column/index", "expr-select-item/index", "column-map/index", "column-ref/index"], function (require, exports, column_41, expr_select_item_12, column_map_27, column_ref_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function columnAlias(item) {
        if (column_41.ColumnUtil.isColumn(item)) {
            return [item.columnAlias];
        }
        else if (expr_select_item_12.ExprSelectItemUtil.isExprSelectItem(item)) {
            return [item.alias];
        }
        else if (column_map_27.ColumnMapUtil.isColumnMap(item)) {
            return column_map_27.ColumnMapUtil.columnAlias(item);
        }
        else if (column_ref_21.ColumnRefUtil.isColumnRef(item)) {
            return column_ref_21.ColumnRefUtil.columnAlias(item);
        }
        else {
            throw new Error("Unknown select item");
        }
    }
    exports.columnAlias = columnAlias;
});
define("select-item/util/query/type-of", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-item/util/query/index", ["require", "exports", "select-item/util/query/column-alias"], function (require, exports, column_alias_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_alias_7);
});
define("select-item/util/index", ["require", "exports", "select-item/util/predicate/index", "select-item/util/query/index"], function (require, exports, predicate_53, query_43) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_53);
    __export(query_43);
});
define("select-item/index", ["require", "exports", "select-item/util/index"], function (require, exports, SelectItemUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectItemUtil = SelectItemUtil;
});
define("select-clause/select-clause", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-clause/util/constructor/value-from-built-in-expr", ["require", "exports", "expr/index", "expr-select-item/index", "column/index"], function (require, exports, expr_16, expr_select_item_13, column_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SELECT_VALUE_ALIAS = "value";
    function valueFromBuiltInExpr(builtInExpr) {
        if (column_42.ColumnUtil.isColumn(builtInExpr) || expr_select_item_13.ExprSelectItemUtil.isExprSelectItem(builtInExpr)) {
            return [builtInExpr];
        }
        else {
            return [
                expr_16.ExprUtil.as(expr_16.ExprUtil.fromBuiltInExpr(builtInExpr), exports.SELECT_VALUE_ALIAS)
            ];
        }
    }
    exports.valueFromBuiltInExpr = valueFromBuiltInExpr;
});
define("select-clause/util/constructor/index", ["require", "exports", "select-clause/util/constructor/value-from-built-in-expr"], function (require, exports, value_from_built_in_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(value_from_built_in_expr_1);
});
define("select-clause/util/operation/left-compound", ["require", "exports", "type-mapping", "column/index", "expr-select-item/index", "column-map/index", "column-ref/index"], function (require, exports, tm, column_43, expr_select_item_14, column_map_28, column_ref_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Assumes `A` is shorter than, or the same length as `B`
     */
    function leftCompound(a, b) {
        const result = [];
        for (let i = 0; i < a.length; ++i) {
            const itemA = a[i];
            const itemB = b[i];
            if (column_43.ColumnUtil.isColumn(itemA)) {
                if (column_43.ColumnUtil.isColumn(itemB) || expr_select_item_14.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                    result.push(column_43.ColumnUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
                }
                else {
                    throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
                }
            }
            else if (expr_select_item_14.ExprSelectItemUtil.isExprSelectItem(itemA)) {
                if (column_43.ColumnUtil.isColumn(itemB) || expr_select_item_14.ExprSelectItemUtil.isExprSelectItem(itemB)) {
                    result.push(expr_select_item_14.ExprSelectItemUtil.withType(itemA, tm.or(itemA.mapper, itemB.mapper)));
                }
                else {
                    throw new Error(`Expected index ${i} to be Column or ExprSelectItem`);
                }
            }
            else if (column_map_28.ColumnMapUtil.isColumnMap(itemA)) {
                if (column_map_28.ColumnMapUtil.isColumnMap(itemB)) {
                    result.push(column_map_28.ColumnMapUtil.compound(itemA, itemB));
                }
                else {
                    throw new Error(`Expected index ${i} to be ColumnMap`);
                }
            }
            else if (column_ref_22.ColumnRefUtil.isColumnRef(itemA)) {
                if (column_ref_22.ColumnRefUtil.isColumnRef(itemB)) {
                    result.push(column_ref_22.ColumnRefUtil.compound(itemA, itemB));
                }
                else {
                    throw new Error(`Expected index ${i} to be ColumnMap`);
                }
            }
            else {
                throw new Error(`Unknown SELECT item at index ${i}`);
            }
        }
        return result;
    }
    exports.leftCompound = leftCompound;
});
define("select-clause/select-value-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-clause/util/query/allowed-non-aggregate-used-ref", ["require", "exports", "column-ref/index", "used-ref/index"], function (require, exports, column_ref_23, used_ref_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedNonAggregateColumnRef(fromClause, groupByClause) {
        const outer = column_ref_23.ColumnRefUtil.fromJoinArray(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins);
        const inner = column_ref_23.ColumnRefUtil.extractColumnIdentifiers(column_ref_23.ColumnRefUtil.fromJoinArray(fromClause.currentJoins == undefined ?
            [] :
            fromClause.currentJoins), groupByClause);
        return column_ref_23.ColumnRefUtil.intersect(outer, inner);
    }
    exports.allowedNonAggregateColumnRef = allowedNonAggregateColumnRef;
    function allowedNonAggregateUsedRef(fromClause, groupByClause) {
        return used_ref_24.UsedRefUtil.fromColumnRef(allowedNonAggregateColumnRef(fromClause, groupByClause));
    }
    exports.allowedNonAggregateUsedRef = allowedNonAggregateUsedRef;
});
define("select-clause/util/query/allowed-used-ref", ["require", "exports", "from-clause/index"], function (require, exports, from_clause_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function allowedColumnRef(fromClause) {
        return from_clause_32.FromClauseUtil.allowedColumnRef(fromClause, { isLateral: true });
    }
    exports.allowedColumnRef = allowedColumnRef;
    function allowedUsedRef(fromClause) {
        return from_clause_32.FromClauseUtil.allowedUsedRef(fromClause, { isLateral: true });
    }
    exports.allowedUsedRef = allowedUsedRef;
});
define("select-clause/util/query/column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-clause/util/query/column-alias-ignore-index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-clause/util/query/duplicate-column-alias", ["require", "exports", "select-item/index", "column-ref/index"], function (require, exports, select_item_2, column_ref_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function duplicateColumnAlias(selectClause) {
        const duplicateTracker = {};
        const result = [];
        for (const item of selectClause) {
            for (const columnAlias of select_item_2.SelectItemUtil.columnAlias(item)) {
                const isDuplicate = duplicateTracker[columnAlias];
                if (isDuplicate === undefined) {
                    /**
                     * We had never encountered it, and now we have.
                     * But it isn't a duplicate.
                     */
                    duplicateTracker[columnAlias] = false;
                }
                else if (!isDuplicate) {
                    /**
                     * We had encountered it when it wasn't a duplicate.
                     * Now, it is a duplicate.
                     */
                    duplicateTracker[columnAlias] = true;
                    result.push(columnAlias);
                }
            }
            if (column_ref_24.ColumnRefUtil.isColumnRef(item)) {
                for (const columnAlias of column_ref_24.ColumnRefUtil.duplicateColumnAlias(item)) {
                    const isDuplicate = duplicateTracker[columnAlias];
                    if (isDuplicate === undefined) {
                        /**
                         * We had never encountered it, and now we have.
                         * But it isn't a duplicate.
                         */
                        duplicateTracker[columnAlias] = false;
                    }
                    else if (!isDuplicate) {
                        /**
                         * We had encountered it when it wasn't a duplicate.
                         * Now, it is a duplicate.
                         */
                        duplicateTracker[columnAlias] = true;
                        result.push(columnAlias);
                    }
                }
            }
        }
        return result;
    }
    exports.duplicateColumnAlias = duplicateColumnAlias;
});
define("select-clause/util/query/index", ["require", "exports", "select-clause/util/query/allowed-non-aggregate-used-ref", "select-clause/util/query/allowed-used-ref", "select-clause/util/query/duplicate-column-alias"], function (require, exports, allowed_non_aggregate_used_ref_3, allowed_used_ref_9, duplicate_column_alias_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(allowed_non_aggregate_used_ref_3);
    __export(allowed_used_ref_9);
    __export(duplicate_column_alias_2);
});
define("select-clause/util/predicate/assert-valid-column-identifier", ["require", "exports", "column-identifier/index"], function (require, exports, column_identifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidColumnIdentifier(selectClause, selects) {
        const selectsIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selects);
        column_identifier_1.ColumnIdentifierArrayUtil.assertNoDuplicate(selectsIdentifiers);
        if (selectClause != undefined) {
            const selectClauseIdentifiers = column_identifier_1.ColumnIdentifierUtil.fromSelectClause(selectClause);
            column_identifier_1.ColumnIdentifierArrayUtil.assertDisjoint(selectClauseIdentifiers, selectsIdentifiers);
        }
    }
    exports.assertValidColumnIdentifier = assertValidColumnIdentifier;
});
define("select-clause/util/predicate/assert-valid-used-ref-aggregate", ["require", "exports", "expr-select-item/index", "used-ref/index", "select-clause/util/query/index"], function (require, exports, expr_select_item_15, used_ref_25, query_44) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidUsedRef_Aggregate(fromClause, selects) {
        const columns = query_44.allowedColumnRef(fromClause);
        for (const selectItem of selects) {
            if (expr_select_item_15.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
                if (selectItem.isAggregate) {
                    used_ref_25.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
                }
            }
        }
    }
    exports.assertValidUsedRef_Aggregate = assertValidUsedRef_Aggregate;
});
define("select-clause/util/predicate/assert-valid-used-ref-non-aggregate", ["require", "exports", "expr-select-item/index", "used-ref/index", "column/index", "column-map/index", "select-clause/util/query/index", "column-identifier-ref/index"], function (require, exports, expr_select_item_16, used_ref_26, column_44, column_map_29, query_45, column_identifier_ref_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects) {
        const columns = query_45.allowedNonAggregateColumnRef(fromClause, groupByClause);
        for (const selectItem of selects) {
            if (expr_select_item_16.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
                if (!selectItem.isAggregate) {
                    used_ref_26.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
                }
            }
            else if (column_44.ColumnUtil.isColumn(selectItem)) {
                column_identifier_ref_11.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
            }
            else if (column_map_29.ColumnMapUtil.isColumnMap(selectItem)) {
                used_ref_26.UsedRefUtil.assertAllowed({ columns }, used_ref_26.UsedRefUtil.fromColumnMap(selectItem));
            }
            else {
                used_ref_26.UsedRefUtil.assertAllowed({ columns }, used_ref_26.UsedRefUtil.fromColumnRef(selectItem));
            }
        }
    }
    exports.assertValidUsedRef_NonAggregate = assertValidUsedRef_NonAggregate;
});
define("select-clause/util/predicate/assert-valid-used-ref", ["require", "exports", "expr-select-item/index", "used-ref/index", "column/index", "column-map/index", "select-clause/util/query/index", "column-identifier-ref/index"], function (require, exports, expr_select_item_17, used_ref_27, column_45, column_map_30, query_46, column_identifier_ref_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidUsedRef(fromClause, selects) {
        const columns = query_46.allowedColumnRef(fromClause);
        for (const selectItem of selects) {
            if (expr_select_item_17.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
                used_ref_27.UsedRefUtil.assertAllowed({ columns }, selectItem.usedRef);
            }
            else if (column_45.ColumnUtil.isColumn(selectItem)) {
                column_identifier_ref_12.ColumnIdentifierRefUtil.assertHasColumnIdentifier(columns, selectItem);
            }
            else if (column_map_30.ColumnMapUtil.isColumnMap(selectItem)) {
                used_ref_27.UsedRefUtil.assertAllowed({ columns }, used_ref_27.UsedRefUtil.fromColumnMap(selectItem));
            }
            else {
                used_ref_27.UsedRefUtil.assertAllowed({ columns }, used_ref_27.UsedRefUtil.fromColumnRef(selectItem));
            }
        }
    }
    exports.assertValidUsedRef = assertValidUsedRef;
});
define("select-clause/util/predicate/index", ["require", "exports", "select-clause/util/predicate/assert-valid-column-identifier", "select-clause/util/predicate/assert-valid-used-ref-aggregate", "select-clause/util/predicate/assert-valid-used-ref-non-aggregate", "select-clause/util/predicate/assert-valid-used-ref"], function (require, exports, assert_valid_column_identifier_1, assert_valid_used_ref_aggregate_1, assert_valid_used_ref_non_aggregate_1, assert_valid_used_ref_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_valid_column_identifier_1);
    __export(assert_valid_used_ref_aggregate_1);
    __export(assert_valid_used_ref_non_aggregate_1);
    __export(assert_valid_used_ref_2);
});
define("select-clause/util/operation/select", ["require", "exports", "column-ref/index", "select-clause/util/query/index", "expr-select-item/index", "select-clause/util/predicate/index"], function (require, exports, column_ref_25, query_47, expr_select_item_18, predicate_54) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the MySQL equivalent of `...selectClause, ...selectClauseDelegate(fromClause)`
     *
     * @param fromClause
     * @param selectClause
     * @param selectDelegate
     *
     * @todo This should only be allowed **BEFORE** the `COMPOUND QUERY` clause.
     * If we `SELECT` after the `COMPOUND QUERY` clause, it'll change the number of columns, leading to bugs.
     */
    function select(fromClause, groupByClause, selectClause, selectDelegate) {
        const columns = query_47.allowedColumnRef(fromClause);
        const selects = selectDelegate(column_ref_25.ColumnRefUtil.tryFlatten(columns));
        predicate_54.assertValidColumnIdentifier(selectClause, selects);
        if (groupByClause == undefined) {
            if (selects.some(selectItem => expr_select_item_18.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate) ||
                (selectClause != undefined &&
                    selectClause.some(selectItem => expr_select_item_18.ExprSelectItemUtil.isExprSelectItem(selectItem) && selectItem.isAggregate))) {
                predicate_54.assertValidUsedRef_Aggregate(fromClause, selects);
                predicate_54.assertValidUsedRef_NonAggregate(fromClause, [], selects);
            }
            else {
                predicate_54.assertValidUsedRef(fromClause, selects);
            }
        }
        else {
            predicate_54.assertValidUsedRef_Aggregate(fromClause, selects);
            predicate_54.assertValidUsedRef_NonAggregate(fromClause, groupByClause, selects);
        }
        return (selectClause == undefined ?
            selects :
            [...selectClause, ...selects]);
    }
    exports.select = select;
});
define("select-clause/util/operation/select-value", ["require", "exports", "select-clause/util/operation/select", "select-clause/util/constructor/index"], function (require, exports, select_3, constructor_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  myQuery
     *      .select(() => [myExpr.as("value")])
     * ```
     *
     * Intended usage,
     * ```ts
     *  myQuery
     *      .selectValue(() => myExpr)
     * ```
     */
    function selectValue(fromClause, groupByClause, selectClause, selectValueDelegate) {
        return select_3.select(fromClause, groupByClause, selectClause, columns => constructor_17.valueFromBuiltInExpr(selectValueDelegate(columns)));
    }
    exports.selectValue = selectValue;
});
define("select-clause/util/operation/index", ["require", "exports", "select-clause/util/operation/left-compound", "select-clause/util/operation/select-value", "select-clause/util/operation/select"], function (require, exports, left_compound_4, select_value_2, select_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(left_compound_4);
    __export(select_value_2);
    __export(select_4);
});
define("select-clause/util/index", ["require", "exports", "select-clause/util/constructor/index", "select-clause/util/operation/index", "select-clause/util/predicate/index", "select-clause/util/query/index"], function (require, exports, constructor_18, operation_33, predicate_55, query_48) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_18);
    __export(operation_33);
    __export(predicate_55);
    __export(query_48);
});
define("select-clause/select-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("select-clause/index", ["require", "exports", "select-clause/util/index"], function (require, exports, SelectClauseUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectClauseUtil = SelectClauseUtil;
});
define("column-identifier/util/constructor/from-select-item", ["require", "exports", "expr-select-item/index", "column-identifier/util/constructor/from-expr-select-item", "column-identifier/util/constructor/from-column", "column-ref/index", "column-identifier/util/constructor/from-column-ref", "column-map/index", "column-identifier/util/constructor/from-column-map", "column/index"], function (require, exports, expr_select_item_19, from_expr_select_item_4, from_column_10, column_ref_26, from_column_ref_4, column_map_31, from_column_map_8, column_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromSelectItem(selectItem) {
        if (expr_select_item_19.ExprSelectItemUtil.isExprSelectItem(selectItem)) {
            return [from_expr_select_item_4.fromExprSelectItem(selectItem)];
        }
        else if (column_46.ColumnUtil.isColumn(selectItem)) {
            return [from_column_10.fromColumn(selectItem)];
        }
        else if (column_map_31.ColumnMapUtil.isColumnMap(selectItem)) {
            return from_column_map_8.fromColumnMap(selectItem);
        }
        else if (column_ref_26.ColumnRefUtil.isColumnRef(selectItem)) {
            return from_column_ref_4.fromColumnRef(selectItem);
        }
        else {
            throw new Error(`Unknown SelectItem`);
        }
    }
    exports.fromSelectItem = fromSelectItem;
});
define("column-identifier/util/constructor/from-select-clause", ["require", "exports", "column-identifier/util/constructor/from-select-item"], function (require, exports, from_select_item_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Does not remove duplicate identifiers
     *
     * @param selectClause
     */
    function fromSelectClause(selectClause) {
        const result = [];
        for (const selectItem of selectClause) {
            result.push(...from_select_item_4.fromSelectItem(selectItem));
        }
        return result;
    }
    exports.fromSelectClause = fromSelectClause;
});
define("column-identifier/util/constructor/index", ["require", "exports", "column-identifier/util/constructor/from-column-map", "column-identifier/util/constructor/from-column-ref", "column-identifier/util/constructor/from-column", "column-identifier/util/constructor/from-expr-select-item", "column-identifier/util/constructor/from-select-clause", "column-identifier/util/constructor/from-select-item"], function (require, exports, from_column_map_9, from_column_ref_5, from_column_11, from_expr_select_item_5, from_select_clause_4, from_select_item_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_9);
    __export(from_column_ref_5);
    __export(from_column_11);
    __export(from_expr_select_item_5);
    __export(from_select_clause_4);
    __export(from_select_item_5);
});
define("column-identifier/util/operation/to-error-message-friendly-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/operation/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/predicate/is-column-identifier", ["require", "exports", "type-util/index"], function (require, exports, type_util_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isColumnIdentifier(raw) {
        if (!type_util_22.isObjectWithOwnEnumerableKeys()(raw, [
            "tableAlias",
            "columnAlias"
        ])) {
            return false;
        }
        return ((typeof raw.tableAlias == "string") &&
            (typeof raw.columnAlias == "string"));
    }
    exports.isColumnIdentifier = isColumnIdentifier;
});
define("column-identifier/util/predicate/is-equal", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isEqual(a, b) {
        return (a.tableAlias == b.tableAlias &&
            a.columnAlias == b.columnAlias);
    }
    exports.isEqual = isEqual;
    function assertIsEqual(a, b) {
        if (a.tableAlias != b.tableAlias) {
            throw new Error(`Table alias mismatch ${a.tableAlias} != ${b.tableAlias}`);
        }
        if (a.columnAlias != b.columnAlias) {
            throw new Error(`Column alias mismatch ${a.columnAlias} != ${b.columnAlias}`);
        }
    }
    exports.assertIsEqual = assertIsEqual;
});
define("column-identifier/util/predicate/index", ["require", "exports", "column-identifier/util/predicate/is-column-identifier", "column-identifier/util/predicate/is-equal"], function (require, exports, is_column_identifier_1, is_equal_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_column_identifier_1);
    __export(is_equal_3);
});
define("column-identifier/util/query/extract-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/query/extract-with-table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/query/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier/util/index", ["require", "exports", "column-identifier/util/constructor/index", "column-identifier/util/predicate/index"], function (require, exports, constructor_19, predicate_56) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_19);
    __export(predicate_56);
});
define("column-identifier/array-util/constructor/from-column-map", ["require", "exports", "column-identifier/util/index"], function (require, exports, ColumnIdentifierUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(columnMap) {
        const result = [];
        for (const columnAlias of Object.keys(columnMap)) {
            result.push(ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]));
        }
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
});
define("column-identifier/array-util/constructor/from-column-ref", ["require", "exports", "column-identifier/array-util/constructor/from-column-map"], function (require, exports, from_column_map_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnRef(columnRef) {
        const result = [];
        for (const tableAlias of Object.keys(columnRef)) {
            result.push(...from_column_map_10.fromColumnMap(columnRef[tableAlias]));
        }
        return result;
    }
    exports.fromColumnRef = fromColumnRef;
});
define("column-identifier/array-util/constructor/index", ["require", "exports", "column-identifier/array-util/constructor/from-column-map", "column-identifier/array-util/constructor/from-column-ref"], function (require, exports, from_column_map_11, from_column_ref_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_11);
    __export(from_column_ref_6);
});
define("column-identifier/array-util/predicate/assert-disjoint", ["require", "exports", "column-identifier/util/index"], function (require, exports, util_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertDisjoint(arrA, arrB) {
        for (const a of arrA) {
            for (const b of arrB) {
                if (util_3.isEqual(a, b)) {
                    throw new Error(`Duplicate column identifier ${a.tableAlias}.${a.columnAlias} found; consider aliasing`);
                }
            }
        }
    }
    exports.assertDisjoint = assertDisjoint;
});
define("column-identifier/array-util/predicate/assert-no-duplicate", ["require", "exports", "column-identifier/util/index"], function (require, exports, util_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNoDuplicate(arr) {
        for (let i = 0; i < arr.length; ++i) {
            for (let j = i + 1; j < arr.length; ++j) {
                if (util_4.isEqual(arr[i], arr[j])) {
                    throw new Error(`Duplicate column identifier ${arr[i].tableAlias}.${arr[i].columnAlias}`);
                }
            }
        }
    }
    exports.assertNoDuplicate = assertNoDuplicate;
});
define("column-identifier/array-util/predicate/index", ["require", "exports", "column-identifier/array-util/predicate/assert-disjoint", "column-identifier/array-util/predicate/assert-no-duplicate"], function (require, exports, assert_disjoint_1, assert_no_duplicate_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_disjoint_1);
    __export(assert_no_duplicate_1);
});
define("column-identifier/array-util/index", ["require", "exports", "column-identifier/array-util/constructor/index", "column-identifier/array-util/predicate/index"], function (require, exports, constructor_20, predicate_57) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_20);
    __export(predicate_57);
});
define("column-identifier/index", ["require", "exports", "column-identifier/array-util/index", "column-identifier/util/index"], function (require, exports, ColumnIdentifierArrayUtil, ColumnIdentifierUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnIdentifierArrayUtil = ColumnIdentifierArrayUtil;
    exports.ColumnIdentifierUtil = ColumnIdentifierUtil;
});
define("column-identifier-map/column-identifier-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
    ;
});
define("column-identifier-map/util/constructor/from-column-map", ["require", "exports", "column-identifier/index"], function (require, exports, column_identifier_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(columnMap) {
        return Object.keys(columnMap).reduce((memo, columnAlias) => {
            memo[columnAlias] = column_identifier_2.ColumnIdentifierUtil.fromColumn(columnMap[columnAlias]);
            return memo;
        }, {});
    }
    exports.fromColumnMap = fromColumnMap;
});
define("column-identifier-map/util/constructor/from-column-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-map/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-map/util/constructor/index", ["require", "exports", "column-identifier-map/util/constructor/from-column-map"], function (require, exports, from_column_map_12) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_12);
});
define("column-identifier-map/util/operation/intersect", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(mapA, mapB) {
        const right = {};
        for (const columnAlias of Object.keys(mapB)) {
            if (Object.prototype.hasOwnProperty.call(mapA, columnAlias) &&
                Object.prototype.propertyIsEnumerable.call(mapA, columnAlias)) {
                continue;
            }
            right[columnAlias] = mapB[columnAlias];
        }
        return {
            ...mapA,
            ...right,
        };
    }
    exports.intersect = intersect;
});
define("column-identifier-map/util/operation/index", ["require", "exports", "column-identifier-map/util/operation/intersect"], function (require, exports, intersect_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(intersect_4);
});
define("column-identifier-map/util/predicate/has-column-identifier", ["require", "exports", "column-identifier/index"], function (require, exports, column_identifier_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasColumnIdentifier(map, identifier) {
        const column = map[identifier.columnAlias];
        if (!column_identifier_3.ColumnIdentifierUtil.isColumnIdentifier(column)) {
            return false;
        }
        return column_identifier_3.ColumnIdentifierUtil.isEqual(column, identifier);
    }
    exports.hasColumnIdentifier = hasColumnIdentifier;
    function assertHasColumnIdentifier(map, identifier) {
        if (!hasColumnIdentifier(map, identifier)) {
            throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier map`);
        }
    }
    exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
    function assertHasColumnIdentifiers(map, identifiers) {
        for (const columnIdentifier of identifiers) {
            assertHasColumnIdentifier(map, columnIdentifier);
        }
    }
    exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
});
define("column-identifier-map/util/predicate/index", ["require", "exports", "column-identifier-map/util/predicate/has-column-identifier"], function (require, exports, has_column_identifier_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(has_column_identifier_1);
});
define("column-identifier-map/util/query/column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-map/util/query/extract-column-identifier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Does not check `tableAlias`
     */
    function extractColumnIdentifiers(map, columnIdentifiers) {
        const result = {};
        for (const columnAlias of Object.keys(map)) {
            if (columnIdentifiers.some(columnIdentifier => columnIdentifier.columnAlias == columnAlias)) {
                result[columnAlias] = map[columnAlias];
            }
        }
        return result;
    }
    exports.extractColumnIdentifiers = extractColumnIdentifiers;
});
define("column-identifier-map/util/query/index", ["require", "exports", "column-identifier-map/util/query/extract-column-identifier"], function (require, exports, extract_column_identifier_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_column_identifier_3);
});
define("column-identifier-map/util/index", ["require", "exports", "column-identifier-map/util/constructor/index", "column-identifier-map/util/operation/index", "column-identifier-map/util/predicate/index", "column-identifier-map/util/query/index"], function (require, exports, constructor_21, operation_34, predicate_58, query_49) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_21);
    __export(operation_34);
    __export(predicate_58);
    __export(query_49);
});
define("column-identifier-map/index", ["require", "exports", "column-identifier-map/util/index"], function (require, exports, ColumnIdentifierMapUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnIdentifierMapUtil = ColumnIdentifierMapUtil;
});
define("column-identifier-ref/column-identifier-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
    ;
});
define("column-identifier-ref/util/constructor/from-column-map-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-ref/util/constructor/from-column", ["require", "exports", "column-identifier/index"], function (require, exports, column_identifier_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function appendColumn(ref, column) {
        let map = ref[column.tableAlias];
        if (map == undefined) {
            map = {};
            ref[column.tableAlias] = map;
        }
        map[column.columnAlias] = column_identifier_4.ColumnIdentifierUtil.fromColumn(column);
        return ref;
    }
    exports.appendColumn = appendColumn;
});
define("column-identifier-ref/util/constructor/from-column-map", ["require", "exports", "column-identifier-ref/util/constructor/from-column"], function (require, exports, from_column_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function appendColumnMap(ref, columnMap) {
        for (const columnAlias of Object.keys(columnMap)) {
            from_column_12.appendColumn(ref, columnMap[columnAlias]);
        }
        return ref;
    }
    exports.appendColumnMap = appendColumnMap;
    function fromColumnMap(columnMap) {
        const result = appendColumnMap({}, columnMap);
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
});
define("column-identifier-ref/util/constructor/from-join-array", ["require", "exports", "column-identifier-ref/util/constructor/from-column-map"], function (require, exports, from_column_map_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function appendJoin(ref, join) {
        from_column_map_13.appendColumnMap(ref, join.columns);
        return ref;
    }
    exports.appendJoin = appendJoin;
    function appendJoinArray(ref, arr) {
        for (const join of arr) {
            appendJoin(ref, join);
        }
        return ref;
    }
    exports.appendJoinArray = appendJoinArray;
    function fromJoinArray(arr) {
        const result = {};
        appendJoinArray(result, arr);
        return result;
    }
    exports.fromJoinArray = fromJoinArray;
});
define("column-identifier-ref/util/constructor/from-column-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-ref/util/constructor/from-select-clause", ["require", "exports", "column-identifier/index", "column-identifier-ref/util/constructor/from-column"], function (require, exports, column_identifier_5, from_column_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromSelectClause(selectClause) {
        const result = {};
        for (const columnIdentifier of column_identifier_5.ColumnIdentifierUtil.fromSelectClause(selectClause)) {
            from_column_13.appendColumn(result, columnIdentifier);
        }
        return result;
    }
    exports.fromSelectClause = fromSelectClause;
});
define("column-identifier-ref/util/constructor/index", ["require", "exports", "column-identifier-ref/util/constructor/from-column-map", "column-identifier-ref/util/constructor/from-column", "column-identifier-ref/util/constructor/from-join-array", "column-identifier-ref/util/constructor/from-select-clause"], function (require, exports, from_column_map_14, from_column_14, from_join_array_5, from_select_clause_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_14);
    __export(from_column_14);
    __export(from_join_array_5);
    __export(from_select_clause_5);
});
define("column-identifier-ref/util/operation/left-intersect", ["require", "exports", "column-identifier-map/index"], function (require, exports, column_identifier_map_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function leftIntersect(refA, refB) {
        const result = {};
        for (const tableAlias of Object.keys(refA)) {
            if (Object.prototype.hasOwnProperty.call(refB, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refB, tableAlias)) {
                result[tableAlias] = column_identifier_map_10.ColumnIdentifierMapUtil.intersect(refA[tableAlias], refB[tableAlias]);
            }
            else {
                result[tableAlias] = refA[tableAlias];
            }
        }
        return result;
    }
    exports.leftIntersect = leftIntersect;
});
define("column-identifier-ref/util/operation/intersect", ["require", "exports", "column-identifier-ref/util/operation/left-intersect"], function (require, exports, left_intersect_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(refA, refB) {
        const left = left_intersect_4.leftIntersect(refA, refB);
        const right = {};
        for (const tableAlias of Object.keys(refB)) {
            if (Object.prototype.hasOwnProperty.call(refA, tableAlias) &&
                Object.prototype.propertyIsEnumerable.call(refA, tableAlias)) {
                continue;
            }
            right[tableAlias] = refB[tableAlias];
        }
        return {
            ...left,
            ...right,
        };
    }
    exports.intersect = intersect;
});
define("column-identifier-ref/util/query/column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-ref/util/query/extract-column-identifier", ["require", "exports", "column-identifier-map/index"], function (require, exports, column_identifier_map_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractColumnIdentifiers(ref, columnIdentifiers) {
        const result = {};
        for (const tableAlias of Object.keys(ref)) {
            const arr = columnIdentifiers.filter(columnIdentifier => columnIdentifier.tableAlias == tableAlias);
            if (arr.length > 0) {
                result[tableAlias] = column_identifier_map_11.ColumnIdentifierMapUtil.extractColumnIdentifiers(ref[tableAlias], arr);
            }
        }
        return result;
    }
    exports.extractColumnIdentifiers = extractColumnIdentifiers;
});
define("column-identifier-ref/util/query/index", ["require", "exports", "column-identifier-ref/util/query/extract-column-identifier"], function (require, exports, extract_column_identifier_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_column_identifier_4);
});
define("column-identifier-ref/util/predicate/has-column-identifier", ["require", "exports", "column-identifier-map/index"], function (require, exports, column_identifier_map_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hasColumnIdentifier(ref, identifier) {
        if (!Object.prototype.hasOwnProperty.call(ref, identifier.tableAlias)) {
            return false;
        }
        const columnMap = ref[identifier.tableAlias];
        return column_identifier_map_12.ColumnIdentifierMapUtil.hasColumnIdentifier(columnMap, identifier);
    }
    exports.hasColumnIdentifier = hasColumnIdentifier;
    function assertHasColumnIdentifier(ref, identifier) {
        if (!hasColumnIdentifier(ref, identifier)) {
            throw new Error(`Column ${identifier.tableAlias}.${identifier.columnAlias} does not exist in column identifier ref`);
        }
    }
    exports.assertHasColumnIdentifier = assertHasColumnIdentifier;
    function assertHasColumnIdentifiers(ref, identifiers) {
        for (const identifier of identifiers) {
            assertHasColumnIdentifier(ref, identifier);
        }
    }
    exports.assertHasColumnIdentifiers = assertHasColumnIdentifiers;
});
define("column-identifier-ref/util/predicate/has-one-table", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("column-identifier-ref/util/predicate/index", ["require", "exports", "column-identifier-ref/util/predicate/has-column-identifier"], function (require, exports, has_column_identifier_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(has_column_identifier_2);
});
define("column-identifier-ref/util/operation/try-flatten", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryFlatten(ref) {
        const tableAliases = Object.keys(ref);
        if (tableAliases.length == 1) {
            return ref[tableAliases[0]];
        }
        else {
            return ref;
        }
    }
    exports.tryFlatten = tryFlatten;
});
define("column-identifier-ref/util/operation/index", ["require", "exports", "column-identifier-ref/util/operation/intersect", "column-identifier-ref/util/operation/left-intersect", "column-identifier-ref/util/operation/try-flatten"], function (require, exports, intersect_5, left_intersect_5, try_flatten_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(intersect_5);
    __export(left_intersect_5);
    __export(try_flatten_2);
});
define("column-identifier-ref/util/index", ["require", "exports", "column-identifier-ref/util/constructor/index", "column-identifier-ref/util/operation/index", "column-identifier-ref/util/predicate/index", "column-identifier-ref/util/query/index"], function (require, exports, constructor_22, operation_35, predicate_59, query_50) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_22);
    __export(operation_35);
    __export(predicate_59);
    __export(query_50);
});
define("column-identifier-ref/index", ["require", "exports", "column-identifier-ref/util/index"], function (require, exports, ColumnIdentifierRefUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnIdentifierRefUtil = ColumnIdentifierRefUtil;
});
define("used-ref/used-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("used-ref/util/constructor/from-column-map", ["require", "exports", "column-identifier-ref/index"], function (require, exports, column_identifier_ref_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnMap(map) {
        const result = {
            __contravarianceMarker: () => { },
            columns: column_identifier_ref_13.ColumnIdentifierRefUtil.fromColumnMap(map),
        };
        return result;
    }
    exports.fromColumnMap = fromColumnMap;
});
define("used-ref/util/constructor/from-column-ref", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumnRef(ref) {
        const result = {
            __contravarianceMarker: () => { },
            columns: ref,
        };
        return result;
    }
    exports.fromColumnRef = fromColumnRef;
});
define("used-ref/util/constructor/from-column", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromColumn(column) {
        const result = {
            __contravarianceMarker: () => { },
            columns: {
                [column.tableAlias]: {
                    [column.columnAlias]: column
                }
            },
        };
        return result;
    }
    exports.fromColumn = fromColumn;
});
define("used-ref/util/constructor/from-join", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("used-ref/util/constructor/from-join-array", ["require", "exports", "column-identifier-ref/index"], function (require, exports, column_identifier_ref_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromJoinArray(joins) {
        const result = {
            __contravarianceMarker: () => { },
            columns: column_identifier_ref_14.ColumnIdentifierRefUtil.fromJoinArray(joins),
        };
        return result;
    }
    exports.fromJoinArray = fromJoinArray;
});
define("used-ref/util/constructor/from-from-clause", ["require", "exports", "used-ref/util/constructor/from-join-array"], function (require, exports, from_join_array_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromFromClause(fromClause) {
        return from_join_array_6.fromJoinArray(fromClause.outerQueryJoins == undefined ?
            [] :
            fromClause.outerQueryJoins);
    }
    exports.fromFromClause = fromFromClause;
});
define("used-ref/util/constructor/index", ["require", "exports", "used-ref/util/constructor/from-column-map", "used-ref/util/constructor/from-column-ref", "used-ref/util/constructor/from-column", "used-ref/util/constructor/from-from-clause", "used-ref/util/constructor/from-join-array"], function (require, exports, from_column_map_15, from_column_ref_7, from_column_15, from_from_clause_2, from_join_array_7) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_column_map_15);
    __export(from_column_ref_7);
    __export(from_column_15);
    __export(from_from_clause_2);
    __export(from_join_array_7);
});
define("used-ref/util/query/extract-column-identifier", ["require", "exports", "column-identifier-ref/index"], function (require, exports, column_identifier_ref_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractColumnIdentifiers(usedRef, columnIdentifiers) {
        const result = {
            __contravarianceMarker: () => { },
            columns: column_identifier_ref_15.ColumnIdentifierRefUtil.extractColumnIdentifiers(usedRef.columns, columnIdentifiers),
        };
        return result;
    }
    exports.extractColumnIdentifiers = extractColumnIdentifiers;
});
define("used-ref/util/query/type-ref-of", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("used-ref/util/query/table-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("used-ref/util/query/index", ["require", "exports", "used-ref/util/query/extract-column-identifier"], function (require, exports, extract_column_identifier_5) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(extract_column_identifier_5);
});
define("used-ref/util/operation/intersect", ["require", "exports", "column-identifier-ref/index"], function (require, exports, column_identifier_ref_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(...arr) {
        let columns = {};
        for (const u of arr) {
            columns = column_identifier_ref_16.ColumnIdentifierRefUtil.intersect(columns, u.columns);
        }
        const result = {
            __contravarianceMarker: () => { },
            columns,
        };
        return result;
    }
    exports.intersect = intersect;
});
define("used-ref/util/operation/with-value", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("used-ref/util/operation/index", ["require", "exports", "used-ref/util/operation/intersect"], function (require, exports, intersect_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(intersect_6);
});
define("used-ref/util/predicate/assert-allowed", ["require", "exports", "column-identifier-ref/index", "column-identifier/index"], function (require, exports, column_identifier_ref_17, column_identifier_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better naming
     *
     * @param allowed - Which references are allowed
     * @param used - Which references were actually used
     */
    function assertAllowed(allowed, used) {
        column_identifier_ref_17.ColumnIdentifierRefUtil.assertHasColumnIdentifiers(allowed.columns, column_identifier_6.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
    }
    exports.assertAllowed = assertAllowed;
});
define("used-ref/util/predicate/assert-empty", ["require", "exports", "column-identifier-ref/index", "column-identifier/index"], function (require, exports, column_identifier_ref_18, column_identifier_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better naming
     *
     * @param used - Which references were actually used
     */
    function assertEmpty(used) {
        column_identifier_ref_18.ColumnIdentifierRefUtil.assertHasColumnIdentifiers({}, column_identifier_7.ColumnIdentifierArrayUtil.fromColumnRef(used.columns));
    }
    exports.assertEmpty = assertEmpty;
});
define("used-ref/util/predicate/is-used-ref", ["require", "exports", "type-util/index"], function (require, exports, type_util_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import {ColumnIdentifierRefUtil} from "../../../column-identifier-ref";
    /**
     * Does not actually check that `x.columns` is a `ColumnIdentifierRef`.
     *
     * @todo Consider adding check for increased type safety.
     */
    function isUsedRef(x) {
        if (!type_util_23.isObjectWithOwnEnumerableKeys()(x, [
            "__contravarianceMarker",
            "columns",
        ])) {
            return false;
        }
        return ((typeof x.__contravarianceMarker == "function") // &&
        //(ColumnIdentifierRefUtil.isColumnIdentifierRef(x.usedRef))
        );
    }
    exports.isUsedRef = isUsedRef;
});
define("used-ref/util/predicate/index", ["require", "exports", "used-ref/util/predicate/assert-allowed", "used-ref/util/predicate/assert-empty", "used-ref/util/predicate/is-used-ref"], function (require, exports, assert_allowed_1, assert_empty_1, is_used_ref_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_allowed_1);
    __export(assert_empty_1);
    __export(is_used_ref_1);
});
define("used-ref/util/index", ["require", "exports", "used-ref/util/constructor/index", "used-ref/util/operation/index", "used-ref/util/predicate/index", "used-ref/util/query/index"], function (require, exports, constructor_23, operation_36, predicate_60, query_51) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_23);
    __export(operation_36);
    __export(predicate_60);
    __export(query_51);
});
define("used-ref/index", ["require", "exports", "used-ref/util/index"], function (require, exports, UsedRefUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UsedRefUtil = UsedRefUtil;
});
define("expr-library/aggregate-factory/make-aggregate-operator-0", ["require", "exports", "expr/index", "ast/index", "used-ref/index"], function (require, exports, expr_17, ast_11, used_ref_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeAggregateOperator0(operatorType, mapper, typeHint) {
        const result = () => {
            return expr_17.expr({
                mapper,
                usedRef: used_ref_28.UsedRefUtil.fromColumnRef({}),
                isAggregate: true,
            }, ast_11.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
        };
        return result;
    }
    exports.makeAggregateOperator0 = makeAggregateOperator0;
});
define("expr-library/aggregate-factory/make-aggregate-operator-1", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_19, expr_18, ast_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeAggregateOperator1(operatorType, mapper, typeHint) {
        const result = (arg) => {
            return expr_18.ExprUtil.aggregateIntersect(mapper, [arg], ast_12.OperatorNodeUtil.operatorNode1(operatorType, [
                built_in_expr_19.BuiltInExprUtil.buildAst(arg),
            ], typeHint));
        };
        return result;
    }
    exports.makeAggregateOperator1 = makeAggregateOperator1;
});
define("expr-library/aggregate-factory/make-aggregate-operator-2", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_20, expr_19, ast_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeAggregateOperator2(operatorType, mapper, typeHint) {
        const result = (left, right) => {
            return expr_19.ExprUtil.aggregateIntersect(mapper, [left, right], ast_13.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_20.BuiltInExprUtil.buildAst(left),
                built_in_expr_20.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeAggregateOperator2 = makeAggregateOperator2;
});
define("expr-library/aggregate-factory/make-aggregate-operator-3", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_21, expr_20, ast_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeAggregateOperator3(operatorType, mapper, typeHint) {
        const result = (left, mid, right) => {
            return expr_20.ExprUtil.aggregateIntersect(mapper, [left, mid, right], ast_14.OperatorNodeUtil.operatorNode3(operatorType, [
                built_in_expr_21.BuiltInExprUtil.buildAst(left),
                built_in_expr_21.BuiltInExprUtil.buildAst(mid),
                built_in_expr_21.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeAggregateOperator3 = makeAggregateOperator3;
});
define("expr-library/aggregate-factory/index", ["require", "exports", "expr-library/aggregate-factory/make-aggregate-operator-0", "expr-library/aggregate-factory/make-aggregate-operator-1", "expr-library/aggregate-factory/make-aggregate-operator-2", "expr-library/aggregate-factory/make-aggregate-operator-3"], function (require, exports, make_aggregate_operator_0_1, make_aggregate_operator_1_1, make_aggregate_operator_2_1, make_aggregate_operator_3_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(make_aggregate_operator_0_1);
    __export(make_aggregate_operator_1_1);
    __export(make_aggregate_operator_2_1);
    __export(make_aggregate_operator_3_1);
});
define("expr-library/aggregate/count-all", ["require", "exports", "type-mapping", "operator-type", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_2, aggregate_factory_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a count of the number of rows
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(*)`
     * + PostgreSQL : `COUNT(*)`
     * + SQLite     : `COUNT(*)`
     *
     * @todo Rename to `count`? or `countRow`?
     * @todo Or add a function `count()` with overloads for `countExpr` and `countAll`?
     */
    exports.countAll = aggregate_factory_1.makeAggregateOperator0(operator_type_2.OperatorType.AGGREGATE_COUNT_ALL, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned());
});
define("expr-library/aggregate/count-expr", ["require", "exports", "type-mapping", "operator-type", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_3, aggregate_factory_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const countExprImpl = aggregate_factory_2.makeAggregateOperator2(operator_type_3.OperatorType.AGGREGATE_COUNT_EXPR, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned());
    /**
     * Returns a count of the number of rows with different non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(DISTINCT x)`
     * + PostgreSQL : `COUNT(DISTINCT x)`
     * + SQLite     : `COUNT(DISTINCT x)`
     */
    exports.countExprDistinct = (arg) => {
        return countExprImpl(true, arg);
    };
    /**
     * Returns a count of the number of rows with non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(x)`
     * + PostgreSQL : `COUNT(x)`
     * + SQLite     : `COUNT(x)`
     */
    exports.countExprAll = (arg) => {
        return countExprImpl(false, arg);
    };
    /**
     * Returns a count of the number of rows with non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#count
     *
     * -----
     *
     * + MySQL      : `COUNT(x)`
     * + PostgreSQL : `COUNT(x)`
     * + SQLite     : `COUNT(x)`
     */
    exports.countExpr = exports.countExprAll;
});
define("expr-library/aggregate/index", ["require", "exports", "expr-library/aggregate/count-all", "expr-library/aggregate/count-expr"], function (require, exports, count_all_1, count_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(count_all_1);
    __export(count_expr_1);
});
define("expr-library/assert/throw-if-null", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/index", "ast/index", "operator-type"], function (require, exports, tm, built_in_expr_22, expr_21, ast_15, operator_type_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function throwIfNull(arg) {
        return expr_21.ExprUtil.intersect(tm.notNull(built_in_expr_22.BuiltInExprUtil.mapper(arg)), [arg], ast_15.OperatorNodeUtil.operatorNode1(operator_type_4.OperatorType.THROW_IF_NULL, [
            built_in_expr_22.BuiltInExprUtil.buildAst(arg)
        ], undefined));
    }
    exports.throwIfNull = throwIfNull;
});
define("expr-library/assert/index", ["require", "exports", "expr-library/assert/throw-if-null"], function (require, exports, throw_if_null_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(throw_if_null_2);
});
define("expr-library/cast/bigint-signed-literal", ["require", "exports", "type-mapping", "used-ref/index", "ast/literal-value-node/index", "expr/expr-impl"], function (require, exports, tm, used_ref_29, literal_value_node_5, expr_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts `string|number|bigint|Decimal` to a `BIGINT SIGNED`
     */
    function bigIntSignedLiteral(rawBigIntSignedLiteral) {
        const mapper = tm.mysql.bigIntSigned();
        const value = mapper("rawBigIntSignedLiteral", String(rawBigIntSignedLiteral));
        return expr_impl_1.expr({
            mapper,
            usedRef: used_ref_29.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, literal_value_node_5.LiteralValueNodeUtil.bigIntSignedLiteralNode(value));
    }
    exports.bigIntSignedLiteral = bigIntSignedLiteral;
});
/**
 * All augmentable types go here.
 *
 * Libraries/applications should use declaration merging to modify these types,
 * which will affect this library's behaviour.
 *
 * https://github.com/microsoft/TypeScript/issues/18877#issuecomment-476921038
 */
define("augmentable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr-library/cast/unsafe-cast-as-decimal", ["require", "exports", "type-mapping/fluent", "operator-type", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, operator_type_5, built_in_expr_23, expr_22, ast_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Move this elsewhere?
     */
    function assertValidDecimalPrecisionAndScale(
    /**
     * + PostgreSQL's min precision is `1`
     * + MySQL's max precision is `65`
     */
    precision, 
    /**
     * + The min scale is `0`.
     * + MySQL's max scale is `30`.
     * + `scale` must be <= `precision`.
     */
    scale) {
        const BigInt = tm.TypeUtil.getBigIntFactoryFunctionOrError();
        const precisionMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(1)), tm.bigIntLtEq(BigInt(65)));
        precision = precisionMapper("precision", precision);
        const scaleMapper = tm.toBigInt().pipe(tm.bigIntGtEq(BigInt(0)), tm.bigIntLtEq(BigInt(30)), tm.bigIntLtEq(precision));
        scale = scaleMapper("scale", scale);
        return {
            precision,
            scale,
        };
    }
    exports.assertValidDecimalPrecisionAndScale = assertValidDecimalPrecisionAndScale;
    function unsafeCastAsDecimal(arg, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale) {
        const argMapper = built_in_expr_23.BuiltInExprUtil.mapper(arg);
        const decimalDefinition = assertValidDecimalPrecisionAndScale(precision, scale);
        return expr_22.expr({
            mapper: tm.canOutputNull(argMapper) ?
                tm.mysql.decimal(precision, scale).orNull() :
                tm.mysql.decimal(precision, scale),
            usedRef: built_in_expr_23.BuiltInExprUtil.usedRef(arg),
            isAggregate: built_in_expr_23.BuiltInExprUtil.isAggregate(arg),
        }, ast_16.OperatorNodeUtil.operatorNode3(operator_type_5.OperatorType.CAST_AS_DECIMAL, [
            built_in_expr_23.BuiltInExprUtil.buildAst(arg),
            built_in_expr_23.BuiltInExprUtil.buildAst(decimalDefinition.precision),
            built_in_expr_23.BuiltInExprUtil.buildAst(decimalDefinition.scale),
        ], undefined));
    }
    exports.unsafeCastAsDecimal = unsafeCastAsDecimal;
});
define("expr-library/cast/decimal-literal", ["require", "exports", "type-mapping", "used-ref/index", "ast/literal-value-node/index", "expr/expr-impl"], function (require, exports, tm, used_ref_30, literal_value_node_6, expr_impl_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * @param rawDecimalLiteral
     *
     * @param precision
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     *
     * @param scale
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    function decimalLiteral(rawDecimalLiteral, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale) {
        return expr_impl_2.expr({
            mapper: tm.mysql.decimal(precision, scale),
            usedRef: used_ref_30.UsedRefUtil.fromColumnRef({}),
            isAggregate: false,
        }, literal_value_node_6.LiteralValueNodeUtil.decimalLiteralNode(rawDecimalLiteral, precision, scale));
    }
    exports.decimalLiteral = decimalLiteral;
});
define("expr-library/factory/make-any-operator-1", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_24, expr_23, ast_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeAnyOperator1(operatorType, mapper, typeHint) {
        const result = (arg) => {
            return expr_23.ExprUtil.intersect(mapper, [arg], ast_17.OperatorNodeUtil.operatorNode1(operatorType, [
                built_in_expr_24.BuiltInExprUtil.buildAst(arg),
            ], typeHint));
        };
        return result;
    }
    exports.makeAnyOperator1 = makeAnyOperator1;
});
define("expr-library/decimal/decimal-mapper", ["require", "exports", "type-mapping/fluent"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * We make this precision and scale far larger than what a database
     * can reasonably reach.
     *
     * PostgreSQL has max precision 1,000.
     *
     * Precision 40,000 and scale 20,000 seems like a safe bet, right?
     */
    exports.decimalMapper = tm.mysql.decimal(40000, 20000);
});
define("expr-library/factory/make-chainable-decimal-operator", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/index", "ast/index", "ast/literal-value-node/index", "built-in-value-expr/index", "expr-library/decimal/decimal-mapper"], function (require, exports, tm, built_in_expr_25, expr_24, ast_18, literal_value_node_7, built_in_value_expr_11, decimal_mapper_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryGetFlattenableElements(
    /**
     * In this specific instance, we could probably have `BuiltInExpr<Decimal>`.
     * Can't accept arbitrary `Decimal` types because they may have invalid precision/scale.
     */
    builtInExpr, operatorType, _identityElement, identityAst, identityParseResult) {
        if (expr_24.ExprUtil.isExpr(builtInExpr)) {
            return ast_18.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
                if (literal_value_node_7.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_11.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                    /**
                     * Eliminate all identity elements
                     */
                    return [];
                }
                else if (ast_18.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                    return ast.operands;
                }
                else {
                    return undefined;
                }
            });
        }
        /**
         * We should not see any `Decimal` built-ins because JS does not have them.
         */
        const builtInExprParseResult = tm.FixedPointUtil.tryParse(String(builtInExpr));
        if (builtInExprParseResult != undefined &&
            tm.FixedPointUtil.isEqual(builtInExprParseResult, identityParseResult, tm.FixedPointUtil.ZeroEqualityAlgorithm.NEGATIVE_AND_POSITIVE_ZERO_ARE_EQUAL)) {
            /**
             * Eliminate all identity elements
             */
            return [];
        }
        return undefined;
    }
    function makeChainableDecimalOperator(operatorType, rawIdentityElement, mapper, 
    /**
     * For now, the typeHint should always be `DECIMAL`
     */
    typeHint) {
        const identityElement = decimal_mapper_1.decimalMapper("rawIdentityElement", rawIdentityElement);
        const identityParseResult = tm.FixedPointUtil.tryParse(rawIdentityElement.toString());
        if (identityParseResult == undefined) {
            throw new Error(`Invalid identity element ${rawIdentityElement}`);
        }
        let identityAst = undefined;
        const result = (...arr) => {
            if (identityAst == undefined) {
                const newIdentityAst = literal_value_node_7.LiteralValueNodeUtil.decimalLiteralNode(identityElement, 65, 30);
                if (!literal_value_node_7.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                    throw new Error(`Invalid identity element`);
                }
                identityAst = newIdentityAst;
            }
            let operands = undefined;
            for (const builtInExpr of arr) {
                const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst, identityParseResult);
                if (flattenableElements != undefined) {
                    /**
                     * Looks like we should flatten this `builtInExpr`
                     */
                    if (flattenableElements.length == 0) {
                        continue;
                    }
                    else {
                        if (operands == undefined) {
                            operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                        }
                        else {
                            operands.push(...flattenableElements);
                        }
                    }
                }
                else {
                    /**
                     * Can't flatten this `builtInExpr`
                     */
                    if (operands == undefined) {
                        operands = [built_in_expr_25.BuiltInExprUtil.buildAst(builtInExpr)];
                    }
                    else {
                        operands.push(built_in_expr_25.BuiltInExprUtil.buildAst(builtInExpr));
                    }
                }
            }
            return expr_24.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
                /**
                 * By convention, applying the operator to zero operands gives you the identity element
                 */
                identityAst :
                (operands.length == 1) ?
                    /**
                     * By convention, applying the operator on one operand does not do anything to the operand
                     */
                    operands[0] :
                    ast_18.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
        };
        return result;
    }
    exports.makeChainableDecimalOperator = makeChainableDecimalOperator;
});
define("expr-library/factory/make-chainable-operator", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index", "ast/literal-value-node/index", "built-in-value-expr/index"], function (require, exports, built_in_expr_26, expr_25, ast_19, literal_value_node_8, built_in_value_expr_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst) {
        if (expr_25.ExprUtil.isExpr(builtInExpr)) {
            return ast_19.AstUtil.tryExtractAst(builtInExpr.ast, ast => {
                if (literal_value_node_8.LiteralValueNodeUtil.isLiteralValueNode(ast) && built_in_value_expr_12.BuiltInValueExprUtil.isEqual(ast.literalValue, identityAst.literalValue)) {
                    /**
                     * Eliminate all identity elements
                     */
                    return [];
                }
                else if (ast_19.OperatorNodeUtil.isOperatorNode(ast) && ast.operatorType == operatorType) {
                    return ast.operands;
                }
                else {
                    return undefined;
                }
            });
        }
        if (built_in_value_expr_12.BuiltInValueExprUtil.isBuiltInValueExpr(builtInExpr) &&
            built_in_value_expr_12.BuiltInValueExprUtil.isEqual(builtInExpr, identityElement)) {
            /**
             * Eliminate all identity elements
             */
            return [];
        }
        return undefined;
    }
    function makeChainableOperator(operatorType, identityElement, mapper, typeHint) {
        let identityAst = undefined;
        const result = (...arr) => {
            if (identityAst == undefined) {
                const newIdentityAst = built_in_expr_26.BuiltInExprUtil.buildAst(identityElement);
                if (!literal_value_node_8.LiteralValueNodeUtil.isLiteralValueNode(newIdentityAst)) {
                    throw new Error(`Invalid identity element`);
                }
                identityAst = newIdentityAst;
            }
            let operands = undefined;
            for (const builtInExpr of arr) {
                const flattenableElements = tryGetFlattenableElements(builtInExpr, operatorType, identityElement, identityAst);
                if (flattenableElements != undefined) {
                    /**
                     * Looks like we should flatten this `builtInExpr`
                     */
                    if (flattenableElements.length == 0) {
                        continue;
                    }
                    else {
                        if (operands == undefined) {
                            operands = [flattenableElements[0], ...flattenableElements.slice(1)];
                        }
                        else {
                            operands.push(...flattenableElements);
                        }
                    }
                }
                else {
                    /**
                     * Can't flatten this `builtInExpr`
                     */
                    if (operands == undefined) {
                        operands = [built_in_expr_26.BuiltInExprUtil.buildAst(builtInExpr)];
                    }
                    else {
                        operands.push(built_in_expr_26.BuiltInExprUtil.buildAst(builtInExpr));
                    }
                }
            }
            return expr_25.ExprUtil.intersect(mapper, arr, ((operands == undefined) ?
                /**
                 * By convention, applying the operator to zero operands gives you the identity element
                 */
                identityAst :
                (operands.length == 1) ?
                    /**
                     * By convention, applying the operator on one operand does not do anything to the operand
                     */
                    operands[0] :
                    ast_19.OperatorNodeUtil.operatorNode1ToN(operatorType, operands, typeHint)));
        };
        return result;
    }
    exports.makeChainableOperator = makeChainableOperator;
});
define("comparable-type/comparable-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("comparable-type/index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr-library/factory/make-operator-1-to-n", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_27, expr_26, ast_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator1ToN(operatorType, mapper, typeHint) {
        const result = (arg0, ...args) => {
            return expr_26.ExprUtil.intersect(mapper, [arg0, ...args], ast_20.OperatorNodeUtil.operatorNode1ToN(operatorType, [
                built_in_expr_27.BuiltInExprUtil.buildAst(arg0),
                ...args.map(built_in_expr_27.BuiltInExprUtil.buildAst),
            ], typeHint));
        };
        return result;
    }
    exports.makeOperator1ToN = makeOperator1ToN;
});
define("expr-library/factory/make-comparison-1-to-n", ["require", "exports", "type-mapping", "expr-library/factory/make-operator-1-to-n"], function (require, exports, tm, make_operator_1_to_n_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeComparison1ToN(operatorType, typeHint) {
        return make_operator_1_to_n_1.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
    }
    exports.makeComparison1ToN = makeComparison1ToN;
});
define("expr-library/factory/make-operator-2-to-n", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_28, expr_27, ast_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator2ToN(operatorType, mapper, typeHint) {
        const result = (arg0, arg1, ...args) => {
            return expr_27.ExprUtil.intersect(mapper, [arg0, arg1, ...args], ast_21.OperatorNodeUtil.operatorNode2ToN(operatorType, [
                built_in_expr_28.BuiltInExprUtil.buildAst(arg0),
                built_in_expr_28.BuiltInExprUtil.buildAst(arg1),
                ...args.map(built_in_expr_28.BuiltInExprUtil.buildAst),
            ], typeHint));
        };
        return result;
    }
    exports.makeOperator2ToN = makeOperator2ToN;
});
define("expr-library/factory/make-comparison-2-to-n", ["require", "exports", "type-mapping", "expr-library/factory/make-operator-2-to-n"], function (require, exports, tm, make_operator_2_to_n_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeComparison2ToN(operatorType, typeHint) {
        return make_operator_2_to_n_1.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
    }
    exports.makeComparison2ToN = makeComparison2ToN;
});
define("expr-library/factory/make-comparison-2", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_28, built_in_expr_29, ast_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    function makeComparison2(operatorType, typeHint) {
        const result = (left, right) => {
            built_in_expr_29.BuiltInExprUtil.assertNonNull("LHS", left);
            built_in_expr_29.BuiltInExprUtil.assertNonNull("RHS", left);
            return expr_28.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_22.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_29.BuiltInExprUtil.buildAst(left),
                built_in_expr_29.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeComparison2 = makeComparison2;
});
define("expr-library/factory/make-comparison-3", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_29, built_in_expr_30, ast_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making ternary comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    function makeComparison3(operatorType, typeHint) {
        const result = (left, mid, right) => {
            built_in_expr_30.BuiltInExprUtil.assertNonNull("LHS", left);
            built_in_expr_30.BuiltInExprUtil.assertNonNull("MHS", mid);
            built_in_expr_30.BuiltInExprUtil.assertNonNull("RHS", left);
            return expr_29.ExprUtil.intersect(tm.mysql.boolean(), [left, mid, right], ast_23.OperatorNodeUtil.operatorNode3(operatorType, [
                built_in_expr_30.BuiltInExprUtil.buildAst(left),
                built_in_expr_30.BuiltInExprUtil.buildAst(mid),
                built_in_expr_30.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeComparison3 = makeComparison3;
});
define("expr-library/factory/make-comparison-projection-2-to-n", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, built_in_expr_31, expr_30, ast_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better name?
     *
     * Called `Projection` because it picks one of its arguments as the return value.
     * Similar to picking columns in a query.
     */
    function makeComparisonProjection2ToN(operatorType, typeHint) {
        const result = (arg0, arg1, ...args) => {
            const arr = [arg0, arg1, ...args];
            return expr_30.ExprUtil.intersect(tm.unsafeOr(...arr.map(built_in_expr_31.BuiltInExprUtil.mapper)), arr, ast_24.OperatorNodeUtil.operatorNode2ToN(operatorType, [
                built_in_expr_31.BuiltInExprUtil.buildAst(arg0),
                built_in_expr_31.BuiltInExprUtil.buildAst(arg1),
                ...args.map(built_in_expr_31.BuiltInExprUtil.buildAst),
            ], typeHint));
        };
        return result;
    }
    exports.makeComparisonProjection2ToN = makeComparisonProjection2ToN;
});
define("expr-library/factory/make-equation-1-to-n", ["require", "exports", "type-mapping", "expr-library/factory/make-operator-1-to-n"], function (require, exports, tm, make_operator_1_to_n_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeEquation1ToN(operatorType, typeHint) {
        return make_operator_1_to_n_2.makeOperator1ToN(operatorType, tm.mysql.boolean(), typeHint);
    }
    exports.makeEquation1ToN = makeEquation1ToN;
});
define("expr-library/factory/make-equation-2-to-n", ["require", "exports", "type-mapping", "expr-library/factory/make-operator-2-to-n"], function (require, exports, tm, make_operator_2_to_n_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeEquation2ToN(operatorType, typeHint) {
        return make_operator_2_to_n_2.makeOperator2ToN(operatorType, tm.mysql.boolean(), typeHint);
    }
    exports.makeEquation2ToN = makeEquation2ToN;
});
define("expr-library/factory/make-equation-2", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_31, built_in_expr_32, ast_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making comparison operators.
     *
     * These do not allow `null` to be used in comparisons.
     */
    function makeEquation2(operatorType, typeHint) {
        const result = (left, right) => {
            built_in_expr_32.BuiltInExprUtil.assertNonNull("LHS", left);
            built_in_expr_32.BuiltInExprUtil.assertNonNull("RHS", left);
            return expr_31.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_25.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_32.BuiltInExprUtil.buildAst(left),
                built_in_expr_32.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeEquation2 = makeEquation2;
});
define("expr-library/factory/make-null-safe-comparison-1", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_32, built_in_expr_33, ast_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making null-safe unary comparison operators.
     */
    function makeNullSafeComparison1(operatorType, typeHint) {
        const result = (builtInExpr) => {
            return expr_32.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_26.OperatorNodeUtil.operatorNode1(operatorType, [
                built_in_expr_33.BuiltInExprUtil.buildAst(builtInExpr),
            ], typeHint));
        };
        return result;
    }
    exports.makeNullSafeComparison1 = makeNullSafeComparison1;
});
define("expr-library/factory/make-null-safe-comparison-2", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_33, built_in_expr_34, ast_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making null-safe comparison operators.
     *
     * These allow `null` in comparisons.
     */
    function makeNullSafeComparison(operatorType, typeHint) {
        const result = (left, right) => {
            return expr_33.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_27.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_34.BuiltInExprUtil.buildAst(left),
                built_in_expr_34.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeNullSafeComparison = makeNullSafeComparison;
});
define("expr-library/factory/make-null-safe-equation-1", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_34, built_in_expr_35, ast_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making null-safe unary equation operators.
     */
    function makeNullSafeEquation1(operatorType, typeHint) {
        const result = (builtInExpr) => {
            return expr_34.ExprUtil.intersect(tm.mysql.boolean(), [builtInExpr], ast_28.OperatorNodeUtil.operatorNode1(operatorType, [
                built_in_expr_35.BuiltInExprUtil.buildAst(builtInExpr),
            ], typeHint));
        };
        return result;
    }
    exports.makeNullSafeEquation1 = makeNullSafeEquation1;
});
define("expr-library/factory/make-null-safe-equation-2", ["require", "exports", "type-mapping", "expr/index", "built-in-expr/index", "ast/index"], function (require, exports, tm, expr_35, built_in_expr_36, ast_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Factory for making null-safe equation operators.
     *
     * These allow `null` in equations.
     */
    function makeNullSafeEquation2(operatorType, typeHint) {
        const result = (left, right) => {
            return expr_35.ExprUtil.intersect(tm.mysql.boolean(), [left, right], ast_29.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_36.BuiltInExprUtil.buildAst(left),
                built_in_expr_36.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeNullSafeEquation2 = makeNullSafeEquation2;
});
define("expr-library/factory/make-operator-0", ["require", "exports", "expr/index", "ast/index", "used-ref/index"], function (require, exports, expr_36, ast_30, used_ref_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator0(operatorType, mapper, typeHint) {
        const result = () => {
            return expr_36.expr({
                mapper,
                usedRef: used_ref_31.UsedRefUtil.fromColumnRef({}),
                isAggregate: false,
            }, ast_30.OperatorNodeUtil.operatorNode0(operatorType, typeHint));
        };
        return result;
    }
    exports.makeOperator0 = makeOperator0;
});
define("expr-library/factory/make-operator-1", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_37, expr_37, ast_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator1(operatorType, mapper, typeHint) {
        const result = (arg) => {
            return expr_37.ExprUtil.intersect(mapper, [arg], ast_31.OperatorNodeUtil.operatorNode1(operatorType, [
                built_in_expr_37.BuiltInExprUtil.buildAst(arg),
            ], typeHint));
        };
        return result;
    }
    exports.makeOperator1 = makeOperator1;
});
define("expr-library/factory/make-operator-1-double-elimination", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index", "ast/util/index"], function (require, exports, built_in_expr_38, expr_38, ast_32, util_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Makes a double elimination unary operator.
     *
     * A double elimination function `f` has the following property,
     * `f(f(x)) == x`
     */
    function makeOperator1DoubleElimination(operatorType, mapper, typeHint) {
        const result = (arg) => {
            return expr_38.ExprUtil.intersect(mapper, [arg], util_5.tryExtractAstOr(built_in_expr_38.BuiltInExprUtil.buildAst(arg), operand => (ast_32.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType ?
                operand.operands[0] :
                undefined), operand => ast_32.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
        };
        return result;
    }
    exports.makeOperator1DoubleElimination = makeOperator1DoubleElimination;
});
define("expr-library/factory/make-operator-1-idempotent", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index", "ast/util/index"], function (require, exports, built_in_expr_39, expr_39, ast_33, util_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Makes an idempotent unary operator.
     *
     * An idempotent function `f` has the following property,
     * `f(f(x)) == f(x)`
     */
    function makeOperator1Idempotent(operatorType, mapper, typeHint) {
        const result = (arg) => {
            return expr_39.ExprUtil.intersect(mapper, [arg], util_6.tryExtractAstOr(built_in_expr_39.BuiltInExprUtil.buildAst(arg), operand => ast_33.OperatorNodeUtil.isOperatorNode(operand) && operand.operatorType == operatorType, operand => ast_33.OperatorNodeUtil.operatorNode1(operatorType, [operand], typeHint)));
        };
        return result;
    }
    exports.makeOperator1Idempotent = makeOperator1Idempotent;
});
define("expr-library/factory/make-operator-2", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_40, expr_40, ast_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator2(operatorType, mapper, typeHint) {
        const result = (left, right) => {
            return expr_40.ExprUtil.intersect(mapper, [left, right], ast_34.OperatorNodeUtil.operatorNode2(operatorType, [
                built_in_expr_40.BuiltInExprUtil.buildAst(left),
                built_in_expr_40.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeOperator2 = makeOperator2;
});
define("expr-library/factory/make-operator-3", ["require", "exports", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, built_in_expr_41, expr_41, ast_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeOperator3(operatorType, mapper, typeHint) {
        const result = (left, mid, right) => {
            return expr_41.ExprUtil.intersect(mapper, [left, mid, right], ast_35.OperatorNodeUtil.operatorNode3(operatorType, [
                built_in_expr_41.BuiltInExprUtil.buildAst(left),
                built_in_expr_41.BuiltInExprUtil.buildAst(mid),
                built_in_expr_41.BuiltInExprUtil.buildAst(right),
            ], typeHint));
        };
        return result;
    }
    exports.makeOperator3 = makeOperator3;
});
define("expr-library/factory/index", ["require", "exports", "expr-library/factory/make-any-operator-1", "expr-library/factory/make-chainable-decimal-operator", "expr-library/factory/make-chainable-operator", "expr-library/factory/make-comparison-1-to-n", "expr-library/factory/make-comparison-2-to-n", "expr-library/factory/make-comparison-2", "expr-library/factory/make-comparison-3", "expr-library/factory/make-comparison-projection-2-to-n", "expr-library/factory/make-equation-1-to-n", "expr-library/factory/make-equation-2-to-n", "expr-library/factory/make-equation-2", "expr-library/factory/make-null-safe-comparison-1", "expr-library/factory/make-null-safe-comparison-2", "expr-library/factory/make-null-safe-equation-1", "expr-library/factory/make-null-safe-equation-2", "expr-library/factory/make-operator-0", "expr-library/factory/make-operator-1-double-elimination", "expr-library/factory/make-operator-1-idempotent", "expr-library/factory/make-operator-1-to-n", "expr-library/factory/make-operator-1", "expr-library/factory/make-operator-2-to-n", "expr-library/factory/make-operator-2", "expr-library/factory/make-operator-3"], function (require, exports, make_any_operator_1_1, make_chainable_decimal_operator_1, make_chainable_operator_1, make_comparison_1_to_n_1, make_comparison_2_to_n_1, make_comparison_2_1, make_comparison_3_1, make_comparison_projection_2_to_n_1, make_equation_1_to_n_1, make_equation_2_to_n_1, make_equation_2_1, make_null_safe_comparison_1_1, make_null_safe_comparison_2_1, make_null_safe_equation_1_1, make_null_safe_equation_2_1, make_operator_0_1, make_operator_1_double_elimination_1, make_operator_1_idempotent_1, make_operator_1_to_n_3, make_operator_1_1, make_operator_2_to_n_3, make_operator_2_1, make_operator_3_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(make_any_operator_1_1);
    __export(make_chainable_decimal_operator_1);
    __export(make_chainable_operator_1);
    __export(make_comparison_1_to_n_1);
    __export(make_comparison_2_to_n_1);
    __export(make_comparison_2_1);
    __export(make_comparison_3_1);
    __export(make_comparison_projection_2_to_n_1);
    __export(make_equation_1_to_n_1);
    __export(make_equation_2_to_n_1);
    __export(make_equation_2_1);
    __export(make_null_safe_comparison_1_1);
    __export(make_null_safe_comparison_2_1);
    __export(make_null_safe_equation_1_1);
    __export(make_null_safe_equation_2_1);
    __export(make_operator_0_1);
    __export(make_operator_1_double_elimination_1);
    __export(make_operator_1_idempotent_1);
    __export(make_operator_1_to_n_3);
    __export(make_operator_1_1);
    __export(make_operator_2_to_n_3);
    __export(make_operator_2_1);
    __export(make_operator_3_1);
});
define("expr-library/cast/unsafe-cast-as-bigint-signed", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_1, operator_type_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Attempts to cast to `BIGINT SIGNED`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS SIGNED INTEGER)`
     *   + Actually gives a signed `bigint`
     *   + Trying to cast `'123e2'` gives `123`
     * + PostgreSQL     : `CAST(x AS bigint)`
     *   + Trying to cast `'123e2'` throws an error
     * + SQLite         : `CAST(x AS BIGINT)`
     *   + Trying to cast `'123e2'` gives `123`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     * + https://github.com/AnyhowStep/tsql/issues/244
     * + https://github.com/AnyhowStep/tsql/issues/245
     */
    exports.unsafeCastAsBigIntSigned = factory_1.makeOperator1Idempotent(operator_type_6.OperatorType.CAST_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull());
});
define("expr-library/cast/unsafe-cast-as-binary", ["require", "exports", "type-mapping/fluent", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_2, operator_type_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Attempts to cast to `BINARY/bytea/BLOB`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS BINARY)`
     *   + `CAST(1234567890 AS BINARY)` returns `[49,50,51,52,53,54,55,56,57,48]`
     *     + Converts to ASCII string first, then to BINARY
     * + PostgreSQL     : `CAST(x AS bytea)`
     *   + `CAST(1234567890 AS bytea)` throws
     * + SQLite         : `CAST(x AS BLOB)`
     *   + `CAST(1234567890 AS BLOB)` returns `[49,50,51,52,53,54,55,56,57,48]`
     *     + Converts to ASCII string first, then to BLOB
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    exports.unsafeCastAsBinary = factory_2.makeOperator1Idempotent(operator_type_7.OperatorType.CAST_AS_BINARY, tm.instanceOfUint8Array().orNull());
});
define("expr-library/cast/unsafe-cast-as-double", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_3, operator_type_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Attempts to cast to `DOUBLE`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL 5.7      : `x + 0e0`
     *   + `('qwerty' + 0e0)` returns `0e0`
     *   + `(TRUE + 0e0)` returns `1e0`
     *   + `(9223372036854775807 + 0e0)` returns `9223372036854776000e0`
     * + PostgreSQL     : `CAST(x AS DOUBLE PRECISION)`
     *   + `CAST('qwerty' AS DOUBLE PRECISION)` throws
     *   + `CAST(TRUE AS DOUBLE PRECISION)` throws
     *   + `CAST(9223372036854775807 AS DOUBLE PRECISION)` returns `9223372036854780000e0`
     * + SQLite         : `CAST(x AS DOUBLE)`
     *   + `CAST('qwerty' AS DOUBLE)` returns `0e0`
     *   + `CAST(TRUE AS DOUBLE)` returns `1e0`
     *   + `CAST(9223372036854775807 AS DOUBLE)` returns `9223372036854776000e0`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    exports.unsafeCastAsDouble = factory_3.makeOperator1Idempotent(operator_type_8.OperatorType.CAST_AS_DOUBLE, tm.orNull(tm.toUnsafeNumber()));
});
define("expr-library/cast/unsafe-cast-as-json", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_4, operator_type_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Attempts to cast to `JSON`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS JSON)`
     *   + `CAST(1 AS JSON)` returns `'1'`
     *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x": "y"}'`
     * + PostgreSQL     : `CAST(x AS JSON)`
     *   + `CAST(1 AS JSON)` throws
     *   + `CAST('{  "x"  :  "y"  }' AS JSON)` returns `'{"x":"y"}'`
     * + SQLite         : `CAST(x AS TEXT)`
     *   + Or implement with user-defined function.
     *   + Or the `JSON()` function?
     *   + https://www.sqlite.org/json1.html#jmini
     *   + SQLite does not have a `JSON` data type; `TEXT` is used for `JSON` values.
     *   + `JSON(1)` returns `'1'`
     *   + `CAST(1 AS TEXT)` returns `'1'`
     *   + `JSON('{  "x"  :  "y"  }')` returns `'{"x":"y"}'`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    exports.unsafeCastAsJson = factory_4.makeOperator1Idempotent(operator_type_9.OperatorType.CAST_AS_JSON, tm.orNull(tm.string()));
});
define("expr-library/cast/unsafe-cast-as-var-char", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_5, operator_type_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Attempts to cast to `VARCHAR`.
     *
     * **Behaviour is not unified.**
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#function_cast
     * + https://www.postgresql.org/docs/9.2/datatype.html#DATATYPE-TABLE
     * + https://www.sqlite.org/datatype3.html
     *
     * -----
     *
     * + MySQL          : `CAST(x AS CHAR)`
     *   + `CAST(TRUE AS CHAR)` returns `'1'`
     *   + `CAST(123e0 AS CHAR)` returns `'123'`
     * + PostgreSQL     : `CAST(x AS VARCHAR)`
     *   + `CAST(TRUE AS VARCHAR)` returns `'true'`
     *   + `CAST(CAST(123e0 AS DOUBLE PRECISION) AS VARCHAR)` returns `'123'`
     * + SQLite         : `CAST(x AS VARCHAR)`
     *   + `CAST(TRUE AS VARCHAR)` returns `'1'`
     *   + `CAST(123e0 AS VARCHAR)` returns `'123.0'`
     *
     * -----
     *
     * + https://github.com/AnyhowStep/tsql/issues/15
     */
    exports.unsafeCastAsVarChar = factory_5.makeOperator1Idempotent(operator_type_10.OperatorType.CAST_AS_VARCHAR, tm.orNull(tm.string()));
});
define("expr-library/cast/index", ["require", "exports", "expr-library/cast/bigint-signed-literal", "expr-library/cast/unsafe-cast-as-decimal", "expr-library/cast/decimal-literal", "expr-library/cast/unsafe-cast-as-bigint-signed", "expr-library/cast/unsafe-cast-as-binary", "expr-library/cast/unsafe-cast-as-double", "expr-library/cast/unsafe-cast-as-json", "expr-library/cast/unsafe-cast-as-var-char"], function (require, exports, bigint_signed_literal_1, unsafe_cast_as_decimal_1, decimal_literal_1, unsafe_cast_as_bigint_signed_1, unsafe_cast_as_binary_1, unsafe_cast_as_double_1, unsafe_cast_as_json_1, unsafe_cast_as_var_char_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(bigint_signed_literal_1);
    __export(unsafe_cast_as_decimal_1);
    //export * from "./cast-as-n-char";
    __export(decimal_literal_1);
    __export(unsafe_cast_as_bigint_signed_1);
    __export(unsafe_cast_as_binary_1);
    __export(unsafe_cast_as_double_1);
    __export(unsafe_cast_as_json_1);
    __export(unsafe_cast_as_var_char_1);
});
define("expr-library/comparison/between", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_6, operator_type_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between
     *
     * This version of the `BETWEEN ... AND` operator prevents `NULL`.
     *
     * For null-safe checks, @see {@link nullSafeBetween}
     *
     */
    exports.between = factory_6.makeComparison3(operator_type_11.OperatorType.BETWEEN_AND);
});
define("expr-library/comparison/greatest", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_7, operator_type_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_greatest
     *
     * This version of the `GREATEST(x, y, ...)` operator prevents `NULL`.
     *
     * No null-safe version is provided in this unification
     * because the different databases treat `NULL` arguments differently.
     *
     * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
     * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
     *
     * -----
     *
     * This version of the `GREATEST(x, y, ...)` operator requires
     * at least 2 arguments because MySQL's requires at least 2.
     *
     * Also, it does not make much sense to get the `GREATEST` of 1 value.
     */
    exports.greatest = factory_7.makeComparisonProjection2ToN(operator_type_12.OperatorType.GREATEST);
});
define("expr-library/comparison/gt-eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_8, operator_type_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal
     *
     * This version of the `>=` operator prevents `NULL`.
     *
     */
    exports.gtEq = factory_8.makeComparison2(operator_type_13.OperatorType.GREATER_THAN_OR_EQUAL);
});
define("expr-library/comparison/gt", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_9, operator_type_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than
     *
     * This version of the `>` operator prevents `NULL`.
     *
     */
    exports.gt = factory_9.makeComparison2(operator_type_14.OperatorType.GREATER_THAN);
});
define("expr-library/comparison/least", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_10, operator_type_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least
     *
     * This version of the `LEAST(x, y, ...)` operator prevents `NULL`.
     *
     * No null-safe version is provided in this unification
     * because the different databases treat `NULL` arguments differently.
     *
     * MySQL and SQLite will return `NULL` if at least one argument is `NULL`.
     * PostgreSQL will return `NULL` only if **all** arguments are `NULL`.
     *
     * -----
     *
     * This version of the `LEAST(x, y, ...)` operator requires
     * at least 2 arguments because MySQL's requires at least 2.
     *
     * Also, it does not make much sense to get the `LEAST` of 1 value.
     */
    exports.least = factory_10.makeComparisonProjection2ToN(operator_type_15.OperatorType.LEAST);
});
define("expr-library/comparison/lt-eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_11, operator_type_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal
     *
     * This version of the `<=` operator prevents `NULL`.
     *
     */
    exports.ltEq = factory_11.makeComparison2(operator_type_16.OperatorType.LESS_THAN_OR_EQUAL);
});
define("expr-library/comparison/lt", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_12, operator_type_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than
     *
     * This version of the `<` operator prevents `NULL`.
     *
     */
    exports.lt = factory_12.makeComparison2(operator_type_17.OperatorType.LESS_THAN);
});
define("expr-library/comparison/not-between", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_13, operator_type_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-between
     *
     * This version of the `NOT BETWEEN ... AND` operator prevents `NULL`.
     *
     * For null-safe checks, @see {@link nullSafeNotBetween}
     *
     */
    exports.notBetween = factory_13.makeComparison3(operator_type_18.OperatorType.NOT_BETWEEN_AND);
});
define("expr-library/comparison/index", ["require", "exports", "expr-library/comparison/between", "expr-library/comparison/greatest", "expr-library/comparison/gt-eq", "expr-library/comparison/gt", "expr-library/comparison/least", "expr-library/comparison/lt-eq", "expr-library/comparison/lt", "expr-library/comparison/not-between"], function (require, exports, between_1, greatest_1, gt_eq_1, gt_1, least_1, lt_eq_1, lt_1, not_between_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(between_1);
    __export(greatest_1);
    __export(gt_eq_1);
    __export(gt_1);
    __export(least_1);
    __export(lt_eq_1);
    __export(lt_1);
    __export(not_between_1);
});
define("expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl", ["require", "exports", "built-in-expr/index", "expr-library/control-flow/case-condition/case-condition-builder-impl"], function (require, exports, built_in_expr_42, case_condition_builder_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UninitializedCaseConditionBuilderImpl {
        constructor() {
        }
        when(condition, then) {
            return new case_condition_builder_impl_1.CaseConditionBuilderImpl([built_in_expr_42.BuiltInExprUtil.mapper(then)], built_in_expr_42.BuiltInExprUtil.intersectUsedRef(condition, then), {
                type: "CaseCondition",
                branches: [
                    [
                        built_in_expr_42.BuiltInExprUtil.buildAst(condition),
                        built_in_expr_42.BuiltInExprUtil.buildAst(then)
                    ]
                ],
                else: undefined,
            }, (built_in_expr_42.BuiltInExprUtil.isAggregate(condition) ||
                built_in_expr_42.BuiltInExprUtil.isAggregate(then)));
        }
    }
    exports.UninitializedCaseConditionBuilderImpl = UninitializedCaseConditionBuilderImpl;
});
define("expr-library/control-flow/case-condition/case-condition", ["require", "exports", "expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl"], function (require, exports, uninitialized_case_condition_builder_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function caseCondition() {
        return new uninitialized_case_condition_builder_impl_1.UninitializedCaseConditionBuilderImpl();
    }
    exports.caseCondition = caseCondition;
});
define("expr-library/control-flow/case-condition/case-condition-builder-impl", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/expr-impl", "used-ref/index"], function (require, exports, tm, built_in_expr_43, expr_impl_3, used_ref_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CaseConditionBuilderImpl {
        constructor(resultMappers, usedRef, ast, isAggregate) {
            this.resultMappers = resultMappers;
            this.usedRef = usedRef;
            this.ast = ast;
            this.isAggregate = isAggregate;
        }
        when(condition, then) {
            return new CaseConditionBuilderImpl([...this.resultMappers, built_in_expr_43.BuiltInExprUtil.mapper(then)], used_ref_32.UsedRefUtil.intersect(this.usedRef, built_in_expr_43.BuiltInExprUtil.intersectUsedRef(condition, then)), {
                type: "CaseCondition",
                /**
                 * https://github.com/microsoft/TypeScript/issues/33573
                 */
                branches: this.ast.branches.concat([
                    [
                        built_in_expr_43.BuiltInExprUtil.buildAst(condition),
                        built_in_expr_43.BuiltInExprUtil.buildAst(then)
                    ]
                ]),
                else: this.ast.else,
            }, (this.isAggregate ||
                built_in_expr_43.BuiltInExprUtil.isAggregate(condition) ||
                built_in_expr_43.BuiltInExprUtil.isAggregate(then)));
        }
        end() {
            return expr_impl_3.expr({
                mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
                usedRef: this.usedRef,
                isAggregate: this.isAggregate,
            }, this.ast);
        }
        else(elseResult) {
            const end = () => {
                return expr_impl_3.expr({
                    mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_43.BuiltInExprUtil.mapper(elseResult)),
                    usedRef: used_ref_32.UsedRefUtil.intersect(this.usedRef, built_in_expr_43.BuiltInExprUtil.usedRef(elseResult)),
                    isAggregate: (this.isAggregate ||
                        built_in_expr_43.BuiltInExprUtil.isAggregate(elseResult))
                }, {
                    ...this.ast,
                    else: built_in_expr_43.BuiltInExprUtil.buildAst(elseResult),
                });
            };
            return {
                end,
            };
        }
    }
    exports.CaseConditionBuilderImpl = CaseConditionBuilderImpl;
});
define("expr-library/control-flow/case-condition/index", ["require", "exports", "expr-library/control-flow/case-condition/case-condition-builder-impl", "expr-library/control-flow/case-condition/case-condition", "expr-library/control-flow/case-condition/uninitialized-case-condition-builder-impl"], function (require, exports, case_condition_builder_impl_2, case_condition_1, uninitialized_case_condition_builder_impl_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(case_condition_builder_impl_2);
    __export(case_condition_1);
    __export(uninitialized_case_condition_builder_impl_2);
});
define("expr-library/control-flow/case-value/uninitialized-case-value-builder-impl", ["require", "exports", "built-in-expr/index", "used-ref/index", "expr-library/control-flow/case-value/case-value-builder-impl"], function (require, exports, built_in_expr_44, used_ref_33, case_value_builder_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UninitializedCaseValueBuilderImpl {
        constructor(usedRef, valueAst, isAggregate) {
            this.usedRef = usedRef;
            this.valueAst = valueAst;
            this.isAggregate = isAggregate;
        }
        when(compareValue, then) {
            return new case_value_builder_impl_1.CaseValueBuilderImpl([built_in_expr_44.BuiltInExprUtil.mapper(then)], used_ref_33.UsedRefUtil.intersect(this.usedRef, built_in_expr_44.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
                type: "CaseValue",
                value: this.valueAst,
                cases: [
                    [
                        built_in_expr_44.BuiltInExprUtil.buildAst(compareValue),
                        built_in_expr_44.BuiltInExprUtil.buildAst(then)
                    ]
                ],
                else: undefined,
            }, (this.isAggregate ||
                built_in_expr_44.BuiltInExprUtil.isAggregate(compareValue) ||
                built_in_expr_44.BuiltInExprUtil.isAggregate(then)));
        }
    }
    exports.UninitializedCaseValueBuilderImpl = UninitializedCaseValueBuilderImpl;
});
define("expr-library/control-flow/case-value/case-value", ["require", "exports", "built-in-expr/index", "expr-library/control-flow/case-value/uninitialized-case-value-builder-impl"], function (require, exports, built_in_expr_45, uninitialized_case_value_builder_impl_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function caseValue(valueExpr) {
        return new uninitialized_case_value_builder_impl_1.UninitializedCaseValueBuilderImpl(built_in_expr_45.BuiltInExprUtil.usedRef(valueExpr), built_in_expr_45.BuiltInExprUtil.buildAst(valueExpr), built_in_expr_45.BuiltInExprUtil.isAggregate(valueExpr));
    }
    exports.caseValue = caseValue;
});
define("expr-library/control-flow/case-value/case-value-builder-impl", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/expr-impl", "used-ref/index"], function (require, exports, tm, built_in_expr_46, expr_impl_4, used_ref_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CaseValueBuilderImpl {
        constructor(resultMappers, usedRef, ast, isAggregate) {
            this.resultMappers = resultMappers;
            this.usedRef = usedRef;
            this.ast = ast;
            this.isAggregate = isAggregate;
        }
        when(compareValue, then) {
            return new CaseValueBuilderImpl([...this.resultMappers, built_in_expr_46.BuiltInExprUtil.mapper(then)], used_ref_34.UsedRefUtil.intersect(this.usedRef, built_in_expr_46.BuiltInExprUtil.intersectUsedRef(compareValue, then)), {
                type: "CaseValue",
                value: this.ast.value,
                /**
                 * https://github.com/microsoft/TypeScript/issues/33573
                 */
                cases: this.ast.cases.concat([
                    [
                        built_in_expr_46.BuiltInExprUtil.buildAst(compareValue),
                        built_in_expr_46.BuiltInExprUtil.buildAst(then)
                    ]
                ]),
                else: this.ast.else,
            }, (this.isAggregate ||
                built_in_expr_46.BuiltInExprUtil.isAggregate(compareValue) ||
                built_in_expr_46.BuiltInExprUtil.isAggregate(then)));
        }
        end() {
            return expr_impl_4.expr({
                mapper: tm.unsafeOr(...this.resultMappers, tm.null()),
                usedRef: this.usedRef,
                isAggregate: this.isAggregate,
            }, this.ast);
        }
        else(elseResult) {
            const end = () => {
                return expr_impl_4.expr({
                    mapper: tm.unsafeOr(...this.resultMappers, built_in_expr_46.BuiltInExprUtil.mapper(elseResult)),
                    usedRef: used_ref_34.UsedRefUtil.intersect(this.usedRef, built_in_expr_46.BuiltInExprUtil.usedRef(elseResult)),
                    isAggregate: (this.isAggregate ||
                        built_in_expr_46.BuiltInExprUtil.isAggregate(elseResult))
                }, {
                    ...this.ast,
                    else: built_in_expr_46.BuiltInExprUtil.buildAst(elseResult),
                });
            };
            return {
                end,
            };
        }
    }
    exports.CaseValueBuilderImpl = CaseValueBuilderImpl;
});
define("expr-library/control-flow/case-value/index", ["require", "exports", "expr-library/control-flow/case-value/case-value-builder-impl", "expr-library/control-flow/case-value/case-value", "expr-library/control-flow/case-value/uninitialized-case-value-builder-impl"], function (require, exports, case_value_builder_impl_2, case_value_1, uninitialized_case_value_builder_impl_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(case_value_builder_impl_2);
    __export(case_value_1);
    __export(uninitialized_case_value_builder_impl_2);
});
define("expr-library/control-flow/case", ["require", "exports", "expr-library/control-flow/case-value/index", "expr-library/control-flow/case-condition/index"], function (require, exports, case_value_2, case_condition_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function caseConstructor(valueExpr) {
        if (valueExpr === undefined) {
            return case_condition_2.caseCondition();
        }
        else {
            return case_value_2.caseValue(valueExpr);
        }
    }
    exports.case = caseConstructor;
});
define("expr-library/control-flow/type-of-coalesce", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("expr-library/control-flow/coalesce", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/index", "ast/operator-node/util/index", "operator-type"], function (require, exports, tm, built_in_expr_47, expr_42, util_7, operator_type_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function coalesceMapper(...args) {
        const builtInExprMapperArr = [];
        let lastMapperNonNull = false;
        for (const builtInExpr of args) {
            const builtInExprMapper = built_in_expr_47.BuiltInExprUtil.mapper(builtInExpr);
            builtInExprMapperArr.push(builtInExprMapper);
            if (!tm.canOutputNull(builtInExprMapper)) {
                lastMapperNonNull = true;
                break;
            }
        }
        return (lastMapperNonNull ?
            tm.notNull(tm.unsafeOr(...builtInExprMapperArr)) :
            tm.unsafeOr(...builtInExprMapperArr));
    }
    exports.coalesceMapper = coalesceMapper;
    /**
     * Returns the first non-`NULL` value in the list,
     * or `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_coalesce
     * + https://www.postgresql.org/docs/9.5/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#coalesce
     *
     * -----
     *
     * + MySQL        : `COALESCE(x, ...)`
     * + PostgreSQL   : `COALESCE(x, ...)`
     * + SQLite       : `COALESCE(x, ...)`
     *
     * -----
     *
     * `COALESCE()` with zero args is just the `NULL` constant.
     */
    function coalesce(...args) {
        const [arg0, arg1, ...argRest] = args;
        if (arg0 === undefined) {
            /**
             * `COALESCE()` with zero args is just the `NULL` constant.
             */
            return expr_42.ExprUtil.fromBuiltInExpr(null);
        }
        else if (arg1 === undefined) {
            /**
             * `COALESCE(x)` is just `x`
             */
            return expr_42.ExprUtil.fromBuiltInExpr(arg0);
        }
        else {
            return expr_42.ExprUtil.intersect(coalesceMapper(...args), args, util_7.operatorNode2ToN(operator_type_19.OperatorType.COALESCE, [
                built_in_expr_47.BuiltInExprUtil.buildAst(arg0),
                built_in_expr_47.BuiltInExprUtil.buildAst(arg1),
                ...argRest.map(built_in_expr_47.BuiltInExprUtil.buildAst)
            ], undefined));
        }
    }
    exports.coalesce = coalesce;
});
define("expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table", ["require", "exports", "table/index", "column-map/index", "key/index", "type-util/index"], function (require, exports, table_33, column_map_32, key_14, type_util_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns) {
        const candidateKeys = table_33.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
        const srcColumnAliases = srcColumns.map(column => column.columnAlias);
        const dstCandidateKey = candidateKeys.find(candidateKey => key_14.KeyUtil.isEqual(candidateKey, srcColumnAliases));
        if (dstCandidateKey == undefined) {
            throw new Error(`${column_map_32.ColumnMapUtil.tableAlias(src.columns)} (${srcColumnAliases.join(",")}) cannot be used to compare with candidate keys of ${column_map_32.ColumnMapUtil.tableAlias(dst.columns)}`);
        }
        column_map_32.ColumnMapUtil.assertIsNullSafeComparable(column_map_32.ColumnMapUtil.fromColumnArray(srcColumns), type_util_24.pickOwnEnumerable(dst.columns, dstCandidateKey));
        return dstCandidateKey;
    }
    exports.assertNullSafeComparableToCandidateKeysOfTable = assertNullSafeComparableToCandidateKeysOfTable;
});
define("expr-library/logical/and", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_14, operator_type_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     *
     * This version of the `AND` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link and3}
     */
    exports.and = factory_14.makeChainableOperator(operator_type_20.OperatorType.AND, true, tm.mysql.boolean());
});
define("expr-library/logical/is-not-null-and", ["require", "exports", "column/index", "expr-library/null-safe-equation/index", "expr-library/logical/and"], function (require, exports, column_47, null_safe_equation_1, and_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNotNullAnd(column, builtInExprDelegate) {
        return and_1.and(null_safe_equation_1.isNotNull(column), builtInExprDelegate({
            [column.columnAlias]: column_47.ColumnUtil.toNonNullable(column)
        }));
    }
    exports.isNotNullAnd = isNotNullAnd;
});
define("expr-library/logical/or", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_15, operator_type_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     *
     * This version of the `OR` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link or3}
     */
    exports.or = factory_15.makeChainableOperator(operator_type_21.OperatorType.OR, false, tm.mysql.boolean());
});
define("expr-library/logical/is-null-or", ["require", "exports", "column/index", "expr-library/null-safe-equation/index", "expr-library/logical/or"], function (require, exports, column_48, null_safe_equation_2, or_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNullOr(column, builtInExprDelegate) {
        return or_1.or(null_safe_equation_2.isNull(column), builtInExprDelegate({
            [column.columnAlias]: column_48.ColumnUtil.toNonNullable(column)
        }));
    }
    exports.isNullOr = isNullOr;
});
define("expr-library/logical/not", ["require", "exports", "type-mapping", "operator-type", "expr-library/factory/index"], function (require, exports, tm, operator_type_22, factory_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     *
     * This version of the `NOT` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link not3}
     */
    exports.not = factory_16.makeOperator1DoubleElimination(operator_type_22.OperatorType.NOT, tm.mysql.boolean());
});
define("expr-library/logical/xor", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_17, operator_type_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * This version of the `XOR` operator forbids `NULL`.
     *
     * For three-valued logic, @see {@link xor3}
     */
    exports.xor = factory_17.makeOperator2(operator_type_23.OperatorType.XOR, tm.mysql.boolean());
});
define("expr-library/logical/index", ["require", "exports", "expr-library/logical/and", "expr-library/logical/is-not-null-and", "expr-library/logical/is-null-or", "expr-library/logical/not", "expr-library/logical/or", "expr-library/logical/xor"], function (require, exports, and_2, is_not_null_and_1, is_null_or_1, not_1, or_2, xor_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(and_2);
    __export(is_not_null_and_1);
    __export(is_null_or_1);
    __export(not_1);
    __export(or_2);
    __export(xor_1);
});
define("expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-keys-of-table-delegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr-library/null-safe-equation/null-safe-eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_18, operator_type_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     *
     * This operator allows `NULL`.
     *
     * This operator performs an equality comparison like the `=` operator,
     * but returns
     * + `true` rather than `NULL` if both operands are `NULL`, and
     * + `false` rather than `NULL` if one operand is `NULL`.
     *
     * For regular equality, @see {@link eq}
     */
    exports.nullSafeEq = factory_18.makeNullSafeEquation2(operator_type_24.OperatorType.NULL_SAFE_EQUAL);
});
define("expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table", ["require", "exports", "table/index", "expr-library/logical/index", "type-util/index", "expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table", "expr-library/null-safe-equation/null-safe-eq"], function (require, exports, table_34, logical_1, type_util_25, assert_null_safe_comparable_to_candidate_keys_of_table_1, null_safe_eq_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqCandidateKeyOfTable = ((src, dst, eqCandidateKeyOfTableDelegate) => {
        const candidateKeys = table_34.TableUtil.extractCandidateKeysWithColumnAliasInTable(dst, src);
        const columnAliases = [];
        for (const key of candidateKeys) {
            columnAliases.push(...key);
        }
        const columns = type_util_25.pickOwnEnumerable(src.columns, columnAliases);
        const srcColumns = eqCandidateKeyOfTableDelegate(columns);
        const dstCandidateKey = assert_null_safe_comparable_to_candidate_keys_of_table_1.assertNullSafeComparableToCandidateKeysOfTable(src, dst, srcColumns);
        /**
         * No need to `.sort()`, just use `candidateKey` and the order
         * the user set.
         */
        const arr = dstCandidateKey.map((columnAlias) => {
            /**
             * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
             */
            const expr = null_safe_eq_1.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
            return expr;
        });
        const result = logical_1.and(...arr);
        return result;
    });
});
define("expr-library/null-safe-equation/eq-candidate-key-of-table/index", ["require", "exports", "expr-library/null-safe-equation/eq-candidate-key-of-table/assert-null-safe-comparable-to-candidate-keys-of-table", "expr-library/null-safe-equation/eq-candidate-key-of-table/eq-candidate-key-of-table"], function (require, exports, assert_null_safe_comparable_to_candidate_keys_of_table_2, eq_candidate_key_of_table_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(assert_null_safe_comparable_to_candidate_keys_of_table_2);
    __export(eq_candidate_key_of_table_1);
});
define("expr-library/null-safe-equation/eq-candidate-key", ["require", "exports", "expr-library/logical/index", "candidate-key/index", "column-map/index", "expr-library/null-safe-equation/null-safe-eq", "built-in-expr/index"], function (require, exports, logical_2, candidate_key_6, column_map_33, null_safe_eq_2, built_in_expr_48) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqCandidateKey = ((table, candidateKeyInput) => {
        const candidateKey = candidate_key_6.CandidateKeyUtil.mapperPreferPrimaryKey(table)(`${column_map_33.ColumnMapUtil.tableAlias(table.columns)}.candidateKey`, candidateKeyInput);
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `candidateKey` was constructed.
         */
        const arr = Object.keys(candidateKey).sort().map((columnAlias) => {
            const expr = null_safe_eq_2.nullSafeEq(table.columns[columnAlias], built_in_expr_48.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], candidateKey[columnAlias]));
            return expr;
        });
        const result = logical_2.and(...arr);
        return result;
    });
});
define("expr-library/null-safe-equation/eq-columns", ["require", "exports", "expr-library/logical/index", "column-map/index", "partial-row/index", "expr-library/null-safe-equation/null-safe-eq", "built-in-expr/index"], function (require, exports, logical_3, column_map_34, partial_row_1, null_safe_eq_3, built_in_expr_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqColumns = ((table, columnsInput) => {
        const columns = partial_row_1.PartialRowUtil.mapper(table)(`${column_map_34.ColumnMapUtil.tableAlias(table.columns)}.columns`, columnsInput);
        const arr = Object.keys(columns)
            .filter((columnAlias) => {
            return columns[columnAlias] !== undefined;
        })
            /**
             * We `.sort()` the keys so our resulting SQL is deterministic,
             * regardless of how `columns` was constructed.
             */
            .sort()
            .map((columnAlias) => {
            const expr = null_safe_eq_3.nullSafeEq(table.columns[columnAlias], built_in_expr_49.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], columns[columnAlias]));
            return expr;
        });
        const result = logical_3.and(...arr);
        return result;
    });
});
define("expr-library/null-safe-equation/eq-primary-key-of-table", ["require", "exports", "table/index", "expr-library/logical/index", "expr-library/null-safe-equation/null-safe-eq"], function (require, exports, table_35, logical_4, null_safe_eq_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqPrimaryKeyOfTable = ((src, dst) => {
        table_35.TableUtil.assertHasNullSafeComparablePrimaryKey(dst, src.columns);
        /**
         * No need to `.sort()`, just use `primaryKey` and the order
         * the user set.
         */
        const arr = dst.primaryKey.map((columnAlias) => {
            /**
             * We use `nullSafeEq` because `src.dstPkX` may have nullable columns.
             */
            const expr = null_safe_eq_4.nullSafeEq(src.columns[columnAlias], dst.columns[columnAlias]);
            return expr;
        });
        const result = logical_4.and(...arr);
        return result;
    });
});
define("expr-library/null-safe-equation/eq-super-key", ["require", "exports", "expr-library/logical/index", "super-key/index", "column-map/index", "expr-library/null-safe-equation/null-safe-eq", "built-in-expr/index"], function (require, exports, logical_5, super_key_2, column_map_35, null_safe_eq_5, built_in_expr_50) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqSuperKey = ((table, superKeyInput) => {
        const superKey = super_key_2.SuperKeyUtil.mapper(table)(`${column_map_35.ColumnMapUtil.tableAlias(table.columns)}.superKey`, superKeyInput);
        const arr = Object.keys(superKey)
            .filter((columnAlias) => {
            return superKey[columnAlias] !== undefined;
        })
            /**
             * We `.sort()` the keys so our resulting SQL is deterministic,
             * regardless of how `superKey` was constructed.
             */
            .sort()
            .map((columnAlias) => {
            const expr = null_safe_eq_5.nullSafeEq(table.columns[columnAlias], built_in_expr_50.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
            return expr;
        });
        const result = logical_5.and(...arr);
        return result;
    });
});
define("expr-library/null-safe-equation/is-not-null", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_19, operator_type_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not-null
     *
     * Tests whether a value is not `NULL`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT NULL), (0 IS NOT NULL), (NULL IS NOT NULL);
     *         -> 1, 1, 0
     * ```
     */
    exports.isNotNull = factory_19.makeNullSafeEquation1(operator_type_25.OperatorType.IS_NOT_NULL);
});
define("expr-library/null-safe-equation/is-null", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_20, operator_type_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null
     *
     * Tests whether a value is NULL.
     *
     * ```sql
     * mysql> SELECT (1 IS NULL), (0 IS NULL), (NULL IS NULL);
     *         -> 0, 0, 1
     * ```
     */
    exports.isNull = factory_20.makeNullSafeEquation1(operator_type_26.OperatorType.IS_NULL);
});
define("expr-library/null-safe-equation/not-null-safe-eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_21, operator_type_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to
     *
     * This operator allows `NULL`.
     *
     * This operator performs an equality comparison like the `=` operator,
     * but returns
     * + `false` rather than `NULL` if both operands are `NULL`, and
     * + `true` rather than `NULL` if one operand is `NULL`.
     *
     * For regular equality, @see {@link eq}
     */
    exports.notNullSafeEq = factory_21.makeNullSafeEquation2(operator_type_27.OperatorType.NOT_NULL_SAFE_EQUAL);
});
define("expr-library/null-safe-equation/index", ["require", "exports", "expr-library/null-safe-equation/eq-candidate-key-of-table/index", "expr-library/null-safe-equation/eq-candidate-key", "expr-library/null-safe-equation/eq-columns", "expr-library/null-safe-equation/eq-primary-key-of-table", "expr-library/null-safe-equation/eq-super-key", "expr-library/null-safe-equation/is-not-null", "expr-library/null-safe-equation/is-null", "expr-library/null-safe-equation/not-null-safe-eq", "expr-library/null-safe-equation/null-safe-eq"], function (require, exports, eq_candidate_key_of_table_2, eq_candidate_key_1, eq_columns_1, eq_primary_key_of_table_1, eq_super_key_1, is_not_null_1, is_null_1, not_null_safe_eq_1, null_safe_eq_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(eq_candidate_key_of_table_2);
    __export(eq_candidate_key_1);
    __export(eq_columns_1);
    __export(eq_primary_key_of_table_1);
    __export(eq_super_key_1);
    __export(is_not_null_1);
    __export(is_null_1);
    __export(not_null_safe_eq_1);
    __export(null_safe_eq_6);
});
define("expr-library/control-flow/if", ["require", "exports", "type-mapping", "built-in-expr/index", "ast/index", "operator-type", "expr/index"], function (require, exports, tm, built_in_expr_51, ast_36, operator_type_28, expr_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Behaves like an `if-else` statement from most programming languages.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_if
     *
     * -----
     *
     * + MySQL        : `IF(x, y, z)`
     * + PostgreSQL   : `CASE WHEN x THEN y ELSE z END`
     * + SQLite       : `CASE WHEN x THEN y ELSE z END`
     *
     * -----
     *
     * @param condition - The boolean expression to evaluate
     * @param then - The result if `condition` is `true`
     * @param elseResult - The result if `condition` is `false`
     *
     * @see caseCondition
     */
    function ifConstructor(condition, then, elseResult) {
        return expr_43.ExprUtil.intersect(tm.or(built_in_expr_51.BuiltInExprUtil.mapper(then), built_in_expr_51.BuiltInExprUtil.mapper(elseResult)), [condition, then, elseResult], ast_36.OperatorNodeUtil.operatorNode3(operator_type_28.OperatorType.IF, [
            built_in_expr_51.BuiltInExprUtil.buildAst(condition),
            built_in_expr_51.BuiltInExprUtil.buildAst(then),
            built_in_expr_51.BuiltInExprUtil.buildAst(elseResult),
        ], undefined));
    }
    exports.if = ifConstructor;
});
define("expr-library/control-flow/if-is-null", ["require", "exports", "column/index", "expr-library/null-safe-equation/index", "expr-library/control-flow/if"], function (require, exports, column_49, null_safe_equation_3, ifImpl) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A special compile-time type-narrowing function.
     *
     * Narrows a column from `T|null` to `T` in the else-branch.
     *
     * Translated to SQL, we get,
     * ```sql
     *  IF(
     *      myColumn IS NULL,
     *      thenExpr,
     *      -- The `elseExpr` is free to use `myColumn` as a non-nullable column
     *      -- because we know `myColumn` is NOT NULL in the else-branch.
     *      elseExpr
     *  )
     * ```
     *
     *
     * @param column - The column to narrow from `T|null` to `T`
     * @param then - The result of the expression, if the `column` is `null`
     * @param elseDelegate - The result of the expression, if the `column` is `T`
     */
    function ifIsNull(column, then, elseDelegate) {
        return ifImpl.if(null_safe_equation_3.isNull(column), then, elseDelegate({
            [column.columnAlias]: column_49.ColumnUtil.toNonNullable(column)
        }));
    }
    exports.ifIsNull = ifIsNull;
});
define("expr-library/control-flow/if-null", ["require", "exports", "built-in-expr/index", "expr-library/control-flow/coalesce", "expr/index", "ast/index", "operator-type"], function (require, exports, built_in_expr_52, coalesce_5, expr_44, ast_37, operator_type_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Equivalent to `COALESCE()` with two arguments.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_ifnull
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL
     * + https://www.sqlite.org/lang_corefunc.html#ifnull
     *
     * -----
     *
     * `COALESCE()` is part of the SQL standard.
     * `IFNULL()` is DB-specific.
     *
     * But `IFNULL()` should behave the same as `COALESCE(x, y)`.
     *
     * -----
     *
     * + MySQL        : `IFNULL(x, y)`
     * + PostgreSQL   : `COALESCE(x, y)`
     * + SQLite       : `IFNULL(x, y)`
     *
     * -----
     *
     * @see coalesce
     */
    function ifNull(arg0, arg1) {
        return expr_44.ExprUtil.intersect(coalesce_5.coalesceMapper(arg0, arg1), [arg0, arg1], ast_37.OperatorNodeUtil.operatorNode2(operator_type_29.OperatorType.IF_NULL, [
            built_in_expr_52.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_52.BuiltInExprUtil.buildAst(arg1)
        ], undefined));
    }
    exports.ifNull = ifNull;
});
define("expr-library/control-flow/null-if", ["require", "exports", "type-mapping", "built-in-expr/index", "expr/index", "ast/index", "operator-type"], function (require, exports, tm, built_in_expr_53, expr_45, ast_38, operator_type_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns `null` if both arguments are null-safe equal.
     *
     * Otherwise, returns the first argument.
     *
     * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * @see nullIfEqual
     */
    function nullIf(arg0, arg1) {
        return expr_45.ExprUtil.intersect(tm.orNull(built_in_expr_53.BuiltInExprUtil.mapper(arg0)), [arg0, arg1], ast_38.OperatorNodeUtil.operatorNode2(operator_type_30.OperatorType.NULL_IF_EQUAL, [
            built_in_expr_53.BuiltInExprUtil.buildAst(arg0),
            built_in_expr_53.BuiltInExprUtil.buildAst(arg1)
        ], undefined));
    }
    exports.nullIf = nullIf;
    /**
     * Synonym for `NULLIF(x, y)`.
     *
     * Returns `null` if both arguments are null-safe equal.
     *
     * Otherwise, returns the first argument.
     *
     * This is equivalent to `IF(arg0 <null-safe-eq> arg1, null, arg0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/control-flow-functions.html#function_nullif
     * + https://www.postgresql.org/docs/9.2/functions-conditional.html#FUNCTIONS-NULLIF
     * + https://www.sqlite.org/lang_corefunc.html#nullif
     *
     * -----
     *
     * + MySQL        : `NULLIF(x, y)`
     * + PostgreSQL   : `NULLIF(x, y)`
     * + SQLite       : `NULLIF(x, y)`
     *
     * @see nullIf
     */
    exports.nullIfEqual = nullIf;
});
define("expr-library/control-flow/index", ["require", "exports", "expr-library/control-flow/case-condition/index", "expr-library/control-flow/case-value/index", "expr-library/control-flow/case", "expr-library/control-flow/coalesce", "expr-library/control-flow/if-is-null", "expr-library/control-flow/if-null", "expr-library/control-flow/if", "expr-library/control-flow/null-if"], function (require, exports, case_condition_3, case_value_3, case_1, coalesce_6, if_is_null_1, if_null_1, if_1, null_if_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(case_condition_3);
    __export(case_value_3);
    __export(case_1);
    __export(coalesce_6);
    __export(if_is_null_1);
    __export(if_null_1);
    __export(if_1);
    __export(null_if_1);
});
define("expr-library/date-time/current-date", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_22, operator_type_31, type_hint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the current date.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-date
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_DATE()`
     * + PostgreSQL     : `CURRENT_DATE()`
     * + SQLite         : `strftime('%Y-%m-%d', 'now')`
     *
     * -----
     *
     * Sets hour, minute, second, millisecond to zero.
     */
    exports.currentDate = factory_22.makeOperator0(operator_type_31.OperatorType.CURRENT_DATE, tm.mysql.dateTime(0), type_hint_1.TypeHint.DATE_TIME);
});
define("expr-library/date-time/current-timestamp", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_23, operator_type_32, type_hint_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the current date-time, accurate to 1-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(0)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(0)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%S', 'now')` gives precision `0`
     */
    exports.currentTimestamp0 = factory_23.makeOperator0(operator_type_32.OperatorType.CURRENT_TIMESTAMP_0, tm.mysql.dateTime(0), type_hint_2.TypeHint.DATE_TIME);
    /**
     * Returns the current date-time, accurate to 0.1-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(1)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(1)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 21)` gives precision `1`
     */
    exports.currentTimestamp1 = factory_23.makeOperator0(operator_type_32.OperatorType.CURRENT_TIMESTAMP_1, tm.mysql.dateTime(1), type_hint_2.TypeHint.DATE_TIME);
    /**
     * Returns the current date-time, accurate to 0.01-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(2)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(2)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `substr(strftime('%Y-%m-%d %H:%M:%f', 'now'), 1, 22)` gives precision `2`
     */
    exports.currentTimestamp2 = factory_23.makeOperator0(operator_type_32.OperatorType.CURRENT_TIMESTAMP_2, tm.mysql.dateTime(2), type_hint_2.TypeHint.DATE_TIME);
    /**
     * Returns the current date-time, accurate to 0.001-second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `CURRENT_TIMESTAMP(3)`
     * + PostgreSQL     : `CURRENT_TIMESTAMP(3)`
     *   + http://www.postgresqltutorial.com/postgresql-localtimestamp/
     *
     *   > The `LOCALTIMESTAMP` function returns a `TIMESTAMP` value **without** time zone while
     *   > the `CURRENT_TIMESTAMP` function returns a `TIMESTAMP` **with** time zone.
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', 'now')` gives precision `3`
     */
    exports.currentTimestamp3 = factory_23.makeOperator0(operator_type_32.OperatorType.CURRENT_TIMESTAMP_3, tm.mysql.dateTime(3), type_hint_2.TypeHint.DATE_TIME);
});
define("expr-library/date-time/extract", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_24, operator_type_33, type_hint_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Extracts the second from a date-time, including fractional seconds; accurate to 0.001 second.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * Behaviour is not defined when using 0.0001 second precision (or more precise).
     * SQLite may alternate between truncating and rounding.
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime) + FLOOR(EXTRACT(MICROSECOND FROM datetime) / 1000e0) / 1000e0`
     * ```sql
     *  SELECT
     *      EXTRACT(SECOND FROM timestamp '2010-03-27 14:45:32.456789') +
     *      FLOOR(EXTRACT(MICROSECOND FROM timestamp '2010-03-27 14:45:32.456789') / 1000.0e0) / 1000.0e0
     *  > 32.456
     * ```
     * + PostgreSQL     : `FLOOR(EXTRACT(SECOND FROM datetime) * 1000) / 1000`
     * + SQLite         : `CAST(strftime('%f', datetime) AS DOUBLE)`
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 14:45:32.456789')
     *  > 32.457
     *  -- The result is rounded, not truncated.
     *  -- If it were truncated, we would get 32.456
     * ```
     * ```sql
     *  SELECT
     *      strftime('%f', '2010-03-27 23:59:59.999999')
     *  > 59.999
     *  -- The result is truncated, not rounded.
     *  -- If it were rounded, we would get 60
     * ```
     *
     * @todo Make behaviour consistent?
     */
    exports.extractFractionalSecond3 = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_FRACTIONAL_SECOND_3, tm.mysql.double(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the second from a date-time, truncating fractional seconds.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(SECOND FROM datetime)`
     * + PostgreSQL     : `CAST(FLOOR(EXTRACT(SECOND FROM datetime)) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%S', datetime) AS BIGINT)`
     */
    exports.extractIntegerSecond = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_INTEGER_SECOND, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the minute from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MINUTE FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MINUTE FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%M', datetime) AS BIGINT)`
     */
    exports.extractMinute = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_MINUTE, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the hour from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(HOUR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(HOUR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%H', datetime) AS BIGINT)`
     */
    exports.extractHour = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_HOUR, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the day (of the month) from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(DAY FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(DAY FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%d', datetime) AS BIGINT)`
     */
    exports.extractDay = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_DAY, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the month from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(MONTH FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(MONTH FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%m', datetime) AS BIGINT)`
     */
    exports.extractMonth = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_MONTH, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
    /**
     * Extracts the year from a date-time.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_extract
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * MySQL returns a `bigint signed`.
     * PostgreSQL returns a `double precision`.
     * SQLite returns a `text`.
     *
     * This library casts all results to `BIGINT SIGNED`
     *
     * -----
     *
     * + MySQL          : `EXTRACT(YEAR FROM datetime)`
     * + PostgreSQL     : `CAST(EXTRACT(YEAR FROM datetime) AS BIGINT)`
     * + SQLite         : `CAST(strftime('%Y', datetime) AS BIGINT)`
     */
    exports.extractYear = factory_24.makeOperator1(operator_type_33.OperatorType.EXTRACT_YEAR, 
    /**
     * Should not be negative
     */
    tm.mysql.bigIntUnsigned(), type_hint_3.TypeHint.DATE_TIME);
});
define("expr-library/date-time/last-day", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_25, operator_type_34, type_hint_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the date of the last day of the month.
     *
     * Sets hour, minute, second, fractional second to zero.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_last-day
     *
     * -----
     *
     * + MySQL          : `LAST_DAY(datetime)`
     * ```sql
     *  SELECT
     *      LAST_DAY(timestamp '2010-03-27 14:45:32.456789')
     *  > 2010-03-31
     * ```
     * + PostgreSQL     :
     * ```sql
     *  SELECT
     *      (
     *          datetime +
     *          interval '1 month' -
     *          CONCAT(EXTRACT(DAY FROM datetime), ' day')::interval
     *      )::date
     * > 2010-03-31T00:00:00.000Z
     * ```
     * + SQLite         :
     * ```sql
     *  SELECT
     *      strftime(
     *          '%Y-%m-%d',
     *          '2010-03-27 14:45:32.456789',
     *          '+1 month',
     *          '-' || strftime('%d', '2010-03-27 14:45:32.456789') || ' day'
     *      )
     *  > 2010-03-31
     * ```
     */
    exports.lastDay = factory_25.makeOperator1(operator_type_34.OperatorType.LAST_DAY, tm.mysql.dateTime(0), type_hint_4.TypeHint.DATE_TIME);
});
define("expr-library/date-time/timestamp-add", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_26, operator_type_35, type_hint_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Adds the specified number of milliseconds to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MICROSECOND, x*1000, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' millisecond')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      (x/1000e0) || ' second'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of milliseconds to add; following MySQL convention
     * @param right - The date-time to add milliseconds to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddMillisecond = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_MILLISECOND, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of seconds to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(SECOND, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' second')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' second'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of seconds to add; following MySQL convention
     * @param right - The date-time to add seconds to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddSecond = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_SECOND, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of minutes to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MINUTE, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' minute')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' minute'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of minutes to add; following MySQL convention
     * @param right - The date-time to add minutes to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddMinute = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_MINUTE, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of hours to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(HOUR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' hour')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' hour'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of hours to add; following MySQL convention
     * @param right - The date-time to add hours to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddHour = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_HOUR, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of days to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(DAY, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' day')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' day'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of days to add; following MySQL convention
     * @param right - The date-time to add days to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddDay = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_DAY, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of months to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(MONTH, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' month')::interval`
     * + SQLite         : Complicated implementation.
     *
     * -----
     *
     * @param left - The number of months to add; following MySQL convention
     * @param right - The date-time to add months to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddMonth = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_MONTH, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
    /**
     * Adds the specified number of years to the date-time.
     *
     * May return `null`, or throw on overflow.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampadd
     * + https://www.postgresql.org/docs/9.4/functions-datetime.html#OPERATORS-DATETIME-TABLE
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPADD(YEAR, x, datetime)`
     * + PostgreSQL     : `datetime + concat(x, ' year')::interval`
     * + SQLite         :
     * ```sql
     *  strftime(
     *      '%Y-%m-%d %H:%M:%f',
     *      datetime,
     *      x || ' year'
     *  );
     * ```
     *
     * -----
     *
     * @param left - The number of years to add; following MySQL convention
     * @param right - The date-time to add years to; following MySQL convention
     *
     * @todo Unify negative overflow behaviour.
     */
    exports.timestampAddYear = factory_26.makeOperator2(operator_type_35.OperatorType.TIMESTAMPADD_YEAR, tm.mysql.dateTime(3).orNull(), type_hint_5.TypeHint.DATE_TIME);
});
define("expr-library/date-time/timestamp-diff", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_27, operator_type_36, type_hint_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the number of milliseconds between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `CAST(TIMESTAMPDIFF(MICROSECOND, from, to)/1000.0 AS SIGNED INTEGER)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60*1000 + EXTRACT(HOUR FROM (to - from))*60*60*1000 + EXTRACT(MINUTE FROM (to - from))*60*1000 + TRUNC(EXTRACT(SECOND FROM (to - from))*1000)`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     *   + Every `EXTRACT()/TRUNC()` should be wrapped with a cast to `BIGINT`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 * 1000 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in milliseconds
     */
    exports.timestampDiffMillisecond = factory_27.makeOperator2(operator_type_36.OperatorType.TIMESTAMPDIFF_MILLISECOND, tm.mysql.bigIntSigned(), type_hint_6.TypeHint.DATE_TIME);
    /**
     * Returns the number of seconds between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(SECOND, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60*60 + EXTRACT(HOUR FROM (to - from))*60*60 + EXTRACT(MINUTE FROM (to - from))*60 + TRUNC(EXTRACT(SECOND FROM (to - from)))`
     *   + The `TRUNC()` at the end is necessary
     *   + Extracting `SECOND` gives a number with decimal places for milliseconds
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in seconds
     */
    exports.timestampDiffSecond = factory_27.makeOperator2(operator_type_36.OperatorType.TIMESTAMPDIFF_SECOND, tm.mysql.bigIntSigned(), type_hint_6.TypeHint.DATE_TIME);
    /**
     * Returns the number of minutes between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(MINUTE, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24*60 + EXTRACT(HOUR FROM (to - from))*60 + EXTRACT(MINUTE FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 * 60 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in minutes
     */
    exports.timestampDiffMinute = factory_27.makeOperator2(operator_type_36.OperatorType.TIMESTAMPDIFF_MINUTE, tm.mysql.bigIntSigned(), type_hint_6.TypeHint.DATE_TIME);
    /**
     * Returns the number of hours between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(HOUR, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))*24 + EXTRACT(HOUR FROM (to - from))`
     * + SQLite         : `CAST( (strftime('%J', to) - strftime('%J', from)) * 24 AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in hours
     */
    exports.timestampDiffHour = factory_27.makeOperator2(operator_type_36.OperatorType.TIMESTAMPDIFF_HOUR, tm.mysql.bigIntSigned(), type_hint_6.TypeHint.DATE_TIME);
    /**
     * Returns the number of days between two date-times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_timestampdiff
     *
     * -----
     *
     * + MySQL          : `TIMESTAMPDIFF(DAY, from, to)`
     * + PostgreSQL     : `EXTRACT(DAY FROM (to - from))`
     * + SQLite         : `CAST(strftime('%J', to) - strftime('%J', from) AS BIGINT)`
     *   + We cast to `BIGINT` to be consistent with MySQL
     *
     * -----
     *
     * @param left - The start date-time
     * @param right - The end date-time
     * @returns - Returns `right - left` in days
     */
    exports.timestampDiffDay = factory_27.makeOperator2(operator_type_36.OperatorType.TIMESTAMPDIFF_DAY, tm.mysql.bigIntSigned(), type_hint_6.TypeHint.DATE_TIME);
});
define("expr-library/date-time/unix-timestamp-now", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_28, operator_type_37, type_hint_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a Unix timestamp representing seconds since '1970-01-01 00:00:00' UTC.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_unix-timestamp
     * + https://www.sqlite.org/lang_datefunc.html
     *
     * -----
     *
     * + MySQL          : `UNIX_TIMESTAMP()`
     * + PostgreSQL     :
     * ```sql
     *  FLOOR(
     *      EXTRACT(EPOCH FROM (
     *          CURRENT_TIMESTAMP -
     *          timestamp '1970-01-01 00:00:00' AT TIME ZONE '00:00'
     *      ))
     *  )
     * ```
     * + SQLite         : `strftime('%s', 'now')`
     */
    exports.unixTimestampNow = factory_28.makeOperator0(operator_type_37.OperatorType.UNIX_TIMESTAMP_NOW, tm.mysql.bigIntUnsigned(), type_hint_7.TypeHint.DATE_TIME);
});
define("expr-library/date-time/utc-string-to-timestamp", ["require", "exports", "type-mapping", "operator-type", "expr-library/factory/index"], function (require, exports, tm, operator_type_38, factory_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     *
     * -----
     *
     * + MySQL          : `CONVERT_TZ(x, '+00:00', @@session.time_zone)`
     * ```sql
     *  SET @@session.time_zone = 'EST';
     *  SELECT
     *      CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone),
     *      FLOOR(UNIX_TIMESTAMP(CONVERT_TZ('1970-01-01 03:00:00.123', '+00:00', @@session.time_zone)));
     *  > 1969-12-31 22:00:00.123
     *  > 10800
     * ```
     * + PostgreSQL     : `(x)::timestamp AT TIME ZONE '+00:00'`
     * ```sql
     *  SET TIME ZONE 'EST';
     *  SELECT
     *      '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00',
     *      FLOOR(EXTRACT(
     *          EPOCH FROM (
     *              '1970-01-01 03:00:00.123'::timestamp AT TIME ZONE '+00:00'
     *          )
     *      ))
     *  > 1970-01-01T03:00:00.123Z
     *  > 10800
     * ```
     * + SQLite         : `strftime('%Y-%m-%d %H:%M:%f', x)`
     * ```sql
     *  SELECT
     *      strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'),
     *      strftime('%s', strftime('%Y-%m-%d %H:%M:%f', '1970-01-01 03:00:00.123'));
     *  > 1970-01-01 03:00:00.123
     *  > 10800
     * ```
     *
     * -----
     *
     * Treat `x` as representing a `UTC` timestamp.
     *
     */
    exports.utcStringToTimestamp = factory_29.makeOperator1(operator_type_38.OperatorType.UTC_STRING_TO_TIMESTAMP_CONSTRUCTOR, tm.mysql.dateTime(3).orNull());
});
define("expr-library/date-time/index", ["require", "exports", "expr-library/date-time/current-date", "expr-library/date-time/current-timestamp", "expr-library/date-time/extract", "expr-library/date-time/last-day", "expr-library/date-time/timestamp-add", "expr-library/date-time/timestamp-diff", "expr-library/date-time/unix-timestamp-now", "expr-library/date-time/utc-string-to-timestamp"], function (require, exports, current_date_1, current_timestamp_1, extract_1, last_day_1, timestamp_add_1, timestamp_diff_1, unix_timestamp_now_1, utc_string_to_timestamp_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(current_date_1);
    //export * from "./current-time";
    __export(current_timestamp_1);
    __export(extract_1);
    __export(last_day_1);
    //export * from "./local-string-to-timestamp";
    __export(timestamp_add_1);
    __export(timestamp_diff_1);
    __export(unix_timestamp_now_1);
    __export(utc_string_to_timestamp_1);
});
define("expr-library/equation/eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_30, operator_type_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal
     *
     * This version of the `=` operator prevents `NULL`.
     *
     * For null-safe equality, @see {@link nullSafeEq}
     */
    exports.eq = factory_30.makeEquation2(operator_type_39.OperatorType.EQUAL);
});
define("expr-library/equation/eq-primary-key", ["require", "exports", "primary-key/index", "expr-library/equation/eq", "expr-library/logical/index", "column-map/index", "built-in-expr/index"], function (require, exports, primary_key_4, eq_1, logical_6, column_map_36, built_in_expr_54) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenience function for,
     * ```ts
     *  tsql.and(
     *      tsql.eq(primaryKeyColumn0, value0),
     *      tsql.eq(primaryKeyColumn1, value1),
     *      tsql.eq(primaryKeyColumn2, value2)
     *      //etc.
     *  );
     * ```
     *
     * -----
     *
     * It is recommended to **only** use this with **object literals**.
     * Excess property checks are disabled for non-object literals.
     * Even if they were enabled, it is possible to slip in extra properties.
     *
     * Extra properties are ignored during run-time but may indicate lapses in logic.
     *
     * -----
     *
     * Uses `eq()` internally because the primary key of a table
     * cannot have nullable columns.
     *
     * @todo Change this to use `nullSafeEq()` jusssst in case people start using
     * nullable columns in PKs for whatever reason?
     *
     * @param table - The table with a primary key
     * @param primaryKeyInput - The primary key values to compare against
     */
    function eqPrimaryKey(table, primaryKeyInput) {
        const primaryKey = primary_key_4.PrimaryKeyUtil.mapper(table)(`${column_map_36.ColumnMapUtil.tableAlias(table.columns)}.primaryKey`, primaryKeyInput);
        /**
         * We `.sort()` the keys so our resulting SQL is deterministic,
         * regardless of how `primaryKey` was constructed.
         */
        const arr = Object.keys(primaryKey).sort().map((columnAlias) => {
            /**
             * We use `eq` because the primary key of a table cannot have
             * nullable columns... Right?
             *
             * @todo Decide if we should use null-safe equality anyway,
             * just to be super safe
             */
            const expr = eq_1.eq(table.columns[columnAlias], built_in_expr_54.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], primaryKey[columnAlias]));
            return expr;
        });
        const result = logical_6.and(...arr);
        return result;
    }
    exports.eqPrimaryKey = eqPrimaryKey;
});
define("expr-library/equation/in-array", ["require", "exports", "expr-library/factory/index", "operator-type", "expr/index"], function (require, exports, factory_31, operator_type_40, expr_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const inArrayImpl = factory_31.makeEquation2ToN(operator_type_40.OperatorType.IN_ARRAY);
    /**
     * The `IN` operator has two overloads.
     * + `x IN (y0, y1, y2, y3, ...)`
     * + `x IN (SELECT y FROM ...)`
     *
     * This implementation is for the first overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
     *
     * The array cannot contain `null` because,
     * + `x IN (NULL)` is `NULL`
     * + `1 IN (NULL, 2)` is `NULL`
     * + `1 IN (NULL, 2, 1)` is `true`
     *
     * -----
     *
     * Calling `inArray()` with an empty array will always
     * return `false` because a value is never in an array of zero elements.
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     */
    function inArray(arg0, args) {
        const [arg1, ...rest] = args;
        if (arg1 == undefined) {
            /**
             * Calling `inArray()` with an empty array will always
             * return `false` because a value is never in an array of zero elements.
             */
            return expr_46.ExprUtil.fromBuiltInExpr(false);
        }
        else {
            return inArrayImpl(arg0, arg1, ...rest);
        }
    }
    exports.inArray = inArray;
});
define("expr-library/equation/in-query", ["require", "exports", "type-mapping", "query-base/index", "expr/index", "operator-type", "built-in-expr/index", "ast/index"], function (require, exports, tm, query_base_12, expr_47, operator_type_41, built_in_expr_55, ast_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The `IN` operator has two overloads.
     * + `x IN (y0, y1, y2, y3, ...)`
     * + `x IN (SELECT y FROM ...)`
     *
     * This implementation is for the second overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL IN (...)` is always `NULL`.
     *
     * The query argument cannot `SELECT` `null` because,
     * + `x IN (SELECT NULL)` is `NULL`
     * + `x IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
     *   + At least one row has a `NULL` value
     *   + No rows have the value `x`
     * + `x IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
     *   + No rows have the value `x`
     * + `1 IN (SELECT NULL UNION SELECT 1)` is `true`
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     *
     * -----
     *
     * ### Problems with MySQL
     *
     * The following produced an error,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 IN (SELECT id FROM myTable LIMIT 1);
     * ```
     *
     * The following is a workaround,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
     * ```
     */
    function inQuery(builtInExpr, query) {
        if (!query_base_12.QueryBaseUtil.isOneSelectItem(query)) {
            throw new Error(`Query must SELECT one item`);
        }
        if (tm.canOutputNull(query.selectClause[0].mapper)) {
            throw new Error(`Query must not SELECT nullable value`);
        }
        return expr_47.expr({
            mapper: tm.mysql.boolean(),
            usedRef: built_in_expr_55.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
            isAggregate: built_in_expr_55.BuiltInExprUtil.isAggregate(builtInExpr),
        }, ast_39.OperatorNodeUtil.operatorNode2(operator_type_41.OperatorType.IN_QUERY, [
            built_in_expr_55.BuiltInExprUtil.buildAst(builtInExpr),
            built_in_expr_55.BuiltInExprUtil.buildAst(query)
        ], undefined));
    }
    exports.inQuery = inQuery;
});
define("expr-library/equation/not-eq", ["require", "exports", "expr-library/factory/index", "operator-type"], function (require, exports, factory_32, operator_type_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal
     *
     * This version of the `<>` operator prevents `NULL`.
     *
     * For null-safe inequality, @see {@link nullSafeNotEq}
     *
     */
    exports.notEq = factory_32.makeEquation2(operator_type_42.OperatorType.NOT_EQUAL);
});
define("expr-library/equation/not-in-array", ["require", "exports", "expr-library/factory/index", "operator-type", "expr/index"], function (require, exports, factory_33, operator_type_43, expr_48) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const notInArrayImpl = factory_33.makeEquation2ToN(operator_type_43.OperatorType.NOT_IN_ARRAY);
    /**
     * The `NOT IN` operator has two overloads.
     * + `x NOT IN (y0, y1, y2, y3, ...)`
     * + `x NOT IN (SELECT y FROM ...)`
     *
     * This implementation is for the first overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
     *
     * The array cannot contain `null` because,
     * + `x NOT IN (NULL)` is `NULL`
     * + `1 NOT IN (NULL, 2)` is `NULL`
     * + `1 NOT IN (NULL, 2, 1)` is `false`
     *
     * -----
     *
     * Calling `notInArray()` with an empty array will always
     * return `true` because a value is always **not** in an array of zero elements.
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     */
    function notInArray(arg0, args) {
        const [arg1, ...rest] = args;
        if (arg1 == undefined) {
            /**
             * Calling `notInArray()` with an empty array will always
             * return `true` because a value is always **not** in an array of zero elements.
             */
            return expr_48.ExprUtil.fromBuiltInExpr(true);
        }
        else {
            return notInArrayImpl(arg0, arg1, ...rest);
        }
    }
    exports.notInArray = notInArray;
});
define("expr-library/equation/not-in-query", ["require", "exports", "type-mapping", "query-base/index", "expr/index", "operator-type", "built-in-expr/index", "ast/index"], function (require, exports, tm, query_base_13, expr_49, operator_type_44, built_in_expr_56, ast_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The `NOT IN` operator has two overloads.
     * + `x NOT IN (y0, y1, y2, y3, ...)`
     * + `x NOT IN (SELECT y FROM ...)`
     *
     * This implementation is for the second overload.
     *
     * -----
     *
     * The first argument cannot be `null` because `NULL NOT IN (...)` is always `NULL`.
     *
     * The query argument cannot `SELECT` `null` because,
     * + `x NOT IN (SELECT NULL)` is `NULL`
     * + `x NOT IN (SELECT nullableColumn FROM myTable)` is `NULL` if,
     *   + At least one row has a `NULL` value
     *   + No rows have the value `x`
     * + `x NOT IN (SELECT nonNullColumn FROM myTable UNION SELECT NULL)` is `NULL` if,
     *   + No rows have the value `x`
     * + `1 NOT IN (SELECT NULL UNION SELECT 1)` is `false`
     *
     * -----
     *
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in
     *
     * > To comply with the SQL standard,
     * > `IN()` returns `NULL` not only if the expression on the left hand side is `NULL`,
     * > but also if no match is found in the list and one of the expressions in the list is `NULL`.
     *
     * https://dev.mysql.com/doc/refman/8.0/en/any-in-some-subqueries.html
     *
     * -----
     *
     * ### Problems with MySQL
     *
     * The following produced an error,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 NOT IN (SELECT id FROM myTable LIMIT 1);
     * ```
     *
     * The following is a workaround,
     * ```sql
     * CREATE TABLE myTable (id INT);
     * INSERT INTO myTable VALUES (1);
     * SELECT 1 NOT IN (SELECT * FROM (SELECT id FROM myTable LIMIT 1) AS tmp);
     * ```
     */
    function notInQuery(builtInExpr, query) {
        if (!query_base_13.QueryBaseUtil.isOneSelectItem(query)) {
            throw new Error(`Query must SELECT one item`);
        }
        if (tm.canOutputNull(query.selectClause[0].mapper)) {
            throw new Error(`Query must not SELECT nullable value`);
        }
        return expr_49.expr({
            mapper: tm.mysql.boolean(),
            usedRef: built_in_expr_56.BuiltInExprUtil.intersectUsedRef(builtInExpr, query),
            isAggregate: built_in_expr_56.BuiltInExprUtil.isAggregate(builtInExpr),
        }, ast_40.OperatorNodeUtil.operatorNode2(operator_type_44.OperatorType.NOT_IN_QUERY, [
            built_in_expr_56.BuiltInExprUtil.buildAst(builtInExpr),
            built_in_expr_56.BuiltInExprUtil.buildAst(query)
        ], undefined));
    }
    exports.notInQuery = notInQuery;
});
define("expr-library/equation/index", ["require", "exports", "expr-library/equation/eq-primary-key", "expr-library/equation/eq", "expr-library/equation/in-array", "expr-library/equation/in-query", "expr-library/equation/not-eq", "expr-library/equation/not-in-array", "expr-library/equation/not-in-query"], function (require, exports, eq_primary_key_1, eq_2, in_array_1, in_query_1, not_eq_1, not_in_array_1, not_in_query_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(eq_primary_key_1);
    __export(eq_2);
    __export(in_array_1);
    __export(in_query_1);
    __export(not_eq_1);
    __export(not_in_array_1);
    __export(not_in_query_1);
});
define("expr-library/information/current-schema", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_34, operator_type_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the default (current) schema name as a string.
     * If there is no default schema, returns `NULL`.
     *
     * -----
     *
     * MySQL does not make a distinction between "database" and "schema".
     * PostgreSQL does.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_database
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://www.sqlite.org/lang_attach.html
     *
     * -----
     *
     * + MySQL      : `DATABASE()`
     * + PostgreSQL : `CURRENT_SCHEMA`
     * + SQLite     : `'main'` should always be the current database.
     *   + There's also `'temp'`, I guess
     */
    exports.currentSchema = factory_34.makeOperator0(operator_type_45.OperatorType.CURRENT_SCHEMA, tm.orNull(tm.string()));
});
define("expr-library/information/current-user", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_35, operator_type_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * On MySQL,
     * > Returns the user name and host name combination for the MySQL account
     * > that the server used to authenticate the current client.
     * > This account determines your access privileges.
     *
     * -----
     *
     * On PostgreSQL,
     * > the user identifier that is applicable for permission checking.
     * > The SQL standard draws a distinction between current_role and current_user,
     * > but PostgreSQL does not, since it unifies users and roles into a single kind of entity.
     *
     * -----
     *
     * SQLite does not have the concept of users.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user
     * + https://www.postgresql.org/docs/9.2/functions-info.html
     * + https://stackoverflow.com/questions/16658880/sqlite-user-password-security/28566503
     *
     * -----
     *
     * + MySQL      : `CURRENT_USER`
     *   + MySQL has a `USER()` function that does something different.
     * + PostgreSQL : `CURRENT_USER`
     * + SQLite     : None. It does not make sense to ask what the current user is.
     */
    exports.currentUser = factory_35.makeOperator0(operator_type_46.OperatorType.CURRENT_USER, tm.orNull(tm.string()));
});
define("expr-library/information/index", ["require", "exports", "expr-library/information/current-schema", "expr-library/information/current-user"], function (require, exports, current_schema_1, current_user_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(current_schema_1);
    __export(current_user_1);
});
define("expr-library/logical-3/and-3", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_36, operator_type_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_and
     *
     * This version of the `AND` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link and}
     */
    exports.and3 = factory_36.makeChainableOperator(operator_type_47.OperatorType.AND, true, tm.mysql.boolean().orNull());
});
define("expr-library/logical-3/is-false", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_37, operator_type_48, type_hint_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `FALSE`.
     *
     * ```sql
     * mysql> SELECT (1 IS FALSE), (0 IS FALSE), (NULL IS FALSE);
     *         -> 0, 1, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS FALSE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isFalse = factory_37.makeOperator1(operator_type_48.OperatorType.IS_FALSE, tm.mysql.boolean(), type_hint_8.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/is-not-false", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_38, operator_type_49, type_hint_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `FALSE`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT FALSE), (0 IS NOT FALSE), (NULL IS NOT FALSE);
     *         -> 1, 0, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS NOT FALSE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isNotFalse = factory_38.makeOperator1(operator_type_49.OperatorType.IS_NOT_FALSE, tm.mysql.boolean(), type_hint_9.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/is-not-true", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_39, operator_type_50, type_hint_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `TRUE`.
     *
     * ```sql
     * mysql> SELECT (1 IS NOT TRUE), (0 IS NOT TRUE), (NULL IS NOT TRUE);
     *         -> 0, 1, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(1 IS NOT TRUE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isNotTrue = factory_39.makeOperator1(operator_type_50.OperatorType.IS_NOT_TRUE, tm.mysql.boolean(), type_hint_10.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/is-not-unknown", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_40, operator_type_51, type_hint_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-not
     *
     * Tests whether a value is not `UNKNOWN`.
     * Basically an alias for `IS NOT NULL`
     *
     * ```sql
     * mysql> SELECT (1 IS NOT UNKNOWN), (0 IS NOT UNKNOWN), (NULL IS NOT UNKNOWN);
     *         -> 1, 1, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS NOT UNKNOWN)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isNotUnknown = factory_40.makeOperator1(operator_type_51.OperatorType.IS_NOT_UNKNOWN, tm.mysql.boolean(), type_hint_11.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/is-true", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_41, operator_type_52, type_hint_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `TRUE`.
     *
     * ```sql
     * mysql> SELECT (1 IS TRUE), (0 IS TRUE), (NULL IS TRUE);
     *         -> 1, 0, 0
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(1 IS TRUE)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isTrue = factory_41.makeOperator1(operator_type_52.OperatorType.IS_TRUE, tm.mysql.boolean(), type_hint_12.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/is-unknown", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_42, operator_type_53, type_hint_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is
     *
     * Tests whether a value is `UNKNOWN`.
     * Basically an alias for `IS NULL`
     *
     * ```sql
     * mysql> SELECT (1 IS UNKNOWN), (0 IS UNKNOWN), (NULL IS UNKNOWN);
     *         -> 0, 0, 1
     * ```
     *
     * -----
     *
     * PostgreSQL does not allow `(0 IS UNKNOWN)` because PostgreSQL
     * has an actual `boolean` type.
     */
    /**
     * @todo Monitor this PR,
     * https://github.com/microsoft/TypeScript/issues/33561
     */
    exports.isUnknown = factory_42.makeOperator1(operator_type_53.OperatorType.IS_UNKNOWN, tm.mysql.boolean(), type_hint_13.TypeHint.BOOLEAN);
});
define("expr-library/logical-3/not-3", ["require", "exports", "type-mapping", "operator-type", "expr-library/factory/index"], function (require, exports, tm, operator_type_54, factory_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_not
     *
     * This version of the `NOT` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link not}
     */
    exports.not3 = factory_43.makeOperator1DoubleElimination(operator_type_54.OperatorType.NOT, tm.mysql.boolean().orNull());
});
define("expr-library/logical-3/or-3", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_44, operator_type_55) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_or
     *
     * This version of the `OR` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link or}
     */
    exports.or3 = factory_44.makeChainableOperator(operator_type_55.OperatorType.OR, false, tm.mysql.boolean().orNull());
});
define("expr-library/logical-3/xor-3", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type"], function (require, exports, tm, factory_45, operator_type_56) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://dev.mysql.com/doc/refman/8.0/en/logical-operators.html#operator_xor
     *
     * This version of the `XOR` operator allows `NULL`.
     *
     * For two-valued logic, @see {@link xor}
     */
    exports.xor3 = factory_45.makeOperator2(operator_type_56.OperatorType.XOR, tm.mysql.boolean().orNull());
});
define("expr-library/logical-3/index", ["require", "exports", "expr-library/logical-3/and-3", "expr-library/logical-3/is-false", "expr-library/logical-3/is-not-false", "expr-library/logical-3/is-not-true", "expr-library/logical-3/is-not-unknown", "expr-library/logical-3/is-true", "expr-library/logical-3/is-unknown", "expr-library/logical-3/not-3", "expr-library/logical-3/or-3", "expr-library/logical-3/xor-3"], function (require, exports, and_3_1, is_false_1, is_not_false_1, is_not_true_1, is_not_unknown_1, is_true_1, is_unknown_1, not_3_1, or_3_1, xor_3_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(and_3_1);
    __export(is_false_1);
    __export(is_not_false_1);
    __export(is_not_true_1);
    __export(is_not_unknown_1);
    __export(is_true_1);
    __export(is_unknown_1);
    __export(not_3_1);
    __export(or_3_1);
    __export(xor_3_1);
});
define("expr-library/string/aggregate/group-concat", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_57, type_hint_14, aggregate_factory_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a string result with the concatenated non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(DISTINCT expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(DISTINCT expr, separator)`
     * + SQLite     : `GROUP_CONCAT(DISTINCT expr)`
     *   + The order of the concatenated elements is arbitrary.
     *   + Uses comma as separator
     *
     * -----
     *
     * Seems like `GROUP_CONCAT()` with `DISTINCT` cannot take a separator
     * for the DB-unified implementation.
     *
     * Unless we modify the SQLite implementation with a user-defined function?
     *
     * -----
     *
     * @param arg - The expression to aggregate
     *
     * @todo Investigate replacing SQLite `GROUP_CONCAT()` with user-defined function
     */
    exports.groupConcatDistinct = aggregate_factory_3.makeAggregateOperator1(operator_type_57.OperatorType.AGGREGATE_GROUP_CONCAT_DISTINCT, tm.orNull(tm.string()), type_hint_14.TypeHint.STRING);
    /**
     * Returns a string result with the concatenated non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#groupconcat
     *
     * + MySQL      : `GROUP_CONCAT(expr SEPARATOR separator)`
     * + PostgreSQL : `STRING_AGG(expr, separator)`
     * + SQLite     : `GROUP_CONCAT(expr, separator)`
     *   + The order of the concatenated elements is arbitrary.
     *
     * @param left  - The expression to aggregate
     * @param right - The separator between expressions
     */
    exports.groupConcatAll = aggregate_factory_3.makeAggregateOperator2(operator_type_57.OperatorType.AGGREGATE_GROUP_CONCAT_ALL, tm.orNull(tm.string()), type_hint_14.TypeHint.STRING);
});
define("expr-library/string/aggregate/index", ["require", "exports", "expr-library/string/aggregate/group-concat"], function (require, exports, group_concat_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(group_concat_1);
});
define("expr-library/string/ascii", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_46, operator_type_58, type_hint_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the numeric value of the leftmost character of the string.
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ascii
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `ASCII(x)`
     * + PostgreSQL     : `ASCII(x)`
     * + SQLite         : None, implement with `x.length == 0 ? 0 : x.charCodeAt(0)`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  ASCII(CHAR(128 USING latin1))
     *  > 128
     *
     *  ASCII(CHAR(128 USING utf32))
     *  > 0
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/2
     */
    exports.ascii = factory_46.makeOperator1(operator_type_58.OperatorType.ASCII, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned(), type_hint_15.TypeHint.STRING);
});
define("expr-library/string/bin", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_47, operator_type_59, type_hint_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a binary string representation of a `bigint` value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bin
     *
     * -----
     *
     * + MySQL          : `BIN(x)`
     * + PostgreSQL     : None. Implement with,
     * ```sql
     *  REGEXP_REPLACE(
     *      (x)::bit(64)::varchar(64),
     *      '^0+(\d+)$',
     *      '\1'
     *  )
     * ```
     * + SQLite         : None. Implement with,
     * ```ts
     * //x >= 0
     * (x).toString(2)
     * //x < 0
     * (2n**64n + BigInt(x)).toString(2)
     * ```
     */
    exports.bin = factory_47.makeOperator1(operator_type_59.OperatorType.BIN, tm.match(/^[01]+$/), type_hint_16.TypeHint.BIGINT_SIGNED);
});
define("expr-library/string/bit-length", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_48, operator_type_60, type_hint_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the length of the string in bits.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_bit-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `BIT_LENGTH(x)`
     * + PostgreSQL     : `BIT_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB)) * 8`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  BIT_LENGTH(CHAR(128 USING latin1))
     *  > 8
     *
     *  BIT_LENGTH(CHAR(128 USING utf32))
     *  > 32
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/3
     */
    exports.bitLength = factory_48.makeOperator1(operator_type_60.OperatorType.BIT_LENGTH, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned(), type_hint_17.TypeHint.STRING);
});
define("expr-library/string/char-length", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_49, operator_type_61, type_hint_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the length of the string, measured in characters.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_char-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#length
     * + https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length
     *
     * -----
     *
     * + MySQL          : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 6
     * + PostgreSQL     : `CHAR_LENGTH(x)`
     *   + `CHAR_LENGTH('cafȩ́')` returns 8
     * + SQLite         : `LENGTH(x)`
     *   + `LENGTH('cafȩ́')` returns 6
     *
     * -----
     *
     * Surrogate pairs may cause results to differ across databases.
     */
    exports.charLength = factory_49.makeOperator1(operator_type_61.OperatorType.CHAR_LENGTH, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned(), type_hint_18.TypeHint.STRING);
});
define("expr-library/string/concat-ws", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_50, operator_type_62, type_hint_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Concatenate With Separator.
     * The first argument is the separator for the rest of the arguments.
     * The separator is added between the strings to be concatenated.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat-ws
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + PostgreSQL     : `CONCAT_WS(separator, x, ...)`
     *   + If the separator is `NULL`, the result is `NULL`
     *   + Ignores `NULL` arguments after the separator
     * + SQLite         : None. Implement with user-defined function.
     */
    exports.concatWs = factory_50.makeOperator2ToN(operator_type_62.OperatorType.CONCAT_WS, tm.string(), type_hint_19.TypeHint.STRING);
});
define("expr-library/string/concat", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_51, operator_type_63, type_hint_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string that results from concatenating the arguments.
     * May have one or more arguments.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `CONCAT(x, ...)` Returns `NULL` if any argument is `NULL`
     *   + MySQL actually treats `||` as the boolean `OR` operator.
     * + PostgreSQL     : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `x || ... || ...` Returns `NULL` if any argument is `NULL`
     *   + SQLite uses an operator, not a function, to concatenate strings
     *   + https://www.sqlite.org/lang_expr.html#collateop
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     *
     * -----
     *
     * @see nullSafeConcat
     */
    exports.concat = factory_51.makeOperator1ToN(operator_type_63.OperatorType.CONCAT, tm.string(), type_hint_20.TypeHint.STRING);
});
define("expr-library/string/like", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/make-operator-3"], function (require, exports, tm, operator_type_64, type_hint_21, make_operator_3_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertValidLikeEscapeChar(escapeChar) {
        tm.stringExactLength(1)("escapeChar", escapeChar);
    }
    exports.assertValidLikeEscapeChar = assertValidLikeEscapeChar;
    const likeEscapeImpl = make_operator_3_2.makeOperator3(operator_type_64.OperatorType.LIKE_ESCAPE, tm.mysql.boolean(), type_hint_21.TypeHint.STRING);
    /**
     * + The escape character must always be specified, with this unified library.
     * + The escape character must be of length `1`.
     *
     * -----
     *
     * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
     *
     * -----
     *
     * This library requires the escape character to always be specified
     * because different databases have different defaults.
     *
     * Forcing an explicit escape character helps keep behaviour more consistent
     * across databases.
     *
     * Default escape characters per database,
     * + MySQL      : backslash (`\`)
     * + PostgreSQL : backslash (`\`)
     * + SQLite     : no-escape-character
     *
     * -----
     *
     * This library requires the escape character to have length `1` because
     * specifying the empty string has different behaviour on different databases,
     * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
     * + PostgreSQL : no-escape-character
     * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
     *
     * @param str - The target of the search
     * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
     * @param escapeChar - The escape character to use on the `pattern`
     */
    function like(str, pattern, escapeChar) {
        assertValidLikeEscapeChar(escapeChar);
        return likeEscapeImpl(str, pattern, escapeChar);
    }
    exports.like = like;
});
define("expr-library/string/escape-like-pattern", ["require", "exports", "expr-library/string/like"], function (require, exports, like_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //TODO-FEATURE Create a version using MySQL/PostgreSQL/SQLite queries
    //REGEXP_REPLACE(pattern, '(\\%|\\_)', '\\$1', 1, 0, 'm') or something
    /**
     * With `LIKE` you can use the following two wildcard characters in the pattern:
     *
     * + `%` matches any number of characters, even zero characters.
     * + `_` matches exactly one character.
     *
     * This function just prepends `escapeChar` to each of the above characters.
     * It also prepends `escapeChar` to itself.
     */
    function escapeLikePattern(pattern, escapeChar) {
        like_1.assertValidLikeEscapeChar(escapeChar);
        /**
         * Escape occurrences of the `escapeChar`
         */
        pattern = pattern.split(escapeChar).join(escapeChar + escapeChar);
        /**
         * Escape wildcard characters
         */
        return pattern.replace(/(\%|\_)/g, s => escapeChar + s);
    }
    exports.escapeLikePattern = escapeLikePattern;
});
define("expr-library/string/from-base64", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_52, operator_type_65, type_hint_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Takes a base-64 encoded string,
     * and returns the decoded result as a `BLOB/bytea`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_from-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `FROM_BASE64(x)`
     *   + `FROM_BASE64('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'base64')`
     *   + `DECODE('~', 'base64')` throws an error
     * + SQLite         : None, implement with user-defined function `atob()`
     *   + `atob('~')` throws an error
     *
     * -----
     *
     * If the input is not a valid base-64 string, some databases throw an error.
     * Others return `NULL`.
     */
    exports.fromBase64 = factory_52.makeOperator1(operator_type_65.OperatorType.FROM_BASE64, tm.orNull(tm.instanceOfUint8Array()), type_hint_22.TypeHint.STRING);
});
define("expr-library/string/hex", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_53, operator_type_66, type_hint_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts each byte of the input to two hexadecimal digits.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_hex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#hex
     *
     * -----
     *
     * + MySQL          : `HEX(x)`
     * + PostgreSQL     : `ENCODE(x, 'hex')`
     * + SQLite         : `HEX(x)`
     */
    exports.hex = factory_53.makeOperator1(operator_type_66.OperatorType.HEX, tm.string(), type_hint_23.TypeHint.BUFFER);
});
define("expr-library/string/in-str", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_54, operator_type_67, type_hint_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the position of the first occurrence of the substring in the target.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_instr
     * + https://www.sqlite.org/lang_corefunc.html#instr
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `INSTR(str, substr)`
     * + PostgreSQL     : `STRPOS(str, substr)`
     * + SQLite         : `INSTR(str, substr)`
     *
     * -----
     *
     * @param left - The target of the search
     * @param right - The substring to look for
     *
     * -----
     *
     * If the substring is not found, it returns `0`.
     * Remember that string indices are one-based; not zero-based.
     *
     * @see position
     */
    exports.inStr = factory_54.makeOperator2(operator_type_67.OperatorType.IN_STR, tm.mysql.bigIntUnsigned(), type_hint_24.TypeHint.STRING);
});
define("expr-library/string/l-pad", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, factory_55, operator_type_68, type_hint_25, built_in_expr_57, expr_50, ast_41) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a string, left-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     *   + `LPAD('123', 5, '')`   === `NULL`
     *   + `LPAD('123', 2, '')`   === `'12'`
     *   + `LPAD('123', -2, 'a')` === `NULL`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     *   + `LPAD('123', 5, '')`   === `'123'`
     *   + `LPAD('123', 2, '')`   === `'12'`
     *   + `LPAD('123', -2, 'a')` === `''`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the desired length is negative, or padding string is empty,
     * the behaviour cannot be unified.
     *
     * MySQL seems to return `NULL`.
     *
     * -----
     *
     * @param left  - The string to pad
     * @param mid   - The desired length of the output
     * @param right - The padding
     *
     * @see lPad
     */
    exports.lPadUnsafe = factory_55.makeOperator3(operator_type_68.OperatorType.LPAD, tm.orNull(tm.string()), type_hint_25.TypeHint.STRING);
    /**
     * Returns a string, left-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `LPAD(str, len, padstr)`
     *   + `LPAD('123', 4, '98')` === `'9123'`
     *   + `LPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * This function does not allow negative `desiredLength`, or empty `padding`.
     *
     * -----
     *
     * @param str           - The string to pad
     * @param desiredLength - The desired length of the output; must not be negative
     * @param padding       - The padding; must not be empty
     *
     * @see lPadUnsafe
     */
    function lPad(str, desiredLength, padding) {
        desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
        padding = tm.stringLength({ min: 1 })(`padding`, padding);
        return expr_50.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_41.OperatorNodeUtil.operatorNode3(operator_type_68.OperatorType.LPAD, [
            built_in_expr_57.BuiltInExprUtil.buildAst(str),
            built_in_expr_57.BuiltInExprUtil.buildAst(desiredLength),
            built_in_expr_57.BuiltInExprUtil.buildAst(padding),
        ], type_hint_25.TypeHint.STRING));
    }
    exports.lPad = lPad;
});
define("expr-library/string/l-trim", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_56, operator_type_69, type_hint_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with leading **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_ltrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#ltrim
     *
     * -----
     *
     * + MySQL          : `LTRIM(x)`
     * + PostgreSQL     : `LTRIM(x)/LTRIM(x, y)`
     * + SQLite         : `LTRIM(x)/LTRIM(x, y)`
     *
     * -----
     *
     * Does not remove other leading whitespace. Only removes leading spaces.
     */
    exports.lTrim = factory_56.makeOperator1(operator_type_69.OperatorType.LTRIM, tm.string(), type_hint_26.TypeHint.STRING);
});
define("expr-library/string/lower", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_57, operator_type_70, type_hint_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with all characters changed to lowercase
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lower
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#lower
     *
     * -----
     *
     * + MySQL          : `LOWER(x)`
     * + PostgreSQL     : `LOWER(x)`
     * + SQLite         : `LOWER(x)`
     */
    exports.lower = factory_57.makeOperator1(operator_type_70.OperatorType.LOWER, tm.string(), type_hint_27.TypeHint.STRING);
});
define("expr-library/string/not-like", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/make-operator-3", "expr-library/string/like"], function (require, exports, tm, operator_type_71, type_hint_28, make_operator_3_3, like_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const notLikeEscapeImpl = make_operator_3_3.makeOperator3(operator_type_71.OperatorType.NOT_LIKE_ESCAPE, tm.mysql.boolean(), type_hint_28.TypeHint.STRING);
    /**
     * + The escape character must always be specified, with this unified library.
     * + The escape character must be of length `1`.
     *
     * -----
     *
     * Different databases, and collations, may cause the `LIKE` operator to handle case-sensitivity differently.
     *
     * -----
     *
     * This library requires the escape character to always be specified
     * because different databases have different defaults.
     *
     * Forcing an explicit escape character helps keep behaviour more consistent
     * across databases.
     *
     * Default escape characters per database,
     * + MySQL      : backslash (`\`)
     * + PostgreSQL : backslash (`\`)
     * + SQLite     : no-escape-character
     *
     * -----
     *
     * This library requires the escape character to have length `1` because
     * specifying the empty string has different behaviour on different databases,
     * + MySQL      : backslash (`\`) (Seems impossible to have no-escape-character)
     * + PostgreSQL : no-escape-character
     * + SQLite     : throws error (Use `x LIKE y` to have no-escape-character)
     *
     * @param str - The target of the search
     * @param pattern - The pattern to search for, may use wildcard characters like `%` and `_`
     * @param escapeChar - The escape character to use on the `pattern`
     */
    function notLike(str, pattern, escapeChar) {
        like_2.assertValidLikeEscapeChar(escapeChar);
        return notLikeEscapeImpl(str, pattern, escapeChar);
    }
    exports.notLike = notLike;
});
define("expr-library/string/null-safe-concat", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_58, operator_type_72, type_hint_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string that results from concatenating the arguments.
     * May have one or more arguments.
     * `NULL` values are treated as empty strings.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : None. Emulate with `CONCAT(COALESCE(x, ''), ...)`
     * + PostgreSQL     : `CONCAT(x, ...)`
     *   + PostgreSQL's `CONCAT(x, ...)` Ignores `NULL` arguments
     *     + This is different from MySQL's `CONCAT()`
     * + SQLite         : `COALESCE(x, '') || ... || ...`
     *
     * -----
     *
     * The SQL standard says,
     * > `<concatenation operator>` is an operator, `||`,
     * > that returns the character string made by joining its character string operands in the order given.
     *
     * MySQL actually treats `||` as the boolean `OR` operator.
     *
     * -----
     *
     * @see concat
     */
    exports.nullSafeConcat = factory_58.makeOperator1ToN(operator_type_72.OperatorType.NULL_SAFE_CONCAT, tm.string(), type_hint_29.TypeHint.STRING);
});
define("expr-library/string/octet-length", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_59, operator_type_73, type_hint_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the length of the string, measured in bytes.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_octet-length
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `OCTET_LENGTH(x)`
     * + PostgreSQL     : `OCTET_LENGTH(x)`
     * + SQLite         : `LENGTH(CAST(x AS BLOB))`
     *
     * -----
     *
     * The character set of the string can affect the result of this function.
     * For example, on MySQL 5.7,
     * ```sql
     *  OCTET_LENGTH(CHAR(128 USING latin1))
     *  > 1
     *
     *  OCTET_LENGTH(CHAR(128 USING utf32))
     *  > 4
     * ```
     *
     * https://www.db-fiddle.com/f/bmj7sAFhiPpFGNVAhBdi3Q/4
     */
    exports.octetLength = factory_59.makeOperator1(operator_type_73.OperatorType.OCTET_LENGTH, 
    /**
     * Should not return a value less than zero
     */
    tm.mysql.bigIntUnsigned(), type_hint_30.TypeHint.STRING);
});
define("expr-library/string/position", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_60, operator_type_74, type_hint_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the position of the first occurrence of the substring in the target.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_position
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     *
     * -----
     *
     * + MySQL          : `POSITION(substr IN str)`
     * + PostgreSQL     : `POSITION(substr IN str)`
     * + SQLite         : `INSTR(str, substr)`
     *
     * -----
     *
     * @param left  - The substring to look for
     * @param right - The target of the search
     *
     * -----
     *
     * If the substring is not found, it returns `0`.
     * Remember that string indices are one-based; not zero-based.
     *
     * @see inStr
     * @todo Remove `inStr()` and keep `position()`?
     */
    exports.position = factory_60.makeOperator2(operator_type_74.OperatorType.POSITION, tm.mysql.bigIntUnsigned(), type_hint_31.TypeHint.STRING);
});
define("expr-library/string/r-pad", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, factory_61, operator_type_75, type_hint_32, built_in_expr_58, expr_51, ast_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a string, right-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_lpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     *   + `RPAD('123', 5, '')`   === `NULL`
     *   + `RPAD('123', 2, '')`   === `'12'`
     *   + `RPAD('123', -2, 'a')` === `NULL`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     *   + `RPAD('123', 5, '')`   === `'123'`
     *   + `RPAD('123', 2, '')`   === `'12'`
     *   + `RPAD('123', -2, 'a')` === `''`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the desired length is negative, or padding string is empty,
     * the behaviour cannot be unified.
     *
     * MySQL seems to return `NULL`.
     *
     * -----
     *
     * @param left  - The string to pad
     * @param mid   - The desired length of the output
     * @param right - The padding
     *
     * @see rPad
     */
    exports.rPadUnsafe = factory_61.makeOperator3(operator_type_75.OperatorType.RPAD, tm.orNull(tm.string()), type_hint_32.TypeHint.STRING);
    /**
     * Returns a string, right-padded to the specified length.
     *
     * If input string is longer than the specified length,
     * the return value is shortened to the specified length.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rpad
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     * + PostgreSQL     : `RPAD(str, len, padstr)`
     *   + `RPAD('123', 4, '98')` === `'1239'`
     *   + `RPAD('123', 2, '98')` === `'12'`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * This function does not allow negative `desiredLength`, or empty `padding`.
     *
     * -----
     *
     * @param str           - The string to pad
     * @param desiredLength - The desired length of the output; must not be negative
     * @param padding       - The padding; must not be empty
     *
     * @see rPadUnsafe
     */
    function rPad(str, desiredLength, padding) {
        desiredLength = tm.bigIntGtEq(tm.BigInt(0))(`desiredLength`, desiredLength);
        padding = tm.stringLength({ min: 1 })(`padding`, padding);
        return expr_51.ExprUtil.intersect(tm.string(), [str, desiredLength, padding], ast_42.OperatorNodeUtil.operatorNode3(operator_type_75.OperatorType.RPAD, [
            built_in_expr_58.BuiltInExprUtil.buildAst(str),
            built_in_expr_58.BuiltInExprUtil.buildAst(desiredLength),
            built_in_expr_58.BuiltInExprUtil.buildAst(padding),
        ], type_hint_32.TypeHint.STRING));
    }
    exports.rPad = rPad;
});
define("expr-library/string/r-trim", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_62, operator_type_76, type_hint_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with trailing **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_rtrim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#rtrim
     *
     * -----
     *
     * + MySQL          : `RTRIM(x)`
     * + PostgreSQL     : `RTRIM(x)/RTRIM(x, y)`
     * + SQLite         : `RTRIM(x)/RTRIM(x, y)`
     *
     * -----
     *
     * Does not remove other trailing whitespace. Only removes trailing spaces.
     */
    exports.rTrim = factory_62.makeOperator1(operator_type_76.OperatorType.RTRIM, tm.string(), type_hint_33.TypeHint.STRING);
});
define("expr-library/string/repeat", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_63, operator_type_77, type_hint_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Repeats a string the specified amount of times.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REPEAT(x, count)`
     * + PostgreSQL     : `REPEAT(x, count)`
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the specified amount is zero or less, it returns an empty string.
     *
     * -----
     *
     * @param left  - The string to repeat
     * @param right - The amount of times to repeat the string
     */
    exports.repeat = factory_63.makeOperator2(operator_type_77.OperatorType.REPEAT, tm.string(), type_hint_34.TypeHint.STRING);
});
define("expr-library/string/replace", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_64, operator_type_78, type_hint_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string `str`
     * with all occurrences of the string `from`
     * replaced by the string `to`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_replace
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#replace
     *
     * -----
     *
     * + MySQL          : `REPLACE(str, from, to)`
     * + PostgreSQL     : `REPLACE(str, from, to)`
     * + SQLite         : `REPLACE(str, from, to)`
     *
     * -----
     *
     * @param left  - The string to transform
     * @param mid   - The string to look for
     * @param right - The replacement string
     */
    exports.replace = factory_64.makeOperator3(operator_type_78.OperatorType.REPLACE, tm.string(), type_hint_35.TypeHint.STRING);
});
define("expr-library/string/reverse", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_65, operator_type_79, type_hint_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with the order of the characters reversed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `REVERSE(x)`
     * + PostgreSQL     : `REVERSE(x)`
     * + SQLite         : None. Implement with user-defined function.
     */
    exports.reverse = factory_65.makeOperator1(operator_type_79.OperatorType.REVERSE, tm.string(), type_hint_36.TypeHint.STRING);
});
define("expr-library/string/to-base64", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_66, operator_type_80, type_hint_37) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts the argument to base-64 encoded form.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_to-base64
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `TO_BASE64(x)`
     * + PostgreSQL     : `ENCODE(x, 'base64')`
     * + SQLite         : None, implement with user-defined function `btoa()`
     */
    exports.toBase64 = factory_66.makeOperator1(operator_type_80.OperatorType.TO_BASE64, tm.string(), type_hint_37.TypeHint.STRING);
});
define("expr-library/string/trim", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_67, operator_type_81, type_hint_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with leading and trailing **space** characters removed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_trim
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-OTHER
     * + https://www.sqlite.org/lang_corefunc.html#trim
     *
     * -----
     *
     * + MySQL          : `TRIM(x)`
     * + PostgreSQL     : `TRIM(x)`
     * + SQLite         : `TRIM(x)`
     *
     * -----
     *
     * Does not remove other leading and trailing whitespace.
     * Only removes leading and trailing spaces.
     */
    exports.trim = factory_67.makeOperator1(operator_type_81.OperatorType.TRIM, tm.string(), type_hint_38.TypeHint.STRING);
});
define("expr-library/string/unhex", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_68, operator_type_82, type_hint_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Takes a hex encoded string,
     * and returns the decoded result as a `BLOB/bytea`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_unhex
     * + https://www.postgresql.org/docs/7.4/functions-string.html#FUNCTIONS-STRING-OTHER
     *
     * -----
     *
     * + MySQL          : `UNHEX(x)`
     *   + `UNHEX('~')` === `NULL`
     * + PostgreSQL     : `DECODE(x, 'hex')`
     *   + `DECODE('~', 'hex')` throws an error
     * + SQLite         : None. Implement with user-defined function.
     *
     * -----
     *
     * If the input is not a valid hex string, some databases throw an error.
     * Others return `NULL`.
     */
    exports.unhex = factory_68.makeOperator1(operator_type_82.OperatorType.UNHEX, tm.orNull(tm.instanceOfUint8Array()), type_hint_39.TypeHint.STRING);
});
define("expr-library/string/upper", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_69, operator_type_83, type_hint_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the string with all characters changed to uppercase
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_upper
     * + https://www.postgresql.org/docs/9.4/functions-string.html#FUNCTIONS-STRING-SQL
     * + https://www.sqlite.org/lang_corefunc.html#upper
     *
     * -----
     *
     * + MySQL          : `UPPER(x)`
     * + PostgreSQL     : `UPPER(x)`
     * + SQLite         : `UPPER(x)`
     */
    exports.upper = factory_69.makeOperator1(operator_type_83.OperatorType.UPPER, tm.string(), type_hint_40.TypeHint.STRING);
});
define("expr-library/string/index", ["require", "exports", "expr-library/string/aggregate/index", "expr-library/string/ascii", "expr-library/string/bin", "expr-library/string/bit-length", "expr-library/string/char-length", "expr-library/string/concat-ws", "expr-library/string/concat", "expr-library/string/escape-like-pattern", "expr-library/string/from-base64", "expr-library/string/hex", "expr-library/string/in-str", "expr-library/string/l-pad", "expr-library/string/l-trim", "expr-library/string/like", "expr-library/string/lower", "expr-library/string/not-like", "expr-library/string/null-safe-concat", "expr-library/string/octet-length", "expr-library/string/position", "expr-library/string/r-pad", "expr-library/string/r-trim", "expr-library/string/repeat", "expr-library/string/replace", "expr-library/string/reverse", "expr-library/string/to-base64", "expr-library/string/trim", "expr-library/string/unhex", "expr-library/string/upper"], function (require, exports, aggregate_1, ascii_1, bin_1, bit_length_1, char_length_1, concat_ws_1, concat_2, escape_like_pattern_1, from_base64_1, hex_1, in_str_1, l_pad_1, l_trim_1, like_3, lower_1, not_like_1, null_safe_concat_1, octet_length_1, position_1, r_pad_1, r_trim_1, repeat_1, replace_1, reverse_1, to_base64_1, trim_1, unhex_1, upper_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_1);
    __export(ascii_1);
    __export(bin_1);
    __export(bit_length_1);
    __export(char_length_1);
    __export(concat_ws_1);
    __export(concat_2);
    __export(escape_like_pattern_1);
    __export(from_base64_1);
    __export(hex_1);
    __export(in_str_1);
    __export(l_pad_1);
    __export(l_trim_1);
    __export(like_3);
    __export(lower_1);
    __export(not_like_1);
    __export(null_safe_concat_1);
    __export(octet_length_1);
    __export(position_1);
    //export * from "./quote";
    __export(r_pad_1);
    __export(r_trim_1);
    __export(repeat_1);
    __export(replace_1);
    __export(reverse_1);
    __export(to_base64_1);
    __export(trim_1);
    __export(unhex_1);
    __export(upper_1);
});
define("expr-library/subquery/exists", ["require", "exports", "type-mapping", "query-base/index", "expr/index", "ast/operator-node/util/index", "operator-type", "used-ref/index", "built-in-expr/index"], function (require, exports, tm, query_base_14, expr_52, util_8, operator_type_84, used_ref_35, built_in_expr_59) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function exists(query) {
        if (!query_base_14.QueryBaseUtil.isAfterFromClause(query) && !query_base_14.QueryBaseUtil.isAfterSelectClause(query)) {
            throw new Error(`Query must be after FROM/SELECT clause`);
        }
        /**
         * Hack for MySQL 5.7 and SQLite < 3.30 thinking the following is `true`,
         * ```sql
         *  EXISTS(SELECT 'hello' LIMIT 0);
         * ```
         */
        if (query.compoundQueryClause == undefined) {
            if ((query.compoundQueryLimitClause != undefined &&
                Number(query.compoundQueryLimitClause.maxRowCount) == 0) ||
                (query.limitClause != undefined &&
                    Number(query.limitClause.maxRowCount) == 0)) {
                return expr_52.expr({
                    mapper: tm.mysql.boolean(),
                    usedRef: used_ref_35.UsedRefUtil.fromFromClause(query.fromClause),
                    isAggregate: false,
                }, built_in_expr_59.BuiltInExprUtil.buildAst(false));
            }
        }
        else {
            if (query.compoundQueryLimitClause != undefined &&
                Number(query.compoundQueryLimitClause.maxRowCount) == 0) {
                return expr_52.expr({
                    mapper: tm.mysql.boolean(),
                    usedRef: used_ref_35.UsedRefUtil.fromFromClause(query.fromClause),
                    isAggregate: false,
                }, built_in_expr_59.BuiltInExprUtil.buildAst(false));
            }
        }
        return expr_52.expr({
            mapper: tm.mysql.boolean(),
            usedRef: used_ref_35.UsedRefUtil.fromFromClause(query.fromClause),
            isAggregate: false,
        }, util_8.operatorNode1(operator_type_84.OperatorType.EXISTS, [query], undefined));
    }
    exports.exists = exists;
});
define("expr-library/subquery/index", ["require", "exports", "expr-library/subquery/exists"], function (require, exports, exists_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(exists_3);
});
define("expr-library/decimal/aggregate/avg", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, decimal_mapper_2, operator_type_85, type_hint_41, aggregate_factory_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const avgImpl = aggregate_factory_4.makeAggregateOperator2(operator_type_85.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_2.decimalMapper.orNull(), type_hint_41.TypeHint.DECIMAL);
    exports.avgDistinct = (arg) => {
        return avgImpl(true, arg);
    };
    exports.avgAll = (arg) => {
        return avgImpl(false, arg);
    };
    exports.avg = exports.avgAll;
});
define("expr-library/decimal/aggregate/max", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, decimal_mapper_3, operator_type_86, type_hint_42, aggregate_factory_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    exports.max = aggregate_factory_5.makeAggregateOperator1(operator_type_86.OperatorType.AGGREGATE_MAX, decimal_mapper_3.decimalMapper.orNull(), type_hint_42.TypeHint.DECIMAL);
});
define("expr-library/decimal/aggregate/min", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, decimal_mapper_4, operator_type_87, type_hint_43, aggregate_factory_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    exports.min = aggregate_factory_6.makeAggregateOperator1(operator_type_87.OperatorType.AGGREGATE_MIN, decimal_mapper_4.decimalMapper.orNull(), type_hint_43.TypeHint.DECIMAL);
});
define("expr-library/decimal/aggregate/sum", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, decimal_mapper_5, operator_type_88, type_hint_44, aggregate_factory_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const sumImpl = aggregate_factory_7.makeAggregateOperator2(operator_type_88.OperatorType.AGGREGATE_SUM, decimal_mapper_5.decimalMapper.orNull(), type_hint_44.TypeHint.DECIMAL);
    exports.sumDistinct = (arg) => {
        return sumImpl(true, arg);
    };
    exports.sumAll = (arg) => {
        return sumImpl(false, arg);
    };
    exports.sum = exports.sumAll;
});
define("expr-library/decimal/aggregate/index", ["require", "exports", "expr-library/decimal/aggregate/avg", "expr-library/decimal/aggregate/max", "expr-library/decimal/aggregate/min", "expr-library/decimal/aggregate/sum"], function (require, exports, avg_1, max_1, min_1, sum_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(avg_1);
    __export(max_1);
    __export(min_1);
    __export(sum_1);
});
define("expr-library/decimal/abs", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "expr-library/factory/index", "type-hint"], function (require, exports, decimal_mapper_6, operator_type_89, factory_70, type_hint_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     */
    exports.abs = factory_70.makeOperator1Idempotent(operator_type_89.OperatorType.ABSOLUTE_VALUE, decimal_mapper_6.decimalMapper, type_hint_45.TypeHint.DECIMAL);
});
define("expr-library/decimal/add", ["require", "exports", "expr-library/decimal/decimal-mapper", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, decimal_mapper_7, factory_71, operator_type_90, type_hint_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = factory_71.makeChainableDecimalOperator(operator_type_90.OperatorType.ADDITION, 0, decimal_mapper_7.decimalMapper, type_hint_46.TypeHint.DECIMAL);
});
define("expr-library/decimal/ceiling", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_8, operator_type_91, type_hint_47, factory_72) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `CEILING(CEILING(x)) == CEILING(x)`
     */
    exports.ceiling = factory_72.makeOperator1Idempotent(operator_type_91.OperatorType.CEILING, decimal_mapper_8.decimalMapper, type_hint_47.TypeHint.DECIMAL);
});
define("expr-library/decimal/exp", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_9, operator_type_92, type_hint_48, factory_73) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exp = factory_73.makeOperator1(operator_type_92.OperatorType.NATURAL_EXPONENTIATION, decimal_mapper_9.decimalMapper, type_hint_48.TypeHint.DECIMAL);
});
define("expr-library/decimal/floor", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_10, operator_type_93, type_hint_49, factory_74) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `FLOOR(FLOOR(x)) == FLOOR(x)`
     */
    exports.floor = factory_74.makeOperator1Idempotent(operator_type_93.OperatorType.FLOOR, decimal_mapper_10.decimalMapper, type_hint_49.TypeHint.DECIMAL);
});
define("expr-library/decimal/fractional-div", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_11, operator_type_94, type_hint_50, factory_75) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Performs regular fixed-point division
     */
    exports.fractionalDiv = factory_75.makeOperator2(operator_type_94.OperatorType.FRACTIONAL_DIVISION, decimal_mapper_11.decimalMapper, type_hint_50.TypeHint.DECIMAL);
});
define("expr-library/decimal/ln", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_12, operator_type_95, type_hint_51, factory_76) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + MySQL      : `LN(0)` === `NULL`
     * + PostgreSQL : `LN(0)` throws error
     */
    exports.ln = factory_76.makeOperator1(operator_type_95.OperatorType.LN, decimal_mapper_12.decimalMapper.orNull(), type_hint_51.TypeHint.DECIMAL);
});
define("expr-library/decimal/log", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_13, operator_type_96, type_hint_52, factory_77) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + MySQL      : `LOG(0, 0)` === `NULL`
     * + PostgreSQL : `LOG(0, 0)` throws error
     */
    exports.log = factory_77.makeOperator2(operator_type_96.OperatorType.LOG, decimal_mapper_13.decimalMapper.orNull(), type_hint_52.TypeHint.DECIMAL);
});
define("expr-library/decimal/log2", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_14, operator_type_97, type_hint_53, factory_78) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + MySQL      : `LOG2(0)` === `NULL`
     * + PostgreSQL : `LOG(2, 0)` throws error
     */
    exports.log2 = factory_78.makeOperator1(operator_type_97.OperatorType.LOG2, decimal_mapper_14.decimalMapper.orNull(), type_hint_53.TypeHint.DECIMAL);
});
define("expr-library/decimal/log10", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_15, operator_type_98, type_hint_54, factory_79) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + MySQL      : `LOG10(0)` === `NULL`
     * + PostgreSQL : `LOG(10, 0)` throws error
     */
    exports.log10 = factory_79.makeOperator1(operator_type_98.OperatorType.LOG10, decimal_mapper_15.decimalMapper.orNull(), type_hint_54.TypeHint.DECIMAL);
});
define("expr-library/decimal/mul", ["require", "exports", "expr-library/decimal/decimal-mapper", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, decimal_mapper_16, factory_80, operator_type_99, type_hint_55) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mul = factory_80.makeChainableDecimalOperator(operator_type_99.OperatorType.MULTIPLICATION, 1, decimal_mapper_16.decimalMapper, type_hint_55.TypeHint.DECIMAL);
});
define("expr-library/decimal/neg", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_17, operator_type_100, type_hint_56, factory_81) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     */
    exports.neg = factory_81.makeOperator1DoubleElimination(operator_type_100.OperatorType.UNARY_MINUS, decimal_mapper_17.decimalMapper, type_hint_56.TypeHint.DECIMAL);
});
define("expr-library/decimal/power", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_18, operator_type_101, type_hint_57, factory_82) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.power = factory_82.makeOperator2(operator_type_101.OperatorType.POWER, decimal_mapper_18.decimalMapper, type_hint_57.TypeHint.DECIMAL);
});
define("expr-library/decimal/random", ["require", "exports", "expr-library/decimal/decimal-mapper", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, decimal_mapper_19, factory_83, operator_type_102, type_hint_58) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.random = factory_83.makeOperator0(operator_type_102.OperatorType.RANDOM, decimal_mapper_19.decimalMapper, type_hint_58.TypeHint.DECIMAL);
});
define("expr-library/decimal/sign", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_20, operator_type_103, type_hint_59, factory_84) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
     */
    exports.sign = factory_84.makeOperator1Idempotent(operator_type_103.OperatorType.SIGN, decimal_mapper_20.decimalMapper, type_hint_59.TypeHint.DECIMAL);
});
define("expr-library/decimal/sqrt", ["require", "exports", "expr-library/decimal/decimal-mapper", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, decimal_mapper_21, operator_type_104, type_hint_60, factory_85) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + MySQL      : `SQRT(-5)` === `null`
     * + PostgreSQL : `SQRT(-5)` throws error
     */
    exports.sqrt = factory_85.makeOperator1(operator_type_104.OperatorType.SQUARE_ROOT, decimal_mapper_21.decimalMapper.orNull(), type_hint_60.TypeHint.DECIMAL);
});
define("expr-library/decimal/sub", ["require", "exports", "expr-library/decimal/decimal-mapper", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, decimal_mapper_22, factory_86, operator_type_105, type_hint_61) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sub = factory_86.makeOperator2(operator_type_105.OperatorType.SUBTRACTION, decimal_mapper_22.decimalMapper, type_hint_61.TypeHint.DECIMAL);
});
define("expr-library/decimal/index", ["require", "exports", "expr-library/decimal/aggregate/index", "expr-library/decimal/abs", "expr-library/decimal/add", "expr-library/decimal/ceiling", "expr-library/decimal/exp", "expr-library/decimal/floor", "expr-library/decimal/fractional-div", "expr-library/decimal/ln", "expr-library/decimal/log", "expr-library/decimal/log2", "expr-library/decimal/log10", "expr-library/decimal/mul", "expr-library/decimal/neg", "expr-library/decimal/power", "expr-library/decimal/random", "expr-library/decimal/sign", "expr-library/decimal/sqrt", "expr-library/decimal/sub"], function (require, exports, aggregate_2, abs_1, add_1, ceiling_1, exp_1, floor_1, fractional_div_1, ln_1, log_1, log2_1, log10_1, mul_1, neg_1, power_1, random_1, sign_1, sqrt_1, sub_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_2);
    __export(abs_1);
    //export * from "./acos";
    __export(add_1);
    //export * from "./asin";
    //export * from "./atan";
    //export * from "./atan2";
    //export * from "./cbrt";
    __export(ceiling_1);
    //export * from "./cos";
    //export * from "./cot";
    //export * from "./degrees";
    __export(exp_1);
    __export(floor_1);
    __export(fractional_div_1);
    /**
     * PostgreSQL and SQLite do not support fractional remainder `frem(x, y)`
     */
    //export * from "./fractional-remainder";
    //export * from "./integer-div";
    //export * from "./integer-remainder";
    __export(ln_1);
    __export(log_1);
    __export(log2_1);
    __export(log10_1);
    __export(mul_1);
    __export(neg_1);
    //export * from "./pi";
    __export(power_1);
    //export * from "./radians";
    __export(random_1);
    //export * from "./round";
    __export(sign_1);
    //export * from "./sin";
    __export(sqrt_1);
    __export(sub_1);
});
//export * from "./tan";
//export * from "./truncate";
define("expr-library/double/aggregate/avg", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_106, type_hint_62, aggregate_factory_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const avgImpl = aggregate_factory_8.makeAggregateOperator2(operator_type_106.OperatorType.AGGREGATE_AVERAGE, tm.orNull(tm.toUnsafeNumber()), type_hint_62.TypeHint.DOUBLE);
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)`
     * + PostgreSQL : `AVG(DISTINCT x)`
     * + SQLite     : `AVG(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.avgDistinct = (arg) => {
        return avgImpl(true, arg);
    };
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.avgAll = (arg) => {
        return avgImpl(false, arg);
    };
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.avg = exports.avgAll;
});
define("expr-library/double/aggregate/max", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_107, type_hint_63, aggregate_factory_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    exports.max = aggregate_factory_9.makeAggregateOperator1(operator_type_107.OperatorType.AGGREGATE_MAX, tm.orNull(tm.toUnsafeNumber()), type_hint_63.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/min", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_108, type_hint_64, aggregate_factory_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    exports.min = aggregate_factory_10.makeAggregateOperator1(operator_type_108.OperatorType.AGGREGATE_MIN, tm.orNull(tm.toUnsafeNumber()), type_hint_64.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/stddev-pop", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_109, type_hint_65, aggregate_factory_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the population standard deviation of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_POP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `STDDEV_POP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The population standard deviation is,
     * ```sql
     *  SQRT(
     *      -- SUM() and AVG() should ignore rows with `NULL` values
     *      SUM(
     *          POW((x - AVG(x), 2)
     *      ) /
     *      COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
     *  )
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    exports.stdDevPop = aggregate_factory_11.makeAggregateOperator1(operator_type_109.OperatorType.AGGREGATE_POPULATION_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_65.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/stddev-samp", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_110, type_hint_66, aggregate_factory_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the sample standard deviation of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * It returns `NULL` if there is only one non-`NULL` value.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_stddev-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://stackoverflow.com/questions/2298339/standard-deviation-for-sqlite
     *
     * -----
     *
     * + MySQL      : `STDDEV_SAMP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `STDDEV_SAMP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The sample standard deviation is,
     * ```sql
     *  SQRT(
     *      -- SUM() and AVG() should ignore rows with `NULL` values
     *      SUM(
     *          POW((x - AVG(x), 2)
     *      ) /
     *      (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
     *  )
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    exports.stdDevSamp = aggregate_factory_12.makeAggregateOperator1(operator_type_110.OperatorType.AGGREGATE_SAMPLE_STANDARD_DEVIATION, tm.orNull(tm.toUnsafeNumber()), type_hint_66.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/sum", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_111, type_hint_67, aggregate_factory_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const sumImpl = aggregate_factory_13.makeAggregateOperator2(operator_type_111.OperatorType.AGGREGATE_SUM, tm.orNull(tm.toUnsafeNumber()), type_hint_67.TypeHint.DOUBLE);
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)`
     * + PostgreSQL : `SUM(DISTINCT x)`
     * + SQLite     : `SUM(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.sumDistinct = (arg) => {
        return sumImpl(true, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(x)`
     * + SQLite     : `SUM(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.sumAll = (arg) => {
        return sumImpl(false, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(x)`
     * + SQLite     : `SUM(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     */
    exports.sum = exports.sumAll;
});
define("expr-library/double/aggregate/var-pop", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_112, type_hint_68, aggregate_factory_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the population variance of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-pop
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_POP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `VAR_POP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The population variance is,
     * ```sql
     *  -- SUM() and AVG() should ignore rows with `NULL` values
     *  SUM(
     *      POW((x - AVG(x), 2)
     *  ) /
     *  COUNT(x) -- Returns a count of the number of rows with non-`NULL` values.
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    exports.varPop = aggregate_factory_14.makeAggregateOperator1(operator_type_112.OperatorType.AGGREGATE_POPULATION_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_68.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/var-samp", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_113, type_hint_69, aggregate_factory_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the sample variance of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * It returns `NULL` if there is only one non-`NULL` value.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_var-samp
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     *
     * -----
     *
     * + MySQL      : `VAR_SAMP(x)`
     *   + Always returns `double`
     * + PostgreSQL : `VAR_SAMP(x)`
     *   + Returns `double precision` if argument is `double precision`; `numeric` otherwise
     * + SQLite     : None. Implement with user-defined function.
     *
     * Should only be provided for `double` because MySQL treats all `x` as `double`.
     *
     * -----
     *
     * The sample variance is,
     * ```sql
     *  -- SUM() and AVG() should ignore rows with `NULL` values
     *  SUM(
     *      POW((x - AVG(x), 2)
     *  ) /
     *  (COUNT(x) - 1) -- Returns a count of the number of rows with non-`NULL` values.
     * ```
     *
     * Of course, you can't use the above expression because you cannot nest aggregate functions.
     * (Cannot use `AVG()` inside of `SUM()`)
     */
    exports.varSamp = aggregate_factory_15.makeAggregateOperator1(operator_type_113.OperatorType.AGGREGATE_SAMPLE_VARIANCE, tm.orNull(tm.toUnsafeNumber()), type_hint_69.TypeHint.DOUBLE);
});
define("expr-library/double/aggregate/index", ["require", "exports", "expr-library/double/aggregate/avg", "expr-library/double/aggregate/max", "expr-library/double/aggregate/min", "expr-library/double/aggregate/stddev-pop", "expr-library/double/aggregate/stddev-samp", "expr-library/double/aggregate/sum", "expr-library/double/aggregate/var-pop", "expr-library/double/aggregate/var-samp"], function (require, exports, avg_2, max_2, min_2, stddev_pop_1, stddev_samp_1, sum_2, var_pop_1, var_samp_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(avg_2);
    __export(max_2);
    __export(min_2);
    __export(stddev_pop_1);
    __export(stddev_samp_1);
    __export(sum_2);
    __export(var_pop_1);
    __export(var_samp_1);
});
define("expr-library/double/abs", ["require", "exports", "type-mapping", "operator-type", "expr-library/factory/index", "type-hint"], function (require, exports, tm, operator_type_114, factory_87, type_hint_70) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the absolute value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_abs
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_corefunc.html#abs
     *
     * -----
     *
     * + MySQL        : `ABS(x)`
     * + PostgreSQL   : `ABS(x)`
     * + SQLite       : `ABS(x)`
     *   + `ABS(Infinity)  = Infinity`
     *   + `ABS(-Infinity) = Infinity`
     *
     * -----
     *
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     */
    exports.abs = factory_87.makeOperator1Idempotent(operator_type_114.OperatorType.ABSOLUTE_VALUE, tm.toUnsafeNumber(), type_hint_70.TypeHint.DOUBLE);
});
define("expr-library/double/acos", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_88, operator_type_115, type_hint_71) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the arc cosine.
     *
     * If the argument is not in [-1, 1], may throw, or return `null`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_acos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ACOS(x)`
     * + PostgreSQL     : `ACOS(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * + MySQL      : `ACOS(1.5)` === `NULL`
     * + PostgreSQL : `ACOS(1.5)` throws error
     */
    exports.acos = factory_88.makeOperator1(operator_type_115.OperatorType.ARC_COSINE, tm.mysql.double().orNull(), type_hint_71.TypeHint.DOUBLE);
});
define("expr-library/double/add", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_89, operator_type_116, type_hint_72) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the addition of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_plus
     *
     * -----
     *
     * + MySQL        : `+`
     *   + `1e308+1e308` throws
     *   + `(-1e308)+(-1e308)` throws
     * + PostgreSQL   : `+`
     *   + `CAST(1e308 AS double precision)+CAST(1e308 AS double precision)` throws
     *   + `CAST(-1e308 AS double precision)+CAST(-1e308 AS double precision)` throws
     * + SQLite       : `+`
     *   + `1e308+1e308 = Infinity`
     *   + `(-1e308)+(-1e308) = -Infinity`
     *
     * -----
     *
     * In SQLite, addition with doubles may return `null`,
     * ```sql
     *  SELECT 1e999 + -1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    exports.add = factory_89.makeChainableOperator(operator_type_116.OperatorType.ADDITION, 0, tm.toUnsafeNumber(), type_hint_72.TypeHint.DOUBLE);
});
define("expr-library/double/asin", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_90, operator_type_117, type_hint_73) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the arc sine.
     *
     * If the argument is not in [-1, 1], may throw, or return `null`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_asin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ASIN(x)`
     * + PostgreSQL     : `ASIN(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * + MySQL      : `ASIN(1.5)` === `NULL`
     * + PostgreSQL : `ASIN(1.5)` throws error
     */
    exports.asin = factory_90.makeOperator1(operator_type_117.OperatorType.ARC_SINE, tm.mysql.double().orNull(), type_hint_73.TypeHint.DOUBLE);
});
define("expr-library/double/atan", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_91, operator_type_118, type_hint_74) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the arc tangent.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN(x)`
     * + PostgreSQL     : `ATAN(x)`
     * + SQLite         : None, implement with user-defined function
     */
    exports.atan = factory_91.makeOperator1(operator_type_118.OperatorType.ARC_TANGENT, tm.mysql.double(), type_hint_74.TypeHint.DOUBLE);
});
define("expr-library/double/atan2", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_92, operator_type_119, type_hint_75) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Similar to calculating the arc tangent of `Y / X`,
     * except that the signs of both arguments are used
     * to determine the quadrant of the result.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_atan2
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `ATAN2(y, x)`
     * + PostgreSQL     : `ATAN2(y, x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * @param left  - The Y of the vector
     * @param right - The X of the vector
     */
    exports.atan2 = factory_92.makeOperator2(operator_type_119.OperatorType.ARC_TANGENT_2, tm.mysql.double(), type_hint_75.TypeHint.DOUBLE);
});
define("expr-library/double/cbrt", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_120, type_hint_76, factory_93) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the cube root
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_pow
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `IF(x >= 0, POWER(x, 1.0/3.0), -POWER(-(x), 1.0/3.0))`
     *   + The `.0` parts are important!
     *   + MySQL's `POWER()` function throws on negative numbers
     * + PostgreSQL   : `||/` or `CBRT(x)` (Lets not use the ugly `||/` operator)
     * + SQLite       : Requres creating a `CBRT(x)` user-defined function
     *
     * -----
     *
     * MySQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 3
     * ```
     *
     * PostgreSQL
     * ```sql
     * SELECT POWER(27, 1.0/3.0)
     * > 2.99999999999999999997
     *
     * SELECT CBRT(27)
     * > 3
     * ```
     */
    exports.cbrt = factory_93.makeOperator1(operator_type_120.OperatorType.CUBE_ROOT, tm.toUnsafeNumber(), type_hint_76.TypeHint.DOUBLE);
});
define("expr-library/double/ceiling", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_121, type_hint_77, factory_94) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the ceiling of the number
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ceiling
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://stackoverflow.com/questions/14969067/getting-the-ceil-value-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `CEIL(x)/CEILING(x)`
     * + PostgreSQL   : `CEIL(x)/CEILING(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * ```sql
     *  SELECT CEILING(1.1)
     *  > 2
     *
     *  SELECT CEILING(-1.1)
     *  > -1
     * ```
     *
     * -----
     *
     * This function is idempotent.
     * `CEILING(CEILING(x)) == CEILING(x)`
     */
    exports.ceiling = factory_94.makeOperator1Idempotent(operator_type_121.OperatorType.CEILING, tm.toUnsafeNumber(), type_hint_77.TypeHint.DOUBLE);
});
define("expr-library/double/cos", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_122, type_hint_78, factory_95) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the cosine
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cos
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COS(x)`
     * + PostgreSQL     : `COS(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COS(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The cosine
     */
    exports.cos = factory_95.makeOperator1(operator_type_122.OperatorType.COSINE, tm.mysql.double().orNull(), type_hint_78.TypeHint.DOUBLE);
});
define("expr-library/double/cot", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_123, type_hint_79, factory_96) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the cotangent
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_cot
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `COT(x)`
     * + PostgreSQL     : `COT(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `COT(1e999)`
     *
     * -----
     *
     * + MySQL      : `COT(0)` throws error
     * + PostgreSQL : `COT(0)` === `NULL`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The cotangent
     */
    exports.cot = factory_96.makeOperator1(operator_type_123.OperatorType.COTANGENT, tm.mysql.double().orNull(), type_hint_79.TypeHint.DOUBLE);
});
define("expr-library/double/degrees", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_124, type_hint_80, factory_97) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts from radians to degrees.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_degrees
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `DEGREES(x)`
     * + PostgreSQL     : `DEGREES(x)`
     * + SQLite         : None, use `x * (180.0/3.1415926535897932384626433832795028841971693993751)`
     *
     * -----
     *
     * @param arg - radians
     * @returns degrees
     */
    exports.degrees = factory_97.makeOperator1(operator_type_124.OperatorType.DEGREES, tm.toUnsafeNumber(), type_hint_80.TypeHint.DOUBLE);
});
define("expr-library/double/exp", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_125, type_hint_81, factory_98) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The natural exponential function
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_exp
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://en.wikipedia.org/wiki/Exponential_function
     *
     * -----
     *
     * + MySQL          : `EXP(x)`
     * + PostgreSQL     : `EXP(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * @param arg - The power value
     * @returns e^arg
     */
    exports.exp = factory_98.makeOperator1(operator_type_125.OperatorType.NATURAL_EXPONENTIATION, tm.toUnsafeNumber(), type_hint_81.TypeHint.DOUBLE);
});
define("expr-library/double/floor", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_126, type_hint_82, factory_99) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the floor of the number
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_floor
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://stackoverflow.com/questions/7129249/getting-the-floor-value-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `FLOOR(x)`
     * + PostgreSQL   : `FLOOR(x)`
     * + SQLite         : None, implement with user-defined function
     *
     * -----
     *
     * ```sql
     *  SELECT FLOOR(1.1)
     *  > 1
     *
     *  SELECT FLOOR(-1.1)
     *  > -2
     * ```
     *
     * -----
     *
     * This function is idempotent.
     * `FLOOR(FLOOR(x)) == FLOOR(x)`
     */
    exports.floor = factory_99.makeOperator1Idempotent(operator_type_126.OperatorType.FLOOR, tm.toUnsafeNumber(), type_hint_82.TypeHint.DOUBLE);
});
define("expr-library/double/fractional-div", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_127, type_hint_83, factory_100) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Performs regular floating-point division
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_divide
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `/`
     * + PostgreSQL   : `/`
     * + SQLite       : `/`
     *
     * -----
     *
     * `1e0/0e0`,
     *
     * + MySQL      : `NULL`
     * + PostgreSQL : throws
     * + SQLite     : `NULL`
     *
     * -----
     *
     * `1e308/0.1e0`,
     *
     * + MySQL      : throws
     * + PostgreSQL : throws
     * + SQLite     : `Infinity`
     *
     * -----
     *
     * `1e308/-0.1e0`,
     *
     * + MySQL      : throws
     * + PostgreSQL : throws
     * + SQLite     : `-Infinity`
     *
     * -----
     *
     * MySQL,
     * ```sql
     *  SELECT
     *      3.141592653539793e0 /
     *      6.233523257997525e0;
     *  > 0.5039834654517689
     * ```
     * PostgreSQL,
     * ```sql
     *  SELECT
     *      CAST(3.141592653539793e0 AS DOUBLE PRECISION) /
     *      CAST(6.233523257997525e0 AS DOUBLE PRECISION);
     *  > 0.503983465451769
     * ```
     *
     * SQLite,
     * ```sql
     *  SELECT
     *      3.141592653539793e0 /
     *      6.233523257997525e0;
     *  > 0.5039834654517689
     * ```
     */
    exports.fractionalDiv = factory_100.makeOperator2(operator_type_127.OperatorType.FRACTIONAL_DIVISION, tm.orNull(tm.toUnsafeNumber()), type_hint_83.TypeHint.DOUBLE);
});
define("expr-library/double/fractional-remainder", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_128, type_hint_84, factory_101) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the remainder after fractional division.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_mod
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_mod
     * + https://stackoverflow.com/questions/53486669/modulo-operation-on-floating-point-numbers-on-postgresql
     *
     * -----
     *
     * + MySQL      : `dividend % divisor`
     * + PostgreSQL : See algorithm below
     * + SQLite     : See algorithm below
     *
     * ```sql
     *  IF(
     *      dividend >= 0,
     *      dividend - FLOOR(dividend / divisor) * divisor,
     *      -((-dividend) - FLOOR((-dividend) / divisor) * divisor)
     *  )
     * ```
     */
    exports.fractionalRemainder = factory_101.makeOperator2(operator_type_128.OperatorType.FRACTIONAL_REMAINDER, tm.mysql.double().orNull(), type_hint_84.TypeHint.DOUBLE);
});
define("expr-library/double/ln", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_129, type_hint_85, factory_102) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the natural logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_ln
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LN(x)`
     * + PostgreSQL     : `LN(x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LN(0)` === `NULL`
     * + PostgreSQL : `LN(0)` throws error
     *
     * -----
     *
     * + MySQL      : `LN(-1)` === `NULL`
     * + PostgreSQL : `LN(-1)` throws error
     */
    exports.ln = factory_102.makeOperator1(operator_type_129.OperatorType.LN, tm.orNull(tm.toUnsafeNumber()), type_hint_85.TypeHint.DOUBLE);
});
define("expr-library/double/log", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_130, type_hint_86, factory_103) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the logarithm to the specified `base`.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `LOG(base, x)`
     * + PostgreSQL     : `LOG(base, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG(0, 0)` === `NULL`
     * + PostgreSQL : `LOG(0, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG(1, 5)` === `NULL`
     * + PostgreSQL : `LOG(1, 5)` throws error
     *
     * -----
     *
     * @param left  - The base
     * @param right - The anti-logarithm
     * @returns log_{base}(anti-logarithm) = logarithm
     */
    exports.log = factory_103.makeOperator2(operator_type_130.OperatorType.LOG, tm.orNull(tm.toUnsafeNumber()), type_hint_86.TypeHint.DOUBLE);
});
define("expr-library/double/log2", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_131, type_hint_87, factory_104) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the base-2 logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log2
     *
     * -----
     *
     * + MySQL          : `LOG2(x)`
     * + PostgreSQL     : `LOG(2.0, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG2(0)` === `NULL`
     * + PostgreSQL : `LOG(2, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG2(-1)` === `NULL`
     * + PostgreSQL : `LOG(2, -1)` throws error
     */
    exports.log2 = factory_104.makeOperator1(operator_type_131.OperatorType.LOG2, tm.orNull(tm.toUnsafeNumber()), type_hint_87.TypeHint.DOUBLE);
});
define("expr-library/double/log10", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_132, type_hint_88, factory_105) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the base-10 logarithm
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_log10
     *
     * -----
     *
     * + MySQL          : `LOG10(x)`
     * + PostgreSQL     : `LOG(10.0, x)`
     * + SQLite         : None, implment with user-defined function
     *
     * -----
     *
     * + MySQL      : `LOG10(0)` === `NULL`
     * + PostgreSQL : `LOG(10, 0)` throws error
     *
     * -----
     *
     * + MySQL      : `LOG10(-1)` === `NULL`
     * + PostgreSQL : `LOG(10, -1)` throws error
     */
    exports.log10 = factory_105.makeOperator1(operator_type_132.OperatorType.LOG10, tm.orNull(tm.toUnsafeNumber()), type_hint_88.TypeHint.DOUBLE);
});
define("expr-library/double/mul", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_106, operator_type_133, type_hint_89) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the multiplication of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_times
     *
     * -----
     *
     * + MySQL        : `*`
     *   + `1e308*1e308` throws
     *   + `1e308*-1e308` throws
     * + PostgreSQL   : `*`
     *   + `CAST(1e308 AS double precision)*CAST(1e308 AS double precision)` throws
     *   + `CAST(1e308 AS double precision)*CAST(-1e308 AS double precision)` throws
     * + SQLite       : `*`
     *   + `1e308*1e308 = Infinity`
     *   + `1e308*-1e308 = -Infinity`
     *
     * -----
     *
     * In SQLite, multiplication with doubles may return `null`,
     * ```sql
     *  SELECT 0e0 * 1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    exports.mul = factory_106.makeChainableOperator(operator_type_133.OperatorType.MULTIPLICATION, 1, tm.toUnsafeNumber(), type_hint_89.TypeHint.DOUBLE);
});
define("expr-library/double/neg", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_134, type_hint_90, factory_107) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the unary minus of the double value
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_unary-minus
     *
     * -----
     *
     * + MySQL        : `-`
     * + PostgreSQL   : `-`
     * + SQLite       : `-`
     *
     * -----
     *
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     */
    exports.neg = factory_107.makeOperator1DoubleElimination(operator_type_134.OperatorType.UNARY_MINUS, tm.toUnsafeNumber(), type_hint_90.TypeHint.DOUBLE);
});
define("expr-library/double/pi", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_108, operator_type_135, type_hint_91) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the value of pi
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_pi
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     * + https://en.wikipedia.org/wiki/Pi
     *
     * -----
     *
     * + MySQL          : `PI()`; MySQL's understanding of pi is... terrible
     *   + https://github.com/AnyhowStep/tsql/issues/252
     *   + The MySQL adapter library **should not** use `PI()`, it should use `3.141592653589793` instead
     * + PostgreSQL     : `PI()` Returns `3.14159265358979`
     * + SQLite         : None, implement using `3.141592653589793`
     *
     * -----
     *
     * In JS, `Math.PI` is `3.141592653589793`
     */
    exports.pi = factory_108.makeOperator0(operator_type_135.OperatorType.PI, tm.mysql.double(), type_hint_91.TypeHint.DOUBLE);
});
define("expr-library/double/power", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_136, type_hint_92, factory_109) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns `base^exponent`
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_power
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `POWER(base, exponent)`
     * + PostgreSQL   : `^` or `POWER(base, exponent)` (Let's not use the ugly `^` operator)
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `POWER(-1, 0.5)`
     *
     * -----
     *
     * If base is negative, and exponent is fractional,
     * + MySQL throws
     * + PostgreSQL throws
     * + SQLite reutrns `null` (`extension-functions.c`)
     *
     * -----
     *
     * If base is zero, and exponent is negative,
     * + MySQL throws
     * + PostgreSQL throws
     * + SQLite reutrns `Infinity` (`extension-functions.c`)
     *
     * -----
     *
     * @param left  - The base
     * @param right - The exponent
     * @returns base^exponent
     *
     * @todo Decide if we should make SQLite throw instead of return `null`
     */
    exports.power = factory_109.makeOperator2(operator_type_136.OperatorType.POWER, tm.orNull(tm.toUnsafeNumber()), type_hint_92.TypeHint.DOUBLE);
});
define("expr-library/double/radians", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_137, type_hint_93, factory_110) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts from degrees to radians.
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_radians
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `RADIANS(x)`
     * + PostgreSQL     : `RADIANS(x)`
     * + SQLite         : None, use `x * (3.1415926535897932384626433832795028841971693993751/180.0)`
     *
     * -----
     *
     * @param arg - degrees
     * @returns radians
     */
    exports.radians = factory_110.makeOperator1(operator_type_137.OperatorType.RADIANS, tm.toUnsafeNumber(), type_hint_93.TypeHint.DOUBLE);
});
define("expr-library/double/random", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_111, operator_type_138, type_hint_94) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a random floating point number in the range, `[0.0, 1.0)`
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_rand
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#random
     *
     * -----
     *
     * + MySQL          : `RAND()`      Returns `0.0 <= v < 1.0`
     * + PostgreSQL     : `RANDOM()`    Returns `0.0 <= v < 1.0`
     * + SQLite         : Incompatible.
     *   SQLite's `RANDOM()` function returns a value between `-9223372036854775808` and `+9223372036854775807`.
     *   See algorithm below to emulate.
     *   Or just use a user-defined function...
     *
     * -----
     *
     * SQLite emulation,
     * ```sql
     *  COALESCE(
     *      NULLIF(
     *          ABS(RANDOM()+0e0) / 9223372036854775809e0,
     *          1
     *      ),
     *      0.999999999999999
     *  )
     * ```
     */
    exports.random = factory_111.makeOperator0(operator_type_138.OperatorType.RANDOM, tm.mysql.double(), type_hint_94.TypeHint.DOUBLE);
});
define("expr-library/double/sign", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_139, type_hint_95, factory_112) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + If the argument is negative, returns -1
     * + If the argument is positive, returns  1
     * + If the argument is zero, returns 0
     *
     * -----
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sign
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE
     *
     * -----
     *
     * + MySQL          : `SIGN(x)`
     * + PostgreSQL     : `SIGN(x)`
     * + SQLite         : `CASE WHEN x > 0 THEN 1e0 WHEN x < 0 THEN -1e0 ELSE 0e0 END`
     *
     * -----
     *
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
    */
    exports.sign = factory_112.makeOperator1Idempotent(operator_type_139.OperatorType.SIGN, tm.mysql.double(), type_hint_95.TypeHint.DOUBLE);
});
define("expr-library/double/sin", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_140, type_hint_96, factory_113) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the sine
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sin
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `SIN(x)`
     * + PostgreSQL     : `SIN(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `SIN(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The sine
     */
    exports.sin = factory_113.makeOperator1(operator_type_140.OperatorType.SINE, tm.mysql.double().orNull(), type_hint_96.TypeHint.DOUBLE);
});
define("expr-library/double/sqrt", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_141, type_hint_97, factory_114) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the square root
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_sqrt
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://stackoverflow.com/questions/13190064/how-to-find-power-of-a-number-in-sqlite
     *
     * -----
     *
     * + MySQL        : `SQRT(x)`
     * + PostgreSQL   : `|/` or `SQRT(x)` (Lets not use the ugly `|/` operator)
     * + SQLite       : Requres creating a `SQRT(x)` user-defined function
     *
     * -----
     *
     * + MySQL      : `SQRT(-5)` === `null`
     * + PostgreSQL : `SQRT(-5)` throws error
     */
    exports.sqrt = factory_114.makeOperator1(operator_type_141.OperatorType.SQUARE_ROOT, tm.orNull(tm.toUnsafeNumber()), type_hint_97.TypeHint.DOUBLE);
});
define("expr-library/double/sub", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_115, operator_type_142, type_hint_98) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the subtraction of the double values
     *
     * The precision of the result is not guaranteed.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/arithmetic-functions.html#operator_minus
     *
     * -----
     *
     * + MySQL        : `-`
     *   + `-1e308 - 1e308` throws
     *   + `1e308 - -1e308` throws
     * + PostgreSQL   : `-`
     *   + `CAST(-1e308 AS DOUBLE PRECISION) - CAST(1e308 AS DOUBLE PRECISION)` throws
     *   + `CAST(1e308 AS DOUBLE PRECISION) - CAST(-1e308 AS DOUBLE PRECISION)` throws
     * + SQLite       : `-`
     *   + `-1e308 - 1e308 = -Infinity`
     *   + `1e308 - -1e308 = Infinity`
     *
     * -----
     *
     * In SQLite, subtraction with doubles may return `null`,
     * ```sql
     *  SELECT 1e999 - 1e999;
     *  > null
     * ```
     *
     * This particular function will be emulated in SQLite such that
     * it'll throw an error, instead of returning `null`.
     */
    exports.sub = factory_115.makeOperator2(operator_type_142.OperatorType.SUBTRACTION, tm.toUnsafeNumber(), type_hint_98.TypeHint.DOUBLE);
});
define("expr-library/double/tan", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_143, type_hint_99, factory_116) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the tangent
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html#function_tan
     * + https://www.postgresql.org/docs/9.1/functions-math.html#FUNCTIONS-MATH-TRIG-TABLE
     *
     * -----
     *
     * + MySQL          : `TAN(x)`
     * + PostgreSQL     : `TAN(x)`
     * + SQLite         : None, implement with user-defined function
     *   + `extension-functions.c` from https://www.sqlite.org/contrib returns `null` for `TAN(1e999)`
     *
     * -----
     *
     * @param arg - Radians
     * @returns The tangent
     */
    exports.tan = factory_116.makeOperator1(operator_type_143.OperatorType.TANGENT, tm.mysql.double().orNull(), type_hint_99.TypeHint.DOUBLE);
});
define("expr-library/double/index", ["require", "exports", "expr-library/double/aggregate/index", "expr-library/double/abs", "expr-library/double/acos", "expr-library/double/add", "expr-library/double/asin", "expr-library/double/atan", "expr-library/double/atan2", "expr-library/double/cbrt", "expr-library/double/ceiling", "expr-library/double/cos", "expr-library/double/cot", "expr-library/double/degrees", "expr-library/double/exp", "expr-library/double/floor", "expr-library/double/fractional-div", "expr-library/double/fractional-remainder", "expr-library/double/ln", "expr-library/double/log", "expr-library/double/log2", "expr-library/double/log10", "expr-library/double/mul", "expr-library/double/neg", "expr-library/double/pi", "expr-library/double/power", "expr-library/double/radians", "expr-library/double/random", "expr-library/double/sign", "expr-library/double/sin", "expr-library/double/sqrt", "expr-library/double/sub", "expr-library/double/tan"], function (require, exports, aggregate_3, abs_2, acos_1, add_2, asin_1, atan_1, atan2_1, cbrt_1, ceiling_2, cos_1, cot_1, degrees_1, exp_2, floor_2, fractional_div_2, fractional_remainder_1, ln_2, log_2, log2_2, log10_2, mul_2, neg_2, pi_1, power_2, radians_1, random_2, sign_2, sin_1, sqrt_2, sub_2, tan_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_3);
    __export(abs_2);
    __export(acos_1);
    __export(add_2);
    __export(asin_1);
    __export(atan_1);
    __export(atan2_1);
    __export(cbrt_1);
    __export(ceiling_2);
    __export(cos_1);
    __export(cot_1);
    __export(degrees_1);
    __export(exp_2);
    __export(floor_2);
    __export(fractional_div_2);
    __export(fractional_remainder_1);
    /**
     * MySQL's `DIV` is just too... Unintuitive.
     * One would think it converts operands to int before performing int-div.
     * Instead, it performs fractional-div, then converts result to int.
     *
     * If you really want integer-div, just cast and divide yourself.
     */
    //export * from "./integer-div";
    /**
     * For the same reason that integer-div is removed.
     */
    //export * from "./integer-remainder";
    __export(ln_2);
    __export(log_2);
    __export(log2_2);
    __export(log10_2);
    __export(mul_2);
    __export(neg_2);
    __export(pi_1);
    __export(power_2);
    __export(radians_1);
    __export(random_2);
    //export * from "./round";
    __export(sign_2);
    __export(sin_1);
    __export(sqrt_2);
    __export(sub_2);
    __export(tan_1);
});
//export * from "./truncate";
define("expr-library/integer/aggregate/avg", ["require", "exports", "operator-type", "type-hint", "expr-library/aggregate-factory/index", "expr-library/decimal/decimal-mapper"], function (require, exports, operator_type_144, type_hint_100, aggregate_factory_16, decimal_mapper_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The return type being `DECIMAL` is intentional.
     */
    const avgImpl = aggregate_factory_16.makeAggregateOperator2(operator_type_144.OperatorType.AGGREGATE_AVERAGE, decimal_mapper_23.decimalMapper.orNull(), type_hint_100.TypeHint.BIGINT_SIGNED);
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(DISTINCT x)`
     * + PostgreSQL : `AVG(DISTINCT x)`
     * + SQLite     : `AVG(DISTINCT x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.avgDistinct = (arg) => {
        return avgImpl(true, arg);
    };
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.avgAll = (arg) => {
        return avgImpl(false, arg);
    };
    /**
     * Returns the average value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#avg
     *
     * -----
     *
     * + MySQL      : `AVG(x)`
     * + PostgreSQL : `AVG(x)`
     * + SQLite     : `AVG(x)`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     * + MySQL tends to return fewer decimal places.
     * + PostgreSQL tends to return more decimal places.
     * + SQLite uses double precision arithmetic, rather than fixed precision.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.avg = exports.avgAll;
});
define("expr-library/integer/aggregate/max", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_145, type_hint_101, aggregate_factory_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the max value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#maxoreunc
     *
     * -----
     *
     * + MySQL      : `MAX(x)`
     * + PostgreSQL : `MAX(x)`
     * + SQLite     : `MAX(x)`
     */
    exports.max = aggregate_factory_17.makeAggregateOperator1(operator_type_145.OperatorType.AGGREGATE_MAX, tm.mysql.bigIntSigned().orNull(), type_hint_101.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/aggregate/min", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_146, type_hint_102, aggregate_factory_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the min value of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_corefunc.html#minoreunc
     *
     * -----
     *
     * + MySQL      : `MIN(x)`
     * + PostgreSQL : `MIN(x)`
     * + SQLite     : `MIN(x)`
     */
    exports.min = aggregate_factory_18.makeAggregateOperator1(operator_type_146.OperatorType.AGGREGATE_MIN, tm.mysql.bigIntSigned().orNull(), type_hint_102.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/aggregate/sum-as-bigint", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/aggregate-factory/index"], function (require, exports, tm, operator_type_147, type_hint_103, aggregate_factory_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const sumAsBigIntSignedImpl = aggregate_factory_19.makeAggregateOperator2(operator_type_147.OperatorType.AGGREGATE_SUM_AS_BIGINT_SIGNED, tm.mysql.bigIntSigned().orNull(), type_hint_103.TypeHint.BIGINT_SIGNED);
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(DISTINCT x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(DISTINCT x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(DISTINCT x)`
     *   + Throws on integer overflow
     *
     */
    exports.sumAsBigIntSignedDistinct = (arg) => {
        return sumAsBigIntSignedImpl(true, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(x)`
     *   + Throws on integer overflow
     *
     */
    exports.sumAsBigIntSignedAll = (arg) => {
        return sumAsBigIntSignedImpl(false, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `CAST(SUM(x) AS SIGNED)`
     *   + Will clamp between min and max bigint signed, instead of throwing on overflow!
     * + PostgreSQL : `SUM(x)`
     *   + Throws on integer overflow
     * + SQLite     : `SUM(x)`
     *   + Throws on integer overflow
     *
     */
    exports.sumAsBigIntSigned = exports.sumAsBigIntSignedAll;
});
define("expr-library/integer/aggregate/sum-as-decimal", ["require", "exports", "operator-type", "type-hint", "expr-library/aggregate-factory/index", "expr-library/decimal/decimal-mapper"], function (require, exports, operator_type_148, type_hint_104, aggregate_factory_20, decimal_mapper_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The return type being `DECIMAL` is intentional.
     */
    const sumAsDecimalImpl = aggregate_factory_20.makeAggregateOperator2(operator_type_148.OperatorType.AGGREGATE_SUM_AS_DECIMAL, decimal_mapper_24.decimalMapper.orNull(), type_hint_104.TypeHint.BIGINT_SIGNED);
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(DISTINCT x)`
     * + PostgreSQL : `SUM(DISTINCT CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(DISTINCT CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.sumAsDecimalDistinct = (arg) => {
        return sumAsDecimalImpl(true, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.sumAsDecimalAll = (arg) => {
        return sumAsDecimalImpl(false, arg);
    };
    /**
     * Returns the total sum of non-`NULL` values from a group.
     *
     * It returns `NULL` if there are no non-`NULL` values.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum
     * + https://www.postgresql.org/docs/9.2/functions-aggregate.html#FUNCTIONS-AGGREGATE-TABLE
     * + https://www.sqlite.org/lang_aggfunc.html#sumunc
     *
     * -----
     *
     * + MySQL      : `SUM(x)`
     * + PostgreSQL : `SUM(CAST(x AS NUMERIC))`
     * + SQLite     : `SUM(CAST(x AS NUMERIC))`
     *
     * -----
     *
     * No guarantees are made about the precision of the return type.
     *
     * @todo Some kind of `DECIMAL` polyfill for SQLite.
     */
    exports.sumAsDecimal = exports.sumAsDecimalAll;
});
define("expr-library/integer/aggregate/index", ["require", "exports", "expr-library/integer/aggregate/avg", "expr-library/integer/aggregate/max", "expr-library/integer/aggregate/min", "expr-library/integer/aggregate/sum-as-bigint", "expr-library/integer/aggregate/sum-as-decimal"], function (require, exports, avg_3, max_3, min_3, sum_as_bigint_1, sum_as_decimal_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(avg_3);
    __export(max_3);
    __export(min_3);
    __export(sum_as_bigint_1);
    __export(sum_as_decimal_1);
});
define("expr-library/integer/bitwise/bitwise-and", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_117, operator_type_149, type_hint_105) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitwiseAnd = factory_117.makeChainableOperator(operator_type_149.OperatorType.BITWISE_AND, tm.BigInt(-1), tm.mysql.bigIntSigned(), type_hint_105.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/bitwise/bitwise-left-shift", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, factory_118, operator_type_150, type_hint_106, built_in_expr_60, expr_53, ast_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Performs a **signed** bitwise left-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     *
     * -----
     *
     * If the RHS is negative, the behaviour is cannot be unified.
     *
     * + MySQL      : `2 << -1` is `0`
     * + PostgreSQL : `2 << -1` is `0`
     * + SQLite     : `2 << -1` is `1`
     * + JavaScript : `2 << -1` is `0`
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; undefined behaviour if negative
     *
     * @see bitwiseLeftShift
     */
    exports.bitwiseLeftShiftUnsafe = factory_118.makeOperator2(operator_type_150.OperatorType.BITWISE_LEFT_SHIFT, tm.mysql.bigIntSigned(), type_hint_106.TypeHint.BIGINT_SIGNED);
    /**
     * Performs a **signed** bitwise left-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x << y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise left-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `<<`
     * + SQLite       : `<<`
     *
     * -----
     *
     * If the RHS is negative, this throws.
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; throws if negative
     *
     * @see bitwiseLeftShiftUnsafe
     */
    function bitwiseLeftShift(left, right) {
        tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
        return expr_53.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_43.OperatorNodeUtil.operatorNode2(operator_type_150.OperatorType.BITWISE_LEFT_SHIFT, [
            built_in_expr_60.BuiltInExprUtil.buildAst(left),
            built_in_expr_60.BuiltInExprUtil.buildAst(right),
        ], type_hint_106.TypeHint.BIGINT_SIGNED));
    }
    exports.bitwiseLeftShift = bitwiseLeftShift;
});
define("expr-library/integer/bitwise/bitwise-not", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_151, type_hint_107, factory_119) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function has the double elimination property.
     * `~(~(x)) == x`
     */
    exports.bitwiseNot = factory_119.makeOperator1DoubleElimination(operator_type_151.OperatorType.BITWISE_NOT, tm.mysql.bigIntSigned(), type_hint_107.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/bitwise/bitwise-or", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_120, operator_type_152, type_hint_108) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitwiseOr = factory_120.makeChainableOperator(operator_type_152.OperatorType.BITWISE_OR, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_108.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/bitwise/bitwise-right-shift", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint", "built-in-expr/index", "expr/index", "ast/index"], function (require, exports, tm, factory_121, operator_type_153, type_hint_109, built_in_expr_61, expr_54, ast_44) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Performs a **signed** bitwise right-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     *
     * -----
     *
     * If the RHS is negative, the behaviour is cannot be unified.
     *
     * + MySQL      : `2 >> -1` is `0`
     * + PostgreSQL : `2 >> -1` is `0`
     * + SQLite     : `2 >> -1` is `4`
     * + JavaScript : `2 >> -1` is `0`
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; undefined behaviour if negative
     *
     * @see bitwiseRightShift
     */
    exports.bitwiseRightShiftUnsafe = factory_121.makeOperator2(operator_type_153.OperatorType.BITWISE_RIGHT_SHIFT, tm.mysql.bigIntSigned(), type_hint_109.TypeHint.BIGINT_SIGNED);
    /**
     * Performs a **signed** bitwise right-shift.
     *
     * + https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift
     * + https://www.postgresql.org/docs/9.0/functions-math.html
     * + https://www.sqlite.org/lang_expr.html#binaryops
     *
     * -----
     *
     * + MySQL        : `CAST(x >> y AS SIGNED)`
     *   + MySQL performs an **unsigned** bitwise right-shift; so we cast to signed to emulate intended behaviour.
     * + PostgreSQL   : `>>`
     * + SQLite       : `>>`
     *
     * -----
     *
     * If the RHS is negative, this throws.
     *
     * -----
     *
     * @param left  - The value to perform the shift on
     * @param right - The amount of bits to shift; throws if negative
     *
     * @see bitwiseRightShiftUnsafe
     */
    function bitwiseRightShift(left, right) {
        tm.bigIntGtEq(tm.BigInt(0))(`RHS`, right);
        return expr_54.ExprUtil.intersect(tm.mysql.bigIntSigned(), [left, right], ast_44.OperatorNodeUtil.operatorNode2(operator_type_153.OperatorType.BITWISE_RIGHT_SHIFT, [
            built_in_expr_61.BuiltInExprUtil.buildAst(left),
            built_in_expr_61.BuiltInExprUtil.buildAst(right),
        ], type_hint_109.TypeHint.BIGINT_SIGNED));
    }
    exports.bitwiseRightShift = bitwiseRightShift;
});
define("expr-library/integer/bitwise/bitwise-xor", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_122, operator_type_154, type_hint_110) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitwiseXor = factory_122.makeOperator2(operator_type_154.OperatorType.BITWISE_XOR, tm.mysql.bigIntSigned(), type_hint_110.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/bitwise/index", ["require", "exports", "expr-library/integer/bitwise/bitwise-and", "expr-library/integer/bitwise/bitwise-left-shift", "expr-library/integer/bitwise/bitwise-not", "expr-library/integer/bitwise/bitwise-or", "expr-library/integer/bitwise/bitwise-right-shift", "expr-library/integer/bitwise/bitwise-xor"], function (require, exports, bitwise_and_1, bitwise_left_shift_1, bitwise_not_1, bitwise_or_1, bitwise_right_shift_1, bitwise_xor_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(bitwise_and_1);
    __export(bitwise_left_shift_1);
    __export(bitwise_not_1);
    __export(bitwise_or_1);
    __export(bitwise_right_shift_1);
    __export(bitwise_xor_1);
});
define("expr-library/integer/abs", ["require", "exports", "type-mapping", "operator-type", "expr-library/factory/index", "type-hint"], function (require, exports, tm, operator_type_155, factory_123, type_hint_111) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `ABS(ABS(x)) == ABS(x)`
     *
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT ABS(-9223372036854775808)
     * ```
     * The above throws an error on MySQL, PostgreSQL and SQLite.
     */
    exports.abs = factory_123.makeOperator1Idempotent(operator_type_155.OperatorType.ABSOLUTE_VALUE, tm.mysql.bigIntSigned(), type_hint_111.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/add", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_124, operator_type_156, type_hint_112) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807+9223372036854775807;
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT -9223372036854775808+-9223372036854775808
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615+18446744073709551615
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is adding two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is adding two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 + -9223372036854775808 + -9223372036854775808
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL` and the result is correctly `-1`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE` and the result is **incorrectly** `0`.
     *
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintAdd()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    exports.add = factory_124.makeChainableOperator(operator_type_156.OperatorType.ADDITION, tm.BigInt(0), tm.mysql.bigIntSigned(), type_hint_112.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/integer-div", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_157, type_hint_113, factory_125) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Treats both arguments as integers and performs integer division
     *
     * -----
     *
     * ### Divide by zero
     *
     * ```sql
     *  SELECT 9223372036854775807 DIV 0; -- MySQL
     *  SELECT 9223372036854775807 / 0; -- PostgreSQL, SQLite
     * ```
     * The above gives `NULL` for MySQL and SQLite.
     * The above throws an error for PostgreSQL.
     */
    exports.integerDiv = factory_125.makeOperator2(operator_type_157.OperatorType.INTEGER_DIVISION, tm.mysql.bigIntSigned().orNull(), type_hint_113.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/integer-remainder", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_158, type_hint_114, factory_126) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The remainder after performing integer division.
     *
     * Integer division is defined as,
     * `dividend / divisor`
     *
     * ```ts
     * result = sign(dividend) * abs(remainder)
     * ```
     *
     * If the dividend is positive, the result is positive.
     * If the dividend is negative, the result is negative.
     *
     * ```ts
     * integerRemainder( 5,  3); //2
     * integerRemainder( 5, -3); //2
     * integerRemainder(-5,  3); //-2
     * integerRemainder(-5, -3); //-2
     * ```
     *
     * -----
     *
     * ### Divide by zero
     *
     * ```sql
     *  SELECT 9223372036854775807 % 0
     * ```
     * The above gives `NULL` for MySQL and SQLite.
     * The above throws an error for PostgreSQL.
     */
    exports.integerRemainder = factory_126.makeOperator2(operator_type_158.OperatorType.INTEGER_REMAINDER, tm.mysql.bigIntSigned().orNull(), type_hint_114.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/mul", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_127, operator_type_159, type_hint_115) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807*9223372036854775807;
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT 9223372036854775807*-9223372036854775808
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615*18446744073709551615
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is multiplying two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is multiplying two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 * -9223372036854775808
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
     *
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintMul()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    exports.mul = factory_127.makeChainableOperator(operator_type_159.OperatorType.MULTIPLICATION, tm.BigInt(1), tm.mysql.bigIntSigned(), type_hint_115.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/neg", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_160, type_hint_116, factory_128) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function has the double elimination property.
     * `NEG(NEG(x)) == x`
     *
     * -----
     *
     * ### `BIGINT SIGNED` too large (from database)
     *
     * Be careful, however,
     * ```sql
     *  CREATE TABLE a (id BIGINT);
     *  INSERT INTO a (id) VALUES (-9223372036854775808);
     *
     *  SELECT
     *      -- 9223372036854775808 is too big
     *      -- to fit in signed bigint
     *      -id
     *  FROM
     *      a
     * ```
     *
     * The above will throw an error on both MySQL and PostgreSQL
     * because `9223372036854775808` is not a valid signed bigint value.
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * ### Double Unary Minus Elimination on Negative `BIGINT SIGNED` Literal
     *
     * The following will not throw an error but will silently
     * cast the result,
     * ```sql
     *  SELECT -(-9223372036854775808);
     * ```
     * Both **do not** error in MySQL and PostgreSQL.
     * PostgreSQL seems to perform double unary minus elimination and treats the result as a `DECIMAL` literal.
     * MySQL seems to perform double unary minus elimination and treats the result as an `BIGINT UNSIGNED` literal.
     *
     * SQLite casts to `DOUBLE`
     *
     * -----
     *
     * ```sql
     *  SELECT -(
     *      CAST(-9223372036854775808 AS BIGINT)
     *  ); -- PostgreSQL
     *
     *  SELECT -(-9223372036854775808 + 0); -- PostgreSQL
     *
     *  SELECT -(
     *      CAST(-9223372036854775808 AS BIGINT SIGNED)
     *  ); -- MySQL
     * ```
     * The above throws an error on PostgreSQL.
     * The above silently casts to an `BIGINT UNSIGNED` on MySQL.
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * ```sql
     *  SELECT
     *      CAST(-(-9223372036854775808) AS BIGINT); -- PostgreSQL
     *
     *  SELECT
     *      CAST(-(-9223372036854775808) AS BIGINT SIGNED); -- MySQL
     * ```
     * The above throws an error on PostgreSQL.
     * The above silently casts to an `BIGINT UNSIGNED`
     *
     * SQLite casts to `DOUBLE`.
     *
     * -----
     *
     * MySQL seems to treat `BIGINT SIGNED` values from **columns** and **literals** differently!
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small.
     *
     * MySQL-specific,
     * ```sql
     *  CREATE TABLE a (id  BIGINT UNSIGNED);
     *  INSERT INTO a (id) VALUES (9223372036854775809);
     *  SELECT -id FROM a;
     * ```
     *
     * `-9223372036854775809` is too small to fit in `BIGINT SIGNED`. This will throw an error.
     *
     * -----
     *
     * ```sql
     *  SELECT -CAST(9223372036854775809 AS UNSIGNED);
     * ```
     * The above gives you a `DECIMAL` type with value `-9223372036854775809` in MySQL.
     * PostgreSQL and SQLite do not have `BIGINT UNSIGNED`.
     *
     * -----
     *
     * MySQL and PostgreSQL query builders should perform the unary minus on the library
     * level as much as possible. However, it is not always feasible...
     *
     * PostgreSQL should perform bigint unary minus with `-CAST(x AS BIGINT)` to avoid implicit conversions.
     *
     * MySQL should just use `CAST(-x AS SIGNED)`.
     *
     * However, on MySQL,
     * `CAST(-18446744073709551615 AS SIGNED)` === `-9223372036854775808` (signed bigint minimum value)
     *
     * It would be nice if it threw an error instead.
     * It throws an error on PostgreSQL.
     *
     * SQLite should have a special `bigintNeg()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    exports.neg = factory_128.makeOperator1DoubleElimination(operator_type_160.OperatorType.UNARY_MINUS, tm.mysql.bigIntSigned(), type_hint_116.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/random-bigint-signed", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_129, operator_type_161, type_hint_117) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns a random `BIGINT SIGNED` in the range,
     * [-9223372036854775808, 9223372036854775807]
     *
     * -----
     *
     * MySQL,
     * ```sql
     *  CAST(
     *      CAST(RAND() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
     *      AS SIGNED
     *  )
     * ```
     *
     * PostgreSQL,
     * ```sql
     *  CAST(
     *      CAST(RANDOM() AS DECIMAL(40,20)) * (9223372036854775807 + 9223372036854775808) - 9223372036854775808
     *      AS BIGINT
     *  )
     * ```
     *
     * SQLite,
     * ```sql
     *  RANDOM()
     * ```
     */
    exports.randomBigIntSigned = factory_129.makeOperator0(operator_type_161.OperatorType.RANDOM, tm.mysql.bigIntSigned(), type_hint_117.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/sign", ["require", "exports", "type-mapping", "operator-type", "type-hint", "expr-library/factory/index"], function (require, exports, tm, operator_type_162, type_hint_118, factory_130) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This function is idempotent.
     * `SIGN(SIGN(x)) == SIGN(x)`
     *
     * Will return -1, 0, 1
     */
    exports.sign = factory_130.makeOperator1Idempotent(operator_type_162.OperatorType.SIGN, tm.mysql.bigIntSigned(), type_hint_118.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/sub", ["require", "exports", "type-mapping", "expr-library/factory/index", "operator-type", "type-hint"], function (require, exports, tm, factory_131, operator_type_163, type_hint_119) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * -----
     *
     * ### `BIGINT SIGNED` too large
     *
     * ```sql
     *  SELECT 9223372036854775807- (-9223372036854775808);
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT SIGNED` too small
     *
     * ```sql
     *  SELECT -9223372036854775808 - 9223372036854775807
     * ```
     * The above throws an error on both MySQL and PostgreSQL.
     * SQLite casts to a `DOUBLE`.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too large
     *
     * ```sql
     *  SELECT 18446744073709551615 - (-9223372036854775808)
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is subtracting two `DECIMAL`s.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is subtracting two `DOUBLE`s.
     *
     * -----
     *
     * ### `BIGINT UNSIGNED` too small
     *
     * ```sql
     *  SELECT 18446744073709551615 - 9223372036854775807 - 9223372036854775807 - 9223372036854775807
     * ```
     * MySQL throws an error.
     * PostgreSQL has no concept of `BIGINT UNSIGNED`; this is of type `DECIMAL`.
     * SQLite has no concept of `BIGINT UNSIGNED`; this is of type `DOUBLE`.
     * -----
     *
     * ### Ensuring consistent behaviour
     *
     * PostgreSQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * MySQL's behaviour is perfect for `BIGINT SIGNED`.
     *
     * To ensure consistent behaviour across DBMS, **do not** use `BIGINT UNSIGNED` for math.
     * It is fine to use it as an auto-increment identifier in MySQL.
     * Just don't perform math on it.
     *
     * SQLite should have a special `bigintSub()` polyfill that does not cast to `DOUBLE`
     * and throws an error on overflow.
     */
    exports.sub = factory_131.makeOperator2(operator_type_163.OperatorType.SUBTRACTION, tm.mysql.bigIntSigned(), type_hint_119.TypeHint.BIGINT_SIGNED);
});
define("expr-library/integer/index", ["require", "exports", "expr-library/integer/aggregate/index", "expr-library/integer/bitwise/index", "expr-library/integer/abs", "expr-library/integer/add", "expr-library/integer/integer-div", "expr-library/integer/integer-remainder", "expr-library/integer/mul", "expr-library/integer/neg", "expr-library/integer/random-bigint-signed", "expr-library/integer/sign", "expr-library/integer/sub"], function (require, exports, aggregate_4, bitwise_1, abs_3, add_3, integer_div_1, integer_remainder_1, mul_3, neg_3, random_bigint_signed_1, sign_3, sub_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_4);
    __export(bitwise_1);
    __export(abs_3);
    __export(add_3);
    __export(integer_div_1);
    __export(integer_remainder_1);
    __export(mul_3);
    __export(neg_3);
    __export(random_bigint_signed_1);
    __export(sign_3);
    __export(sub_3);
});
define("expr-library/index", ["require", "exports", "expr-library/aggregate/index", "expr-library/aggregate-factory/index", "expr-library/assert/index", "expr-library/cast/index", "expr-library/comparison/index", "expr-library/control-flow/index", "expr-library/date-time/index", "expr-library/equation/index", "expr-library/factory/index", "expr-library/information/index", "expr-library/logical/index", "expr-library/logical-3/index", "expr-library/null-safe-equation/index", "expr-library/string/index", "expr-library/subquery/index", "expr-library/decimal/index", "expr-library/double/index", "expr-library/integer/index"], function (require, exports, aggregate_5, aggregate_factory_21, assert_1, cast_1, comparison_1, control_flow_1, date_time_2, equation_1, factory_132, information_1, logical_7, logical_3_1, null_safe_equation_4, string_1, subquery_1, decimal, double, integer) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_5);
    __export(aggregate_factory_21);
    __export(assert_1);
    __export(cast_1);
    __export(comparison_1);
    __export(control_flow_1);
    __export(date_time_2);
    __export(equation_1);
    __export(factory_132);
    __export(information_1);
    __export(logical_7);
    __export(logical_3_1);
    __export(null_safe_equation_4);
    __export(string_1);
    __export(subquery_1);
    exports.decimal = decimal;
    exports.double = double;
    exports.integer = integer;
});
define("ast/literal-value-node/util/constructor/decimal-literal-node", ["require", "exports", "type-mapping", "ast/literal-value-node/literal-value-node", "expr-library/index"], function (require, exports, tm, literal_value_node_9, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function decimalLiteralNode(rawDecimalLiteral, 
    /**
     * + MySQL's max precision is `65`
     * + PostgreSQL's min precision is `1`
     */
    precision, 
    /**
     * + MySQL's max scale is `30`.
     * + The min scale is `0`.
     * + `scale` must be <= `precision`.
     */
    scale) {
        const mapper = tm.mysql.decimal(precision, scale);
        const decimalDefinition = ExprLib.assertValidDecimalPrecisionAndScale(precision, scale);
        const literalValue = mapper("rawDecimalLiteral", rawDecimalLiteral).toString();
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_9.LiteralValueType.DECIMAL,
            literalValue,
            precision: decimalDefinition.precision,
            scale: decimalDefinition.scale,
        };
    }
    exports.decimalLiteralNode = decimalLiteralNode;
});
define("ast/literal-value-node/util/constructor/double-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function doubleLiteralNode(literalValue) {
        /**
         * The SQL standard forbids NaN, Infinity, -Infinity.
         * However, SQLite supports infinities.
         *
         * The job of throwing on these 3 values will have to
         * fall to the sqlfiers.
         */
        /*
        if (!isFinite(literalValue)) {
            throw new Error(`Double literal must be finite`);
        }
        */
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_10.LiteralValueType.DOUBLE,
            literalValue,
        };
    }
    exports.doubleLiteralNode = doubleLiteralNode;
});
define("ast/literal-value-node/util/constructor/null-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function nullLiteralNode(literalValue) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_11.LiteralValueType.NULL,
            literalValue,
        };
    }
    exports.nullLiteralNode = nullLiteralNode;
});
define("ast/literal-value-node/util/constructor/string-literal-node", ["require", "exports", "ast/literal-value-node/literal-value-node"], function (require, exports, literal_value_node_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringLiteralNode(literalValue) {
        return {
            type: "LiteralValue",
            literalValueType: literal_value_node_12.LiteralValueType.STRING,
            literalValue,
        };
    }
    exports.stringLiteralNode = stringLiteralNode;
});
define("ast/literal-value-node/util/constructor/index", ["require", "exports", "ast/literal-value-node/util/constructor/bigint-literal-node", "ast/literal-value-node/util/constructor/boolean-literal-node", "ast/literal-value-node/util/constructor/buffer-literal-node", "ast/literal-value-node/util/constructor/date-time-literal-node", "ast/literal-value-node/util/constructor/decimal-literal-node", "ast/literal-value-node/util/constructor/double-literal-node", "ast/literal-value-node/util/constructor/null-literal-node", "ast/literal-value-node/util/constructor/string-literal-node"], function (require, exports, bigint_literal_node_1, boolean_literal_node_1, buffer_literal_node_1, date_time_literal_node_1, decimal_literal_node_1, double_literal_node_1, null_literal_node_1, string_literal_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(bigint_literal_node_1);
    __export(boolean_literal_node_1);
    __export(buffer_literal_node_1);
    __export(date_time_literal_node_1);
    __export(decimal_literal_node_1);
    __export(double_literal_node_1);
    __export(null_literal_node_1);
    __export(string_literal_node_1);
});
define("ast/literal-value-node/util/predicate/is-literal-value-node", ["require", "exports", "ast/literal-value-node/literal-value-node", "type-util/index"], function (require, exports, literal_value_node_13, type_util_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Does not check for `precision` and `scale` for `DecimalLiteralNode`.
     * Just assumes it exists.
     */
    function isLiteralValueNode(mixed) {
        if (!type_util_26.isObjectWithOwnEnumerableKeys()(mixed, [
            "type",
            "literalValueType",
            "literalValue"
        ])) {
            return false;
        }
        return (mixed.type === "LiteralValue" &&
            literal_value_node_13.literalValueTypeElements.includes(mixed.literalValueType));
    }
    exports.isLiteralValueNode = isLiteralValueNode;
});
define("ast/literal-value-node/util/predicate/index", ["require", "exports", "ast/literal-value-node/util/predicate/is-literal-value-node"], function (require, exports, is_literal_value_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_literal_value_node_1);
});
define("ast/literal-value-node/util/index", ["require", "exports", "ast/literal-value-node/util/constructor/index", "ast/literal-value-node/util/predicate/index"], function (require, exports, constructor_24, predicate_61) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_24);
    __export(predicate_61);
});
define("ast/literal-value-node/index", ["require", "exports", "ast/literal-value-node/literal-value-node", "ast/literal-value-node/util/index"], function (require, exports, literal_value_node_14, LiteralValueNodeUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(literal_value_node_14);
    exports.LiteralValueNodeUtil = LiteralValueNodeUtil;
});
define("ast/sqlfier/operator-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/identifier-node", ["require", "exports", "type-util/index"], function (require, exports, type_util_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function identifierNode(...identifiers) {
        return {
            type: "Identifier",
            identifiers,
        };
    }
    exports.identifierNode = identifierNode;
    /**
     * Does not check that each element of the `identifiers` property is a `string`
     *
     * @param mixed
     */
    function isIdentifierNode(mixed) {
        if (!type_util_27.isObjectWithOwnEnumerableKeys()(mixed, [
            "type",
            "identifiers",
        ])) {
            return false;
        }
        return (mixed.type === "Identifier" &&
            Array.isArray(mixed.identifiers) &&
            mixed.identifiers.length >= 1);
    }
    exports.isIdentifierNode = isIdentifierNode;
});
define("ast/sqlfier/identifier-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/query-base-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/literal-value-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/case-condition-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/parentheses-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/case-value-node/case-value-node", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/case-value-node/util/predicate/is-case-value-node", ["require", "exports", "type-util/index"], function (require, exports, type_util_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isCaseValueNode(mixed) {
        if (!type_util_28.isObjectWithOwnEnumerableKeys()(mixed, [
            "type",
            "value",
            "cases",
            "else"
        ])) {
            return false;
        }
        return (mixed.type === "CaseValue");
    }
    exports.isCaseValueNode = isCaseValueNode;
});
define("ast/case-value-node/util/predicate/index", ["require", "exports", "ast/case-value-node/util/predicate/is-case-value-node"], function (require, exports, is_case_value_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_case_value_node_1);
});
define("ast/case-value-node/util/index", ["require", "exports", "ast/case-value-node/util/predicate/index"], function (require, exports, predicate_62) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_62);
});
define("ast/case-value-node/index", ["require", "exports", "ast/case-value-node/util/index"], function (require, exports, CaseValueNodeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CaseValueNodeUtil = CaseValueNodeUtil;
});
define("ast/sqlfier/case-sqlfier", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/sqlfier/not-implemented-sqlfier", ["require", "exports", "operator-type", "ast/literal-value-node/index"], function (require, exports, operator_type_164, literal_value_node_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const notImplemented = () => {
        throw new Error(`Not implemented`);
    };
    const operatorNotImplemented = (operatorNode) => {
        throw new Error(`Not implemented ${operatorNode.operatorType}`);
    };
    const literalValueNotImplemented = (literalValueNode) => {
        throw new Error(`Not implemented ${literalValueNode.literalValueType}`);
    };
    exports.notImplementedSqlfier = {
        identifierSqlfier: notImplemented,
        literalValueSqlfier: Object
            .values(literal_value_node_15.LiteralValueType)
            .reduce((memo, literalValueType) => {
            memo[literalValueType] = literalValueNotImplemented;
            return memo;
        }, {}),
        operatorSqlfier: Object
            .values(operator_type_164.OperatorType)
            .reduce((memo, operatorType) => {
            memo[operatorType] = operatorNotImplemented;
            return memo;
        }, {}),
        queryBaseSqlfier: notImplemented,
        caseValueSqlfier: notImplemented,
        caseConditionSqlfier: notImplemented,
    };
});
define("ast/sqlfier/index", ["require", "exports", "ast/sqlfier/not-implemented-sqlfier"], function (require, exports, not_implemented_sqlfier_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(not_implemented_sqlfier_1);
});
define("ast/function-call", ["require", "exports", "ast/parentheses", "ast/util/index"], function (require, exports, parentheses_1, AstUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FunctionArg {
        constructor(ast) {
            this.type = "FunctionArg";
            this.toSql = (sqlfier) => {
                return AstUtil.toSql(this.ast, sqlfier);
            };
            if (parentheses_1.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
                //No need to wrap arguments in parentheses...
                //Unless the argument is a sub-query...
                this.ast = ast.ast;
            }
            else {
                this.ast = ast;
            }
        }
        static IsFunctionArg(x) {
            if (x instanceof FunctionArg) {
                return true;
            }
            if (x == undefined) {
                return false;
            }
            const mixed = x;
            return ((mixed.type == "FunctionArg") &&
                /**
                 * @todo Debate if this is necessary.
                 * Safer, but slower.
                 */
                //AstUtil.isAst(mixed.ast) &&
                (typeof mixed.toSql == "function"));
        }
    }
    exports.FunctionArg = FunctionArg;
    class FunctionCall {
        constructor(functionName, args) {
            this.type = "FunctionCall";
            this.toSql = (sqlfier) => {
                const argsSql = this.args
                    .map(arg => arg.toSql(sqlfier))
                    .join(", ");
                return `${this.functionName}(${argsSql})`;
            };
            this.functionName = functionName;
            this.args = args;
        }
        static IsFunctionCall(x) {
            if (x instanceof FunctionCall) {
                return true;
            }
            if (x == undefined) {
                return false;
            }
            const mixed = x;
            return ((mixed.type == "FunctionCall") &&
                (typeof mixed.functionName == "string") &&
                /**
                 * @todo Debate if we should check each element is `FunctionArg`
                 * Safer, but slower.
                 */
                (Array.isArray(mixed.args)) &&
                (typeof mixed.toSql == "function"));
        }
    }
    exports.FunctionCall = FunctionCall;
    function functionArg(ast) {
        if (FunctionArg.IsFunctionArg(ast)) {
            return ast;
        }
        return new FunctionArg(ast);
    }
    exports.functionArg = functionArg;
    function functionCall(functionName, args) {
        return new FunctionCall(functionName, args.map(functionArg));
    }
    exports.functionCall = functionCall;
});
define("ast/util/is-ast", ["require", "exports", "ast/parentheses", "ast/function-call", "ast/operator-node/index", "ast/identifier-node", "query-base/index", "ast/literal-value-node/index", "ast/case-value-node/index", "ast/case-condition-node/index"], function (require, exports, parentheses_2, function_call_1, operator_node_2, identifier_node_1, query_base_15, literal_value_node_16, case_value_node_1, case_condition_node_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A type guard for the `Ast` type
     *
     * @param raw
     */
    function isAst(raw) {
        if (typeof raw == "string") {
            return true;
        }
        if (parentheses_2.Parentheses.IsParentheses(raw)) {
            return true;
        }
        if (function_call_1.FunctionCall.IsFunctionCall(raw)) {
            return true;
        }
        if (operator_node_2.OperatorNodeUtil.isOperatorNode(raw)) {
            return true;
        }
        if (identifier_node_1.isIdentifierNode(raw)) {
            return true;
        }
        if (literal_value_node_16.LiteralValueNodeUtil.isLiteralValueNode(raw)) {
            return true;
        }
        if (Array.isArray(raw)) {
            for (const item of raw) {
                if (!isAst(item)) {
                    return false;
                }
            }
            return true;
        }
        if (query_base_15.QueryBaseUtil.isQuery(raw)) {
            return true;
        }
        if (case_value_node_1.CaseValueNodeUtil.isCaseValueNode(raw)) {
            return true;
        }
        if (case_condition_node_1.CaseConditionNodeUtil.isCaseConditionNode(raw)) {
            return true;
        }
        return false;
    }
    exports.isAst = isAst;
});
define("formatter/TokenType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenType;
    (function (TokenType) {
        TokenType["WHITESPACE"] = "whitespace";
        TokenType["WORD"] = "word";
        TokenType["STRING"] = "string";
        TokenType["RESERVED"] = "reserved";
        TokenType["RESERVED_TOPLEVEL"] = "reserved-toplevel";
        TokenType["RESERVED_NEWLINE"] = "reserved-newline";
        TokenType["RESERVED_PRE_NEWLINE"] = "reserved-pre-newline";
        TokenType["OPERATOR"] = "operator";
        TokenType["OPEN_PAREN"] = "open-paren";
        TokenType["CLOSE_PAREN"] = "close-paren";
        TokenType["LINE_COMMENT"] = "line-comment";
        TokenType["BLOCK_COMMENT"] = "block-comment";
        TokenType["NUMBER"] = "number";
        TokenType["PLACEHOLDER"] = "placeholder";
    })(TokenType = exports.TokenType || (exports.TokenType = {}));
});
define("formatter/Indentation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function last(arr) {
        if (arr.length == 0) {
            return undefined;
        }
        else {
            return arr[arr.length - 1];
        }
    }
    //Poor man's enum?
    const INDENT_TYPE_TOP_LEVEL = "top-level";
    const INDENT_TYPE_BLOCK_LEVEL = "block-level";
    /* eslint-disable local/no-method */
    /**
     * Manages indentation levels.
     *
     * There are two types of indentation levels:
     *
     * - BLOCK_LEVEL : increased by open-parenthesis
     * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
     */
    class Indentation {
        /**
         * @param {String} indent Indent value, default is "  " (2 spaces)
         */
        constructor(indent) {
            this.indent = (indent == undefined) ? "  " : indent;
            this.indentTypes = [];
        }
        /**
         * Returns current indentation string.
         * @return {String}
         */
        getIndent() {
            return this.indent.repeat(this.indentTypes.length);
        }
        /**
         * Increases indentation by one top-level indent.
         */
        increaseToplevel() {
            this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
        }
        /**
         * Increases indentation by one block-level indent.
         */
        increaseBlockLevel() {
            this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
        }
        /**
         * Decreases indentation by one top-level indent.
         * Does nothing when the previous indent is not top-level.
         */
        decreaseTopLevel() {
            if (last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
                this.indentTypes.pop();
            }
        }
        /**
         * Decreases indentation by one block-level indent.
         * If there are top-level indents within the block-level indent,
         * throws away these as well.
         */
        decreaseBlockLevel() {
            while (this.indentTypes.length > 0) {
                const type = this.indentTypes.pop();
                if (type !== INDENT_TYPE_TOP_LEVEL) {
                    break;
                }
            }
        }
    }
    exports.Indentation = Indentation;
});
define("formatter/Token", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("formatter/InlineBlock", ["require", "exports", "formatter/TokenType"], function (require, exports, TokenType_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const INLINE_MAX_LENGTH = 50;
    /* eslint-disable local/no-method */
    /**
     * Bookkeeper for inline blocks.
     *
     * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.
     * These blocks are formatted on a single line, unlike longer parenthized
     * expressions where open-parenthesis causes newline and increase of indentation.
     */
    class InlineBlock {
        constructor() {
            this.level = 0;
        }
        /**
         * Begins inline block when lookahead through upcoming tokens determines
         * that the block would be smaller than INLINE_MAX_LENGTH.
         * @param  {Object[]} tokens Array of all tokens
         * @param  {Number} index Current token position
         */
        beginIfPossible(tokens, index) {
            if (this.level === 0 && this.isInlineBlock(tokens, index)) {
                this.level = 1;
            }
            else if (this.level > 0) {
                this.level++;
            }
            else {
                this.level = 0;
            }
        }
        /**
         * Finishes current inline block.
         * There might be several nested ones.
         */
        end() {
            this.level--;
        }
        /**
         * True when inside an inline block
         * @return {Boolean}
         */
        isActive() {
            return this.level > 0;
        }
        // Check if this should be an inline parentheses block
        // Examples are "NOW()", "COUNT(*)", "int(10)", key(`somecolumn`), DECIMAL(7,2)
        isInlineBlock(tokens, index) {
            let length = 0;
            let level = 0;
            for (let i = index; i < tokens.length; i++) {
                const token = tokens[i];
                length += token.value.length;
                // Overran max length
                if (length > INLINE_MAX_LENGTH) {
                    return false;
                }
                if (token.type === TokenType_1.TokenType.OPEN_PAREN) {
                    level++;
                }
                else if (token.type === TokenType_1.TokenType.CLOSE_PAREN) {
                    level--;
                    if (level === 0) {
                        return true;
                    }
                }
                if (this.isForbiddenToken(token)) {
                    return false;
                }
            }
            return false;
        }
        // Reserved words that cause newlines, comments and semicolons
        // are not allowed inside inline parentheses block
        isForbiddenToken({ type, value }) {
            return type === TokenType_1.TokenType.RESERVED_TOPLEVEL ||
                type === TokenType_1.TokenType.RESERVED_NEWLINE ||
                type === TokenType_1.TokenType.RESERVED_PRE_NEWLINE ||
                //TokenType.COMMENT does not exist.
                //This is effectively, type === undefined
                //This is why plain JS sucks.
                //type === TokenType.COMMENT ||
                type === TokenType_1.TokenType.BLOCK_COMMENT ||
                value === ";";
        }
    }
    exports.InlineBlock = InlineBlock;
});
define("formatter/Params", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* eslint-disable local/no-method */
    /**
     * Handles placeholder replacement with given params.
     */
    class Params {
        /**
         * @param {Object} params
         */
        constructor(params) {
            this.params = params;
            this.index = 0;
        }
        /**
         * Returns param value that matches given placeholder with param key.
         * @param {Object} token
         * @param {String} token.key Placeholder key
         * @param {String} token.value Placeholder value
         * @return {String} param or token.value when params are missing
         */
        get({ key, value }) {
            if (this.params == undefined) {
                return value;
            }
            if (key != undefined) {
                if (Array.isArray(this.params)) {
                    throw new Error(`Cannot use array params with named placeholders`);
                }
                else {
                    return this.params[key];
                }
            }
            else {
                if (Array.isArray(this.params)) {
                    return this.params[this.index++];
                }
                else {
                    throw new Error(`Cannot use object params with index placeholders`);
                }
            }
        }
    }
    exports.Params = Params;
});
define("formatter/Tokenizer", ["require", "exports", "formatter/TokenType"], function (require, exports, TokenType_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    const reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(str) {
        return (str != "" && reHasRegExpChar.test(str))
            ? str.replace(reRegExpChar, '\\$&')
            : str;
    }
    /* eslint-disable local/no-method */
    class Tokenizer {
        /**
         * @param {Object} cfg
         *  @param {String[]} cfg.reservedWords Reserved words in SQL
         *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately
         *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline
         *  @param {String[]} cfg.stringTypes String types to enable: "", '', ``, [], N''
         *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [
         *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]
         *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?
         *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :
         *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --
         *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #
         */
        constructor(cfg) {
            this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
            this.WHITESPACE_REGEX = /^(\s+)/;
            //The original NUMBER_REGEX was this -> /^((-\s*)?[0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\b/;
            this.NUMBER_REGEX = /^(([-+])?([0-9]*\.?[0-9]+)([eE]([-+])?([0-9]+))?)\b/;
            //Added <=> as the NULL-safe equality operator
            this.OPERATOR_REGEX = /^(<=>|!=|<>|==|<=|>=|!<|!>|\|\||::|->>|->|~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|.)/;
            this.BLOCK_COMMENT_REGEX = /^(\/\*[^]*?(?:\*\/|$))/;
            this.LINE_COMMENT_REGEX = this.createLineCommentRegex(cfg.lineCommentTypes);
            this.RESERVED_TOPLEVEL_REGEX = this.createReservedWordRegex(cfg.reservedToplevelWords);
            this.RESERVED_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedNewlineWords);
            this.RESERVED_PRE_NEWLINE_REGEX = this.createReservedWordRegex(cfg.reservedPreNewlineWords);
            this.RESERVED_PLAIN_REGEX = this.createReservedWordRegex(cfg.reservedWords);
            this.WORD_REGEX = this.createWordRegex(cfg.specialWordChars);
            this.STRING_REGEX = this.createStringRegex(cfg.stringTypes);
            this.OPEN_PAREN_REGEX = this.createParenRegex(cfg.openParens);
            this.CLOSE_PAREN_REGEX = this.createParenRegex(cfg.closeParens);
            this.INDEXED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.indexedPlaceholderTypes, "[0-9]*");
            this.IDENT_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, "[a-zA-Z0-9._$]+");
            this.STRING_NAMED_PLACEHOLDER_REGEX = this.createPlaceholderRegex(cfg.namedPlaceholderTypes, this.createStringPattern(cfg.stringTypes));
        }
        createLineCommentRegex(lineCommentTypes) {
            return new RegExp(`^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join("|")}).*?(?:\n|$))`);
        }
        createReservedWordRegex(reservedWords) {
            const reservedWordsPattern = reservedWords.join("|").replace(/ /g, "\\s+");
            return new RegExp(`^(${reservedWordsPattern})\\b`, "i");
        }
        createWordRegex(specialChars = []) {
            return new RegExp(`^([\\w${specialChars.join("")}]+)`);
        }
        createStringRegex(stringTypes) {
            return new RegExp("^(" + this.createStringPattern(stringTypes) + ")");
        }
        // This enables the following string patterns:
        // 1. backtick quoted string using `` to escape
        // 2. square bracket quoted string (SQL Server) using ]] to escape
        // 3. double quoted string using "" or \" to escape
        // 4. single quoted string using '' or \' to escape
        // 5. national character quoted string using N'' or N\' to escape
        // 6. double quoted string using "" to escape (should not be used with number 3)
        // 7. single quoted string using '' to escape (should not be used with number 4)
        createStringPattern(stringTypes) {
            const patterns = {
                "``": "((`[^`]*($|`))+)",
                "[]": "((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)",
                "\"\"": "((\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*(\"|$))+)",
                "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
                "N''": "((N'[^N'\\\\]*(?:\\\\.[^N'\\\\]*)*('|$))+)",
                "X''": "((X'[^X'\\\\]*(?:\\\\.[^X'\\\\]*)*('|$))+)",
                "pascal-double": `(("[^"]*($|"))+)`,
                "pascal-single": "(('[^']*($|'))+)",
            };
            return stringTypes.map(t => patterns[t]).join("|");
        }
        createParenRegex(parens) {
            return new RegExp("^(" + parens.map(p => this.escapeParen(p)).join("|") + ")", "i");
        }
        escapeParen(paren) {
            if (paren.length === 1) {
                // A single punctuation character
                return escapeRegExp(paren);
            }
            else {
                // longer word
                return "\\b" + paren + "\\b";
            }
        }
        createPlaceholderRegex(types, pattern) {
            if (types.length == 0) {
                return undefined;
            }
            const typesRegex = types.map(escapeRegExp).join("|");
            return new RegExp(`^((?:${typesRegex})(?:${pattern}))`);
        }
        /**
         * Takes a SQL string and breaks it into tokens.
         * Each token is an object with type and value.
         *
         * @param {String} input The SQL string
         * @return {Object[]} tokens An array of tokens.
         *  @return {String} token.type
         *  @return {String} token.value
         */
        tokenize(input) {
            const tokens = [];
            let token;
            // Keep processing the string until it is empty
            while (input.length > 0) {
                // Get the next token and the token type
                token = this.getNextToken(input, token);
                if (token == undefined) {
                    throw new Error(`No token found`);
                }
                // Advance the string
                input = input.substring(token.value.length);
                tokens.push(token);
            }
            return tokens;
        }
        getNextToken(input, previousToken) {
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return this.getWhitespaceToken(input) ||
                this.getCommentToken(input) ||
                this.getStringToken(input) ||
                this.getOpenParenToken(input) ||
                this.getCloseParenToken(input) ||
                this.getPlaceholderToken(input) ||
                this.getNumberToken(input) ||
                this.getReservedWordToken(input, previousToken) ||
                this.getWordToken(input) ||
                this.getOperatorToken(input);
        }
        getWhitespaceToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.WHITESPACE,
                regex: this.WHITESPACE_REGEX
            });
        }
        getCommentToken(input) {
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return this.getLineCommentToken(input) || this.getBlockCommentToken(input);
        }
        getLineCommentToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.LINE_COMMENT,
                regex: this.LINE_COMMENT_REGEX
            });
        }
        getBlockCommentToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.BLOCK_COMMENT,
                regex: this.BLOCK_COMMENT_REGEX
            });
        }
        getStringToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.STRING,
                regex: this.STRING_REGEX
            });
        }
        getOpenParenToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.OPEN_PAREN,
                regex: this.OPEN_PAREN_REGEX
            });
        }
        getCloseParenToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.CLOSE_PAREN,
                regex: this.CLOSE_PAREN_REGEX
            });
        }
        getPlaceholderToken(input) {
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            return this.getIdentNamedPlaceholderToken(input) ||
                this.getStringNamedPlaceholderToken(input) ||
                this.getIndexedPlaceholderToken(input);
        }
        getIdentNamedPlaceholderToken(input) {
            return this.getPlaceholderTokenWithKey({
                input,
                regex: this.IDENT_NAMED_PLACEHOLDER_REGEX,
                parseKey: (v) => v.slice(1)
            });
        }
        getStringNamedPlaceholderToken(input) {
            return this.getPlaceholderTokenWithKey({
                input,
                regex: this.STRING_NAMED_PLACEHOLDER_REGEX,
                parseKey: (v) => this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) })
            });
        }
        getIndexedPlaceholderToken(input) {
            return this.getPlaceholderTokenWithKey({
                input,
                regex: this.INDEXED_PLACEHOLDER_REGEX,
                parseKey: (v) => v.slice(1)
            });
        }
        getPlaceholderTokenWithKey({ input, regex, parseKey }) {
            const token = this.getTokenOnFirstMatch({ input, regex, type: TokenType_2.TokenType.PLACEHOLDER });
            if (token == undefined) {
                return undefined;
            }
            token.key = parseKey(token.value);
            return token;
        }
        getEscapedPlaceholderKey({ key, quoteChar }) {
            return key.replace(new RegExp(escapeRegExp("\\") + quoteChar, "g"), quoteChar);
        }
        // Decimal, binary, or hex numbers
        getNumberToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.NUMBER,
                regex: this.NUMBER_REGEX
            });
        }
        // Punctuation and symbols
        getOperatorToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.OPERATOR,
                regex: this.OPERATOR_REGEX
            });
        }
        getReservedWordToken(input, previousToken) {
            // A reserved word cannot be preceded by a "."
            // this makes it so in "mytable.from", "from" is not considered a reserved word
            if (previousToken != undefined && previousToken.value === ".") {
                return;
            }
            return (
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            this.getToplevelReservedToken(input) ||
                this.getNewlineReservedToken(input) ||
                this.getPreNewlineReservedToken(input) ||
                this.getPlainReservedToken(input));
        }
        getToplevelReservedToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.RESERVED_TOPLEVEL,
                regex: this.RESERVED_TOPLEVEL_REGEX
            });
        }
        getNewlineReservedToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.RESERVED_NEWLINE,
                regex: this.RESERVED_NEWLINE_REGEX
            });
        }
        getPreNewlineReservedToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.RESERVED_PRE_NEWLINE,
                regex: this.RESERVED_PRE_NEWLINE_REGEX
            });
        }
        getPlainReservedToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.RESERVED,
                regex: this.RESERVED_PLAIN_REGEX
            });
        }
        getWordToken(input) {
            return this.getTokenOnFirstMatch({
                input,
                type: TokenType_2.TokenType.WORD,
                regex: this.WORD_REGEX
            });
        }
        getTokenOnFirstMatch({ input, type, regex }) {
            const matches = (regex == undefined) ?
                undefined :
                input.match(regex);
            if (matches == undefined) {
                return undefined;
            }
            const value = matches[1];
            if (value == undefined) {
                throw new Error(`No value found; is the regex missing a capture group?`);
            }
            return { type, value };
        }
    }
    exports.Tokenizer = Tokenizer;
});
define("formatter/Formatter", ["require", "exports", "formatter/TokenType", "formatter/Indentation", "formatter/InlineBlock", "formatter/Params"], function (require, exports, TokenType_3, Indentation_1, InlineBlock_1, Params_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* eslint-disable local/no-method */
    class Formatter {
        /**
         * @param {Object} cfg
         *   @param {Object} cfg.indent
         *   @param {Object} cfg.params
         * @param {Tokenizer} tokenizer
         */
        constructor(cfg, tokenizer) {
            this.cfg = (cfg == undefined) ?
                {} :
                cfg;
            this.indentation = new Indentation_1.Indentation(this.cfg.indent);
            this.inlineBlock = new InlineBlock_1.InlineBlock();
            this.params = new Params_1.Params(this.cfg.params);
            this.tokenizer = tokenizer;
            this.previousReservedWord = undefined;
            this.tokens = [];
            this.index = 0;
        }
        /**
         * Formats whitespaces in a SQL string to make it easier to read.
         *
         * @param {String} query The SQL query string
         * @return {String} formatted query
         */
        format(query) {
            this.tokens = this.tokenizer.tokenize(query);
            const formattedQuery = this.getFormattedQueryFromTokens();
            return formattedQuery.trim();
        }
        getFormattedQueryFromTokens() {
            let formattedQuery = "";
            this.tokens.forEach((token, index) => {
                this.index = index;
                if (token.type === TokenType_3.TokenType.WHITESPACE) {
                    // ignore (we do our own whitespace formatting)
                }
                else if (token.type === TokenType_3.TokenType.LINE_COMMENT) {
                    formattedQuery = this.formatLineComment(token, formattedQuery);
                }
                else if (token.type === TokenType_3.TokenType.BLOCK_COMMENT) {
                    formattedQuery = this.formatBlockComment(token, formattedQuery);
                }
                else if (token.type === TokenType_3.TokenType.RESERVED_TOPLEVEL) {
                    formattedQuery = this.formatToplevelReservedWord(token, formattedQuery);
                    this.previousReservedWord = token;
                }
                else if (token.type === TokenType_3.TokenType.RESERVED_NEWLINE) {
                    formattedQuery = this.formatNewlineReservedWord(token, formattedQuery);
                    this.previousReservedWord = token;
                }
                else if (token.type === TokenType_3.TokenType.RESERVED_PRE_NEWLINE) {
                    formattedQuery = this.formatPreNewlineReservedWord(token, formattedQuery);
                    this.previousReservedWord = token;
                }
                else if (token.type === TokenType_3.TokenType.RESERVED) {
                    formattedQuery = this.formatWithSpaces(token, formattedQuery);
                    this.previousReservedWord = token;
                }
                else if (token.type === TokenType_3.TokenType.OPEN_PAREN) {
                    formattedQuery = this.formatOpeningParentheses(token, formattedQuery);
                }
                else if (token.type === TokenType_3.TokenType.CLOSE_PAREN) {
                    formattedQuery = this.formatClosingParentheses(token, formattedQuery);
                }
                else if (token.type === TokenType_3.TokenType.PLACEHOLDER) {
                    formattedQuery = this.formatPlaceholder(token, formattedQuery);
                }
                else if (token.value === ",") {
                    formattedQuery = this.formatComma(token, formattedQuery);
                }
                else if (token.value === ":") {
                    formattedQuery = this.formatWithSpaceAfter(token, formattedQuery);
                }
                else if (token.value === "." || token.value === ";") {
                    formattedQuery = this.formatWithoutSpaces(token, formattedQuery);
                }
                else {
                    formattedQuery = this.formatWithSpaces(token, formattedQuery);
                }
            });
            return formattedQuery;
        }
        formatLineComment(token, query) {
            return this.addNewline(query + token.value);
        }
        formatBlockComment(token, query) {
            return this.addNewline(this.addNewline(query) + this.indentComment(token.value));
        }
        indentComment(comment) {
            return comment.replace(/\n/g, "\n" + this.indentation.getIndent());
        }
        formatToplevelReservedWord(token, query) {
            this.indentation.decreaseTopLevel();
            query = this.addNewline(query);
            this.indentation.increaseToplevel();
            query += this.equalizeWhitespace(token.value);
            return this.addNewline(query);
        }
        formatNewlineReservedWord(token, query) {
            //Different from original implementation. I think this looks nicer.
            if (query.length > 0 && !query.endsWith(" ")) {
                query += " ";
            }
            return this.addNewline(query + this.equalizeWhitespace(token.value));
        }
        formatPreNewlineReservedWord(token, query) {
            //The original formatNewlineReservedWord() implementation
            //Useful for WHEN clause of CASE
            return this.addNewline(query) + this.equalizeWhitespace(token.value) + " ";
        }
        // Replace any sequence of whitespace characters with single space
        equalizeWhitespace(string) {
            return string.replace(/\s+/g, " ");
        }
        // Opening parentheses increase the block indent level and start a new line
        formatOpeningParentheses(token, query) {
            // Take out the preceding space unless there was whitespace there in the original query
            // or another opening parens or line comment
            const preserveWhitespaceFor = [
                TokenType_3.TokenType.WHITESPACE,
                TokenType_3.TokenType.OPEN_PAREN,
                TokenType_3.TokenType.LINE_COMMENT,
            ];
            if (!this.hasPreviousToken() || !preserveWhitespaceFor.includes(this.previousToken().type)) {
                query = query.trimRight();
            }
            query += token.value;
            this.inlineBlock.beginIfPossible(this.tokens, this.index);
            if (!this.inlineBlock.isActive()) {
                this.indentation.increaseBlockLevel();
                query = this.addNewline(query);
            }
            return query;
        }
        // Closing parentheses decrease the block indent level
        formatClosingParentheses(token, query) {
            if (this.inlineBlock.isActive()) {
                this.inlineBlock.end();
                return this.formatWithSpaceAfter(token, query);
            }
            else {
                this.indentation.decreaseBlockLevel();
                return this.formatWithSpaces(token, this.addNewline(query));
            }
        }
        formatPlaceholder(token, query) {
            return query + this.params.get(token) + " ";
        }
        // Commas start a new line (unless within inline parentheses or SQL "LIMIT" clause)
        formatComma(token, query) {
            query = this.trimTrailingWhitespace(query) + token.value + " ";
            if (this.inlineBlock.isActive()) {
                return query;
            }
            else if (this.previousReservedWord != undefined && /^LIMIT$/i.test(this.previousReservedWord.value)) {
                return query;
            }
            else {
                return this.addNewline(query);
            }
        }
        formatWithSpaceAfter(token, query) {
            return this.trimTrailingWhitespace(query) + token.value + " ";
        }
        formatWithoutSpaces(token, query) {
            return this.trimTrailingWhitespace(query) + token.value;
        }
        formatWithSpaces(token, query) {
            if (token.value == "HACKED_AND_NO_NEW_LINE") {
                return query + "AND" + " ";
            }
            return query + token.value + " ";
        }
        addNewline(query) {
            return query.trimRight() + "\n" + this.indentation.getIndent();
        }
        trimTrailingWhitespace(query) {
            if (this.hasPreviousNonWhitespaceToken() && this.previousNonWhitespaceToken().type === TokenType_3.TokenType.LINE_COMMENT) {
                return query.trimRight() + "\n";
            }
            else {
                return query.trimRight();
            }
        }
        hasPreviousNonWhitespaceToken() {
            let n = 1;
            while (this.hasPreviousToken(n) && this.previousToken(n).type === TokenType_3.TokenType.WHITESPACE) {
                n++;
            }
            return this.hasPreviousToken(n);
        }
        previousNonWhitespaceToken() {
            let n = 1;
            while (this.previousToken(n).type === TokenType_3.TokenType.WHITESPACE) {
                n++;
            }
            return this.previousToken(n);
        }
        hasPreviousToken(offset = 1) {
            return (this.index - offset) >= 0;
        }
        previousToken(offset = 1) {
            const result = this.tokens[this.index - offset];
            if (result == undefined) {
                throw new Error(`No previous token. index ${this.index}, offset ${offset}`);
            }
            return result;
        }
    }
    exports.Formatter = Formatter;
});
define("formatter/SqlFormatter", ["require", "exports", "formatter/Formatter", "formatter/Tokenizer"], function (require, exports, Formatter_1, Tokenizer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const reservedWords = [
        "ACCESSIBLE", "ACTION", "AGAINST", "AGGREGATE", "ALGORITHM", "ALL", "ALTER", "ANALYSE", "ANALYZE", "AS", "ASC", "AUTOCOMMIT",
        "AUTO_INCREMENT",
        "BACKUP", "BEGIN", "BETWEEN", "BINLOG", "BOTH",
        "CASCADE", "CASE", "CHANGE", "CHANGED", "CHARACTER SET", "CHARSET", "CHECK", "CHECKSUM", "COLLATE", "COLLATION", "COLUMN", "COLUMNS",
        "COMMENT", "COMMIT", "COMMITTED", "COMPRESSED", "CONCURRENT", "CONSTRAINT", "CONTAINS", "CONVERT", "CREATE", "CROSS",
        "CURRENT_TIMESTAMP",
        "DATABASE", "DATABASES", "DAY", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "DEFAULT", "DEFINER", "DELAYED", "DELETE", "DESC", "DESCRIBE",
        "DETERMINISTIC", "DISTINCT", "DISTINCTROW", "DIV", "DO", "DROP", "DUMPFILE", "DUPLICATE", "DYNAMIC",
        "ENCLOSED", "END", "ENGINE", "ENGINES", "ENGINE_TYPE", "ESCAPE", "ESCAPED", "EVENTS", "EXEC", "EXECUTE", "EXISTS", "EXPLAIN",
        "EXTENDED",
        "FAST", "FETCH", "FIELDS", "FILE", "FIRST", "FIXED", "FLUSH", "FOR", "FORCE", "FOREIGN", "FULL", "FULLTEXT", "FUNCTION",
        "GLOBAL", "GRANT", "GRANTS", "GROUP_CONCAT",
        "HEAP", "HIGH_PRIORITY", "HOSTS", "HOUR", "HOUR_MINUTE", "HOUR_SECOND",
        "IDENTIFIED", "IF", "IFNULL", "IGNORE", "IN", "INDEX", "INDEXES", "INFILE", "INSERT", "INSERT_ID", "INSERT_METHOD", "INTERVAL",
        "INTO", "INVOKER", "IS", "ISOLATION",
        "KEY", "KEYS", "KILL",
        "LAST_INSERT_ID", "LEADING", "LEVEL", "LIKE", "LINEAR", "LINES", "LOAD", "LOCAL", "LOCK", "LOCKS", "LOGS", "LOW_PRIORITY",
        "MARIA", "MASTER", "MASTER_CONNECT_RETRY", "MASTER_HOST", "MASTER_LOG_FILE", "MATCH", "MAX_CONNECTIONS_PER_HOUR",
        "MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", "MERGE", "MINUTE", "MINUTE_SECOND",
        "MIN_ROWS", "MODE", "MODIFY", "MONTH", "MRG_MYISAM", "MYISAM",
        "NAMES", "NATURAL", "NOT", "NOW()", "NULL",
        "ON DELETE", "ON UPDATE", "ONLY", "OPEN", "OPTIMIZE", "OPTION", "OPTIONALLY", "OUTFILE",
        "PACK_KEYS", "PAGE", "PARTIAL", "PARTITION", "PARTITIONS", "PASSWORD", "PRIMARY", "PRIVILEGES", "PROCEDURE", "PROCESS", "PROCESSLIST",
        "PURGE",
        "QUICK",
        "RAID0", "RAID_CHUNKS", "RAID_CHUNKSIZE", "RAID_TYPE", "RANGE", "READ", "READ_ONLY", "READ_WRITE", "REFERENCES", "REGEXP", "RELOAD",
        "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLICATION", "RESET", "RESTORE", "RESTRICT", "RETURN", "RETURNS", "REVOKE", "RLIKE",
        "ROLLBACK", "ROW", "ROWS", "ROW_FORMAT",
        "SECOND", "SECURITY", "SEPARATOR", "SERIALIZABLE", "SESSION", "SHARE", "SHOW", "SHUTDOWN", "SLAVE", "SONAME", "SOUNDS", "SQL",
        "SQL_AUTO_IS_NULL", "SQL_BIG_RESULT", "SQL_BIG_SELECTS", "SQL_BIG_TABLES", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS",
        "SQL_LOG_BIN", "SQL_LOG_OFF", "SQL_LOG_UPDATE", "SQL_LOW_PRIORITY_UPDATES", "SQL_MAX_JOIN_SIZE", "SQL_NO_CACHE",
        "SQL_QUOTE_SHOW_CREATE", "SQL_SAFE_UPDATES", "SQL_SELECT_LIMIT", "SQL_SLAVE_SKIP_COUNTER", "SQL_SMALL_RESULT", "SQL_WARNINGS",
        "START", "STARTING", "STATUS", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRING", "STRIPED", "SUPER",
        "TABLE", "TABLES", "TEMPORARY", "TERMINATED", "THEN", "TO", "TRAILING", "TRANSACTIONAL", "TRUE", "TRUNCATE", "TYPE", "TYPES",
        "UNCOMMITTED", "UNIQUE", "UNLOCK", "UNSIGNED", "USAGE", "USE", "USING",
        "VARIABLES", "VIEW", "WITH", "WORK", "WRITE",
        "YEAR_MONTH",
        //This will be rendered as `AND` but without a new line
        "HACKED_AND_NO_NEW_LINE"
    ];
    const reservedToplevelWords = [
        "ADD", "AFTER", "ALTER COLUMN", "ALTER TABLE",
        "DELETE FROM",
        "EXCEPT",
        "FETCH FIRST", "FROM",
        "GROUP BY", "GO",
        "HAVING",
        "INSERT INTO", "INSERT", "INTERSECT",
        "LIMIT",
        "MODIFY",
        "ORDER BY",
        /*New reserved top-level word*/ "SELECT DISTINCT SQL_CALC_FOUND_ROWS",
        /*New reserved top-level word*/ "SELECT DISTINCT",
        /*New reserved top-level word*/ "SELECT SQL_CALC_FOUND_ROWS",
        "SELECT", "SET CURRENT SCHEMA", "SET SCHEMA", "SET",
        "UNION ALL", /*New reserved top-level word*/ "UNION DISTINCT", "UNION", "UPDATE",
        "VALUES",
        "WHERE",
        //Originally in reservedNewlineWords
        //But I think this is better to me
        "CROSS APPLY", "CROSS JOIN",
        "INNER JOIN",
        "JOIN",
        "LEFT JOIN", "LEFT OUTER JOIN",
        "OUTER APPLY", "OUTER JOIN",
        "RIGHT JOIN", "RIGHT OUTER JOIN",
        //Originally in reservedWords
        //But I think this is better to me
        "ON",
        "OFFSET",
    ];
    const reservedNewlineWords = [
        "AND",
        "OR",
        "XOR"
    ];
    const reservedPreNewlineWords = [
        "WHEN",
        "ELSE",
    ];
    exports.defaultTokenizerConfig = {
        reservedWords,
        reservedToplevelWords,
        reservedNewlineWords,
        reservedPreNewlineWords,
        stringTypes: [/*`""`,*/ "N''", /*"''",*/ "``", "[]", "X''", "pascal-double", "pascal-single"],
        openParens: ["(", "CASE"],
        closeParens: [")", "END"],
        indexedPlaceholderTypes: ["?"],
        namedPlaceholderTypes: ["@", ":"],
        lineCommentTypes: ["#", "--"],
        specialWordChars: undefined,
    };
    /* eslint-disable local/no-method */
    class SqlFormatter {
        /**
         * @param {Object} cfg Different set of configurations
         */
        constructor(cfg, tokenizerConfig) {
            this.cfg = cfg;
            /**
             * @todo Not use this hack.
             * We want to ignore properties set to `undefined`.
             */
            this.tokenizerConfig = { ...tokenizerConfig };
            for (const key of Object.keys(this.tokenizerConfig)) {
                if (this.tokenizerConfig[key] === undefined) {
                    delete this.tokenizerConfig[key];
                }
            }
        }
        /**
         * Format the whitespace in a Standard SQL string to make it easier to read
         *
         * @param {String} query The Standard SQL string
         * @return {String} formatted string
         */
        format(query) {
            if (this.tokenizer == undefined) {
                this.tokenizer = new Tokenizer_1.Tokenizer({
                    ...exports.defaultTokenizerConfig,
                    ...this.tokenizerConfig,
                });
            }
            return new Formatter_1.Formatter(this.cfg, this.tokenizer).format(query);
        }
    }
    exports.SqlFormatter = SqlFormatter;
});
define("formatter/index", ["require", "exports", "formatter/Formatter", "formatter/Indentation", "formatter/InlineBlock", "formatter/Params", "formatter/SqlFormatter", "formatter/Tokenizer", "formatter/TokenType"], function (require, exports, Formatter_2, Indentation_2, InlineBlock_2, Params_2, SqlFormatter_1, Tokenizer_2, TokenType_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Formatter_2);
    __export(Indentation_2);
    __export(InlineBlock_2);
    __export(Params_2);
    __export(SqlFormatter_1);
    __export(Tokenizer_2);
    __export(TokenType_4);
});
define("ast/util/to-sql", ["require", "exports", "ast/parentheses", "ast/function-call", "ast/operator-node/index", "ast/identifier-node", "query-base/index", "ast/literal-value-node/index", "ast/case-value-node/index", "ast/case-condition-node/index"], function (require, exports, parentheses_3, function_call_2, operator_node_3, identifier_node_2, query_base_16, literal_value_node_17, case_value_node_2, case_condition_node_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toSqlAst(ast, sqlfier) {
        if (typeof ast == "string") {
            return ast;
        }
        else if (parentheses_3.Parentheses.IsParentheses(ast)) {
            return ast.toSql(sqlfier);
        }
        else if (function_call_2.FunctionCall.IsFunctionCall(ast)) {
            return ast.toSql(sqlfier);
        }
        else if (operator_node_3.OperatorNodeUtil.isOperatorNode(ast)) {
            return sqlfier.operatorSqlfier[ast.operatorType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
        }
        else if (identifier_node_2.isIdentifierNode(ast)) {
            return sqlfier.identifierSqlfier(ast);
        }
        else if (query_base_16.QueryBaseUtil.isQuery(ast)) {
            return sqlfier.queryBaseSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
        }
        else if (literal_value_node_17.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
            return sqlfier.literalValueSqlfier[ast.literalValueType](ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
        }
        else if (case_value_node_2.CaseValueNodeUtil.isCaseValueNode(ast)) {
            return sqlfier.caseValueSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
        }
        else if (case_condition_node_2.CaseConditionNodeUtil.isCaseConditionNode(ast)) {
            return sqlfier.caseConditionSqlfier(ast, (ast2) => toSql(ast2, sqlfier), sqlfier);
        }
        else {
            return ast.map(subAst => toSql(subAst, sqlfier)).join(" ");
        }
    }
    exports.toSqlAst = toSqlAst;
    /**
     * Converts an AST to a SQL string.
     *
     * **DOES NOT** prettify the output.
     *
     * @see {@link toSqlPretty} for prettified output.
     *
     * @param ast
     */
    function toSql(ast, sqlfier) {
        const result = toSqlAst(ast, sqlfier);
        if (typeof result == "string") {
            return result;
        }
        else {
            return toSql(result, sqlfier);
        }
    }
    exports.toSql = toSql;
});
define("ast/util/to-sql-pretty", ["require", "exports", "formatter/index", "ast/util/to-sql"], function (require, exports, formatter_1, to_sql_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts an AST to a SQL string.
     *
     * Prettifies the output.
     *
     * -----
     *
     * Perfomance is generally "okay" but when queries become
     * hundreds of thousands of characters long,
     * it can take a long time.
     *
     * Use this with caution.
     *
     * @param ast
     */
    function toSqlPretty(ast, sqlfier, tokenizerConfig) {
        const sql = to_sql_1.toSql(ast, sqlfier);
        return new formatter_1.SqlFormatter(undefined, tokenizerConfig).format(sql);
    }
    exports.toSqlPretty = toSqlPretty;
});
define("ast/util/try-extract-ast", ["require", "exports", "ast/parentheses"], function (require, exports, parentheses_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + If the AST satisfies the predicate, it is returned.
     * + If the AST is a `Parentheses` that contains an AST satisfying the predicate,
     * the `Parentheses` is returned.
     * + Else, `undefined` is returned.
     */
    function tryExtractAst(operand, extractDelegate) {
        const extractResult = extractDelegate(operand);
        if (extractResult != undefined) {
            if (typeof extractResult == "boolean") {
                //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                if (extractResult) {
                    return operand;
                }
            }
            else {
                return extractResult;
            }
        }
        if (parentheses_4.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
            return tryExtractAst(operand.ast, extractDelegate);
        }
        return undefined;
    }
    exports.tryExtractAst = tryExtractAst;
    function tryExtractAstOr(operand, extractDelegate, noMatchDelegate) {
        const extractResult = extractDelegate(operand);
        if (extractResult != undefined) {
            if (typeof extractResult == "boolean") {
                if (extractResult) {
                    return operand;
                }
            }
            else {
                return extractResult;
            }
        }
        if (parentheses_4.Parentheses.IsParentheses(operand) && operand.canUnwrap) {
            return tryExtractAstOr(operand.ast, extractDelegate, noMatchDelegate);
        }
        return noMatchDelegate(operand);
    }
    exports.tryExtractAstOr = tryExtractAstOr;
});
define("ast/util/try-unwrap-parentheses", ["require", "exports", "ast/parentheses"], function (require, exports, parentheses_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tryUnwrapParentheses(ast) {
        if (parentheses_5.Parentheses.IsParentheses(ast) && ast.canUnwrap) {
            return ast.ast;
        }
        else {
            return ast;
        }
    }
    exports.tryUnwrapParentheses = tryUnwrapParentheses;
});
define("ast/util/index", ["require", "exports", "ast/util/insert-between", "ast/util/is-ast", "ast/util/to-sql-pretty", "ast/util/to-sql", "ast/util/try-extract-ast", "ast/util/try-unwrap-parentheses"], function (require, exports, insert_between_1, is_ast_1, to_sql_pretty_1, to_sql_2, try_extract_ast_1, try_unwrap_parentheses_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(insert_between_1);
    __export(is_ast_1);
    __export(to_sql_pretty_1);
    __export(to_sql_2);
    __export(try_extract_ast_1);
    __export(try_unwrap_parentheses_1);
});
define("ast/parentheses", ["require", "exports", "ast/util/index", "ast/function-call", "ast/identifier-node", "ast/literal-value-node/index"], function (require, exports, AstUtil, function_call_3, identifier_node_3, literal_value_node_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function shouldWrap(ast, canUnwrap) {
        if (Parentheses.IsParentheses(ast)) {
            if (!canUnwrap && ast.canUnwrap) {
                return true;
            }
            else {
                return false;
            }
        }
        if (function_call_3.FunctionCall.IsFunctionCall(ast)) {
            return false;
        }
        if (literal_value_node_18.LiteralValueNodeUtil.isLiteralValueNode(ast)) {
            return false;
        }
        if (identifier_node_3.isIdentifierNode(ast)) {
            return false;
        }
        if (typeof ast == "string") {
            return false;
        }
        if (Array.isArray(ast)) {
            if (ast.length == 0) {
                throw new Error(`Attempt to add parentheses around empty query tree`);
            }
            else if (ast.length == 1) {
                return shouldWrap(ast[0], canUnwrap);
            }
            else {
                return true;
            }
        }
        return true;
    }
    class Parentheses {
        constructor(ast, canUnwrap) {
            this.type = "Parentheses";
            this.toSql = (sqlfier) => {
                /**
                 * @todo Investigate this logic
                 */
                const sqlAst = (sqlfier.parenthesesSqlfier == undefined ?
                    AstUtil.toSqlAst(this.ast, sqlfier) :
                    sqlfier.parenthesesSqlfier(this, (ast2) => AstUtil.toSql(ast2, sqlfier), sqlfier));
                if (!this.canUnwrap || shouldWrap(sqlAst, this.canUnwrap)) {
                    return `(${AstUtil.toSql(sqlAst, sqlfier)})`;
                }
                else {
                    return AstUtil.toSql(sqlAst, sqlfier);
                }
            };
            this.ast = ast;
            this.canUnwrap = canUnwrap;
        }
        static IsParentheses(x) {
            if (x instanceof Parentheses) {
                return true;
            }
            if (x == undefined) {
                return false;
            }
            const mixed = x;
            return ((mixed.type == "Parentheses") &&
                /**
                 * @todo Debate if this is necessary.
                 * Safer, but slower.
                 */
                //AstUtil.isAst(mixed.ast) &&
                (typeof mixed.canUnwrap == "boolean") &&
                (typeof mixed.toSql == "function"));
        }
        static Create(ast, canUnwrap = true) {
            if (shouldWrap(ast, canUnwrap)) {
                if (Parentheses.IsParentheses(ast)) {
                    return new Parentheses(ast.ast, canUnwrap);
                }
                else {
                    return new Parentheses(ast, canUnwrap);
                }
            }
            else {
                return ast;
            }
        }
    }
    exports.Parentheses = Parentheses;
    function parentheses(ast, canUnwrap) {
        return Parentheses.Create(ast, canUnwrap);
    }
    exports.parentheses = parentheses;
});
define("ast/ast", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/case-condition-node/case-condition-node", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("ast/case-condition-node/util/predicate/is-case-condition-node", ["require", "exports", "type-util/index"], function (require, exports, type_util_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isCaseConditionNode(mixed) {
        if (!type_util_29.isObjectWithOwnEnumerableKeys()(mixed, [
            "type",
            "branches",
            "else"
        ])) {
            return false;
        }
        return (mixed.type === "CaseCondition");
    }
    exports.isCaseConditionNode = isCaseConditionNode;
});
define("ast/case-condition-node/util/predicate/index", ["require", "exports", "ast/case-condition-node/util/predicate/is-case-condition-node"], function (require, exports, is_case_condition_node_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_case_condition_node_1);
});
define("ast/case-condition-node/util/index", ["require", "exports", "ast/case-condition-node/util/predicate/index"], function (require, exports, predicate_63) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(predicate_63);
});
define("ast/case-condition-node/index", ["require", "exports", "ast/case-condition-node/util/index"], function (require, exports, CaseConditionNodeUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CaseConditionNodeUtil = CaseConditionNodeUtil;
});
define("ast/index", ["require", "exports", "ast/case-condition-node/index", "ast/case-value-node/index", "ast/literal-value-node/index", "ast/operator-node/index", "ast/sqlfier/index", "ast/function-call", "ast/identifier-node", "ast/parentheses", "ast/util/index"], function (require, exports, case_condition_node_3, case_value_node_3, literal_value_node_19, operator_node_4, sqlfier_1, function_call_4, identifier_node_4, parentheses_6, AstUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(case_condition_node_3);
    __export(case_value_node_3);
    __export(literal_value_node_19);
    __export(operator_node_4);
    __export(sqlfier_1);
    __export(function_call_4);
    __export(identifier_node_4);
    __export(parentheses_6);
    exports.AstUtil = AstUtil;
});
define("expr/expr", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("expr/util/constructor/from-built-in-expr", ["require", "exports", "expr/expr-impl", "built-in-expr/index"], function (require, exports, expr_impl_5, built_in_expr_62) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromBuiltInExpr(builtInExpr) {
        if (builtInExpr instanceof expr_impl_5.ExprImpl) {
            return builtInExpr;
        }
        const mapper = built_in_expr_62.BuiltInExprUtil.mapper(builtInExpr);
        const usedRef = built_in_expr_62.BuiltInExprUtil.usedRef(builtInExpr);
        const isAggregate = built_in_expr_62.BuiltInExprUtil.isAggregate(builtInExpr);
        const ast = built_in_expr_62.BuiltInExprUtil.buildAst(builtInExpr);
        return expr_impl_5.expr({
            mapper,
            usedRef,
            isAggregate,
        }, ast);
    }
    exports.fromBuiltInExpr = fromBuiltInExpr;
    function fromRawExprNoUsedRefInput(mapper, value) {
        if (built_in_expr_62.BuiltInExprUtil.isAnyNonValueExpr(value)) {
            /**
             * Cannot map a `NonValueExpr`
             */
            return fromBuiltInExpr(value);
        }
        else {
            return fromBuiltInExpr(built_in_expr_62.BuiltInExprUtil.fromValueExpr(mapper, value));
        }
    }
    exports.fromRawExprNoUsedRefInput = fromRawExprNoUsedRefInput;
});
define("expr/util/constructor/index", ["require", "exports", "expr/util/constructor/from-built-in-expr"], function (require, exports, from_built_in_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(from_built_in_expr_1);
});
define("expr/util/operation/aggregate-intersect", ["require", "exports", "built-in-expr/index", "expr/expr-impl"], function (require, exports, built_in_expr_63, expr_impl_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function aggregateIntersect(mapper, args, ast) {
        /**
         * @todo Set the `name` parameter?
         */
        built_in_expr_63.BuiltInExprUtil.assertAllNonAggregate(``, args);
        return expr_impl_6.expr({
            mapper,
            usedRef: built_in_expr_63.BuiltInExprUtil.intersectUsedRef(...args),
            isAggregate: true,
        }, ast);
    }
    exports.aggregateIntersect = aggregateIntersect;
});
define("expr/util/operation/as", ["require", "exports", "constants", "aliased-expr/index"], function (require, exports, constants_4, aliased_expr_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function as(expr, alias) {
        const result = new aliased_expr_2.AliasedExpr({
            mapper: expr.mapper,
            tableAlias: constants_4.ALIASED,
            alias,
            usedRef: expr.usedRef,
            isAggregate: expr.isAggregate,
        }, expr.ast);
        return result;
    }
    exports.as = as;
});
define("expr/util/operation/intersect", ["require", "exports", "built-in-expr/index", "expr/expr-impl"], function (require, exports, built_in_expr_64, expr_impl_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function intersect(mapper, args, ast) {
        return expr_impl_7.expr({
            mapper,
            usedRef: built_in_expr_64.BuiltInExprUtil.intersectUsedRef(...args),
            isAggregate: args.some(built_in_expr_64.BuiltInExprUtil.isAggregate),
        }, ast);
    }
    exports.intersect = intersect;
});
define("expr/util/operation/sort", ["require", "exports", "sort-direction/index"], function (require, exports, sort_direction_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function asc(expr) {
        return [expr, sort_direction_9.SortDirection.ASC];
    }
    exports.asc = asc;
    function desc(expr) {
        return [expr, sort_direction_9.SortDirection.DESC];
    }
    exports.desc = desc;
    function sort(expr, sortDirection) {
        return [expr, sortDirection];
    }
    exports.sort = sort;
});
define("expr/util/operation/index", ["require", "exports", "expr/util/operation/aggregate-intersect", "expr/util/operation/as", "expr/util/operation/intersect", "expr/util/operation/sort"], function (require, exports, aggregate_intersect_1, as_4, intersect_7, sort_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aggregate_intersect_1);
    __export(as_4);
    __export(intersect_7);
    __export(sort_3);
});
define("expr/util/predicate/is-expr", ["require", "exports", "type-util/index"], function (require, exports, type_util_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import {UsedRefUtil} from "../../../used-ref";
    //import {AstUtil} from "../../../ast";
    /**
     * Does not actually check,
     * + `x.usedRef` is `IUsedRef`
     * + `x.ast` is `Ast`
     *
     * @todo Consider adding checks for increased type safety.
     */
    function isExpr(x) {
        if (!type_util_30.isObjectWithOwnEnumerableKeys()(x, [
            "mapper",
            "usedRef",
            "isAggregate",
            "ast"
        ])) {
            return false;
        }
        return ((typeof x.mapper == "function") //&&
        //UsedRefUtil.isUsedRef(x.usedRef) &&
        //AstUtil.isAst(x.ast) &&
        //(typeof x.isAggregate == "boolean")
        );
    }
    exports.isExpr = isExpr;
});
define("expr/util/predicate/index", ["require", "exports", "expr/util/predicate/is-expr"], function (require, exports, is_expr_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_expr_1);
});
define("expr/util/index", ["require", "exports", "expr/util/constructor/index", "expr/util/operation/index", "expr/util/predicate/index"], function (require, exports, constructor_25, operation_37, predicate_64) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_25);
    __export(operation_37);
    __export(predicate_64);
});
define("expr/expr-impl", ["require", "exports", "ast/index", "expr/util/index"], function (require, exports, ast_45, ExprUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * https://github.com/microsoft/TypeScript/issues/32707#issuecomment-518347966
     *
     * This hack should only really be reserved for types that are more likely
     * to trigger max depth/max count errors.
     */
    class ExprImpl {
        constructor(data, ast) {
            this.mapper = data.mapper;
            this.usedRef = data.usedRef;
            this.isAggregate = data.isAggregate;
            //Gotta' play it safe.
            //We want to preserve the order of operations.
            this.ast = ast_45.parentheses(ast);
        }
        /**
         * If you are running into "max instantiation depth" errors,
         * consider adding explicit `TableExpr<>` type annotations.
         *
         * If that doesn't help,
         * consider using `ExprUtil.as()` instead.
         *
         * Also, consider reading this to understand my frustration,
         * https://github.com/microsoft/TypeScript/issues/29511
         *
         * @param alias
         */
        as(alias) {
            return ExprUtil.as(this, alias);
        }
        /**
         * ```sql
         * ORDER BY
         *  RAND() ASC
         * ```
         */
        asc() {
            return ExprUtil.asc(this);
        }
        /**
         * ```sql
         * ORDER BY
         *  RAND() DESC
         * ```
         */
        desc() {
            return ExprUtil.desc(this);
        }
        /**
         * ```sql
         * ORDER BY
         *  (myTable.myColumn IS NOT NULL) ASC,
         *  RAND() DESC
         * ```
         */
        sort(sortDirection) {
            return ExprUtil.sort(this, sortDirection);
        }
    }
    exports.ExprImpl = ExprImpl;
    function expr(data, ast) {
        return new ExprImpl(data, ast);
    }
    exports.expr = expr;
});
define("expr/index", ["require", "exports", "expr/expr-impl", "expr/util/index"], function (require, exports, expr_impl_8, ExprUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(expr_impl_8);
    exports.ExprUtil = ExprUtil;
});
define("built-in-expr/built-in-expr", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("built-in-expr/index", ["require", "exports", "built-in-expr/util/index"], function (require, exports, BuiltInExprUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BuiltInExprUtil = BuiltInExprUtil;
});
define("data-type/data-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("data-type/data-type-impl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("type-util/pop-union", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("schema-validation/schema-validation-error", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SchemaValidationErrorType;
    (function (SchemaValidationErrorType) {
        SchemaValidationErrorType["TABLE_ON_APPLICATION_ONLY"] = "TABLE_ON_APPLICATION_ONLY";
        SchemaValidationErrorType["TABLE_ALIAS_MISMATCH"] = "TABLE_ALIAS_MISMATCH";
        SchemaValidationErrorType["PRIMARY_KEY_ON_APPLICATION_ONLY"] = "PRIMARY_KEY_ON_APPLICATION_ONLY";
        SchemaValidationErrorType["PRIMARY_KEY_MISMATCH"] = "PRIMARY_KEY_MISMATCH";
        SchemaValidationErrorType["CANDIDATE_KEY_ON_APPLICATION_ONLY"] = "CANDIDATE_KEY_ON_APPLICATION_ONLY";
        SchemaValidationErrorType["DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY"] = "DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY";
        SchemaValidationErrorType["COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_ON_APPLICATION_ONLY"] = "COLUMN_ON_APPLICATION_ONLY";
        SchemaValidationErrorType["COLUMN_ALIAS_MISMATCH"] = "COLUMN_ALIAS_MISMATCH";
        SchemaValidationErrorType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
        SchemaValidationErrorType["AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL"] = "AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_NULLABLE_ON_DATABASE_ONLY"] = "COLUMN_NULLABLE_ON_DATABASE_ONLY";
        SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION"] = "COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION";
        SchemaValidationErrorType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
        SchemaValidationErrorType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL";
    })(SchemaValidationErrorType = exports.SchemaValidationErrorType || (exports.SchemaValidationErrorType = {}));
});
define("schema-validation/schema-validation-warning", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SchemaValidationWarningType;
    (function (SchemaValidationWarningType) {
        SchemaValidationWarningType["TABLE_ON_DATABASE_ONLY"] = "TABLE_ON_DATABASE_ONLY";
        SchemaValidationWarningType["TABLE_HAS_NO_PRIMARY_KEY"] = "TABLE_HAS_NO_PRIMARY_KEY";
        SchemaValidationWarningType["PRIMARY_KEY_ON_DATABASE_ONLY"] = "PRIMARY_KEY_ON_DATABASE_ONLY";
        SchemaValidationWarningType["CANDIDATE_KEY_ON_DATABASE_ONLY"] = "CANDIDATE_KEY_ON_DATABASE_ONLY";
        SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE"] = "COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE";
        SchemaValidationWarningType["COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED"] = "COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED";
        SchemaValidationWarningType["AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED";
        SchemaValidationWarningType["AUTO_INCREMENT_ON_DATABASE_ONLY"] = "AUTO_INCREMENT_ON_DATABASE_ONLY";
        SchemaValidationWarningType["AUTO_INCREMENT_MISMATCH_INSERT_DISABLED"] = "AUTO_INCREMENT_MISMATCH_INSERT_DISABLED";
        SchemaValidationWarningType["COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED";
        SchemaValidationWarningType["COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED"] = "COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED";
        SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE";
        SchemaValidationWarningType["COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED";
        SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY";
        SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE";
        SchemaValidationWarningType["COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED"] = "COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED";
    })(SchemaValidationWarningType = exports.SchemaValidationWarningType || (exports.SchemaValidationWarningType = {}));
});
define("schema-validation/schema-validation-result", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("sqlstring/index", ["require", "exports", "type-mapping"], function (require, exports, tm) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ID_BACKTICK_GLOBAL_REGEXP = /`/g;
    const ID_DOUBLE_QUOTE_GLOBAL_REGEXP = /"/g;
    const CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
    const CHARS_ESCAPE_MAP = {
        "\0": "\\0",
        "\b": "\\b",
        "\t": "\\t",
        "\n": "\\n",
        "\r": "\\r",
        "\x1a": "\\Z",
        "\"": "\\\"",
        "\'": "\\\'",
        "\\": "\\\\",
    };
    /**
     * Escapes a MySQL identifier.
     *
     * For example,
     * + Database name
     * + Table name
     * + Column name
     * + Alias
     *
     * -----
     *
     * ```ts
     * escapeIdentifier("x") == "`x`"
     * escapeIdentifier("x.y") == "`x.y`"
     * escapeIdentifier("x`x.y") == "`x``x.y`"
     * ```
     *
     * @param rawIdentifier - The identifier to escape
     *
     * @todo Refactor this.
     * + MySQL uses backticks.
     * + PostgreSQL uses double quotes. (Following the same rules as MySQL)
     * + MySQL can be made to use double quotes by enabling `ANSI_QUOTES` but this is disabled by default
     *
     * Each database adapter will need to create their own `escaoeIdentifier` function
     * and pass it around.
     *
     * A pain in the butt. Necessary, however.
     *
     * -----
     *
     * Another option would be forcing the MySQL adapter to always run a SQL query
     * to enable `ANSI_QUOTES`...
     *
     * Definitely less of a hassle there.
     *
     * @deprecated Use the `Identifier` AST Node instead
     */
    function escapeIdentifierWithBackticks(rawIdentifier) {
        return ("`" +
            String(rawIdentifier).replace(ID_BACKTICK_GLOBAL_REGEXP, "``") +
            "`");
    }
    exports.escapeIdentifierWithBackticks = escapeIdentifierWithBackticks;
    function escapeIdentifierWithDoubleQuotes(rawIdentifier) {
        return ("\"" +
            String(rawIdentifier).replace(ID_DOUBLE_QUOTE_GLOBAL_REGEXP, "\"\"") +
            "\"");
    }
    exports.escapeIdentifierWithDoubleQuotes = escapeIdentifierWithDoubleQuotes;
    function tryUnescapeIdentifierWithDoubleQuotes(rawIdentifier) {
        rawIdentifier = rawIdentifier.trim();
        if (rawIdentifier.startsWith(`"`) && rawIdentifier.endsWith(`"`)) {
            rawIdentifier = rawIdentifier.substr(1, rawIdentifier.length - 2);
            return rawIdentifier.replace(/""/g, `"`);
        }
        else {
            return rawIdentifier;
        }
    }
    exports.tryUnescapeIdentifierWithDoubleQuotes = tryUnescapeIdentifierWithDoubleQuotes;
    /**
     * Escapes a MySQL value.
     *
     * Does not handle `Date` as timezones are a pain.
     *
     * @param rawValue - The value to escape
     */
    function escapeValue(rawValue) {
        if (rawValue === null) {
            return "NULL";
        }
        if (tm.TypeUtil.isBigInt(rawValue)) {
            /**
             * Max `BIGINT SIGNED` value: `SELECT 9223372036854775807+9223372036854775807`
             *
             * + MySQL      : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
             * + PostgreSQL : `SELECT 9223372036854775807+9223372036854775807`; Error, out of range of bigint signed value
             * + SQLite     : `SELECT 9223372036854775807+9223372036854775807`; `18446744073709552000` (incorrect value)
             * + Expected   : `18446744073709551614`
             *
             * -----
             *
             * + MySQL      : `SELECT 18446744073709551615+18446744073709551615`; Error, out of range of bigint unsigned value
             * + PostgreSQL : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103230` (DECIMAL, not bigint unsigned)
             * + SQLite     : `SELECT 18446744073709551615+18446744073709551615`; `36893488147419103000` (incorrect value)
             * + Expected   : `36893488147419103230`
             *
             * PostgreSQL and SQLite do not support `BIGINT UNSIGNED`.
             * Selecting an integer larger than bigint signed in PostgreSQL will give you a `DECIMAL` value.
             *
             * @todo Fix this
             */
            return String(rawValue);
        }
        switch (typeof rawValue) {
            case "boolean": {
                return rawValue ?
                    "TRUE" :
                    "FALSE";
            }
            case "number": {
                if (!isFinite(rawValue)) {
                    return "NULL";
                }
                const result = String(rawValue);
                if (result.indexOf("e") < 0) {
                    /**
                     * We add `e0` at the end to signal to the DBMS that this is a double value.
                     * Not a `DECIMAL` value.
                     */
                    /**
                     * + MySQL      : `SELECT 1e300`; `1e300`
                     * + PostgreSQL : `SELECT 1e300`; `1000000000...` (total 300 zeroes) (DECIMAL)
                     * + SQLite     : `SELECT 1e300`; `1e300`
                     *
                     * -----
                     *
                     * PostgreSQL:
                     * ```sql
                     *  SELECT
                     *      pg_typeof(1e19), -- numeric
                     *      pg_typeof(1e1),  -- numeric
                     *      pg_typeof(10)    -- integer
                     * ```
                     *
                     * SQLite:
                     * ```sql
                     *  SELECT
                     *      typeof(1e19), -- real
                     *      typeof(1e1),  -- real
                     *      typeof(10)    -- integer
                     * ```
                     */
                    return result + "e0";
                }
                else {
                    return result;
                }
            }
            case "object": {
                if (rawValue instanceof Uint8Array) {
                    return uint8ArrayToString(rawValue);
                }
                else {
                    throw new Error(`Don't know how to escape non-Uint8Array object`);
                }
            }
            default: {
                throw new Error(`Don't know how to escape ${typeof rawValue}`);
            }
        }
    }
    exports.escapeValue = escapeValue;
    ;
    //https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
    function buf2hex(buffer) {
        return Array.prototype.map
            .call(new Uint8Array(buffer), 
        //Should always return a string of length 2
        x => ("0" + x.toString(16)).slice(-2))
            .join("");
    }
    function uint8ArrayToString(buffer) {
        return "X" + cStyleEscapeString(buf2hex(buffer));
    }
    ;
    /**
     * Only MySQL supports C-style escapes (using the backslash character).
     */
    function cStyleEscapeString(rawString) {
        let result = "";
        let chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
        let match = CHARS_GLOBAL_REGEXP.exec(rawString);
        while (match != undefined) {
            const escapedChar = CHARS_ESCAPE_MAP[match[0]];
            if (escapedChar == undefined) {
                throw new Error(`Unknown escapable character ${match[0]}`);
            }
            result += rawString.slice(chunkIndex, match.index) + escapedChar;
            chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
            match = CHARS_GLOBAL_REGEXP.exec(rawString);
        }
        if (chunkIndex === 0) {
            //Nothing was escaped
            return "'" + rawString + "'";
        }
        if (chunkIndex < rawString.length) {
            return "'" + result + rawString.slice(chunkIndex) + "'";
        }
        return "'" + result + "'";
    }
    exports.cStyleEscapeString = cStyleEscapeString;
    /**
     * PostgreSQL and SQLite use Pascal-style escapes
     */
    function pascalStyleEscapeString(rawString) {
        const result = rawString.replace(/\'/g, `''`);
        return "'" + result + "'";
    }
    exports.pascalStyleEscapeString = pascalStyleEscapeString;
});
define("schema-validation/util/operation/validate-column", ["require", "exports", "schema-validation/schema-validation-error", "schema-validation/schema-validation-warning", "sqlstring/index"], function (require, exports, schema_validation_error_1, schema_validation_warning_1, sqlstring_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function validateColumn(applicationTable, applicationColumn, columnMeta) {
        const result = {
            errors: [],
            warnings: [],
        };
        /**
         * Sanity check...
         */
        if (applicationColumn.columnAlias != columnMeta.columnAlias) {
            result.errors.push({
                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_ALIAS_MISMATCH,
                description: `Application column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)}, database column is named ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)}`,
                tableAlias: applicationTable.alias,
                applicationColumnAlias: applicationColumn.columnAlias,
                databaseColumnAlias: columnMeta.columnAlias,
            });
            return result;
        }
        const applicationNullable = applicationTable.nullableColumns.includes(columnMeta.columnAlias);
        const applicationMutable = applicationTable.mutableColumns.includes(applicationColumn.columnAlias);
        /*const applicationAutoIncrement = (
            applicationTable.autoIncrement != undefined &&
            applicationTable.autoIncrement == applicationColumn.columnAlias
        );*/
        const applicationGenerated = applicationTable.generatedColumns.includes(applicationColumn.columnAlias);
        const applicationExplicitDefaultValue = applicationTable.explicitDefaultValueColumns.includes(applicationColumn.columnAlias);
        if (columnMeta.isNullable) {
            if (applicationNullable) {
                /**
                 * OK
                 */
            }
            else {
                /**
                 * + Database is nullable.
                 * + Application is **not** nullable.
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` the `NULL` value will fail.
                 * + Attempts to `INSERT` are fine.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression expecting non-`NULL` will fail.
                 *
                 */
                result.errors.push({
                    type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_DATABASE_ONLY,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on database only; SELECTs will fail`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                });
            }
        }
        else {
            if (applicationNullable) {
                /**
                 * + Database is **not** nullable.
                 * + Application is nullable.
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` the `NULL` value will fail.
                 * + Attempts to `UPDATE` to the `NULL` value will fail.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression expecting nullable are fine.
                 *
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs using NULL value will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else if (applicationMutable) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_UPDATE_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; UPDATEs using NULL value will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_NULLABLE_ON_APPLICATION_ONLY_INSERT_AND_UPDATE_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is nullable on application only; INSERTs and UPDATEs using NULL value will fail but both are disabled`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
            }
            else {
                /**
                 * OK
                 */
            }
        }
        if (columnMeta.generationExpression != undefined) {
            if (applicationGenerated) {
                /**
                 * OK
                 */
            }
            else {
                /**
                 * + This column is generated on the database
                 * + This column is **not** generated on the application
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail because you cannot set values for generated columns.
                 * + Attsmpts to `UPDATE` will fail because you cannot set values for generated columns.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else if (applicationMutable) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_DATABASE_ONLY_UPDATE_WILL_FAIL,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; UPDATEs will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_DATABASE_ONLY_INSERT_AND_UPDATE_DISABLED,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on database only; INSERTs and UPDATEs will fail but both are disabled`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                    });
                }
            }
        }
        else {
            if (applicationGenerated) {
                if (applicationTable.autoIncrement != undefined &&
                    applicationTable.autoIncrement == applicationColumn.columnAlias) {
                    result.errors.push({
                        type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_AND_AUTO_INCREMENT_ON_APPLICATION,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} cannot be generated and auto-increment at the same time`,
                        tableAlias: applicationTable.alias,
                        applicationColumnAlias: applicationTable.autoIncrement,
                    });
                }
                else {
                    if (columnMeta.isNullable ||
                        columnMeta.isAutoIncrement ||
                        columnMeta.explicitDefaultValue != undefined) {
                        /**
                         * + This column has an implicit/explicit default/generated value on the database
                         *
                         * So, we can kind of pretend it's generated on application code, anyway.
                         *
                         * + Attempts to `SELECT` are fine.
                         * + Attempts to `INSERT` won't set the value because we say it is generated.
                         * + Attempts to `UPDATE` won't set the value because we say it is generated.
                         * + Attempts to `DELETE` are fine.
                         * + Attempts to use as expression are fine.
                         */
                        result.warnings.push({
                            type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_USING_DATABASE_DEFAULT_VALUE,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will use database default value`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                    else {
                        /**
                         * We say it is generated on application code.
                         * But it has **no** default/generated value on the database.
                         *
                         * + Attempts to `SELECT` are fine.
                         * + Attempts to `INSERT` will fail because we cannot set the value on application code,
                         *   and there is no default/generated value on the database.
                         * + Attempts to `UPDATE` won't set the value because we say it is generated.
                         * + Attempts to `DELETE` are fine.
                         * + Attempts to use as expression are fine.
                         */
                        if (applicationTable.insertEnabled) {
                            result.errors.push({
                                type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail`,
                                tableAlias: applicationTable.alias,
                                columnAlias: applicationColumn.columnAlias,
                            });
                        }
                        else {
                            result.warnings.push({
                                type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_GENERATED_ON_APPLICATION_ONLY_INSERT_DISABLED,
                                description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} is generated on application only; INSERTs will fail but INSERTs are disabled`,
                                tableAlias: applicationTable.alias,
                                columnAlias: applicationColumn.columnAlias,
                            });
                        }
                    }
                }
            }
            else {
                /**
                 * OK
                 */
            }
        }
        if (columnMeta.explicitDefaultValue != undefined) {
            if (applicationExplicitDefaultValue) {
                /**
                 * OK
                 */
            }
            else {
                /**
                 * It has an explicit default value on the database.
                 * But not on application code.
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` are fine; they just cannot use the default value.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                result.warnings.push({
                    type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_DATABASE_ONLY,
                    description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on database only`,
                    tableAlias: applicationTable.alias,
                    columnAlias: applicationColumn.columnAlias,
                    explicitDefaultValue: columnMeta.explicitDefaultValue,
                });
            }
        }
        else {
            if (applicationExplicitDefaultValue) {
                if (columnMeta.isNullable ||
                    columnMeta.isAutoIncrement ||
                    columnMeta.generationExpression != undefined) {
                    /**
                     * It **does not** have an explicit default value on the database.
                     * But it does, on application code.
                     *
                     * However, it does have other default/generated values on the database...
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` are fine; they will just use the other default/generated values on the database.
                     * + Attempts to `UPDATE` are fine.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    result.warnings.push({
                        type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_USING_DATABASE_GENERATED_OR_NULL_VALUE,
                        description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will use database generated or NULL value`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationColumn.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                    });
                }
                else {
                    /**
                     * It **does not** have an explicit default value on the database.
                     * But it does, on application code.
                     *
                     * There are also no other default/generated values on the database...
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail; there is no default/generated value on the database to use.
                     * + Attempts to `UPDATE` are fine.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    if (applicationTable.insertEnabled) {
                        result.errors.push({
                            type: schema_validation_error_1.SchemaValidationErrorType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                    else {
                        result.warnings.push({
                            type: schema_validation_warning_1.SchemaValidationWarningType.COLUMN_EXPLICIT_DEFAULT_VALUE_ON_APPLICATION_ONLY_INSERT_DISABLED,
                            description: `Column ${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_1.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} has explicit default value on application only; INSERTs will fail but INSERTs are disabled`,
                            tableAlias: applicationTable.alias,
                            columnAlias: applicationColumn.columnAlias,
                        });
                    }
                }
            }
            else {
                /**
                 * OK
                 */
            }
        }
        return result;
    }
    exports.validateColumn = validateColumn;
});
define("schema-validation/util/operation/validate-table", ["require", "exports", "schema-validation/schema-validation-error", "key/index", "schema-validation/schema-validation-warning", "schema-validation/util/operation/validate-column", "sqlstring/index"], function (require, exports, schema_validation_error_2, key_15, schema_validation_warning_2, validate_column_1, sqlstring_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function validateTable(applicationTable, tableMeta) {
        const result = {
            errors: [],
            warnings: [],
        };
        /**
         * Sanity check...
         */
        if (applicationTable.alias != tableMeta.tableAlias) {
            result.errors.push({
                type: schema_validation_error_2.SchemaValidationErrorType.TABLE_ALIAS_MISMATCH,
                description: `Application table is named ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}, database table is named ${sqlstring_2.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}`,
                applicationTableAlias: applicationTable.alias,
                databaseTableAlias: tableMeta.tableAlias,
            });
            return result;
        }
        /**
         * Primary key check
         */
        if (tableMeta.primaryKey == undefined) {
            if (applicationTable.primaryKey == undefined) {
                result.warnings.push({
                    type: schema_validation_warning_2.SchemaValidationWarningType.TABLE_HAS_NO_PRIMARY_KEY,
                    description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY`,
                    tableAlias: applicationTable.alias,
                });
            }
            else {
                result.errors.push({
                    type: schema_validation_error_2.SchemaValidationErrorType.PRIMARY_KEY_ON_APPLICATION_ONLY,
                    description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
                    tableAlias: applicationTable.alias,
                    primaryKey: [...applicationTable.primaryKey],
                });
            }
        }
        else {
            if (applicationTable.primaryKey == undefined) {
                result.warnings.push({
                    type: schema_validation_warning_2.SchemaValidationWarningType.PRIMARY_KEY_ON_DATABASE_ONLY,
                    description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
                    tableAlias: applicationTable.alias,
                    primaryKey: [...tableMeta.primaryKey.columnAliases],
                });
            }
            else {
                if (key_15.KeyUtil.isEqual(applicationTable.primaryKey, tableMeta.primaryKey.columnAliases)) {
                    //OK, no problems here
                }
                else {
                    result.errors.push({
                        type: schema_validation_error_2.SchemaValidationErrorType.PRIMARY_KEY_MISMATCH,
                        description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has PRIMARY KEY (${applicationTable.primaryKey.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on application, PRIMARY KEY (${tableMeta.primaryKey.columnAliases.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on database`,
                        tableAlias: applicationTable.alias,
                        applicationPrimaryKey: [...applicationTable.primaryKey],
                        databasePrimaryKey: [...tableMeta.primaryKey.columnAliases],
                    });
                }
            }
        }
        /**
         * Candidate keys check
         */
        const candidateKeysOnDatabaseOnly = tableMeta.candidateKeys.filter(candidateKeyMeta => {
            if (applicationTable.primaryKey != undefined &&
                key_15.KeyUtil.isEqual(applicationTable.primaryKey, candidateKeyMeta.columnAliases)) {
                return false;
            }
            const applicationCandidateKey = applicationTable.candidateKeys.find(applicationCandidateKey => {
                return key_15.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
            });
            return (applicationCandidateKey == undefined);
        });
        for (const candidateKey of candidateKeysOnDatabaseOnly) {
            result.warnings.push({
                type: schema_validation_warning_2.SchemaValidationWarningType.CANDIDATE_KEY_ON_DATABASE_ONLY,
                description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.columnAliases.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on database only`,
                tableAlias: applicationTable.alias,
                databaseCandidateKey: [...candidateKey.columnAliases],
            });
        }
        const candidateKeysOnApplicationOnly = applicationTable.candidateKeys.filter(applicationCandidateKey => {
            if (tableMeta.primaryKey != undefined &&
                key_15.KeyUtil.isEqual(tableMeta.primaryKey.columnAliases, applicationCandidateKey)) {
                return false;
            }
            const candidateKeyMeta = tableMeta.candidateKeys.find(candidateKeyMeta => {
                return key_15.KeyUtil.isEqual(applicationCandidateKey, candidateKeyMeta.columnAliases);
            });
            return (candidateKeyMeta == undefined);
        });
        for (const candidateKey of candidateKeysOnApplicationOnly) {
            result.errors.push({
                type: schema_validation_error_2.SchemaValidationErrorType.CANDIDATE_KEY_ON_APPLICATION_ONLY,
                description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has CANDIDATE KEY (${candidateKey.map(sqlstring_2.escapeIdentifierWithDoubleQuotes).join(", ")}) on application only`,
                tableAlias: applicationTable.alias,
                applicationCandidateKey: [...candidateKey],
            });
        }
        /**
         * Tables should really have a candidate key...
         */
        if (tableMeta.primaryKey == undefined && tableMeta.candidateKeys.length == 0) {
            result.errors.push({
                type: schema_validation_error_2.SchemaValidationErrorType.DATABASE_TABLE_HAS_NO_PRIMARY_OR_CANDIDATE_KEY,
                description: `Table ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} has no PRIMARY KEY or CANDIDATE KEY on database`,
                tableAlias: applicationTable.alias,
            });
        }
        /**
         * There should only be zero or one auto-increment column on tables.
         * We validate them here.
         */
        const autoIncrementColumnMeta = tableMeta.columns.find(columnMeta => columnMeta.isAutoIncrement);
        if (autoIncrementColumnMeta == undefined) {
            if (applicationTable.autoIncrement == undefined) {
                /**
                 * OK!
                 */
            }
            else {
                /**
                 * + The database has **no** auto-increment column.
                 * + The application has an auto-increment column.
                 *
                 * -----
                 *
                 * + Attempts to `SELECT` are fine.
                 * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
                 * + Attempts to `UPDATE` are fine.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression are fine.
                 */
                if (applicationTable.insertEnabled) {
                    result.errors.push({
                        type: schema_validation_error_2.SchemaValidationErrorType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_WILL_FAIL,
                        description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationTable.autoIncrement,
                    });
                }
                else {
                    result.warnings.push({
                        type: schema_validation_warning_2.SchemaValidationWarningType.AUTO_INCREMENT_ON_APPLICATION_ONLY_INSERT_DISABLED,
                        description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application only; INSERTs will fail but INSERTs are disabled`,
                        tableAlias: applicationTable.alias,
                        columnAlias: applicationTable.autoIncrement,
                    });
                }
            }
        }
        else {
            if (applicationTable.autoIncrement == undefined) {
                result.warnings.push({
                    type: schema_validation_warning_2.SchemaValidationWarningType.AUTO_INCREMENT_ON_DATABASE_ONLY,
                    description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} is auto-increment on database only`,
                    tableAlias: tableMeta.tableAlias,
                    columnAlias: autoIncrementColumnMeta.columnAlias,
                });
            }
            else {
                if (autoIncrementColumnMeta.columnAlias == applicationTable.autoIncrement) {
                    /**
                     * OK!
                     */
                }
                else {
                    /**
                     * The database and application disagree what the auto-increment column is.
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will fail because `.insertOne()` expects the auto-increment columns to be the same.
                     * + Attempts to `UPDATE` are fine.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression are fine.
                     */
                    if (applicationTable.insertEnabled) {
                        result.errors.push({
                            type: schema_validation_error_2.SchemaValidationErrorType.AUTO_INCREMENT_MISMATCH_INSERT_WILL_FAIL,
                            description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail`,
                            tableAlias: tableMeta.tableAlias,
                            databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                            applicationColumnAlias: applicationTable.autoIncrement,
                        });
                    }
                    else {
                        result.warnings.push({
                            type: schema_validation_warning_2.SchemaValidationWarningType.AUTO_INCREMENT_MISMATCH_INSERT_DISABLED,
                            description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.autoIncrement)} is auto-increment on application, ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(autoIncrementColumnMeta.columnAlias)} on database; INSERTs will fail but INSERTs are disabled`,
                            tableAlias: tableMeta.tableAlias,
                            databaseColumnAlias: autoIncrementColumnMeta.columnAlias,
                            applicationColumnAlias: applicationTable.autoIncrement,
                        });
                    }
                }
            }
        }
        /**
         * Validate columns
         */
        for (const columnMeta of tableMeta.columns) {
            const applicationColumn = applicationTable.columns[columnMeta.columnAlias];
            if (applicationColumn == undefined) {
                if (applicationTable.insertEnabled) {
                    if (
                    /**
                     * There's an implicit default/generated value
                     */
                    columnMeta.isNullable ||
                        columnMeta.isAutoIncrement ||
                        /**
                         * There's an explicit default/generated value
                         */
                        columnMeta.generationExpression != undefined ||
                        columnMeta.explicitDefaultValue != undefined) {
                        /**
                         * + Database has column
                         * + Application **does not** have column
                         * + Database column has default/generated value
                         * + `INSERT` is enabled
                         *
                         * -----
                         *
                         * + Attempts to `SELECT` are fine.
                         * + Attempts to `INSERT` are fine; will just use default/generated value on database.
                         * + Attempts to `UPDATE` will never happen; does not exist on application.
                         * + Attempts to `DELETE` are fine.
                         * + Attempts to use as expression will never happen; does not exist on application.
                         *
                         */
                        result.warnings.push({
                            type: schema_validation_warning_2.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_WITH_DEFAULT_OR_GENERATED_VALUE,
                            description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; but has a default or generated value`,
                            tableAlias: tableMeta.tableAlias,
                            databaseColumnAlias: columnMeta.columnAlias,
                            isNullable: columnMeta.isNullable,
                            isAutoIncrement: columnMeta.isAutoIncrement,
                            generationExpression: columnMeta.generationExpression,
                            explicitDefaultValue: columnMeta.explicitDefaultValue,
                            insertEnabled: applicationTable.insertEnabled,
                        });
                    }
                    else {
                        /**
                         * + Database has column
                         * + Application **does not** have column
                         * + Database column **does not** have default/generated value
                         * + `INSERT` is enabled
                         *
                         * -----
                         *
                         * + Attempts to `SELECT` are fine.
                         * + Attempts to `INSERT` will fail; does not exist on application, and no default/generated value on database.
                         * + Attempts to `UPDATE` will never happen; does not exist on application.
                         * + Attempts to `DELETE` are fine.
                         * + Attempts to use as expression will never happen; does not exist on application.
                         *
                         */
                        result.errors.push({
                            type: schema_validation_error_2.SchemaValidationErrorType.COLUMN_ON_DATABASE_ONLY_INSERT_WILL_FAIL,
                            description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs will fail`,
                            tableAlias: tableMeta.tableAlias,
                            databaseColumnAlias: columnMeta.columnAlias,
                            isNullable: columnMeta.isNullable,
                            isAutoIncrement: columnMeta.isAutoIncrement,
                            generationExpression: columnMeta.generationExpression,
                            explicitDefaultValue: columnMeta.explicitDefaultValue,
                            insertEnabled: applicationTable.insertEnabled,
                        });
                    }
                }
                else {
                    /**
                     * + Database has column
                     * + Application **does not** have column
                     * + `INSERT` is disabled
                     *
                     * -----
                     *
                     * + Attempts to `SELECT` are fine.
                     * + Attempts to `INSERT` will never happen; it is disabled.
                     * + Attempts to `UPDATE` will never happen; does not exist on application.
                     * + Attempts to `DELETE` are fine.
                     * + Attempts to use as expression will never happen; does not exist on application.
                     *
                     */
                    result.warnings.push({
                        type: schema_validation_warning_2.SchemaValidationWarningType.COLUMN_ON_DATABASE_ONLY_INSERT_DISABLED,
                        description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(columnMeta.columnAlias)} exists on database only; INSERTs may fail but INSERTs are disabled`,
                        tableAlias: tableMeta.tableAlias,
                        databaseColumnAlias: columnMeta.columnAlias,
                        isNullable: columnMeta.isNullable,
                        isAutoIncrement: columnMeta.isAutoIncrement,
                        generationExpression: columnMeta.generationExpression,
                        explicitDefaultValue: columnMeta.explicitDefaultValue,
                        insertEnabled: applicationTable.insertEnabled,
                    });
                }
            }
            else {
                const validateColumnResult = validate_column_1.validateColumn(applicationTable, applicationColumn, columnMeta);
                result.errors.push(...validateColumnResult.errors);
                result.warnings.push(...validateColumnResult.warnings);
            }
        }
        for (const columnAlias of Object.keys(applicationTable.columns)) {
            const applicationColumn = applicationTable.columns[columnAlias];
            const columnMeta = tableMeta.columns.find(columnMeta => columnMeta.columnAlias == columnAlias);
            if (columnMeta == undefined) {
                /**
                 *
                 * + Attempts to `SELECT` will fail.
                 * + Attempts to `INSERT` will fail.
                 * + Attempts to `UPDATE` will fail.
                 * + Attempts to `DELETE` are fine.
                 * + Attempts to use as expression will fail.
                 *
                 */
                result.errors.push({
                    type: schema_validation_error_2.SchemaValidationErrorType.COLUMN_ON_APPLICATION_ONLY,
                    description: `Column ${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationTable.alias)}.${sqlstring_2.escapeIdentifierWithDoubleQuotes(applicationColumn.columnAlias)} exists on application only`,
                    tableAlias: applicationTable.alias,
                    applicationColumnAlias: applicationColumn.columnAlias,
                });
            }
        }
        return result;
    }
    exports.validateTable = validateTable;
});
define("schema-validation/util/operation/validate-schema", ["require", "exports", "schema-validation/schema-validation-warning", "schema-validation/util/operation/validate-table", "schema-validation/schema-validation-error", "sqlstring/index"], function (require, exports, schema_validation_warning_3, validate_table_1, schema_validation_error_3, sqlstring_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function validateSchema(applicationTables, schemaMeta) {
        const result = {
            errors: [],
            warnings: [],
        };
        const tablesOnDatabaseOnly = schemaMeta.tables.filter(tableMeta => {
            const applicationTable = applicationTables.find(applicationTable => applicationTable.alias == tableMeta.tableAlias);
            return (applicationTable == undefined);
        });
        for (const tableMeta of tablesOnDatabaseOnly) {
            result.warnings.push({
                type: schema_validation_warning_3.SchemaValidationWarningType.TABLE_ON_DATABASE_ONLY,
                description: `Table ${sqlstring_3.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}.${sqlstring_3.escapeIdentifierWithDoubleQuotes(tableMeta.tableAlias)} exists on database only`,
                databaseTableAlias: tableMeta.tableAlias,
            });
        }
        const tablesOnApplicationOnly = applicationTables.filter(applicationTable => {
            const tableMeta = schemaMeta.tables.find(tableMeta => applicationTable.alias == tableMeta.tableAlias);
            return (tableMeta == undefined);
        });
        for (const applicationTable of tablesOnApplicationOnly) {
            result.errors.push({
                type: schema_validation_error_3.SchemaValidationErrorType.TABLE_ON_APPLICATION_ONLY,
                description: `Table ${sqlstring_3.escapeIdentifierWithDoubleQuotes(applicationTable.alias)} exists on application only; not found on schema ${sqlstring_3.escapeIdentifierWithDoubleQuotes(schemaMeta.schemaAlias)}`,
                applicationTableAlias: applicationTable.alias,
                databaseSchemaAlias: schemaMeta.schemaAlias,
            });
        }
        for (const applicationTable of applicationTables) {
            const tableMeta = schemaMeta.tables.find(tableMeta => tableMeta.tableAlias == applicationTable.alias);
            if (tableMeta == undefined) {
                continue;
            }
            const validateTableResult = validate_table_1.validateTable(applicationTable, tableMeta);
            result.errors.push(...validateTableResult.errors);
            result.warnings.push(...validateTableResult.warnings);
        }
        return result;
    }
    exports.validateSchema = validateSchema;
});
define("schema-validation/util/operation/index", ["require", "exports", "schema-validation/util/operation/validate-column", "schema-validation/util/operation/validate-schema", "schema-validation/util/operation/validate-table"], function (require, exports, validate_column_2, validate_schema_1, validate_table_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(validate_column_2);
    __export(validate_schema_1);
    __export(validate_table_2);
});
define("schema-validation/util/index", ["require", "exports", "schema-validation/util/operation/index"], function (require, exports, operation_38) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(operation_38);
});
define("schema-validation/index", ["require", "exports", "schema-validation/schema-validation-error", "schema-validation/schema-validation-warning", "schema-validation/util/index"], function (require, exports, schema_validation_error_4, schema_validation_warning_4, SchemaValidationUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(schema_validation_error_4);
    __export(schema_validation_warning_4);
    exports.SchemaValidationUtil = SchemaValidationUtil;
});
define("design-pattern-log/log", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-log/util/constructor/06-set-tracked-defaults", ["require", "exports", "design-pattern-log/log-impl", "custom-expr/index"], function (require, exports, log_impl_1, custom_expr_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setTrackedDefaults(log, rawTrackedDefaults) {
        const trackedDefaults = {};
        for (const columnAlias of log.tracked) {
            const customExpr = rawTrackedDefaults[columnAlias];
            if (customExpr === undefined) {
                continue;
            }
            const value = custom_expr_1.CustomExprUtil.mapNonCorrelated(log.logTable.columns[columnAlias], customExpr);
            trackedDefaults[columnAlias] = value;
        }
        const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, copyDefaultsDelegate, } = log;
        return new log_impl_1.Log({
            tracked,
            doNotCopy,
            copy,
            trackedWithDefaultValue: Object.keys(trackedDefaults),
            logTable,
            ownerTable,
            latestOrder,
        }, {
            copyDefaultsDelegate,
            trackedDefaults,
        });
    }
    exports.setTrackedDefaults = setTrackedDefaults;
    class LogMustSetTrackedDefaults {
        constructor(data) {
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
            this.latestOrder = data.latestOrder;
            this.tracked = data.tracked;
            this.doNotCopy = data.doNotCopy;
            this.copy = data.copy;
            this.copyDefaultsDelegate = data.copyDefaultsDelegate;
        }
        setTrackedDefaults(rawTrackedDefaults) {
            return setTrackedDefaults(this, rawTrackedDefaults);
        }
    }
    exports.LogMustSetTrackedDefaults = LogMustSetTrackedDefaults;
});
define("design-pattern-log/util/constructor/05-set-copy-defaults-delegate", ["require", "exports", "table/index", "primary-key/index", "custom-expr/index", "used-ref/index", "design-pattern-log/util/constructor/06-set-tracked-defaults", "data-type/index"], function (require, exports, table_36, primary_key_5, custom_expr_2, used_ref_36, _06_set_tracked_defaults_1, data_type_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setCopyDefaultsDelegate(log, rawCopyDefaultsDelegate) {
        /**
         * Nothing is allowed
         */
        const allowedRef = used_ref_36.UsedRefUtil.fromColumnRef({});
        const requiredColumnAliases = table_36.TableUtil.requiredColumnAlias(log.logTable)
            .filter(columnName => (log.copy.indexOf(columnName) >= 0));
        const optionalColumnAliases = table_36.TableUtil.optionalColumnAlias(log.logTable)
            .filter(columnName => (log.copy.indexOf(columnName) >= 0));
        const copyDefaults = async (args) => {
            const customExprResult = await rawCopyDefaultsDelegate({
                ...args,
                ownerPrimaryKey: primary_key_5.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, args.ownerPrimaryKey),
            });
            const valueExprResult = {};
            for (const columnAlias of requiredColumnAliases) {
                const customExpr = customExprResult[columnAlias];
                if (customExpr === undefined) {
                    throw new Error(`Expected a value for ${log.logTable.alias}.${columnAlias}`);
                }
                const usedRef = custom_expr_2.CustomExprUtil.usedRef(customExpr);
                used_ref_36.UsedRefUtil.assertAllowed(allowedRef, usedRef);
                valueExprResult[columnAlias] = await data_type_6.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
            }
            for (const columnAlias of optionalColumnAliases) {
                const customExpr = customExprResult[columnAlias];
                if (customExpr === undefined) {
                    continue;
                }
                const usedRef = custom_expr_2.CustomExprUtil.usedRef(customExpr);
                used_ref_36.UsedRefUtil.assertAllowed(allowedRef, usedRef);
                valueExprResult[columnAlias] = await data_type_6.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[columnAlias], args.connection, customExpr);
            }
            return valueExprResult;
        };
        const { logTable, ownerTable, latestOrder, tracked, doNotCopy, copy, } = log;
        return new _06_set_tracked_defaults_1.LogMustSetTrackedDefaults({
            logTable,
            ownerTable,
            latestOrder,
            tracked,
            doNotCopy,
            copy,
            copyDefaultsDelegate: copyDefaults,
        });
    }
    exports.setCopyDefaultsDelegate = setCopyDefaultsDelegate;
    class LogMustSetCopyDefaultsDelegate {
        constructor(data) {
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
            this.latestOrder = data.latestOrder;
            this.tracked = data.tracked;
            this.doNotCopy = data.doNotCopy;
            this.copy = data.copy;
        }
        setCopyDefaults(rawCopyDefaultsDelegate) {
            return setCopyDefaultsDelegate(this, rawCopyDefaultsDelegate);
        }
    }
    exports.LogMustSetCopyDefaultsDelegate = LogMustSetCopyDefaultsDelegate;
});
define("design-pattern-log/util/constructor/04-set-do-not-copy", ["require", "exports", "column-map/index", "column-identifier-map/index", "design-pattern-log/util/constructor/06-set-tracked-defaults", "design-pattern-log/util/constructor/05-set-copy-defaults-delegate"], function (require, exports, column_map_37, column_identifier_map_13, _06_set_tracked_defaults_2, _05_set_copy_defaults_delegate_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setDoNotCopy(log, delegate) {
        const columns = column_map_37.ColumnMapUtil.pick(log.logTable.columns, log.copy);
        const doNotCopy = delegate(columns);
        column_identifier_map_13.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(columns, doNotCopy);
        const { logTable, ownerTable, latestOrder, tracked, } = log;
        const copy = log.copy
            .filter((columnName) => {
            return !doNotCopy.some(c => c.columnAlias == columnName);
        });
        if (copy.length == 0) {
            const result = new _06_set_tracked_defaults_2.LogMustSetTrackedDefaults({
                logTable,
                ownerTable,
                latestOrder,
                tracked,
                doNotCopy: doNotCopy.map(c => c.columnAlias),
                copy,
                copyDefaultsDelegate: () => Promise.resolve({}),
            });
            return result;
        }
        else {
            const result = new _05_set_copy_defaults_delegate_1.LogMustSetCopyDefaultsDelegate({
                logTable,
                ownerTable,
                latestOrder,
                tracked,
                doNotCopy: doNotCopy.map(c => c.columnAlias),
                copy,
            });
            return result;
        }
    }
    exports.setDoNotCopy = setDoNotCopy;
    class LogMustSetDoNotCopy {
        constructor(data) {
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
            this.latestOrder = data.latestOrder;
            this.tracked = data.tracked;
            this.copy = data.copy;
        }
        setDoNotCopy(delegate) {
            return setDoNotCopy(this, delegate);
        }
    }
    exports.LogMustSetDoNotCopy = LogMustSetDoNotCopy;
});
define("design-pattern-log/util/constructor/03-set-tracked", ["require", "exports", "column/index", "column-map/index", "column-identifier-map/index", "design-pattern-log/util/constructor/04-set-do-not-copy"], function (require, exports, column_50, column_map_38, column_identifier_map_14, _04_set_do_not_copy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LogMustSetTracked {
        constructor(data) {
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
            this.latestOrder = data.latestOrder;
        }
        setTracked(trackedDelegate) {
            const trackedColumns = column_map_38.ColumnMapUtil.omit(this.logTable.columns, [
                ...this.ownerTable.primaryKey,
                ...this.logTable.generatedColumns,
                this.latestOrder[0].columnAlias,
            ]);
            const tracked = trackedDelegate(trackedColumns);
            column_identifier_map_14.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(trackedColumns, tracked);
            const invalidCopy = [
                ...this.ownerTable.primaryKey,
                ...this.logTable.generatedColumns,
                ...(this.logTable.autoIncrement == undefined ?
                    [] :
                    [this.logTable.autoIncrement]),
                this.latestOrder[0].columnAlias,
                ...tracked.map(column => column.columnAlias),
            ];
            const copy = column_50.ColumnArrayUtil.fromColumnMap(this.logTable.columns)
                .map(column => column.columnAlias)
                .filter(columnAlias => {
                return !invalidCopy.includes(columnAlias);
            });
            return new _04_set_do_not_copy_1.LogMustSetDoNotCopy({
                logTable: this.logTable,
                ownerTable: this.ownerTable,
                latestOrder: this.latestOrder,
                tracked: tracked.map(column => column.columnAlias),
                copy: copy,
            });
        }
    }
    exports.LogMustSetTracked = LogMustSetTracked;
});
define("design-pattern-log/util/constructor/02-set-latest-order", ["require", "exports", "key/index", "column-map/index", "column-identifier-map/index", "design-pattern-log/util/constructor/03-set-tracked"], function (require, exports, key_16, column_map_39, column_identifier_map_15, _03_set_tracked_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function latestOrderColumnAlias(data) {
        const { logTable, ownerTable } = data;
        const possibleColumnAliases = [
            ...logTable.explicitDefaultValueColumns,
            ...logTable.generatedColumns,
        ];
        const result = possibleColumnAliases.filter(columnAlias => key_16.KeyArrayUtil.hasKey(logTable.candidateKeys, [...ownerTable.primaryKey, columnAlias]));
        return result;
    }
    exports.latestOrderColumnAlias = latestOrderColumnAlias;
    class LogMustSetLatestOrder {
        constructor(data) {
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
        }
        setLatestOrder(latestOrderDelegate) {
            const latestOrderColumns = column_map_39.ColumnMapUtil.pick(this.logTable.columns, latestOrderColumnAlias(this));
            const latestOrder = latestOrderDelegate(latestOrderColumns);
            column_identifier_map_15.ColumnIdentifierMapUtil.assertHasColumnIdentifiers(latestOrderColumns, [latestOrder[0]]);
            return new _03_set_tracked_1.LogMustSetTracked({
                logTable: this.logTable,
                ownerTable: this.ownerTable,
                latestOrder,
            });
        }
    }
    exports.LogMustSetLatestOrder = LogMustSetLatestOrder;
});
define("design-pattern-log/util/constructor/01-set-owner", ["require", "exports", "design-pattern-log/util/constructor/02-set-latest-order"], function (require, exports, _02_set_latest_order_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LogMustSetOwner {
        constructor(data) {
            this.logTable = data.logTable;
        }
        setOwner(ownerTable) {
            return new _02_set_latest_order_1.LogMustSetLatestOrder({
                logTable: this.logTable,
                ownerTable,
            });
        }
    }
    exports.LogMustSetOwner = LogMustSetOwner;
});
define("design-pattern-log/util/constructor/00-log", ["require", "exports", "design-pattern-log/util/constructor/01-set-owner"], function (require, exports, _01_set_owner_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function log(logTable) {
        return new _01_set_owner_1.LogMustSetOwner({
            logTable,
        });
    }
    exports.log = log;
});
/*
import {table} from "../../../table";
import * as tm from "type-mapping";
import {KeyArrayUtil} from "../../../key";
import {Identity} from "../../../type-util";
import {from, requireOuterQueryJoins} from "../../../unified-query";
import {eqPrimaryKeyOfTable} from "../../../expr-library";

export const businessFile = table("businessFile")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessFileId : tm.mysql.bigIntSigned(),
        awsS3PresignedUploadId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
        fileTypeId : tm.mysql.bigIntSigned(),
        updatedAt : tm.mysql.dateTime(),
        updatedAt2 : tm.mysql.dateTime(),
        updatedByExternalUserId : tm.mysql.varChar().orNull(),
    })
    .setAutoIncrement(c => c.businessFileId)
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt,
    ])
    .addCandidateKey(c => [
        c.businessId,
        c.fileTypeId,
        c.updatedAt2,
    ])
    .addExplicitDefaultValue(c => [c.updatedAt])
    .addExplicitDefaultValue(c => [c.updatedAt2])
    .removeAllMutable();

export const businessFileType = table("businessFileType")
    .addColumns({
        businessId : tm.mysql.bigIntSigned(),
        businessTypeId : tm.mysql.bigIntSigned(),
        fileTypeId : tm.mysql.bigIntSigned(),
        createdAt : tm.mysql.dateTime(),
    })
    .setPrimaryKey(c => [c.businessId, c.fileTypeId])
    .addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

export const business = table("business")
    .addColumns({
        appId : tm.mysql.bigIntSigned(),
        businessId : tm.mysql.bigIntSigned(),
        externalUserId : tm.mysql.varChar(),
    })
    .setAutoIncrement(c => c.businessId)
    //.addExplicitDefaultValue(c => [c.createdAt])
    .removeAllMutable();

businessFile.candidateKeys
type ca = LatestOrderColumnAlias<typeof businessFile, typeof businessFileType>;
type cm = LatestOrderColumnMap<typeof businessFile, typeof businessFileType>;

const businessFileLog = log(
    {
        logTable : businessFile,
        ownerTable : businessFileType
    },
    columns => columns.updatedAt.desc(),
    columns => [columns.awsS3PresignedUploadId]
).setDoNotCopy(
    columns => [columns.updatedByExternalUserId]
).setCopyDefaults(({ownerPrimaryKey, connection}) => {
    return business.fetchOneByPrimaryKey(
        connection,
        ownerPrimaryKey,
        c => [c.appId, c.externalUserId]
    );
}).setTrackedDefaults({
    awsS3PresignedUploadId : 1n
});
businessFileLog.setDoNotCopy(columns => [])
*/
define("design-pattern-log/util/constructor/index", ["require", "exports", "design-pattern-log/util/constructor/00-log", "design-pattern-log/util/constructor/01-set-owner", "design-pattern-log/util/constructor/02-set-latest-order", "design-pattern-log/util/constructor/03-set-tracked", "design-pattern-log/util/constructor/04-set-do-not-copy", "design-pattern-log/util/constructor/05-set-copy-defaults-delegate", "design-pattern-log/util/constructor/06-set-tracked-defaults"], function (require, exports, _00_log_1, _01_set_owner_2, _02_set_latest_order_2, _03_set_tracked_2, _04_set_do_not_copy_2, _05_set_copy_defaults_delegate_2, _06_set_tracked_defaults_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(_00_log_1);
    __export(_01_set_owner_2);
    __export(_02_set_latest_order_2);
    __export(_03_set_tracked_2);
    __export(_04_set_do_not_copy_2);
    __export(_05_set_copy_defaults_delegate_2);
    __export(_06_set_tracked_defaults_3);
});
define("design-pattern-log/util/execution/exists", ["require", "exports", "unified-query/index", "primary-key/index", "expr-library/index"], function (require, exports, unified_query_10, primary_key_6, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function exists(log, connection, primaryKey) {
        primaryKey = primary_key_6.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
        return unified_query_10.QueryUtil.newInstance()
            .from(log.logTable)
            .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
            .exists(connection);
    }
    exports.exists = exists;
});
define("design-pattern-log/util/execution/fetch-default", ["require", "exports", "execution/index", "primary-key/index", "table/index", "expr-library/index", "unified-query/index", "key/index", "expr/index", "built-in-expr/index", "isolation-level"], function (require, exports, execution_7, primary_key_7, table_37, ExprLib, unified_query_11, key_17, expr_55, built_in_expr_65, isolation_level_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assertAllTrackedHasDefaultValue(log) {
        if (!key_17.KeyUtil.isEqual(log.tracked, log.trackedWithDefaultValue)) {
            throw new Error(`Not all tracked columns have a default value`);
        }
    }
    exports.assertAllTrackedHasDefaultValue = assertAllTrackedHasDefaultValue;
    async function fetchDefault(log, // & AssertAllTrackedHasDefaultValue<LogT>,
    connection, primaryKey) {
        //assertAllTrackedHasDefaultValue(log);
        primaryKey = primary_key_7.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
        return connection.readOnlyTransactionIfNotInOne(isolation_level_8.IsolationLevel.REPEATABLE_READ, async (connection) => {
            //If the owner does not exist, there is no default value
            await table_37.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
            const copyDefaults = await log.copyDefaultsDelegate({
                ownerPrimaryKey: primaryKey,
                connection,
            });
            const trackedColumnAliases = Object.keys(log.trackedDefaults);
            const selectClause = trackedColumnAliases.map((trackedColumnAlias) => {
                const rawExprNoUsedRef = log.trackedDefaults[trackedColumnAlias];
                return expr_55.ExprUtil.fromBuiltInExpr(built_in_expr_65.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], rawExprNoUsedRef)).as(trackedColumnAlias);
            });
            const trackedDefaults = await execution_7.ExecutionUtil.fetchOne(unified_query_11.QueryUtil.newInstance()
                .select(() => selectClause), connection);
            return {
                ...copyDefaults,
                ...trackedDefaults,
                ...primaryKey,
            };
        });
    }
    exports.fetchDefault = fetchDefault;
});
define("design-pattern-log/util/execution/latest-by-primary-key", ["require", "exports", "unified-query/index", "primary-key/index", "expr-library/index"], function (require, exports, unified_query_12, primary_key_8, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function latestByPrimaryKey(log, primaryKey) {
        primaryKey = primary_key_8.PrimaryKeyUtil.mapper(log.ownerTable)(`${log.ownerTable.alias} PRIMARY KEY`, primaryKey);
        return unified_query_12.QueryUtil.newInstance()
            .from(log.logTable)
            .where(() => ExprLib.eqColumns(log.logTable, primaryKey))
            .orderBy(() => [log.latestOrder])
            .limit(1);
    }
    exports.latestByPrimaryKey = latestByPrimaryKey;
});
define("design-pattern-log/util/execution/fetch-latest", ["require", "exports", "design-pattern-log/util/execution/latest-by-primary-key"], function (require, exports, latest_by_primary_key_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchLatest(log, connection, primaryKey) {
        const result = latest_by_primary_key_1.latestByPrimaryKey(log, primaryKey)
            .select(((columns) => [columns]))
            .fetchOne(connection);
        return result;
    }
    exports.fetchLatest = fetchLatest;
});
define("design-pattern-log/util/execution/fetch-latest-or-default", ["require", "exports", "design-pattern-log/util/execution/fetch-default", "design-pattern-log/util/execution/fetch-latest", "isolation-level"], function (require, exports, fetch_default_1, fetch_latest_1, isolation_level_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchLatestOrDefault(log, connection, primaryKey) {
        return connection.readOnlyTransactionIfNotInOne(isolation_level_9.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const latestOrUndefined = await fetch_latest_1.fetchLatest(log, connection, primaryKey).orUndefined();
            if (latestOrUndefined != undefined) {
                return {
                    isDefault: false,
                    row: latestOrUndefined,
                };
            }
            return fetch_default_1.fetchDefault(log, connection, primaryKey)
                .then((def) => {
                return {
                    isDefault: true,
                    row: def,
                };
            });
        });
    }
    exports.fetchLatestOrDefault = fetchLatestOrDefault;
});
define("design-pattern-log/util/execution/fetch-latest-value", ["require", "exports", "design-pattern-log/util/execution/latest-by-primary-key"], function (require, exports, latest_by_primary_key_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchLatestValue(log, connection, primaryKey, selectValueDelegate) {
        const result = latest_by_primary_key_2.latestByPrimaryKey(log, primaryKey)
            .selectValue(selectValueDelegate)
            .fetchValue(connection);
        return result;
    }
    exports.fetchLatestValue = fetchLatestValue;
});
define("design-pattern-log/util/execution/fetch-latest-value-or-default", ["require", "exports", "design-pattern-log/util/execution/fetch-latest-value", "column-map/index", "table/index", "expr-library/index", "column-identifier-map/index", "data-type/index", "isolation-level"], function (require, exports, fetch_latest_value_1, column_map_40, table_38, ExprLib, column_identifier_map_16, data_type_7, isolation_level_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function fetchLatestValueOrDefault(log, connection, primaryKey, selectValueDelegate) {
        const columns = column_map_40.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
        const column = selectValueDelegate(columns);
        column_identifier_map_16.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
        const latestValueOrUndefined = await fetch_latest_value_1.fetchLatestValue(log, connection, primaryKey, () => column).orUndefined();
        if (latestValueOrUndefined !== undefined) {
            return latestValueOrUndefined;
        }
        return connection.readOnlyTransactionIfNotInOne(isolation_level_10.IsolationLevel.REPEATABLE_READ, async (connection) => {
            //If the owner does not exist, there is no default value
            await table_38.TableUtil.assertExists(log.ownerTable, connection, () => ExprLib.eqPrimaryKey(log.ownerTable, primaryKey));
            return data_type_7.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[column.columnAlias], connection, log.trackedDefaults[column.columnAlias]);
        });
    }
    exports.fetchLatestValueOrDefault = fetchLatestValueOrDefault;
});
define("design-pattern-log/util/execution/track-result", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-log/util/execution/unsafe-track", ["require", "exports", "execution/index", "table/index", "design-pattern-log/util/execution/fetch-latest-or-default", "sqlstring/index", "data-type/index", "built-in-expr/index", "isolation-level"], function (require, exports, execution_8, table_39, fetch_latest_or_default_1, sqlstring_4, data_type_8, built_in_expr_66, isolation_level_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function toInsertRow(log, connection, prvRow, newRow) {
        const result = {};
        /**
         * Copy `prvRow`'s primary key
         */
        for (const primaryKeyColumnAlias of log.ownerTable.primaryKey) {
            const prvValueExpr = prvRow[primaryKeyColumnAlias];
            result[primaryKeyColumnAlias] = built_in_expr_66.BuiltInExprUtil.fromValueExpr(log.logTable.columns[primaryKeyColumnAlias], prvValueExpr);
        }
        /**
         * Copy all `tracked` values, if no new value is provided.
         */
        let changed = false;
        for (const trackedColumnAlias of log.tracked) {
            const newCustomExpr = newRow[trackedColumnAlias];
            const prvValueExpr = prvRow[trackedColumnAlias];
            if (newCustomExpr === undefined) {
                if (prvValueExpr === undefined) {
                    throw new Error(`No new or previous value for ${sqlstring_4.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_4.escapeIdentifierWithDoubleQuotes(trackedColumnAlias)} was found`);
                }
                else {
                    /**
                     * Use the previous value, since we don't have a new value.
                     */
                    result[trackedColumnAlias] = built_in_expr_66.BuiltInExprUtil.fromValueExpr(log.logTable.columns[trackedColumnAlias], prvValueExpr);
                }
            }
            else {
                const newValueExpr = await data_type_8.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[trackedColumnAlias], connection, newCustomExpr);
                result[trackedColumnAlias] = newValueExpr;
                if (!data_type_8.DataTypeUtil.isNullSafeEqual(log.logTable.columns[trackedColumnAlias].mapper, newValueExpr, prvValueExpr)) {
                    /**
                     * New value is used, we consider this a change.
                     */
                    changed = true;
                }
            }
        }
        /**
         * We expect new values for all required `doNotCopy` columns
         */
        for (const doNotCopyColumnAlias of log.doNotCopy) {
            const newCustomExpr = newRow[doNotCopyColumnAlias];
            if (newCustomExpr === undefined) {
                if (table_39.TableUtil.isRequiredColumnAlias(log.logTable, doNotCopyColumnAlias)) {
                    throw new Error(`Expected a new value for ${sqlstring_4.escapeIdentifierWithDoubleQuotes(log.logTable.alias)}.${sqlstring_4.escapeIdentifierWithDoubleQuotes(doNotCopyColumnAlias)}`);
                }
                else {
                    continue;
                }
            }
            const newValueExpr = await data_type_8.DataTypeUtil.evaluateCustomExpr(log.logTable.columns[doNotCopyColumnAlias], connection, newCustomExpr);
            result[doNotCopyColumnAlias] = newValueExpr;
        }
        /**
         * Copy the previous row's `copy`
         */
        for (const copyColumnAlias of log.copy) {
            const prvValueExpr = prvRow[copyColumnAlias];
            result[copyColumnAlias] = built_in_expr_66.BuiltInExprUtil.fromValueExpr(log.logTable.columns[copyColumnAlias], prvValueExpr);
        }
        return {
            changed,
            insertRow: result,
        };
    }
    /**
     * Allows `tracked` columns without default values to be unset.
     * However, this comes with the risk of run-time errors, if no previous row is found.
     */
    async function unsafeTrack(log, connection, primaryKey, unsafeTrackRow) {
        return connection.transactionIfNotInOne(isolation_level_11.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const latestOrDefault = await fetch_latest_or_default_1.fetchLatestOrDefault(log, connection, primaryKey);
            const { changed, insertRow } = await toInsertRow(log, connection, latestOrDefault.row, unsafeTrackRow);
            if (changed) {
                return {
                    changed,
                    previous: latestOrDefault,
                    current: await execution_8.ExecutionUtil.insertAndFetch(log.logTable, connection, insertRow),
                };
            }
            else {
                return {
                    changed,
                    previous: latestOrDefault,
                };
            }
        });
    }
    exports.unsafeTrack = unsafeTrack;
});
define("design-pattern-log/util/execution/track-or-insert", ["require", "exports", "design-pattern-log/util/execution/unsafe-track"], function (require, exports, unsafe_track_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function trackOrInsert(log, connection, primaryKey, trackOrInsertRow) {
        return unsafe_track_1.unsafeTrack(log, connection, primaryKey, trackOrInsertRow);
    }
    exports.trackOrInsert = trackOrInsert;
});
define("design-pattern-log/util/execution/track", ["require", "exports", "design-pattern-log/util/execution/fetch-default", "design-pattern-log/util/execution/unsafe-track"], function (require, exports, fetch_default_2, unsafe_track_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function track(log, connection, primaryKey, trackRow) {
        fetch_default_2.assertAllTrackedHasDefaultValue(log);
        return unsafe_track_2.unsafeTrack(log, connection, primaryKey, trackRow);
    }
    exports.track = track;
});
define("design-pattern-log/util/execution/index", ["require", "exports", "design-pattern-log/util/execution/exists", "design-pattern-log/util/execution/fetch-default", "design-pattern-log/util/execution/fetch-latest-or-default", "design-pattern-log/util/execution/fetch-latest-value-or-default", "design-pattern-log/util/execution/fetch-latest-value", "design-pattern-log/util/execution/fetch-latest", "design-pattern-log/util/execution/latest-by-primary-key", "design-pattern-log/util/execution/track-or-insert", "design-pattern-log/util/execution/track", "design-pattern-log/util/execution/unsafe-track"], function (require, exports, exists_4, fetch_default_3, fetch_latest_or_default_2, fetch_latest_value_or_default_1, fetch_latest_value_2, fetch_latest_2, latest_by_primary_key_3, track_or_insert_1, track_1, unsafe_track_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(exists_4);
    __export(fetch_default_3);
    __export(fetch_latest_or_default_2);
    __export(fetch_latest_value_or_default_1);
    __export(fetch_latest_value_2);
    __export(fetch_latest_2);
    __export(latest_by_primary_key_3);
    __export(track_or_insert_1);
    __export(track_1);
    __export(unsafe_track_3);
});
define("design-pattern-log/util/correlated-subquery/exists", ["require", "exports", "unified-query/index", "expr-library/index"], function (require, exports, unified_query_13, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function exists(log) {
        return ExprLib.exists(unified_query_13.QueryUtil.newInstance()
            .requireOuterQueryJoins(...[log.ownerTable])
            .from(log.logTable)
            .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable)));
    }
    exports.exists = exists;
});
define("design-pattern-log/util/correlated-subquery/latest", ["require", "exports", "unified-query/index", "expr-library/index"], function (require, exports, unified_query_14, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function latest(log) {
        return unified_query_14.QueryUtil.newInstance()
            .requireOuterQueryJoins(...[log.ownerTable])
            .from(log.logTable)
            .where(() => ExprLib.eqPrimaryKeyOfTable(log.logTable, log.ownerTable))
            .orderBy(() => [log.latestOrder])
            .limit(1);
    }
    exports.latest = latest;
});
define("design-pattern-log/util/correlated-subquery/latest-value-or-default", ["require", "exports", "type-mapping", "expr-library/index", "design-pattern-log/util/correlated-subquery/exists", "column-map/index", "column-identifier-map/index", "design-pattern-log/util/correlated-subquery/latest"], function (require, exports, tm, ExprLib, exists_5, column_map_41, column_identifier_map_17, latest_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function latestValueOrDefault(log, selectValueDelegate) {
        const columns = column_map_41.ColumnMapUtil.pick(log.logTable.columns, log.trackedWithDefaultValue);
        const column = selectValueDelegate(columns);
        column_identifier_map_17.ColumnIdentifierMapUtil.assertHasColumnIdentifier(columns, column);
        if (tm.canOutputNull(column.mapper)) {
            /**
             * It is possible for a row to exist but the value is `NULL`.
             * Especially when the column is nullable.
             */
            return ExprLib.if(exists_5.exists(log), latest_1.latest(log)
                .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
        }
        else {
            /**
             * Column is not nullable, we should never have `NULL`
             * unless it's because a row does not exist.
             */
            return ExprLib.coalesce(latest_1.latest(log)
                .selectValue(() => column), log.trackedDefaults[column.columnAlias]);
        }
    }
    exports.latestValueOrDefault = latestValueOrDefault;
});
define("design-pattern-log/util/correlated-subquery/latest-value", ["require", "exports", "design-pattern-log/util/correlated-subquery/latest", "expr/index"], function (require, exports, latest_2, expr_56) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function latestValue(log, selectValueDelegate) {
        return expr_56.ExprUtil.fromBuiltInExpr(latest_2.latest(log)
            .selectValue(selectValueDelegate));
    }
    exports.latestValue = latestValue;
});
define("design-pattern-log/util/correlated-subquery/index", ["require", "exports", "design-pattern-log/util/correlated-subquery/exists", "design-pattern-log/util/correlated-subquery/latest-value-or-default", "design-pattern-log/util/correlated-subquery/latest-value", "design-pattern-log/util/correlated-subquery/latest"], function (require, exports, exists_6, latest_value_or_default_1, latest_value_1, latest_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(exists_6);
    __export(latest_value_or_default_1);
    __export(latest_value_1);
    __export(latest_3);
});
define("design-pattern-log/util/index", ["require", "exports", "design-pattern-log/util/constructor/index", "design-pattern-log/util/execution/index", "design-pattern-log/util/correlated-subquery/index"], function (require, exports, constructor_26, execution_9, CorrelatedSubquery) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_26);
    __export(execution_9);
    exports.CorrelatedSubquery = CorrelatedSubquery;
});
define("design-pattern-log/log-impl", ["require", "exports", "design-pattern-log/util/index"], function (require, exports, LogUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Log {
        constructor(data, extraData) {
            /**
             * A collection of correlated subqueries/expressions,
             * these require the `ownerTable` to be in the `FROM` clause.
             */
            this.correlatedSubquery = {
                exists: () => {
                    return LogUtil.CorrelatedSubquery.exists(this);
                },
                latest: () => {
                    return LogUtil.CorrelatedSubquery.latest(this);
                },
                latestValue: (selectValueDelegate) => {
                    return LogUtil.CorrelatedSubquery.latestValue(this, selectValueDelegate);
                },
                latestValueOrDefault: (selectValueDelegate) => {
                    return LogUtil.CorrelatedSubquery.latestValueOrDefault(this, selectValueDelegate);
                },
            };
            this.tracked = data.tracked;
            this.doNotCopy = data.doNotCopy;
            this.copy = data.copy;
            this.trackedWithDefaultValue = data.trackedWithDefaultValue;
            this.logTable = data.logTable;
            this.ownerTable = data.ownerTable;
            this.latestOrder = data.latestOrder;
            this.copyDefaultsDelegate = extraData.copyDefaultsDelegate;
            this.trackedDefaults = extraData.trackedDefaults;
        }
        fetchDefault(connection, primaryKey) {
            return LogUtil.fetchDefault(this, connection, primaryKey);
        }
        fetchLatest(connection, primaryKey) {
            return LogUtil.fetchLatest(this, connection, primaryKey);
        }
        fetchLatestValue(connection, primaryKey, selectValueDelegate) {
            return LogUtil.fetchLatestValue(this, connection, primaryKey, selectValueDelegate);
        }
        /**
         * @todo Make this part of fluent API of `fetchLatest()`?
         */
        fetchLatestOrDefault(connection, primaryKey) {
            return LogUtil.fetchLatestOrDefault(this, connection, primaryKey);
        }
        fetchLatestValueOrDefault(connection, primaryKey, selectValueDelegate) {
            return LogUtil.fetchLatestValueOrDefault(this, connection, primaryKey, selectValueDelegate);
        }
        exists(connection, primaryKey) {
            return LogUtil.exists(this, connection, primaryKey);
        }
        trackOrInsert(connection, primaryKey, trackOrInsertRow) {
            return LogUtil.trackOrInsert(this, connection, primaryKey, trackOrInsertRow);
        }
        unsafeTrack(connection, primaryKey, unsafeTrackRow) {
            return LogUtil.unsafeTrack(this, connection, primaryKey, unsafeTrackRow);
        }
        track(connection, primaryKey, trackRow) {
            return LogUtil.track(this, connection, primaryKey, trackRow);
        }
    }
    exports.Log = Log;
});
define("design-pattern-log/index", ["require", "exports", "design-pattern-log/log-impl", "design-pattern-log/util/index", "design-pattern-log/util/index"], function (require, exports, log_impl_2, LogUtil, util_9) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(log_impl_2);
    exports.LogUtil = LogUtil;
    exports.log = util_9.log;
});
define("design-pattern-table-per-type/table-per-type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/query/column-alias", ["require", "exports", "table/index", "key/index", "column-map/index"], function (require, exports, table_40, key_18, column_map_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function columnAliases(tpt) {
        const result = table_40.TableUtil.columnAlias(tpt.childTable);
        for (const parentTable of tpt.parentTables) {
            result.push(...table_40.TableUtil.columnAlias(parentTable));
        }
        return key_18.KeyUtil.removeDuplicates(result);
    }
    exports.columnAliases = columnAliases;
    function isColumnAlias(tpt, columnAlias) {
        if (column_map_42.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
            return true;
        }
        for (const parentTable of tpt.parentTables) {
            if (column_map_42.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
                return true;
            }
        }
        return false;
    }
    exports.isColumnAlias = isColumnAlias;
});
define("design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias", ["require", "exports", "column-map/index"], function (require, exports, column_map_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractAllTablesWithColumnAlias(tpt, columnAlias) {
        const result = [];
        if (column_map_43.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
            result.push(tpt.childTable);
        }
        for (const parentTable of tpt.parentTables) {
            if (column_map_43.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
                result.push(parentTable);
            }
        }
        return result;
    }
    exports.extractAllTablesWithColumnAlias = extractAllTablesWithColumnAlias;
});
define("design-pattern-table-per-type/util/query/extract-table-with-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/query/column-type", ["require", "exports", "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias", "data-type/index"], function (require, exports, extract_all_tables_with_column_alias_1, data_type_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function columnMapper(tpt, columnAlias) {
        const mappers = extract_all_tables_with_column_alias_1.extractAllTablesWithColumnAlias(tpt, columnAlias)
            .map(table => table.columns[columnAlias].mapper);
        if (mappers.length == 0) {
            throw new Error(`Table-per-type hierarchy for ${tpt.childTable.alias} does not have column alias ${columnAlias}`);
        }
        if (mappers.length == 1) {
            return mappers[0];
        }
        let result = data_type_9.DataTypeUtil.intersect(mappers[0], mappers[1]);
        for (let i = 2; i < mappers.length; ++i) {
            result = data_type_9.DataTypeUtil.intersect(result, mappers[i]);
        }
        return result;
    }
    exports.columnMapper = columnMapper;
});
define("design-pattern-table-per-type/util/query/parent-column-alias", ["require", "exports", "table/index", "key/index", "column-map/index"], function (require, exports, table_41, key_19, column_map_44) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function parentColumnAliases(tpt) {
        const result = [];
        for (const parentTable of tpt.parentTables) {
            result.push(...table_41.TableUtil.columnAlias(parentTable));
        }
        return key_19.KeyUtil.removeDuplicates(result);
    }
    exports.parentColumnAliases = parentColumnAliases;
    function isParentColumnAlias(tpt, columnAlias) {
        for (const parentTable of tpt.parentTables) {
            if (column_map_44.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
                return true;
            }
        }
        return false;
    }
    exports.isParentColumnAlias = isParentColumnAlias;
});
define("design-pattern-table-per-type/util/query/extract-all-parent-tables-with-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/query/explicit-default-value-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/query/parent-column-alias", "column-map/index"], function (require, exports, column_alias_8, parent_column_alias_1, column_map_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isExplicitDefaultValueColumnAlias(tpt, columnAlias) {
        if (parent_column_alias_1.isParentColumnAlias(tpt, columnAlias)) {
            for (const parentTable of tpt.parentTables) {
                if (column_map_45.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
                    !parentTable.explicitDefaultValueColumns.includes(columnAlias)) {
                    return false;
                }
            }
            return true;
        }
        else {
            return tpt.childTable.explicitDefaultValueColumns.includes(columnAlias);
        }
    }
    exports.isExplicitDefaultValueColumnAlias = isExplicitDefaultValueColumnAlias;
    function explicitDefaultValueColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_8.columnAliases(tpt)) {
            if (isExplicitDefaultValueColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.explicitDefaultValueColumnAliases = explicitDefaultValueColumnAliases;
});
define("design-pattern-table-per-type/util/predicate/is-table-per-type", ["require", "exports", "type-util/index", "table/index"], function (require, exports, type_util_31, table_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Actually only checks if it has all the properties of `ITablePerType`.
     *
     * So, if it has all the properties but they're of the wrong data type...
     */
    function isTablePerType(mixed) {
        if (!type_util_31.isObjectWithOwnEnumerableKeys()(mixed, [
            "childTable",
            "parentTables",
            "autoIncrement",
            "explicitAutoIncrementValueEnabled",
            "insertAndFetchPrimaryKey",
            "joins"
        ])) {
            return false;
        }
        return (table_42.TableUtil.isTable(mixed.childTable) &&
            /**
             * Does not check if all elements are `ITable`
             */
            (mixed.parentTables instanceof Array) &&
            /**
             * Does not check if all elements are `string`
             */
            (mixed.autoIncrement instanceof Array) &&
            /**
             * Does not check if all elements are `string`
             */
            (mixed.explicitAutoIncrementValueEnabled instanceof Array) &&
            /**
             * Does not check if all elements are `string`
             */
            (mixed.insertAndFetchPrimaryKey instanceof Array) &&
            /**
             * Does not check if all elements are `string`
             */
            (mixed.joins instanceof Array));
    }
    exports.isTablePerType = isTablePerType;
});
define("design-pattern-table-per-type/util/predicate/index", ["require", "exports", "design-pattern-table-per-type/util/predicate/is-table-per-type"], function (require, exports, is_table_per_type_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(is_table_per_type_1);
});
define("design-pattern-table-per-type/util/query/extract-all-tables", ["require", "exports", "table/index", "design-pattern-table-per-type/util/predicate/index"], function (require, exports, table_43, predicate_65) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractAllTables(t) {
        if (predicate_65.isTablePerType(t)) {
            return [
                ...t.parentTables,
                t.childTable,
            ];
        }
        else if (table_43.TableUtil.isTable(t)) {
            return [t];
        }
        else {
            throw new Error(`Expected ITable or ITablePerType`);
        }
    }
    exports.extractAllTables = extractAllTables;
});
define("design-pattern-table-per-type/util/query/extract-auto-increment", ["require", "exports", "table/index", "design-pattern-table-per-type/util/predicate/index"], function (require, exports, table_44, predicate_66) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractAutoIncrement(t) {
        if (predicate_66.isTablePerType(t)) {
            return [...t.autoIncrement];
        }
        else if (table_44.TableUtil.isTable(t)) {
            return (t.autoIncrement == undefined ?
                [] :
                [t.autoIncrement]);
        }
        else {
            throw new Error(`Expected ITable or ITablePerType`);
        }
    }
    exports.extractAutoIncrement = extractAutoIncrement;
});
define("design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled", ["require", "exports", "table/index", "design-pattern-table-per-type/util/predicate/index"], function (require, exports, table_45, predicate_67) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractExplicitAutoIncrementValueEnabled(t) {
        if (predicate_67.isTablePerType(t)) {
            return [...t.explicitAutoIncrementValueEnabled];
        }
        else if (table_45.TableUtil.isTable(t)) {
            return (
            //eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            t.explicitAutoIncrementValueEnabled ?
                (t.autoIncrement == undefined ?
                    [] :
                    [t.autoIncrement]) :
                []);
        }
        else {
            throw new Error(`Expected ITable or ITablePerType`);
        }
    }
    exports.extractExplicitAutoIncrementValueEnabled = extractExplicitAutoIncrementValueEnabled;
});
define("design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key", ["require", "exports", "table/index", "design-pattern-table-per-type/util/predicate/index"], function (require, exports, table_46, predicate_68) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractInsertAndFetchPrimaryKey(t) {
        if (predicate_68.isTablePerType(t)) {
            return [...t.insertAndFetchPrimaryKey];
        }
        else if (table_46.TableUtil.isTable(t) && t.primaryKey != undefined) {
            return (t.autoIncrement == undefined ?
                t.primaryKey.filter(columnAlias => (!t.generatedColumns.includes(columnAlias) &&
                    t.autoIncrement != columnAlias)) :
                []);
        }
        else {
            throw new Error(`Expected TableWithPrimaryKey or ITablePerType`);
        }
    }
    exports.extractInsertAndFetchPrimaryKey = extractInsertAndFetchPrimaryKey;
});
define("design-pattern-table-per-type/util/query/extract-child-table", ["require", "exports", "table/index"], function (require, exports, table_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractChildTable(t) {
        if (table_47.TableUtil.isTable(t)) {
            return t;
        }
        else {
            return t.childTable;
        }
    }
    exports.extractChildTable = extractChildTable;
});
define("design-pattern-table-per-type/util/query/extract-column-alias", ["require", "exports", "table/index", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/predicate/index"], function (require, exports, table_48, column_alias_9, predicate_69) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractColumnAliases(t) {
        if (predicate_69.isTablePerType(t)) {
            return column_alias_9.columnAliases(t);
        }
        else if (table_48.TableUtil.isTable(t)) {
            return table_48.TableUtil.columnAlias(t);
        }
        else {
            throw new Error(`Expected ITable or ITablePerType`);
        }
    }
    exports.extractColumnAliases = extractColumnAliases;
});
define("design-pattern-table-per-type/util/query/extract-parent-tables", ["require", "exports", "table/index"], function (require, exports, table_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function extractParentTables(t) {
        if (table_49.TableUtil.isTable(t)) {
            return [];
        }
        else {
            return [...t.parentTables];
        }
    }
    exports.extractParentTables = extractParentTables;
});
define("design-pattern-table-per-type/util/query/find-last-join-to-table", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function findLastJoinToTable(tpt, toTableAlias) {
        for (let i = tpt.joins.length - 1; i >= 0; --i) {
            if (tpt.joins[i][1] == toTableAlias) {
                return tpt.joins[i];
            }
        }
        throw new Error(`No join to ${toTableAlias} exists in table-per-type hierarchy for ${tpt.childTable.alias}`);
    }
    exports.findLastJoinToTable = findLastJoinToTable;
});
define("design-pattern-table-per-type/util/query/find-table-with-column-alias", ["require", "exports", "column-map/index"], function (require, exports, column_map_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Goes up the inheritance hierarchy, starting from `childTable`,
     * to look for a table with `columnAlias` as a column
     */
    function findTableWithColumnAlias(tpt, columnAlias) {
        if (column_map_46.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias)) {
            return tpt.childTable;
        }
        for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
            const parentTable = tpt.parentTables[i];
            if (column_map_46.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias)) {
                return parentTable;
            }
        }
        throw new Error(`No column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
    }
    exports.findTableWithColumnAlias = findTableWithColumnAlias;
});
define("design-pattern-table-per-type/util/query/find-table-with-generated-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Goes up the inheritance hierarchy, starting from `childTable`,
     * to look for a table with `columnAlias` as a generated column
     */
    function findTableWithGeneratedColumnAlias(tpt, columnAlias) {
        if (tpt.childTable.generatedColumns.includes(columnAlias)) {
            return tpt.childTable;
        }
        for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
            const parentTable = tpt.parentTables[i];
            if (parentTable.generatedColumns.includes(columnAlias)) {
                return parentTable;
            }
        }
        throw new Error(`No generated column ${columnAlias} in table-per-type hierarchy for ${tpt.childTable.alias}`);
    }
    exports.findTableWithGeneratedColumnAlias = findTableWithGeneratedColumnAlias;
});
define("design-pattern-table-per-type/util/query/generated-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias"], function (require, exports, column_alias_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isGeneratedColumnAlias(tpt, columnAlias) {
        if (tpt.childTable.generatedColumns.includes(columnAlias)) {
            return true;
        }
        for (const parentTable of tpt.parentTables) {
            if (parentTable.generatedColumns.includes(columnAlias)) {
                return true;
            }
        }
        return false;
    }
    exports.isGeneratedColumnAlias = isGeneratedColumnAlias;
    function generatedColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_10.columnAliases(tpt)) {
            if (isGeneratedColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.generatedColumnAliases = generatedColumnAliases;
});
define("design-pattern-table-per-type/util/query/implicit-auto-increment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function implicitAutoIncrement(tpt) {
        return tpt.autoIncrement.filter(columnAlias => {
            return !tpt.explicitAutoIncrementValueEnabled.includes(columnAlias);
        });
    }
    exports.implicitAutoIncrement = implicitAutoIncrement;
});
define("design-pattern-table-per-type/util/query/insertable-column-alias", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/query/mutable-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias", "column-map/index"], function (require, exports, column_alias_11, column_map_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMutableColumnAlias(tpt, columnAlias) {
        if (column_map_47.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
            !tpt.childTable.mutableColumns.includes(columnAlias)) {
            return false;
        }
        for (const parentTable of tpt.parentTables) {
            if (column_map_47.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
                !parentTable.mutableColumns.includes(columnAlias)) {
                return false;
            }
        }
        return column_alias_11.isColumnAlias(tpt, columnAlias);
    }
    exports.isMutableColumnAlias = isMutableColumnAlias;
    function mutableColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_11.columnAliases(tpt)) {
            if (isMutableColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.mutableColumnAliases = mutableColumnAliases;
});
define("design-pattern-table-per-type/util/query/non-generated-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/query/generated-column-alias"], function (require, exports, column_alias_12, generated_column_alias_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function nonGeneratedColumnAliases(tpt) {
        const generated = generated_column_alias_1.generatedColumnAliases(tpt);
        const result = column_alias_12.columnAliases(tpt)
            .filter(columnAlias => {
            return !generated.includes(columnAlias);
        });
        return result;
    }
    exports.nonGeneratedColumnAliases = nonGeneratedColumnAliases;
});
define("design-pattern-table-per-type/util/query/nullable-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias", "column-map/index"], function (require, exports, column_alias_13, column_map_48) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNullableColumnAlias(tpt, columnAlias) {
        if (column_map_48.ColumnMapUtil.hasColumnAlias(tpt.childTable.columns, columnAlias) &&
            !tpt.childTable.nullableColumns.includes(columnAlias)) {
            return false;
        }
        for (const parentTable of tpt.parentTables) {
            if (column_map_48.ColumnMapUtil.hasColumnAlias(parentTable.columns, columnAlias) &&
                !parentTable.nullableColumns.includes(columnAlias)) {
                return false;
            }
        }
        return column_alias_13.isColumnAlias(tpt, columnAlias);
    }
    exports.isNullableColumnAlias = isNullableColumnAlias;
    function nullableColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_13.columnAliases(tpt)) {
            if (isNullableColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.nullableColumnAliases = nullableColumnAliases;
});
define("design-pattern-table-per-type/util/query/optional-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/explicit-default-value-column-alias", "design-pattern-table-per-type/util/query/nullable-column-alias", "design-pattern-table-per-type/util/query/generated-column-alias", "design-pattern-table-per-type/util/query/column-alias"], function (require, exports, explicit_default_value_column_alias_1, nullable_column_alias_3, generated_column_alias_2, column_alias_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isOptionalColumnAlias(tpt, columnAlias) {
        return (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
            ((nullable_column_alias_3.isNullableColumnAlias(tpt, columnAlias) ||
                explicit_default_value_column_alias_1.isExplicitDefaultValueColumnAlias(tpt, columnAlias)) &&
                !generated_column_alias_2.isGeneratedColumnAlias(tpt, columnAlias)));
    }
    exports.isOptionalColumnAlias = isOptionalColumnAlias;
    function optionalColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_14.columnAliases(tpt)) {
            if (isOptionalColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.optionalColumnAliases = optionalColumnAliases;
});
define("design-pattern-table-per-type/util/query/primary-key-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias"], function (require, exports, column_alias_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isPrimaryColumnAlias(tpt, columnAlias) {
        if (tpt.childTable.primaryKey.includes(columnAlias)) {
            return true;
        }
        for (const parentTable of tpt.parentTables) {
            if (parentTable.primaryKey.includes(columnAlias)) {
                return true;
            }
        }
        return false;
    }
    exports.isPrimaryColumnAlias = isPrimaryColumnAlias;
    function primaryKeyColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_15.columnAliases(tpt)) {
            if (isPrimaryColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.primaryKeyColumnAliases = primaryKeyColumnAliases;
});
define("design-pattern-table-per-type/util/query/required-column-alias", ["require", "exports", "design-pattern-table-per-type/util/query/explicit-default-value-column-alias", "design-pattern-table-per-type/util/query/nullable-column-alias", "design-pattern-table-per-type/util/query/generated-column-alias", "design-pattern-table-per-type/util/query/column-alias"], function (require, exports, explicit_default_value_column_alias_2, nullable_column_alias_4, generated_column_alias_3, column_alias_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isRequiredColumnAlias(tpt, columnAlias) {
        return (column_alias_16.isColumnAlias(tpt, columnAlias) &&
            !(generated_column_alias_3.isGeneratedColumnAlias(tpt, columnAlias) ||
                nullable_column_alias_4.isNullableColumnAlias(tpt, columnAlias) ||
                explicit_default_value_column_alias_2.isExplicitDefaultValueColumnAlias(tpt, columnAlias) ||
                tpt.autoIncrement.includes(columnAlias)));
    }
    exports.isRequiredColumnAlias = isRequiredColumnAlias;
    function requiredColumnAliases(tpt) {
        const result = [];
        for (const columnAlias of column_alias_16.columnAliases(tpt)) {
            if (isRequiredColumnAlias(tpt, columnAlias)) {
                result.push(columnAlias);
            }
        }
        return result;
    }
    exports.requiredColumnAliases = requiredColumnAliases;
});
define("design-pattern-table-per-type/util/query/row", ["require", "exports", "type-mapping", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/query/column-type"], function (require, exports, tm, column_alias_17, column_type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function rowMapper(tpt) {
        const result = tm.objectFromArray(...column_alias_17.columnAliases(tpt)
            .map(columnAlias => tm.withName(column_type_1.columnMapper(tpt, columnAlias), columnAlias)));
        return result;
    }
    exports.rowMapper = rowMapper;
});
define("design-pattern-table-per-type/util/query/super-key-mapper", ["require", "exports", "type-mapping", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/query/column-type"], function (require, exports, tm, column_alias_18, column_type_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey) {
        const result = tm.objectFromArray(...column_alias_18.columnAliases(tpt).map(columnAlias => {
            const mapper = tm.withName(column_type_2.columnMapper(tpt, columnAlias), columnAlias);
            if (candidateKey.includes(columnAlias)) {
                return mapper;
            }
            else {
                return tm.optional(mapper);
            }
        }));
        return result;
    }
    function superKeyMapper(tpt) {
        const arr = tpt.childTable.candidateKeys.map(candidateKey => {
            return superKeyMapper_FromCandidateKeyImpl(tpt, candidateKey);
        });
        return tm.unsafeOr(...arr);
    }
    exports.superKeyMapper = superKeyMapper;
});
define("design-pattern-table-per-type/util/query/index", ["require", "exports", "design-pattern-table-per-type/util/query/column-alias", "design-pattern-table-per-type/util/query/column-type", "design-pattern-table-per-type/util/query/explicit-default-value-column-alias", "design-pattern-table-per-type/util/query/extract-all-tables-with-column-alias", "design-pattern-table-per-type/util/query/extract-all-tables", "design-pattern-table-per-type/util/query/extract-auto-increment", "design-pattern-table-per-type/util/query/extract-explicit-auto-increment-value-enabled", "design-pattern-table-per-type/util/query/extract-insert-and-fetch-primary-key", "design-pattern-table-per-type/util/query/extract-child-table", "design-pattern-table-per-type/util/query/extract-column-alias", "design-pattern-table-per-type/util/query/extract-parent-tables", "design-pattern-table-per-type/util/query/find-last-join-to-table", "design-pattern-table-per-type/util/query/find-table-with-column-alias", "design-pattern-table-per-type/util/query/find-table-with-generated-column-alias", "design-pattern-table-per-type/util/query/generated-column-alias", "design-pattern-table-per-type/util/query/implicit-auto-increment", "design-pattern-table-per-type/util/query/mutable-column-alias", "design-pattern-table-per-type/util/query/non-generated-column-alias", "design-pattern-table-per-type/util/query/nullable-column-alias", "design-pattern-table-per-type/util/query/optional-column-alias", "design-pattern-table-per-type/util/query/parent-column-alias", "design-pattern-table-per-type/util/query/primary-key-column-alias", "design-pattern-table-per-type/util/query/required-column-alias", "design-pattern-table-per-type/util/query/row", "design-pattern-table-per-type/util/query/super-key-mapper"], function (require, exports, column_alias_19, column_type_3, explicit_default_value_column_alias_3, extract_all_tables_with_column_alias_2, extract_all_tables_1, extract_auto_increment_1, extract_explicit_auto_increment_value_enabled_1, extract_insert_and_fetch_primary_key_1, extract_child_table_1, extract_column_alias_1, extract_parent_tables_1, find_last_join_to_table_1, find_table_with_column_alias_1, find_table_with_generated_column_alias_1, generated_column_alias_4, implicit_auto_increment_1, mutable_column_alias_1, non_generated_column_alias_1, nullable_column_alias_5, optional_column_alias_2, parent_column_alias_2, primary_key_column_alias_1, required_column_alias_2, row_1, super_key_mapper_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(column_alias_19);
    __export(column_type_3);
    __export(explicit_default_value_column_alias_3);
    __export(extract_all_tables_with_column_alias_2);
    __export(extract_all_tables_1);
    __export(extract_auto_increment_1);
    __export(extract_explicit_auto_increment_value_enabled_1);
    __export(extract_insert_and_fetch_primary_key_1);
    //export * from "./extract-child-column-alias";
    __export(extract_child_table_1);
    __export(extract_column_alias_1);
    //export * from "./extract-parent-column-alias";
    __export(extract_parent_tables_1);
    __export(find_last_join_to_table_1);
    __export(find_table_with_column_alias_1);
    __export(find_table_with_generated_column_alias_1);
    __export(generated_column_alias_4);
    __export(implicit_auto_increment_1);
    __export(mutable_column_alias_1);
    __export(non_generated_column_alias_1);
    __export(nullable_column_alias_5);
    __export(optional_column_alias_2);
    __export(parent_column_alias_2);
    __export(primary_key_column_alias_1);
    __export(required_column_alias_2);
    __export(row_1);
    __export(super_key_mapper_1);
});
define("design-pattern-table-per-type/util/constructor/table-per-type", ["require", "exports", "design-pattern-table-per-type/table-per-type-impl", "design-pattern-table-per-type/util/query/index"], function (require, exports, table_per_type_impl_1, query_52) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tablePerType(childTable) {
        return new table_per_type_impl_1.TablePerType({
            childTable,
            parentTables: [],
            autoIncrement: query_52.extractAutoIncrement(childTable),
            explicitAutoIncrementValueEnabled: query_52.extractExplicitAutoIncrementValueEnabled(childTable),
            insertAndFetchPrimaryKey: query_52.extractInsertAndFetchPrimaryKey(childTable),
        }, []);
    }
    exports.tablePerType = tablePerType;
});
define("design-pattern-table-per-type/util/constructor/index", ["require", "exports", "design-pattern-table-per-type/util/constructor/table-per-type"], function (require, exports, table_per_type_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(table_per_type_1);
});
define("design-pattern-table-per-type/util/execution/assignment-map", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/execution-impl/absorb-row", ["require", "exports", "built-in-expr/index", "data-type/index"], function (require, exports, built_in_expr_67, data_type_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @todo Better name
     *
     * Adds properties from `row` to `result`.
     *
     * If a property from `row` already exists on `result`,
     * we use `table` to check if the values on both objects are equal.
     *
     * If they are not equal, an `Error` is thrown.
     */
    function absorbRow(result, table, row) {
        for (const columnAlias of Object.keys(row)) {
            /**
             * This is guaranteed to be a value expression.
             */
            const newValue = row[columnAlias];
            if (Object.prototype.hasOwnProperty.call(result, columnAlias)) {
                /**
                 * This `curValue` could be a non-value expression.
                 * We only want value expressions.
                 */
                const curValue = result[columnAlias];
                if (built_in_expr_67.BuiltInExprUtil.isAnyNonValueExpr(curValue)) {
                    /**
                     * Add this new value to the `result`
                     * so we can use it to update rows of tables
                     * further down the inheritance hierarchy.
                     */
                    result[columnAlias] = newValue;
                    continue;
                }
                if (curValue === newValue) {
                    /**
                     * They are equal, do nothing.
                     */
                    continue;
                }
                /**
                 * We need some custom equality checking logic
                 */
                if (!data_type_10.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], 
                /**
                 * This may throw
                 */
                table.columns[columnAlias].mapper(`${table.alias}.${columnAlias}`, curValue), newValue)) {
                    /**
                     * @todo Custom `Error` type
                     */
                    throw new Error(`All columns with the same name in an inheritance hierarchy must have the same value; mismatch found for ${table.alias}.${columnAlias}`);
                }
            }
            else {
                /**
                 * Add this new value to the `result`
                 * so we can use it to update rows of tables
                 * further down the inheritance hierarchy.
                 */
                result[columnAlias] = newValue;
            }
        }
    }
    exports.absorbRow = absorbRow;
});
define("design-pattern-table-per-type/util/execution-impl/from", ["require", "exports", "unified-query/index", "design-pattern-table-per-type/util/query/index"], function (require, exports, unified_query_15, query_53) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is used to implement a more efficient `fetchOne` operation.
     *
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    function from(tpt) {
        if (tpt.parentTables.length == 0) {
            return unified_query_15.QueryUtil.newInstance()
                .from(tpt.childTable);
        }
        let query = unified_query_15.QueryUtil.newInstance()
            .from(tpt.childTable);
        /**
         * We are iterating **backwards**.
         * This is intentional.
         */
        for (let i = tpt.parentTables.length - 1; i >= 0; --i) {
            const parent = tpt.parentTables[i];
            const [fromTableAlias,] = query_53.findLastJoinToTable(tpt, parent.alias);
            query = unified_query_15.QueryUtil.innerJoinUsingPrimaryKey(query, src => src[fromTableAlias], parent);
        }
        return query;
    }
    exports.from = from;
});
define("design-pattern-table-per-type/util/execution-impl/assert-exists-impl", ["require", "exports", "execution/index", "design-pattern-table-per-type/util/execution-impl/from"], function (require, exports, execution_10, from_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function assertExistsImpl(tpt, connection, whereDelegate) {
        return execution_10.ExecutionUtil.assertExists(from_3.from(tpt)
            .where(whereDelegate), connection);
    }
    exports.assertExistsImpl = assertExistsImpl;
});
define("design-pattern-table-per-type/util/execution-impl/delete-one-impl", ["require", "exports", "type-mapping", "execution/index", "design-pattern-table-per-type/util/query/index", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, tm, execution_11, query_54, ExprLib, execution_impl_1, isolation_level_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteOneImpl(tpt, connection, whereDelegate) {
        /**
         * @todo Add `assertDeletable()` or something
         */
        /**
         * Using `SERIALIZABLE` because it's possible for a different transaction to
         * `UPDATE` primary key values between the `fetchOne()` and multiple `deleteOne()` calls.
         */
        return connection.transactionIfNotInOne(isolation_level_12.IsolationLevel.SERIALIZABLE, async (connection) => {
            return connection.savepoint(async (connection) => {
                const primaryKeys = await execution_11.ExecutionUtil.fetchOne(execution_impl_1.from(tpt)
                    .where(whereDelegate)
                    .select(() => query_54.primaryKeyColumnAliases(tpt).map(columnAlias => {
                    const table = query_54.findTableWithColumnAlias(tpt, columnAlias);
                    return table.columns[columnAlias];
                })), connection);
                const deleteChildResult = await execution_11.ExecutionUtil.deleteOne(tpt.childTable, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKeys));
                const deleteOneResults = [
                    {
                        ...deleteChildResult,
                        table: tpt.childTable,
                    },
                ];
                let deletedRowCount = deleteChildResult.deletedRowCount;
                let warningCount = deleteChildResult.warningCount;
                /**
                 * We use `.reverse()` here to `DELETE` the parents
                 * as we go up the inheritance hierarchy.
                 */
                for (const parentTable of [...tpt.parentTables].reverse()) {
                    const deleteParentResult = await execution_11.ExecutionUtil.deleteOne(parentTable, connection, () => ExprLib.eqPrimaryKey(parentTable, primaryKeys));
                    deleteOneResults.push({
                        ...deleteParentResult,
                        table: parentTable,
                    });
                    deletedRowCount = tm.BigIntUtil.add(deletedRowCount, deleteParentResult.deletedRowCount);
                    warningCount = tm.BigIntUtil.add(warningCount, deleteParentResult.warningCount);
                }
                return {
                    deleteOneResults,
                    deletedRowCount,
                    warningCount,
                };
            });
        });
    }
    exports.deleteOneImpl = deleteOneImpl;
});
define("design-pattern-table-per-type/util/execution-impl/exists-impl", ["require", "exports", "execution/index", "design-pattern-table-per-type/util/execution-impl/from"], function (require, exports, execution_12, from_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function existsImpl(tpt, connection, whereDelegate) {
        return execution_12.ExecutionUtil.existsImpl(from_4.from(tpt)
            .where(whereDelegate), connection);
    }
    exports.existsImpl = existsImpl;
});
define("design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl", ["require", "exports", "type-mapping", "design-pattern-table-per-type/util/execution-impl/delete-one-impl", "design-pattern-table-per-type/util/execution-impl/exists-impl", "isolation-level"], function (require, exports, tm, delete_one_impl_1, exists_impl_2, isolation_level_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteZeroOrOneImpl(tpt, connection, whereDelegate) {
        /**
         * @todo Add `assertDeletable()` or something
         */
        /**
         * `SERIALIZABLE` because it uses `deleteOneImpl()`, which uses `SERIALIZABLE`
         */
        return connection.transactionIfNotInOne(isolation_level_13.IsolationLevel.SERIALIZABLE, async (connection) => {
            const existsResult = await exists_impl_2.existsImpl(tpt, connection, whereDelegate);
            if (!existsResult.exists) {
                return {
                    /**
                     * Used as a discriminant.
                     */
                    deleteOneResults: undefined,
                    query: { sql: existsResult.sql },
                    //Alias for affectedRows
                    deletedRowCount: tm.BigInt(0),
                    /**
                     * @todo MySQL sometimes gives a `warningCount` value `> 0` for
                     * `DELETE` statements. Recall why.
                     */
                    warningCount: tm.BigInt(0),
                    /**
                     * An arbitrary message.
                     * May be an empty string.
                     */
                    message: "",
                };
            }
            return delete_one_impl_1.deleteOneImpl(tpt, connection, whereDelegate);
        });
    }
    exports.deleteZeroOrOneImpl = deleteZeroOrOneImpl;
});
define("design-pattern-table-per-type/util/execution-impl/fetch-one-impl", ["require", "exports", "execution/util/operation/impl/index", "unified-query/index", "design-pattern-table-per-type/util/query/index", "design-pattern-table-per-type/util/execution-impl/from", "data-type/index"], function (require, exports, ExecutionImpl, unified_query_16, query_55, from_5, data_type_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function cleanFetchedRow(tpt, rawRow) {
        const cleanRow = {};
        for (const columnAlias of query_55.columnAliases(tpt)) {
            const tables = query_55.extractAllTablesWithColumnAlias(tpt, columnAlias);
            for (let i = 0; i < tables.length; ++i) {
                const table = tables[i];
                const value = rawRow[table.alias][columnAlias];
                for (let j = i + 1; j < tables.length; ++j) {
                    const otherTable = tables[j];
                    const otherValue = rawRow[otherTable.alias][columnAlias];
                    if (!data_type_11.DataTypeUtil.isNullSafeEqual(table.columns[columnAlias], value, 
                    /**
                     * This may throw
                     */
                    table.columns[columnAlias].mapper(`(${otherTable.alias}->${table.alias}).${columnAlias}`, otherValue))) {
                        /**
                         * @todo Custom Error type
                         */
                        throw new Error(`Expected ${table.alias}.${columnAlias} and ${otherTable.alias}.${columnAlias} to have the same value`);
                    }
                    if (!data_type_11.DataTypeUtil.isNullSafeEqual(otherTable.columns[columnAlias], otherValue, 
                    /**
                     * This may throw
                     */
                    otherTable.columns[columnAlias].mapper(`(${table.alias}->${otherTable.alias}).${columnAlias}`, value))) {
                        /**
                         * @todo Custom Error type
                         */
                        throw new Error(`Expected ${otherTable.alias}.${columnAlias} and ${table.alias}.${columnAlias} to have the same value`);
                    }
                }
            }
            //If we are here, then it doesn't matter which value of `columnAlias` we use.
            cleanRow[columnAlias] = rawRow[tables[0].alias][columnAlias];
        }
        return cleanRow;
    }
    /**
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    function fetchOneImpl(tpt, connection, whereDelegate) {
        try {
            if (tpt.parentTables.length == 0) {
                return ExecutionImpl.fetchOneImpl(unified_query_16.QueryUtil.newInstance()
                    .from(tpt.childTable)
                    .where(whereDelegate)
                    .select(columns => [columns]), connection);
            }
            const query = from_5.from(tpt)
                .where(whereDelegate)
                .select(columns => [columns]);
            const limitedQuery = ExecutionImpl.trySetLimit2(query);
            const fetchLimit2Promise = ExecutionImpl.fetchAllImpl(limitedQuery, connection);
            const result = fetchLimit2Promise.then((fetched) => {
                const rawRow = ExecutionImpl.ensureOne(limitedQuery, fetched);
                return {
                    sql: fetched.sql,
                    row: cleanFetchedRow(tpt, rawRow),
                };
            });
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return fetchLimit2Promise
                    .then((fetched) => {
                    const rawRowOrDefaultValue = ExecutionImpl.ensureOneOr(limitedQuery, fetched, defaultValue);
                    return {
                        sql: fetched.sql,
                        row: (rawRowOrDefaultValue === defaultValue ?
                            defaultValue :
                            cleanFetchedRow(tpt, rawRowOrDefaultValue)),
                    };
                });
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result.or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchOneImpl = fetchOneImpl;
});
define("design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate", ["require", "exports", "execution/index", "column-ref/index", "column/index", "design-pattern-table-per-type/util/execution-impl/index", "design-pattern-table-per-type/util/query/index", "built-in-expr/index", "expr/index", "data-type/index"], function (require, exports, execution_13, column_ref_27, column_51, execution_impl_2, query_56, built_in_expr_68, expr_57, data_type_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally.
     *
     * @todo Better name
     */
    async function invokeAssignmentDelegate(tpt, connection, whereDelegate, assignmentMapDelegate) {
        const columns = column_ref_27.ColumnRefUtil.fromColumnArray(column_51.ColumnArrayUtil.fromColumnMapArray([
            tpt.childTable.columns,
            ...tpt.parentTables.map(parentTable => parentTable.columns)
        ]));
        /**
         * May contain extra properties that are not mutable columns,
         * or even columns at all.
         */
        const rawAssignmentMap = assignmentMapDelegate(columns);
        const columnAliasArr = Object.keys(rawAssignmentMap);
        if (columnAliasArr.length == 0) {
            /**
             * @todo Perform an exists check, if the row does not exist,
             * throw rowNotFound, for early-exit.
             *
             * At the moment, this isn't so important because we have
             * other methods downstream that will throw it.
             */
            return {};
        }
        const query = execution_impl_2.from(tpt)
            .where(whereDelegate)
            .select(() => columnAliasArr
            .filter(columnAlias => query_56.isMutableColumnAlias(tpt, columnAlias))
            .map(columnAlias => {
            const customExpr = rawAssignmentMap[columnAlias];
            if (built_in_expr_68.BuiltInExprUtil.isAnyNonValueExpr(customExpr)) {
                /**
                 * We have a non-value expression
                 */
                return expr_57.expr({
                    mapper: data_type_12.DataTypeUtil.intersect(query_56.columnMapper(tpt, columnAlias), built_in_expr_68.BuiltInExprUtil.mapper(customExpr)),
                    usedRef: built_in_expr_68.BuiltInExprUtil.usedRef(customExpr),
                    isAggregate: built_in_expr_68.BuiltInExprUtil.isAggregate(customExpr),
                }, built_in_expr_68.BuiltInExprUtil.buildAst(customExpr)).as(columnAlias);
            }
            else {
                /**
                 * We have a value expression
                 */
                return expr_57.ExprUtil.fromRawExprNoUsedRefInput(query_56.columnMapper(tpt, columnAlias), customExpr).as(columnAlias);
            }
        }));
        /**
         * Should only contain value expressions now.
         */
        return execution_13.ExecutionUtil.fetchOne(query, connection);
    }
    exports.invokeAssignmentDelegate = invokeAssignmentDelegate;
});
define("design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl", ["require", "exports", "type-mapping", "type-util/index", "execution/index", "design-pattern-table-per-type/util/execution-impl/absorb-row", "isolation-level"], function (require, exports, tm, type_util_32, execution_14, absorb_row_1, isolation_level_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Not meant to be called externally.
     *
     * **DOES NOT** use savepoints, internally.
     * You **SHOULD** use savepoints before calling this function.
     */
    async function updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult) {
        return connection.transactionIfNotInOne(isolation_level_14.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const updateOneResults = [
                {
                    ...updateAndFetchChildResult,
                    table: tpt.childTable,
                },
            ];
            let updatedRowCount = updateAndFetchChildResult.updatedRowCount;
            let warningCount = updateAndFetchChildResult.warningCount;
            const result = updateAndFetchChildResult.row;
            /**
             * We use `.reverse()` here to `UPDATE` the parents
             * as we go up the inheritance hierarchy.
             */
            for (const parentTable of [...tpt.parentTables].reverse()) {
                const updateAndFetchParentResult = await execution_14.ExecutionUtil.updateAndFetchOneByPrimaryKey(parentTable, connection, 
                /**
                 * The `result` should contain the primary key values we are interested in
                 */
                result, () => type_util_32.pickOwnEnumerable(cleanedAssignmentMap, parentTable.mutableColumns));
                updateOneResults.push({
                    ...updateAndFetchParentResult,
                    table: parentTable,
                });
                updatedRowCount = tm.BigIntUtil.add(updatedRowCount, updateAndFetchParentResult.updatedRowCount);
                warningCount = tm.BigIntUtil.add(warningCount, updateAndFetchParentResult.warningCount);
                absorb_row_1.absorbRow(result, parentTable, updateAndFetchParentResult.row);
            }
            return {
                updateOneResults,
                /**
                 * +1 for the `childTable`.
                 */
                foundRowCount: tm.BigInt(tpt.parentTables.length + 1),
                updatedRowCount,
                warningCount,
                row: result,
            };
        });
    }
    exports.updateAndFetchOneImpl = updateAndFetchOneImpl;
});
define("design-pattern-table-per-type/util/execution-impl/index", ["require", "exports", "design-pattern-table-per-type/util/execution-impl/absorb-row", "design-pattern-table-per-type/util/execution-impl/assert-exists-impl", "design-pattern-table-per-type/util/execution-impl/delete-one-impl", "design-pattern-table-per-type/util/execution-impl/delete-zero-or-one-impl", "design-pattern-table-per-type/util/execution-impl/exists-impl", "design-pattern-table-per-type/util/execution-impl/fetch-one-impl", "design-pattern-table-per-type/util/execution-impl/from", "design-pattern-table-per-type/util/execution-impl/invoke-assignment-delegate", "design-pattern-table-per-type/util/execution-impl/update-and-fetch-one-impl"], function (require, exports, absorb_row_2, assert_exists_impl_1, delete_one_impl_2, delete_zero_or_one_impl_1, exists_impl_3, fetch_one_impl_3, from_6, invoke_assignment_delegate_1, update_and_fetch_one_impl_6) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(absorb_row_2);
    __export(assert_exists_impl_1);
    __export(delete_one_impl_2);
    __export(delete_zero_or_one_impl_1);
    __export(exists_impl_3);
    __export(fetch_one_impl_3);
    __export(from_6);
    __export(invoke_assignment_delegate_1);
    __export(update_and_fetch_one_impl_6);
});
define("design-pattern-table-per-type/util/execution/delete-one-by-candidate-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index"], function (require, exports, ExprLib, execution_impl_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteOneByCandidateKey(tpt, connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return execution_impl_3.deleteOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
    }
    exports.deleteOneByCandidateKey = deleteOneByCandidateKey;
});
define("design-pattern-table-per-type/util/execution/delete-one-by-primary-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index"], function (require, exports, ExprLib, execution_impl_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteOneByPrimaryKey(tpt, connection, primaryKey) {
        return execution_impl_4.deleteOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
    }
    exports.deleteOneByPrimaryKey = deleteOneByPrimaryKey;
});
define("design-pattern-table-per-type/util/operation/remove-duplicate-parents", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeDuplicateParents(arr) {
        const result = [];
        for (const parentTable of arr) {
            /**
             * @todo Add `.schemaName` property?
             * When checking `.alias` only, it may think a different
             * table from a different schema is the same table.
             */
            if (result.find(r => r.alias == parentTable.alias) != undefined) {
                continue;
            }
            result.push(parentTable);
        }
        return result;
    }
    exports.removeDuplicateParents = removeDuplicateParents;
});
define("design-pattern-table-per-type/util/operation/add-parent", ["require", "exports", "table/index", "design-pattern-table-per-type/util/query/index", "design-pattern-table-per-type/table-per-type-impl", "design-pattern-table-per-type/util/operation/remove-duplicate-parents", "design-pattern-table-per-type/util/predicate/index", "key/index"], function (require, exports, table_50, query_57, table_per_type_impl_2, remove_duplicate_parents_1, predicate_70, key_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addParent_AutoIncrement(tpt, parent) {
        const parentColumnAliases = query_57.extractColumnAliases(parent);
        return key_20.KeyUtil.removeDuplicates([
            ...query_57.extractAutoIncrement(parent),
            ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
        ]);
    }
    function addParent_ExplicitAutoIncrementValueEnabled(tpt, parent) {
        const parentColumnAliases = query_57.extractColumnAliases(parent);
        return key_20.KeyUtil.removeDuplicates([
            ...query_57.extractExplicitAutoIncrementValueEnabled(parent).filter(columnAlias => (tpt.explicitAutoIncrementValueEnabled.includes(columnAlias) ||
                !tpt.autoIncrement.includes(columnAlias))),
            ...tpt.explicitAutoIncrementValueEnabled.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
        ]);
    }
    function addParent_InsertAndFetchPrimaryKey(tpt, parent) {
        const parentColumnAliases = query_57.extractColumnAliases(parent);
        return key_20.KeyUtil.removeDuplicates([
            ...query_57.extractInsertAndFetchPrimaryKey(parent),
            ...tpt.autoIncrement.filter(columnAlias => !parentColumnAliases.includes(columnAlias)),
        ]);
    }
    /**
     * @todo Check that a column is not both auto-increment and generated at the same time
     *
     * @todo Check that `tpt.childTable` can join to `parent.childTable` using `parent.childTable`'s primary key
     *
     * @todo Check that columns have compatible types; must be assigble from child to parent
     *       Example: child.type = "red"|"blue", parent.type = "red"|"blue"|"green"
     *
     * @todo Check that inheritance is not circular
     *       Example: `Animal` cannot be a child of `Animal`.
     *       Example: This is invalid: `Dog extends Animal extends Mammal extends Dog`
     */
    function addParent(tpt, parent) {
        let joins = undefined;
        if (table_50.TableUtil.isTable(parent)) {
            joins = [
                [
                    tpt.childTable.alias,
                    parent.alias,
                ],
                ...tpt.joins,
            ];
        }
        else if (predicate_70.isTablePerType(parent)) {
            joins = [
                ...parent.joins,
                [
                    tpt.childTable.alias,
                    parent.childTable.alias,
                ],
                ...tpt.joins,
            ];
        }
        else {
            throw new Error(`Expected ITable or ITablePerType for parent`);
        }
        return new table_per_type_impl_2.TablePerType({
            childTable: tpt.childTable,
            parentTables: remove_duplicate_parents_1.removeDuplicateParents([
                ...query_57.extractAllTables(parent),
                ...tpt.parentTables,
            ]),
            autoIncrement: addParent_AutoIncrement(tpt, parent),
            explicitAutoIncrementValueEnabled: addParent_ExplicitAutoIncrementValueEnabled(tpt, parent),
            insertAndFetchPrimaryKey: addParent_InsertAndFetchPrimaryKey(tpt, parent),
        }, joins);
    }
    exports.addParent = addParent;
});
define("design-pattern-table-per-type/util/operation/eq-super-key", ["require", "exports", "design-pattern-table-per-type/util/query/index", "expr-library/index", "built-in-expr/index"], function (require, exports, query_58, ExprLib, built_in_expr_69) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqSuperKey = ((tpt, superKeyInput) => {
        const superKey = query_58.superKeyMapper(tpt)(`${tpt.childTable}.superKey`, superKeyInput);
        const arr = Object.keys(superKey)
            .filter((columnAlias) => {
            return superKey[columnAlias] !== undefined;
        })
            /**
             * We `.sort()` the keys so our resulting SQL is deterministic,
             * regardless of how `superKey` was constructed.
             */
            .sort()
            .map((columnAlias) => {
            const table = query_58.findTableWithColumnAlias(tpt, columnAlias);
            const expr = ExprLib.nullSafeEq(table.columns[columnAlias], built_in_expr_69.BuiltInExprUtil.fromValueExpr(table.columns[columnAlias], superKey[columnAlias]));
            return expr;
        });
        const result = ExprLib.and(...arr);
        return result;
    });
});
define("design-pattern-table-per-type/util/operation/index", ["require", "exports", "design-pattern-table-per-type/util/operation/add-parent", "design-pattern-table-per-type/util/operation/eq-super-key", "design-pattern-table-per-type/util/operation/remove-duplicate-parents"], function (require, exports, add_parent_1, eq_super_key_2, remove_duplicate_parents_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(add_parent_1);
    __export(eq_super_key_2);
    __export(remove_duplicate_parents_2);
});
define("design-pattern-table-per-type/util/execution/delete-one-by-super-key", ["require", "exports", "design-pattern-table-per-type/util/execution-impl/index", "design-pattern-table-per-type/util/operation/index"], function (require, exports, execution_impl_5, operation_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteOneBySuperKey(tpt, connection, superKey) {
        return execution_impl_5.deleteOneImpl(tpt, connection, () => operation_39.eqSuperKey(tpt, superKey));
    }
    exports.deleteOneBySuperKey = deleteOneBySuperKey;
});
define("design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index"], function (require, exports, ExprLib, execution_impl_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteZeroOrOneByCandidateKey(tpt, connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey) {
        return execution_impl_6.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
    }
    exports.deleteZeroOrOneByCandidateKey = deleteZeroOrOneByCandidateKey;
});
define("design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index"], function (require, exports, ExprLib, execution_impl_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteZeroOrOneByPrimaryKey(tpt, connection, primaryKey) {
        return execution_impl_7.deleteZeroOrOneImpl(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
    }
    exports.deleteZeroOrOneByPrimaryKey = deleteZeroOrOneByPrimaryKey;
});
define("design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key", ["require", "exports", "design-pattern-table-per-type/util/execution-impl/index", "design-pattern-table-per-type/util/operation/index"], function (require, exports, execution_impl_8, operation_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function deleteZeroOrOneBySuperKey(tpt, connection, superKey) {
        return execution_impl_8.deleteZeroOrOneImpl(tpt, connection, () => operation_40.eqSuperKey(tpt, superKey));
    }
    exports.deleteZeroOrOneBySuperKey = deleteZeroOrOneBySuperKey;
});
define("design-pattern-table-per-type/util/execution/fetch-one", ["require", "exports", "design-pattern-table-per-type/util/execution-impl/index"], function (require, exports, execution_impl_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * + Assumes `parentTables` has no duplicates.
     * + Assumes `childTable` is not in `parentTables`.
     * + Assumes any shared `columnAlias` between tables **must** have the same value.
     * + Assumes `joins` represents a valid inheritance graph.
     */
    function fetchOne(tpt, connection, whereDelegate) {
        try {
            const p = execution_impl_9.fetchOneImpl(tpt, connection, whereDelegate);
            const result = p.then(({ row }) => row);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = (defaultValue) => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return p.or(defaultValue).then(({ row }) => row);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                return result
                    .or(undefined);
            };
            return result;
        }
        catch (err) {
            const result = Promise.reject(err);
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.or = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            //eslint-disable-next-line @typescript-eslint/unbound-method
            result.orUndefined = () => {
                //To avoid `unhandled rejection` warnings
                result.catch(() => { });
                return Promise.reject(err);
            };
            return result;
        }
    }
    exports.fetchOne = fetchOne;
});
define("design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution/fetch-one"], function (require, exports, ExprLib, fetch_one_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOneByCandidateKey(tpt, connection, candidateKey) {
        return fetch_one_3.fetchOne(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey));
    }
    exports.fetchOneByCandidateKey = fetchOneByCandidateKey;
});
define("design-pattern-table-per-type/util/execution/fetch-one-by-primary-key", ["require", "exports", "expr-library/index", "design-pattern-table-per-type/util/execution/fetch-one"], function (require, exports, ExprLib, fetch_one_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOneByPrimaryKey(tpt, connection, primaryKey) {
        return fetch_one_4.fetchOne(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey));
    }
    exports.fetchOneByPrimaryKey = fetchOneByPrimaryKey;
});
define("design-pattern-table-per-type/util/execution/fetch-one-by-super-key", ["require", "exports", "design-pattern-table-per-type/util/execution/fetch-one", "design-pattern-table-per-type/util/operation/index"], function (require, exports, fetch_one_5, operation_41) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function fetchOneBySuperKey(tpt, connection, superKey) {
        return fetch_one_5.fetchOne(tpt, connection, () => operation_41.eqSuperKey(tpt, superKey));
    }
    exports.fetchOneBySuperKey = fetchOneBySuperKey;
});
define("design-pattern-table-per-type/util/execution/insert-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("design-pattern-table-per-type/util/execution/insert-and-fetch", ["require", "exports", "execution/index", "type-util/index", "design-pattern-table-per-type/util/query/index", "table/index", "expr/index", "used-ref/index", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, execution_15, type_util_33, query_59, table_51, expr_58, used_ref_37, execution_impl_10, isolation_level_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Assumes there are no duplicate `parentTables`.
     *
     * `.addParent()` should remove duplicates.
     */
    async function insertAndFetch(tpt, connection, insertRow) {
        /**
         * @todo Add `assertInsertable()` or something
         */
        return connection.transactionIfNotInOne(isolation_level_15.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const generated = query_59.generatedColumnAliases(tpt);
                const result = type_util_33.omitOwnEnumerable(insertRow, [
                    /**
                     * We omit implicit auto-increment values because we do not
                     * want them to be set by users of the library.
                     */
                    ...query_59.implicitAutoIncrement(tpt),
                    /**
                     * We omit generated values because users can't set them, anyway.
                     */
                    ...generated,
                ]);
                for (const columnAlias of generated) {
                    const table = query_59.findTableWithGeneratedColumnAlias(tpt, columnAlias);
                    const sqlString = await connection.tryFetchGeneratedColumnExpression(table_51.TableUtil.tryGetSchemaName(table), table.alias, columnAlias);
                    if (sqlString == undefined) {
                        throw new Error(`Generated column ${table.alias}.${columnAlias} should have generation expression`);
                    }
                    result[columnAlias] = expr_58.expr({
                        mapper: table.columns[columnAlias].mapper,
                        usedRef: used_ref_37.UsedRefUtil.fromColumnRef({}),
                        /**
                         * `GENERATED` columns should not have aggregate expressions.
                         */
                        isAggregate: false,
                    }, 
                    /**
                     * This `sqlString` is not allowed to reference any columns.
                     * If it does, there is a very high chance that it will cause an error.
                     *
                     * @todo Find use case where we need to allow this to reference columns.
                     */
                    sqlString);
                }
                for (const table of [...tpt.parentTables, tpt.childTable]) {
                    const fetchedRow = await execution_15.ExecutionUtil.insertAndFetch(
                    /**
                     * We use `InsertAndFetchOptions`, instead of creating
                     * a new table instance because we want events to use the
                     * original `table` instance.
                     *
                     * `event.isFor()` methods use `===` internally
                     */
                    table, connection, result, {
                        /**
                         * We want to allow explicit auto-increment values internally,
                         * so that the same value is used for all tables of the same
                         * inheritance hierarchy.
                         */
                        explicitAutoIncrementValueEnabled: true,
                    });
                    execution_impl_10.absorbRow(result, table, fetchedRow);
                }
                return result;
            });
        });
    }
    exports.insertAndFetch = insertAndFetch;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key", ["require", "exports", "type-util/index", "execution/index", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, type_util_34, execution_16, ExprLib, execution_impl_11, isolation_level_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchOneByCandidateKey(tpt, connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_16.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const cleanedAssignmentMap = await execution_impl_11.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqCandidateKey(tpt.childTable, candidateKey), assignmentMapDelegate);
                /**
                 * @todo If `result` contains any primaryKey values,
                 * then we will need to fetch the **current** primaryKey values,
                 * before any `UPDATE` statements are executed.
                 *
                 * This function breaks if we try to update values
                 * of columns that are foreign keys.
                 *
                 * I do not want to disable foreign key checks.
                 */
                const updateAndFetchChildResult = await execution_16.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, candidateKey, () => type_util_34.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
                return execution_impl_11.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
            });
        });
    }
    exports.updateAndFetchOneByCandidateKey = updateAndFetchOneByCandidateKey;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key", ["require", "exports", "type-util/index", "execution/index", "expr-library/index", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, type_util_35, execution_17, ExprLib, execution_impl_12, isolation_level_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_17.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const cleanedAssignmentMap = await execution_impl_12.invokeAssignmentDelegate(tpt, connection, () => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey), assignmentMapDelegate);
                /**
                 * @todo If `result` contains any primaryKey values,
                 * then we will need to fetch the **current** primaryKey values,
                 * before any `UPDATE` statements are executed.
                 *
                 * This function breaks if we try to update values
                 * of columns that are foreign keys.
                 *
                 * I do not want to disable foreign key checks.
                 */
                const updateAndFetchChildResult = await execution_17.ExecutionUtil.updateAndFetchOneByPrimaryKey(tpt.childTable, connection, primaryKey, () => type_util_35.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
                return execution_impl_12.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
            });
        });
    }
    exports.updateAndFetchOneByPrimaryKey = updateAndFetchOneByPrimaryKey;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key", ["require", "exports", "type-util/index", "execution/index", "design-pattern-table-per-type/util/operation/index", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, type_util_36, execution_18, operation_42, execution_impl_13, isolation_level_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_18.IsolationLevel.REPEATABLE_READ, async (connection) => {
            return connection.savepoint(async (connection) => {
                const cleanedAssignmentMap = await execution_impl_13.invokeAssignmentDelegate(tpt, connection, () => operation_42.eqSuperKey(tpt, superKey), assignmentMapDelegate);
                /**
                 * @todo If `result` contains any primaryKey values,
                 * then we will need to fetch the **current** primaryKey values,
                 * before any `UPDATE` statements are executed.
                 *
                 * This function breaks if we try to update values
                 * of columns that are foreign keys.
                 *
                 * I do not want to disable foreign key checks.
                 */
                const updateAndFetchChildResult = await execution_18.ExecutionUtil.updateAndFetchOneByCandidateKey(tpt.childTable, connection, 
                /**
                 * We have already used the `superKey` to "clean" our assignment map.
                 * So, we can be reasonably sure that the `superKey` itself
                 * refers to exactly one row that exists.
                 *
                 * Now, we can pretend this `superKey` is a `candidateKey`,
                 * discarding all non-key columns.
                 *
                 * This should not introduce any bugs.
                 */
                superKey, () => type_util_36.pickOwnEnumerable(cleanedAssignmentMap, tpt.childTable.mutableColumns));
                return execution_impl_13.updateAndFetchOneImpl(tpt, connection, cleanedAssignmentMap, updateAndFetchChildResult);
            });
        });
    }
    exports.updateAndFetchOneBySuperKey = updateAndFetchOneBySuperKey;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key", ["require", "exports", "type-mapping", "execution/index", "expr-library/index", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key", "unified-query/index", "isolation-level"], function (require, exports, tm, execution_19, ExprLib, update_and_fetch_one_by_candidate_key_4, unified_query_17, isolation_level_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneByCandidateKey(tpt, connection, 
    /**
     * @todo Try and recall why I wanted `AssertNonUnion<>`
     * I didn't write compile-time tests for it...
     */
    candidateKey, // & AssertNonUnion<CandidateKeyT>,
    assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_19.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const existsResult = await execution_19.ExecutionUtil.existsImpl(unified_query_17.QueryUtil.newInstance()
                .from(tpt.childTable)
                .where(() => ExprLib.eqCandidateKey(tpt.childTable, candidateKey)), connection);
            if (!existsResult.exists) {
                return {
                    query: {
                        sql: existsResult.sql,
                    },
                    //Alias for affectedRows
                    foundRowCount: tm.BigInt(0),
                    //Alias for changedRows
                    updatedRowCount: tm.BigInt(0),
                    /**
                     * May be the duplicate row count, or some other value.
                     */
                    warningCount: tm.BigInt(0),
                    /**
                     * An arbitrary message.
                     * May be an empty string.
                     */
                    message: "",
                    row: undefined,
                };
            }
            return update_and_fetch_one_by_candidate_key_4.updateAndFetchOneByCandidateKey(tpt, connection, candidateKey, assignmentMapDelegate);
        });
    }
    exports.updateAndFetchZeroOrOneByCandidateKey = updateAndFetchZeroOrOneByCandidateKey;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key", ["require", "exports", "type-mapping", "execution/index", "expr-library/index", "unified-query/index", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key", "isolation-level"], function (require, exports, tm, execution_20, ExprLib, unified_query_18, update_and_fetch_one_by_primary_key_3, isolation_level_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_20.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const existsResult = await execution_20.ExecutionUtil.existsImpl(unified_query_18.QueryUtil.newInstance()
                .from(tpt.childTable)
                .where(() => ExprLib.eqPrimaryKey(tpt.childTable, primaryKey)), connection);
            if (!existsResult.exists) {
                return {
                    query: {
                        sql: existsResult.sql,
                    },
                    //Alias for affectedRows
                    foundRowCount: tm.BigInt(0),
                    //Alias for changedRows
                    updatedRowCount: tm.BigInt(0),
                    /**
                     * May be the duplicate row count, or some other value.
                     */
                    warningCount: tm.BigInt(0),
                    /**
                     * An arbitrary message.
                     * May be an empty string.
                     */
                    message: "",
                    row: undefined,
                };
            }
            return update_and_fetch_one_by_primary_key_3.updateAndFetchOneByPrimaryKey(tpt, connection, primaryKey, assignmentMapDelegate);
        });
    }
    exports.updateAndFetchZeroOrOneByPrimaryKey = updateAndFetchZeroOrOneByPrimaryKey;
});
define("design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key", ["require", "exports", "type-mapping", "design-pattern-table-per-type/util/operation/index", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key", "design-pattern-table-per-type/util/execution-impl/index", "isolation-level"], function (require, exports, tm, operation_43, update_and_fetch_one_by_super_key_3, execution_impl_14, isolation_level_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function updateAndFetchZeroOrOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate) {
        return connection.transactionIfNotInOne(isolation_level_21.IsolationLevel.REPEATABLE_READ, async (connection) => {
            const existsResult = await execution_impl_14.existsImpl(tpt, connection, () => operation_43.eqSuperKey(tpt, superKey));
            if (!existsResult.exists) {
                return {
                    query: {
                        sql: existsResult.sql,
                    },
                    //Alias for affectedRows
                    foundRowCount: tm.BigInt(0),
                    //Alias for changedRows
                    updatedRowCount: tm.BigInt(0),
                    /**
                     * May be the duplicate row count, or some other value.
                     */
                    warningCount: tm.BigInt(0),
                    /**
                     * An arbitrary message.
                     * May be an empty string.
                     */
                    message: "",
                    row: undefined,
                };
            }
            return update_and_fetch_one_by_super_key_3.updateAndFetchOneBySuperKey(tpt, connection, superKey, assignmentMapDelegate);
        });
    }
    exports.updateAndFetchZeroOrOneBySuperKey = updateAndFetchZeroOrOneBySuperKey;
});
define("design-pattern-table-per-type/util/execution/index", ["require", "exports", "design-pattern-table-per-type/util/execution/delete-one-by-candidate-key", "design-pattern-table-per-type/util/execution/delete-one-by-primary-key", "design-pattern-table-per-type/util/execution/delete-one-by-super-key", "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-candidate-key", "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-primary-key", "design-pattern-table-per-type/util/execution/delete-zero-or-one-by-super-key", "design-pattern-table-per-type/util/execution/fetch-one-by-candidate-key", "design-pattern-table-per-type/util/execution/fetch-one-by-primary-key", "design-pattern-table-per-type/util/execution/fetch-one-by-super-key", "design-pattern-table-per-type/util/execution/fetch-one", "design-pattern-table-per-type/util/execution/insert-and-fetch", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-candidate-key", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-primary-key", "design-pattern-table-per-type/util/execution/update-and-fetch-one-by-super-key", "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-candidate-key", "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-primary-key", "design-pattern-table-per-type/util/execution/update-and-fetch-zero-or-one-by-super-key"], function (require, exports, delete_one_by_candidate_key_1, delete_one_by_primary_key_1, delete_one_by_super_key_1, delete_zero_or_one_by_candidate_key_1, delete_zero_or_one_by_primary_key_1, delete_zero_or_one_by_super_key_1, fetch_one_by_candidate_key_1, fetch_one_by_primary_key_1, fetch_one_by_super_key_1, fetch_one_6, insert_and_fetch_2, update_and_fetch_one_by_candidate_key_5, update_and_fetch_one_by_primary_key_4, update_and_fetch_one_by_super_key_4, update_and_fetch_zero_or_one_by_candidate_key_2, update_and_fetch_zero_or_one_by_primary_key_2, update_and_fetch_zero_or_one_by_super_key_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(delete_one_by_candidate_key_1);
    __export(delete_one_by_primary_key_1);
    __export(delete_one_by_super_key_1);
    __export(delete_zero_or_one_by_candidate_key_1);
    __export(delete_zero_or_one_by_primary_key_1);
    __export(delete_zero_or_one_by_super_key_1);
    __export(fetch_one_by_candidate_key_1);
    __export(fetch_one_by_primary_key_1);
    __export(fetch_one_by_super_key_1);
    __export(fetch_one_6);
    __export(insert_and_fetch_2);
    __export(update_and_fetch_one_by_candidate_key_5);
    __export(update_and_fetch_one_by_primary_key_4);
    __export(update_and_fetch_one_by_super_key_4);
    __export(update_and_fetch_zero_or_one_by_candidate_key_2);
    __export(update_and_fetch_zero_or_one_by_primary_key_2);
    __export(update_and_fetch_zero_or_one_by_super_key_2);
});
define("design-pattern-table-per-type/util/index", ["require", "exports", "design-pattern-table-per-type/util/constructor/index", "design-pattern-table-per-type/util/execution/index", "design-pattern-table-per-type/util/execution-impl/index", "design-pattern-table-per-type/util/operation/index", "design-pattern-table-per-type/util/query/index"], function (require, exports, constructor_27, execution_21, execution_impl_15, operation_44, query_60) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(constructor_27);
    __export(execution_21);
    __export(execution_impl_15);
    __export(operation_44);
    __export(query_60);
});
define("design-pattern-table-per-type/table-per-type-impl", ["require", "exports", "design-pattern-table-per-type/util/index", "expr-library/index"], function (require, exports, TablePerTypeUtil, ExprLib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TablePerType {
        constructor(data, joins) {
            this.childTable = data.childTable;
            this.parentTables = data.parentTables;
            this.autoIncrement = data.autoIncrement;
            this.explicitAutoIncrementValueEnabled = data.explicitAutoIncrementValueEnabled;
            this.insertAndFetchPrimaryKey = data.insertAndFetchPrimaryKey;
            this.joins = joins;
        }
        addParent(parentTable) {
            return TablePerTypeUtil.addParent(this, parentTable);
        }
        fetchOne(connection, whereDelegate) {
            return TablePerTypeUtil.fetchOne(this, connection, whereDelegate);
        }
        fetchOneByCandidateKey(connection, candidateKey) {
            return TablePerTypeUtil.fetchOneByCandidateKey(this, connection, candidateKey);
        }
        fetchOneByPrimaryKey(connection, primaryKey) {
            return TablePerTypeUtil.fetchOneByPrimaryKey(this, connection, primaryKey);
        }
        fetchOneBySuperKey(connection, superKey) {
            return TablePerTypeUtil.fetchOneBySuperKey(this, connection, superKey);
        }
        insertAndFetch(connection, row) {
            return TablePerTypeUtil.insertAndFetch(this, connection, row);
        }
        updateAndFetchOneByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey, // & AssertNonUnion<CandidateKeyT>,
        assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
        }
        updateAndFetchOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
        }
        updateAndFetchOneBySuperKey(connection, superKey, assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
        }
        updateAndFetchZeroOrOneByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey, // & AssertNonUnion<CandidateKeyT>,
        assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchZeroOrOneByCandidateKey(this, connection, candidateKey, assignmentMapDelegate);
        }
        updateAndFetchZeroOrOneByPrimaryKey(connection, primaryKey, assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchZeroOrOneByPrimaryKey(this, connection, primaryKey, assignmentMapDelegate);
        }
        updateAndFetchZeroOrOneBySuperKey(connection, superKey, assignmentMapDelegate) {
            return TablePerTypeUtil.updateAndFetchZeroOrOneBySuperKey(this, connection, superKey, assignmentMapDelegate);
        }
        deleteOneByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey) {
            return TablePerTypeUtil.deleteOneByCandidateKey(this, connection, candidateKey);
        }
        deleteOneByPrimaryKey(connection, primaryKey) {
            return TablePerTypeUtil.deleteOneByPrimaryKey(this, connection, primaryKey);
        }
        deleteOneBySuperKey(connection, superKey) {
            return TablePerTypeUtil.deleteOneBySuperKey(this, connection, superKey);
        }
        deleteZeroOrOneByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey) {
            return TablePerTypeUtil.deleteZeroOrOneByCandidateKey(this, connection, candidateKey);
        }
        deleteZeroOrOneByPrimaryKey(connection, primaryKey) {
            return TablePerTypeUtil.deleteZeroOrOneByPrimaryKey(this, connection, primaryKey);
        }
        deleteZeroOrOneBySuperKey(connection, superKey) {
            return TablePerTypeUtil.deleteZeroOrOneBySuperKey(this, connection, superKey);
        }
        existsByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey) {
            return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey)).then(result => result.exists);
        }
        existsByPrimaryKey(connection, primaryKey) {
            return TablePerTypeUtil.existsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey)).then(result => result.exists);
        }
        existsBySuperKey(connection, superKey) {
            return TablePerTypeUtil.existsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey)).then(result => result.exists);
        }
        assertExistsByCandidateKey(connection, 
        /**
         * @todo Try and recall why I wanted `AssertNonUnion<>`
         * I didn't write compile-time tests for it...
         */
        candidateKey) {
            return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqCandidateKey(this.childTable, candidateKey));
        }
        assertExistsByPrimaryKey(connection, primaryKey) {
            return TablePerTypeUtil.assertExistsImpl(this, connection, () => ExprLib.eqPrimaryKey(this.childTable, primaryKey));
        }
        assertExistsBySuperKey(connection, superKey) {
            return TablePerTypeUtil.assertExistsImpl(this, connection, () => TablePerTypeUtil.eqSuperKey(this, superKey));
        }
    }
    exports.TablePerType = TablePerType;
});
define("design-pattern-table-per-type/index", ["require", "exports", "design-pattern-table-per-type/table-per-type-impl", "design-pattern-table-per-type/util/index"], function (require, exports, table_per_type_impl_3, TablePerTypeUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(table_per_type_impl_3);
    exports.TablePerTypeUtil = TablePerTypeUtil;
    exports.tablePerType = TablePerTypeUtil.tablePerType;
});
define("promise-util/invoke-async-callback-safely", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function invokeAsyncCallbackSafely(asyncCallback, thenCallback, catchCallback) {
        try {
            return asyncCallback()
                .then(thenCallback, catchCallback);
        }
        catch (syncErr) {
            return catchCallback(syncErr);
        }
    }
    exports.invokeAsyncCallbackSafely = invokeAsyncCallbackSafely;
});
define("promise-util/index", ["require", "exports", "promise-util/invoke-async-callback-safely"], function (require, exports, invoke_async_callback_safely_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(invoke_async_callback_safely_1);
});
define("async-queue", ["require", "exports", "promise-util/index"], function (require, exports, promise_util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const emptyPromise = Promise.resolve();
    class AsyncQueueStoppingError extends Error {
        constructor(message) {
            super(message);
            Object.setPrototypeOf(this, AsyncQueueStoppingError.prototype);
        }
    }
    exports.AsyncQueueStoppingError = AsyncQueueStoppingError;
    AsyncQueueStoppingError.prototype.name = "AsyncQueueStoppingError";
    /**
     * Only one `ItemT` can be allocated at a time.
     * Only one enqueued callback can be running at a time.
     *
     * This can be used to implement `IConnection.lock()`
     */
    class AsyncQueue {
        constructor(allocateDelegate) {
            this.shouldStop = false;
            this.lastPromise = emptyPromise;
            this.deallocateErr = undefined;
            /**
             * Enqueues a callback that will be run asynchronously.
             *
             * Only one callback will be running at any given time.
             */
            this.enqueue = (callback) => {
                if (this.shouldStop) {
                    return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
                }
                if (this.deallocateErr != undefined) {
                    /**
                     * We should not enqueue anymore callbacks,
                     * our allocator/deallocator has run into problems.
                     */
                    return Promise.reject(this.deallocateErr);
                }
                const tryResetQueue = () => {
                    if (this.lastPromise == callbackPromise) {
                        this.lastPromise = emptyPromise;
                    }
                };
                const runCallback = () => {
                    /**
                     * It's okay if this throws because we execute
                     * `runCallback` inside of a `.then()`
                     */
                    const { item, deallocate } = this.allocateDelegate();
                    return promise_util_1.invokeAsyncCallbackSafely(() => callback(item), (result) => {
                        return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                            tryResetQueue();
                            return result;
                        }, (deallocateErr) => {
                            tryResetQueue();
                            this.deallocateErr = deallocateErr;
                            return result;
                        });
                    }, (callbackErr) => {
                        return promise_util_1.invokeAsyncCallbackSafely(deallocate, () => {
                            tryResetQueue();
                            return Promise.reject(callbackErr);
                        }, (deallocateErr) => {
                            tryResetQueue();
                            this.deallocateErr = deallocateErr;
                            return Promise.reject(callbackErr);
                        });
                    });
                };
                const callbackPromise = this.lastPromise.then(runCallback, runCallback);
                this.lastPromise = callbackPromise;
                return callbackPromise;
            };
            /**
             * This makes all future calls to `.enqueue()` throw a run-time error.
             *
             * Returns a promise that resolves when the last enqueued
             * callback resolves.
             */
            this.stop = () => {
                this.shouldStop = true;
                return this.lastPromise.then(() => { }, () => { });
            };
            /**
             * Enqueues a callback that will be run asynchronously.
             * This callback will be given another `AsyncQueue` instance.
             *
             * This `AsyncQueue` will wait for the other instance to
             * complete before continuing.
             *
             * Only one callback will be running at any given time.
             */
            this.lock = (callback) => {
                if (this.shouldStop) {
                    return Promise.reject(new AsyncQueueStoppingError("The async queue is stopping, or has stopped"));
                }
                if (this.deallocateErr != undefined) {
                    /**
                     * We should not enqueue anymore callbacks,
                     * our allocator/deallocator has run into problems.
                     */
                    return Promise.reject(this.deallocateErr);
                }
                const tryResetQueue = () => {
                    if (this.lastPromise == callbackPromise) {
                        this.lastPromise = emptyPromise;
                    }
                };
                const runCallback = () => {
                    const nestedAsyncQueue = new AsyncQueue(this.allocateDelegate);
                    return promise_util_1.invokeAsyncCallbackSafely(() => callback(nestedAsyncQueue), (result) => {
                        const onStop = () => {
                            tryResetQueue();
                            /**
                             * Copy over the `deallocateErr` because
                             * they share the same `allocateDelegate`
                             */
                            this.deallocateErr = nestedAsyncQueue.deallocateErr;
                            return result;
                        };
                        /**
                         * Calling `.stop()` should never throw a synchronous error...
                         * I think.
                         */
                        return nestedAsyncQueue.stop()
                            .then(onStop, onStop);
                    }, (callbackErr) => {
                        const onStop = () => {
                            tryResetQueue();
                            /**
                             * Copy over the `deallocateErr` because
                             * they share the same `allocateDelegate`
                             */
                            this.deallocateErr = nestedAsyncQueue.deallocateErr;
                            return Promise.reject(callbackErr);
                        };
                        /**
                         * Calling `.stop()` should never throw a synchronous error...
                         * I think.
                         */
                        return nestedAsyncQueue.stop()
                            .then(onStop, onStop);
                    });
                };
                const callbackPromise = this.lastPromise.then(runCallback, runCallback);
                this.lastPromise = callbackPromise;
                return callbackPromise;
            };
            this.allocateDelegate = allocateDelegate;
        }
        getShouldStop() {
            return this.shouldStop;
        }
    }
    exports.AsyncQueue = AsyncQueue;
});
define("string-util/zero-pad", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
        zeroPad(1, 4)     === "0001"
        zeroPad(34, 4)    === "0034"
        zeroPad(678, 4)   === "0678"
        zeroPad(1337, 4)  === "1337"
        zeroPad(92678, 4) === "92678"
    */
    function zeroPad(num, length) {
        const str = num.toString();
        if (str.length < length) {
            return "0".repeat(length - str.length) + str;
        }
        else {
            return str;
        }
    }
    exports.zeroPad = zeroPad;
    function trailingZeroPad(num, length) {
        const str = num.toString();
        if (str.length < length) {
            return str + "0".repeat(length - str.length);
        }
        else {
            return str;
        }
    }
    exports.trailingZeroPad = trailingZeroPad;
});
define("string-util/index", ["require", "exports", "string-util/zero-pad"], function (require, exports, zero_pad_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(zero_pad_1);
});
define("date-time-util/util", ["require", "exports", "string-util/index"], function (require, exports, StringUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //Uses UTC
    //Truncates if fractionSecondPrecision is too small.
    function toSqlUtc(d, fractionalSecondPrecision /*|4|5|6*/) {
        if (!isFinite(d.getTime())) {
            throw new Error("Invalid date passed");
        }
        const year = StringUtil.zeroPad(d.getUTCFullYear(), 4);
        //getUTCMonth() returns [0, 11]
        //We want [1, 12]
        const month = StringUtil.zeroPad(d.getUTCMonth() + 1, 2);
        const day = StringUtil.zeroPad(d.getUTCDate(), 2);
        const hour = StringUtil.zeroPad(d.getUTCHours(), 2);
        const minute = StringUtil.zeroPad(d.getUTCMinutes(), 2);
        const second = StringUtil.zeroPad(d.getUTCSeconds(), 2);
        if (fractionalSecondPrecision == 0) {
            /*
                https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html
    
                The TIMESTAMP syntax produces a DATETIME value in MySQL
                because DATETIME has a range that more closely corresponds
                to the standard SQL TIMESTAMP type,
                which has a year range from 0001 to 9999.
    
                (The MySQL TIMESTAMP year range is 1970 to 2038.)
            */
            return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
        }
        else {
            const ms = StringUtil.zeroPad(d.getUTCMilliseconds(), fractionalSecondPrecision).substr(0, fractionalSecondPrecision);
            /*
                https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html
    
                The TIMESTAMP syntax produces a DATETIME value in MySQL
                because DATETIME has a range that more closely corresponds
                to the standard SQL TIMESTAMP type,
                which has a year range from 0001 to 9999.
    
                (The MySQL TIMESTAMP year range is 1970 to 2038.)
            */
            return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;
        }
    }
    exports.toSqlUtc = toSqlUtc;
    //Month is zero-based
    //Day is one-based
    function isValidDate(year, month, day) {
        var d = new Date(year, month, day);
        if (d.getFullYear() === year && d.getMonth() === month && d.getDate() === day) {
            return true;
        }
        return false;
    }
    const mySqlDateTimeRegex = /^(\d{4})-(\d{2})-(\d{2})( (\d{2}):(\d{2}):(\d{2})(\.(\d{1,6}))?)?$/;
    //Assumes UTC
    function fromSqlUtc(sql, fractionalSecondPrecision /*|4|5|6*/) {
        const match = mySqlDateTimeRegex.exec(sql);
        if (match == undefined) {
            throw new Error(`Invalid MySQL DATETIME string`);
        }
        const year = parseInt(match[1]);
        //1-based
        const month = parseInt(match[2]);
        //1-based
        const dayOfMonth = parseInt(match[3]);
        if (!isValidDate(year, month - 1, dayOfMonth)) {
            throw new Error(`Invalid MySQL DATETIME string; month or day does not exist for given year`);
        }
        const hour = (match[5] == undefined) ?
            0 :
            parseInt(match[5]);
        if (hour > 23) {
            throw new Error(`Hour must be [0, 23]`);
        }
        const minute = (match[6] == undefined) ?
            0 :
            parseInt(match[6]);
        if (minute > 59) {
            throw new Error(`Minute must be [0, 59]`);
        }
        const second = (match[7] == undefined) ?
            0 :
            parseInt(match[7]);
        if (second > 59) {
            throw new Error(`Second must be [0, 59]`);
        }
        const microsecondPart = (match[9] == undefined) ?
            0 :
            parseInt(StringUtil.trailingZeroPad(match[9], 6));
        if (microsecondPart > 999999) {
            throw new Error(`Microsecond must be [0, 999999]`);
        }
        const millisecond = Math.floor(microsecondPart / 1000);
        const microsecond = microsecondPart % 1000;
        if (match[9] != undefined &&
            match[9].length > fractionalSecondPrecision) {
            throw new Error(`Expected DATETIME(${fractionalSecondPrecision}), received DATETIME(${match[9].length})`);
        }
        //TODO-FEATURE Microsecond support
        //BEGIN TEMPORARY NON-SUPPORT FOR MICROSECOND
        if (microsecond != 0) {
            throw new Error(`Microsecond support for DATETIME is not supported yet`);
        }
        //END TEMPORARY NON-SUPPORT FOR MICROSECOND
        const utcMillisecondTimestamp = Date.UTC(year, 
        //Date.UTC() expects [0, 11]
        month - 1, dayOfMonth, hour, minute, second, millisecond);
        return new Date(utcMillisecondTimestamp);
    }
    exports.fromSqlUtc = fromSqlUtc;
});
define("date-time-util/index", ["require", "exports", "date-time-util/util"], function (require, exports, util_10) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(util_10);
});
define("index", ["require", "exports", "aliased-expr/index", "aliased-table/index", "ast/index", "built-in-expr/index", "built-in-value-expr/index", "candidate-key/index", "column/index", "column-identifier/index", "column-identifier-map/index", "column-identifier-ref/index", "column-map/index", "column-ref/index", "compound-query/index", "compound-query-clause/index", "compound-query-order-by-clause/index", "custom-expr/index", "data-type/index", "derived-table/index", "derived-table-select-item/index", "design-pattern-log/index", "design-pattern-table-per-type/index", "event/index", "execution/index", "expr/index", "expr-column/index", "expr-library/index", "expr-select-item/index", "from-clause/index", "group-by-clause/index", "having-clause/index", "insert/index", "insert-select/index", "join/index", "join-map/index", "key/index", "limit-clause/index", "map-delegate/index", "mapper-map/index", "on-clause/index", "order/index", "order-by-clause/index", "partial-row/index", "primary-key/index", "query-base/index", "row/index", "schema-validation/index", "select-clause/index", "select-item/index", "sort-direction/index", "super-key/index", "sqlstring/index", "table/index", "table-where/index", "type-map/index", "type-ref/index", "unified-query/index", "update/index", "used-ref/index", "value-expr/index", "where-clause/index", "async-queue", "constants", "error/index", "isolation-level", "operator-type", "transaction-access-mode", "type-hint", "date-time-util/index", "formatter/index", "promise-util/index", "tuple-util/index", "type-util/index"], function (require, exports, aliased_expr_3, aliased_table_5, ast_46, built_in_expr_70, built_in_value_expr_13, candidate_key_7, column_52, column_identifier_8, column_identifier_map_18, column_identifier_ref_19, column_map_49, column_ref_28, compound_query_5, compound_query_clause_2, compound_query_order_by_clause_2, custom_expr_3, data_type_13, derived_table_3, derived_table_select_item_2, design_pattern_log_1, design_pattern_table_per_type_1, event_18, execution_22, expr_59, expr_column_2, expr_library_2, expr_select_item_20, from_clause_33, group_by_clause_3, having_clause_2, insert_7, insert_select_6, join_18, join_map_12, key_21, limit_clause_7, map_delegate_2, mapper_map_1, on_clause_5, order_3, order_by_clause_2, partial_row_2, primary_key_9, query_base_17, row_2, schema_validation_1, select_clause_7, select_item_3, sort_direction_10, super_key_3, sqlstring_5, table_52, table_where_3, type_map_1, type_ref_1, unified_query_19, update_3, used_ref_38, value_expr_1, where_clause_15, async_queue_1, constants_5, error_15, isolation_level_22, operator_type_165, transaction_access_mode_1, type_hint_120, DateTimeUtil, FormatUtil, PromiseUtil, TupleUtil, TypeUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(aliased_expr_3);
    __export(aliased_table_5);
    __export(ast_46);
    __export(built_in_expr_70);
    __export(built_in_value_expr_13);
    __export(candidate_key_7);
    __export(column_52);
    __export(column_identifier_8);
    __export(column_identifier_map_18);
    __export(column_identifier_ref_19);
    __export(column_map_49);
    __export(column_ref_28);
    __export(compound_query_5);
    __export(compound_query_clause_2);
    __export(compound_query_order_by_clause_2);
    __export(custom_expr_3);
    __export(data_type_13);
    __export(derived_table_3);
    __export(derived_table_select_item_2);
    __export(design_pattern_log_1);
    __export(design_pattern_table_per_type_1);
    __export(event_18);
    __export(execution_22);
    __export(expr_59);
    __export(expr_column_2);
    __export(expr_library_2);
    __export(expr_select_item_20);
    __export(from_clause_33);
    __export(group_by_clause_3);
    __export(having_clause_2);
    __export(insert_7);
    __export(insert_select_6);
    __export(join_18);
    __export(join_map_12);
    __export(key_21);
    __export(limit_clause_7);
    __export(map_delegate_2);
    __export(mapper_map_1);
    __export(on_clause_5);
    __export(order_3);
    __export(order_by_clause_2);
    __export(partial_row_2);
    __export(primary_key_9);
    __export(query_base_17);
    __export(row_2);
    __export(schema_validation_1);
    __export(select_clause_7);
    __export(select_item_3);
    __export(sort_direction_10);
    __export(super_key_3);
    __export(sqlstring_5);
    __export(table_52);
    __export(table_where_3);
    __export(type_map_1);
    __export(type_ref_1);
    __export(unified_query_19);
    __export(update_3);
    __export(used_ref_38);
    __export(value_expr_1);
    __export(where_clause_15);
    __export(async_queue_1);
    __export(constants_5);
    __export(error_15);
    __export(isolation_level_22);
    __export(operator_type_165);
    __export(transaction_access_mode_1);
    __export(type_hint_120);
    exports.DateTimeUtil = DateTimeUtil;
    exports.FormatUtil = FormatUtil;
    exports.PromiseUtil = PromiseUtil;
    exports.TupleUtil = TupleUtil;
    exports.TypeUtil = TypeUtil;
});
//# sourceMappingURL=index.js.map