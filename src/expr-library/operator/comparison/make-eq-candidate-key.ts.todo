import * as tm from "type-mapping";
import {TableWithPrimaryKey, ITable} from "../../../table";
import {PrimaryKey_NonUnion, PrimaryKeyUtil} from "../../../primary-key";
import {UnionToIntersection} from "../../../type-util";
import {Expr} from "../../../expr";
import {UsedRefUtil} from "../../../used-ref";
import {eq} from "./eq";
import {and} from "../logical";
import {CandidateKey} from "../../../candidate-key";

/**
 * Convenience function for,
 * ```ts
 *  tsql.and(
 *      tsql.nullSafeEq(candidateKeyColumn0, value0),
 *      tsql.nullSafeEq(candidateKeyColumn1, value1),
 *      tsql.nullSafeEq(candidateKeyColumn2, value2)
 *      //etc.
 *  );
 * ```
 *
 * Uses `nullSafeEq()` internally because the candidate key of a table
 * may have nullable columns.
 *
 * @param table - The table with a candidate key
 * @param candidateKey - The candidate key values to compare against
 */
export function eqCandidateKey<
    TableT extends Pick<ITable, "columns"|"candidateKeys">
> (
    table : TableT,
    /**
     * ```ts
     *  //The following types are equal
     *  type a = (
     *      | ({x: ""} & {a: ""})
     *      | ({x: ""} & {b: ""})
     *      | ({y: ""} & {a: ""})
     *      | ({y: ""} & {b: ""})
     *  );
     *  type a = UnionToIntersection<
     *      | [{x:""}|{y:""}]
     *      | [{a:""}|{b:""}]
     *  >[number];
     * ```
     * http://www.typescriptlang.org/play/#code/C4TwDgpgBAqgdgSwPZwCpIJJ2BATgZwgGNhk4AeeAPigF4oAKAWACgp3HWPvY4oIAHjjgATfFACGcEFAD8jANYAuXgEo6NAG5IEIqCrgRNeLh3WDhYzmx7sGyqAjgAzPFAzraWnSNPt18hj6UIbGuKyqANysrAD0AFSsoJCSdNbcAD6MAN4CKgBE+QC+UABkUNkSBcWqflBZDLnVJeXZAEbNtTbsDdkgzWUVVVCFRV2ZOf0jxYPtnRGs8bFJ4NASafBk6Fg4BMSkKOR1WQDaTaMZfUqjALrHUGdVF3O3rFQncACuALZteDdAA
     */
    candidateKey : CandidateKey<TableT>
) : (
    Expr<{
        mapper : tm.SafeMapper<boolean>,
        usedRef : UsedRefUtil.FromColumnMap<TableT["columns"]>
    }>
) {
    PrimaryKeyUtil.mapper(table)(`${table}.primaryKey`, primaryKey);

    const arr = table.primaryKey.map((columnAlias) => {
        /**
         * We use `eq` because the primary key of a table cannot have
         * nullable columns.
         */
        const expr = eq(
            table.columns[columnAlias],
            primaryKey[columnAlias as keyof UnionToIntersection<PrimaryKey_NonUnion<TableT>>]
        );
        return expr as Expr<{
            mapper : tm.SafeMapper<boolean>,
            usedRef : UsedRefUtil.FromColumnMap<TableT["columns"]>
        }>;
    });
    const result = and(...arr);
    return result as Expr<{
        mapper : tm.SafeMapper<boolean>,
        usedRef : UsedRefUtil.FromColumnMap<TableT["columns"]>
    }>;
}
